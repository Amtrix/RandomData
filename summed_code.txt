#include<iostream>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<vector>
#include<queue>
using namespace std;

#define f first
#define s second

struct STR{
   char s[11];
};

struct TYP{
   int f , s;
   TYP( int p1 , int p2 ):f(p1),s(p2){};
   TYP(){};
   bool operator<(const TYP b ) const{
      return f > b.f;
   }
};

int nodes;
STR names[10000];
vector< TYP >edge[10000];
int DP[10000];

int dijkstra( int a, int b ){
   int i,j,k;
   for(i=0;i<nodes;i++){
      DP[i]=999999;
   }
   DP[a]=0;
   priority_queue< TYP >Q;
   Q.push( TYP(0,a) );
   bool breakIt= false;
   int S = 999999;
   TYP u;
   while(!Q.empty()){
      u = Q.top();Q.pop();
      if( u.s == b )break;
      for(i=0;i<edge[u.s].size() && !breakIt;i++){
         int dist = u.f + edge[u.s][i].s;
         if( DP[ edge[u.s][i].f ] > dist && dist<S ){
            DP[ edge[u.s][i].f ] = dist;
            Q.push( TYP(dist, edge[u.s][i].f ) );
         }
         if( edge[u.s][i].f == b )S=dist;
      }
   }
   return DP[b];
}

int main(){

   int tests,e,i,j,k,a,b;
   STR from , to ;
   scanf("%d",&tests);
   for(int i=0;i<tests;i++){
      scanf("%d\n",&nodes);
      for(j=0;j<nodes;j++){
         edge[j].clear();
         scanf("%s",&names[j].s );
         scanf("%d",&e);
         for(k=0;k<e;k++){
            scanf("%d%d",&a,&b);
            edge[j].push_back( TYP(a-1,b) );
         }
      }
      scanf("%d\n",&a);
      for(j=0;j<a;j++){
         scanf("%s %s",from.s,to.s);
         int iA(-1), iB(-1);
         for(k=0;k<nodes && (iA==-1 || iB==-1) ;k++){
            if( iA==-1 && strcmp(names[k].s,from.s)==0 )
              iA = k;
            if( iB==-1 && strcmp(names[k].s,to.s)==0 )
              iB = k;
         }
         printf("%d\n",dijkstra(iA,iB) );
      }
   }
  // system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<fstream>
using namespace std;

struct BANK_CODE{
   short control;
   int   code;
   short g1,g2,g3,g4;
   BANK_CODE(){};
   bool operator<( BANK_CODE &S ){
      if ( control<S.control ) return true;
      else if( control>S.control ) return false;
      
      if ( code<S.code ) return true;
      else if( code>S.code ) return false;
      
      if ( g1<S.g1 ) return true;
      else if( g1>S.g1 ) return false;
      
      if ( g2<S.g2 ) return true;
      else if( g2>S.g2 ) return false;
      
      if ( g3<S.g3 ) return true;
      else if( g3>S.g3 ) return false;
      
      if ( g4<S.g4 ) return true;
      else if( g4>S.g4 ) return false;
      return true;
   }
   bool operator==( BANK_CODE &S ){
      return ( control==S.control && code==S.code && g1==S.g1 && g2==S.g2 && g3==S.g3 && g4==S.g4 );
   }
   void Read(){
      scanf("%d %d %d %d %d %d",&control,&code,&g1,&g2,&g3,&g4);
   }
   void Write(){
      printf("%.2d %.8d %.4d %.4d %.4d %.4d",control,code,g1,g2,g3,g4);
   }
};


BANK_CODE accounts[100001];

bool cmp( int a, int b ){
   return ( accounts[a]<accounts[b] );
}

int main(){
 //  printf("%.5d",5);
 //  system("Pause");
   vector<int>idx;
  // freopen("Ulaz.txt","r",stdin);
  // freopen("Izlaz.txt","w",stdout);
   int n,m,i,j;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      idx.clear();
      scanf("%d",&m);
      for(j=0;j<m;j++){
         accounts[j].Read();
         //accounts[j].Write();cout<<endl;
         idx.push_back(j);
      }
      sort(idx.begin(),idx.end(),cmp);
    //  for(j=0;j<m;j++)cout<<idx[j]<<" ";cout<<endl;
      j=0;
      while(j<idx.size()){
         int u = j+1;
         while( u<idx.size() && accounts[ idx[j] ] == accounts[ idx[u] ] )u++;
        // cout<<j<<" "<<u<<endl;
         accounts[ idx[j] ].Write(); printf(" %d\n",u-j);
         j=u;
      }if(i<n-1)cout<<endl;
   }
  // system("Pause");
   return 0;
}

#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<stack>
#include<set>
#include<queue>
#include<vector>
#include<iostream>
using namespace std;
const int inf = (int)10e9;

struct edge{
   int dist,E;
   edge(int p2,int p3):dist(p2),E(p3){};
   edge(){};
};

int n,m,S,E;
vector<edge>way[100005];
int dist[100005];

class comp{
   public:
      bool direction;       
      comp( bool rastuci ):direction(rastuci){};
      comp():direction(true){};       
      bool operator()( const int &A, const int &B) const{   
         if(dist[A]>=dist[B])return 1;
         return 0;
      }            
};  


void shortest()
{
   int i,u;
   int node,val,alt;
   priority_queue< int , vector<int> , comp >Q;
   dist[S]=0;
   Q.push( S );
   int sizeN = n;
   while(dist[Q.top()] != inf && !Q.empty())
   {
      node= Q.top();
      Q.pop(); 
      if( node == E )break;
      for(i=0;i<way[node].size();i++)
      {
         alt = dist[node]+ way[node][i].dist;
         if( alt < dist[way[node][i].E] )
         {
            dist[way[node][i].E] = alt;
            Q.push(way[node][i].E);
         }
         
      }
   }
   if( dist[E]==inf )
      cout<<"NONE"<<endl;
   else
      cout<<dist[E]<<endl;
}


int main()
{
       
   int a,b,c,d,t;
   scanf("%d",&t);
   for( int j=0;j<t;j++){
      scanf("%d%d%d%d",&n,&m,&S,&E);
      for(int i=1;i<=n;i++){
         dist[i]=inf;
         way[i].clear();
      }
      for(int i=0;i<m;i++)
      {
         scanf("%d%d%d",&a,&b,&c);
         way[a].push_back( edge( c,b) );
         way[b].push_back( edge( c,a) );
      }
      shortest();
   }
   //system("Pause");
   return 0;
}

/* Zadano je nekoliko pravougaonika ( moze biti i kvadrata )
   koji se medjusobno mogu i preklapati. Potrebno je napisati
   program koji ce racunati ukupnu povrsinu
   koju oni prekrivaju. Stranice pravougaonika su paralelne s
   koordinatnim osima dok su koordinate vrhova prirodni brojevi.
   Program snimiti pod imenom POVRSINA. 
*/

#include<cstdio>
#include<cstdlib>

bool matrica[501][501];

int main(){
   int i,j,k;
   int n, x1,x2,y1,y2,res=0;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d%d%d%d",&x1,&x2,&y1,&y2);
      for(j=x1;j<x2;j++)
         for(k=y2;k<y1;k++)
            if( matrica[j][k] == false )
               matrica[j][k]=true,res++;
   }
   printf("%d\n",res);
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<vector>
#include<queue>
using namespace std;

#define f first
#define s second

struct STR{
   char s[11];
};

struct TYP{
   int f , s;
   TYP( int p1 , int p2 ):f(p1),s(p2){};
   TYP(){};
   bool operator<(const TYP b ) const{
      return f > b.f;
   }
};

int nodes;
STR names[10000];
vector< TYP >edge[10000];
int DP[10000];

int dijkstra( int a, int b ){
   int i,j,k;
   for(i=0;i<nodes;i++){
      DP[i]=999999;
   }
   DP[a]=0;
   priority_queue< TYP >Q;
   Q.push( TYP(0,a) );
   bool breakIt= false;
   int S = 999999;
   TYP u;
   while(!Q.empty()){
      u = Q.top();Q.pop();
      if( u.s == b )break;
      for(i=0;i<edge[u.s].size() && !breakIt;i++){
         int dist = u.f + edge[u.s][i].s;
         if( DP[ edge[u.s][i].f ] > dist && dist<S ){
            DP[ edge[u.s][i].f ] = dist;
            Q.push( TYP(dist, edge[u.s][i].f ) );
         }
         if( edge[u.s][i].f == b )S=dist;
      }
   }
   return DP[b];
}

int main(){

   int tests,e,i,j,k,a,b;
   STR from , to ;
   scanf("%d",&tests);
   for(int i=0;i<tests;i++){
      scanf("%d\n",&nodes);
      for(j=0;j<nodes;j++){
         edge[j].clear();
         scanf("%s",&names[j].s );
         scanf("%d",&e);
         for(k=0;k<e;k++){
            scanf("%d%d",&a,&b);
            edge[j].push_back( TYP(a-1,b) );
         }
      }
      scanf("%d\n",&a);
      for(j=0;j<a;j++){
         scanf("%s %s",from.s,to.s);
         int iA(-1), iB(-1);
         for(k=0;k<nodes && (iA==-1 || iB==-1) ;k++){
            if( iA==-1 && strcmp(names[k].s,from.s)==0 )
              iA = k;
            if( iB==-1 && strcmp(names[k].s,to.s)==0 )
              iB = k;
         }
         printf("%d\n",dijkstra(iA,iB) );
      }
   }
  // system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
using namespace std;

#define f first
#define s second

bool cmpS( pair<char,int>a, pair<char,int>b ){
   if( a.f < b.f )return true;
 else if( a.f==b.f && a.s<b.s )return true;
   return false;
}

int n,size;
char last[1000000];
pair<char,int> first[1000000];
int pok[1000000];

/*
bool Prepare_Pok(int s){
   int j = 0;
   for(int i=s;i<size;i++){
      if( i==first[j].s )return false;
      else pok[i]=first[j].s;
      j++;
   }
   return true;
} */

int main(){
   int i,j,k;
  // FILE *in = fopen("Ulaz.txt","r");
   scanf("%d\n",&n);
   scanf("%s",last);   size = strlen(last);
   for(i=0;i<size;i++){
      first[i].f=last[i];
      first[i].s=i;
   }
   sort( first, first + size , cmpS );
   int t = n-1;
   for(i=0;i<size;i++){
       cout<<first[t].f;
       t = first[t].s;
   }cout<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdlib>
using namespace std;

char a[1000000],b[1000000];
int next[100000];
int i,k,n;
char ch;

void sort( int l, int r ){
   int i,j,k,t;
   i = l;
   j = r;
   k = next[(i+j)/2];
   while( i<=j ){
       while( a[next[i]]<a[k] || (a[next[i]]==a[k] && next[i]<k) )i++;
       while( a[k]<a[next[j]] || (a[next[j]]==a[k] && k<next[j]) )j--;
       if( i<=j ){
          t = next[i];
          next[i] = next[j];
          next[j]=t;
          i++;
          j--;
       } 
   }
   if(i<r) sort( i,r );
   if(l<j) sort( l,j );
}

int main(){
   //FILE *in = fopen("Ulaz.txt","r");
   scanf("%d\n",&k);
   scanf("%s",b);
   int i;
   for(i=0;i<strlen(b);i++){
      a[i+1]=b[i];
      next[i+1]=i+1;
   }
   n=i;
   sort(1,n);
   for(i=1;i<=n;i++){
      k = next[k];
         cout<<a[k];
   }cout<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;


string invite[10001];
string list[40001];
int poz[40001];
int hash[40001];

int n,m;

int bsearch( int s ){
   int lo = 0 , hi = n-1;
   while(lo<=hi){
      int mid = (lo+hi)/2;
      if(  list[s]==invite[mid] )return mid;
      else if( list[s]<invite[mid] ) hi = mid-1;
      else lo = mid+1;
   }
   return -1;
}


int main(){
    ifstream cin("DAT(1).txt");
   int i,j;
   cin>>n;
   for(i=0;i<n;i++)cin>>invite[i];
   cin>>m;
   for(i=0;i<m;i++){
      cin>>list[i];
      hash[i]=-1;
   }
   sort(invite,invite+n);
   int vis = 0;
   int res = 400000;
   int lo = 0;
   for(i=0;i<m;i++){
      int b = bsearch( i );
      if( b== -1 )poz[i]=-1;
      else if(b>=0){
         if( hash[b]!=-1)poz[ hash[b] ]=-1;
         else vis++;
         //if(m>40000)poz[-444444]=-1; //// IT SAYS TRUE!? // THATS THE RESON FOR MLE, I DID IT ADVISEDLY // HOW ????
         poz[i]=b;
         //if(m>40000)poz[-444444]=-1; /// THIS WILL NEVER BE... DON'T know WHY
         hash[b]=i;
         while( poz[lo]==-1) lo++;
         if( vis==n)res = min( res , i-lo+1);
         
      }
   }
   cout<<res<<endl;
  system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<math.h>
using namespace std;

int main(){
   ifstream cin("Ulaz.txt");
   ofstream cout("Izlaz.txt");
   long long res=0;
   int tests;
   int A;char oper=' ';
   cin>>tests;
   for(int i=0;i<tests;i++){
      oper = ' ';
      bool mode = true;;
      while( oper!='=' ){
         if( mode == true ){
            cin>>A;
            if( oper==' ' )res = A;
            else if( oper=='*')res*=A;
            else if( oper=='+')res+=A;
            else if( oper=='-')res-=A;
            else if( oper=='/') res /= A;
            mode = !mode;
         }else{
            cin>>oper;
            mode = !mode;
         }
      }
      cout<<res<<endl;
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<math.h>
using namespace std;

struct edge{
   int A,B;
   long long dist;
   edge( int p1,int p2 , long long p3):A(p1),B(p2),dist(p3){};
   edge(){};
};

vector<edge>V;
int coord[300][2];
bool hasSat[300];
bool visited[300];

long long Euclid( int p1, int p2 ){
   return ( ((long long)(coord[p1][0]-coord[p2][0]))*(coord[p1][0]-coord[p2][0]) + (coord[p1][1]-coord[p2][1])*(coord[p1][1]-coord[p2][1]) );
}

bool cmpV( edge A , edge B ){
   return A.dist < B.dist;
}

bool cmpM( int p1,int p2 ){
   return V[p1].dist>V[p2].dist;
}

int main(){
   int i,j,k;
   int sat,nodes;
  // FILE *in = fopen("Ulaz.txt","r");
   scanf("%d%d",&sat,&nodes);
   for(i=0;i<nodes;i++){
      scanf("%d%d",&coord[i][0],&coord[i][1]);
      for(j=0;j<i;j++)
         V.push_back( edge(i,j,Euclid(i,j)) );
   }
   sort( V.begin() , V.end() , cmpV );
   visited[0]=true;
   int poz=-1;
   int selected =  0;
   vector<long long>mst;
   while( selected!=nodes-1){
      poz ++;
      if( (visited[ V[poz].A ]==false&&visited[ V[poz].B ]==true) || (visited[ V[poz].B ]==false&&visited[ V[poz].A ]==true)   ){
         mst.push_back( poz );
         visited[ V[poz].A ] = visited[ V[poz].B ] = true;
         selected++;
         poz=-1;
      }
   }
   sort( mst.begin(), mst.end() , cmpM );
   int it=0;

   cout<<sqrt( V[mst[sat-1]].dist )<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<cstdlib>
#include<vector>
#include<queue>
using namespace std;

#define f first
#define s second

int n,m;
int subNiz(0);
vector< pair<int,int> >graph[20001];
int LEN[2][20001];


void dijakstra( int start ){
   int i;
   priority_queue< pair<int,int> , vector<pair<int,int> > , greater< pair<int,int> > >Q;
   for(i=1;i<=n;i++){
      LEN[subNiz][i]=INT_MAX;
   }
   LEN[subNiz][start]=0;
   Q.push( make_pair( 0 , start ) );
   while(!Q.empty() ){
      pair<int,int>P = Q.top(); Q.pop();
      for( i=0 ; i<graph[ P.s ].size() ; i++ ){
         if( LEN[subNiz][P.s] + graph[ P.s ][i].s < LEN[subNiz][ graph[P.s][i].f ] ){
            LEN[subNiz][ graph[P.s][i].f ] = LEN[subNiz][P.s] + graph[ P.s ][i].s;
            Q.push( make_pair( LEN[subNiz][P.s] + graph[ P.s ][i].s , graph[P.s][i].f )  );
         }
      }
   }
}

int main(){
   int i,j;
   int Sr,Er;
   int Sj,Ej;
   int a,b,d;
   scanf("%d%d",&n,&m);
   scanf("%d%d%d%d",&Sj,&Ej,&Sr,&Er);
   for(i=0;i<m+1;i++){
      scanf("%d%d%d",&a,&b,&d);
      graph[a].push_back( make_pair(b,d) );
   }
   dijakstra( Sj );subNiz++;
   dijakstra( Sr );
   int res = INT_MAX;
   for(i=1;i<=n;i++)
      if( LEN[0][i] == LEN[1][i] )
         res = min( LEN[0][i] , res );
   if( res == INT_MAX) printf("-1\n");
   else printf("%d\n",res);
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<vector>
using namespace std;

struct camac{
   int poz,len;
   camac( int p1, int p2 ):poz(p1),len(p2){};
   camac(){};
};

vector<camac>V;

bool cmpI( camac a , camac b ){
   return a.poz<b.poz;
}

int main(){
   int n,i,j;
   int a,b;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d%d",&b,&a);
      V.push_back( camac(a,b) );
   }
   sort(V.begin(),V.end(),cmpI);
   int limit = V[0].poz;
   int res=1;
   int o=0;
   for(i=1;i<n;i++){
      if( V[i].poz>=limit ){
         o = limit;
         limit = max(V[i].poz,V[i].len+limit);
         res++;
      }else
         limit = min( limit , max(V[i].poz,V[i].len+o) );
   }
   cout<<res<<endl;
   system("pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<fstream>
#include<cstdlib>
#include<cstdio>
#include<vector>
using namespace std;

#define f first
#define s second

bool used[10001];
vector< pair<int,int> >interval;

bool cmpI( pair<int,int>A, pair<int,int> B ){
   return A.s<B.s;
}

int sum(int a,int b){
   int count = 0;
   for(;a<=b;a++)
      count += used[a];
   return count;
}

int main(){
   int n,a,b,i;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d%d",&a,&b);
      interval.push_back( make_pair(a,b) );
   }
   sort( interval.begin() , interval.end(), cmpI );
   int res=0;
   for(i=0;i<n;i++){
      int have = sum(interval[i].f,interval[i].s);
      if( have == 0 ){
         used[interval[i].s]=used[interval[i].s-1]=1;
         res+=2;
      }else if( have == 1 ){
         if( !used[interval[i].s] )used[interval[i].s]=true;
         else used[interval[i].s-1]=true;
         res++;
      }
   }
   cout<<res<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<vector>
using namespace std;

template <class item>
int ExtractBit( item v , int d ){
   int SZ = sizeof( v );
   int BITS = SZ*8;
   return v>>(BITS-d) & 1;
}

int main(){
   int i,j;
   long long NUM;
   cin>>NUM;
   for(i=1;i<=sizeof(NUM)*8;i++)
      cout<<ExtractBit(NUM,i);cout<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<math.h>
#include<vector>
#include<iomanip>
using namespace std;

#define f first
#define s second

int D[100001];
int n,m;
vector< pair<int,int> >V;

int diff( int a , int b ){
   int diffA = b-a;
   int diffB = ((n-b)+1)+(a-1);
   return min(diffA,diffB);
}

bool cmpI( pair<int,int>a, pair<int,int>b ){
   return diff( a.f , a.s ) < diff(b.f , b.s );
}

int main(){
   int i,j,k;
   int a,b;
  // FILE *in = fopen("Ulaz.txt","r");
   scanf("%d%d",&n,&m);
   if( m==0 ){cout<<n<<endl;system("Pause");return 0;}
   for(i=0;i<m;i++){
      scanf("%d%d",&a,&b);
      V.push_back( make_pair( min(a,b), max(a,b) ) );
   }
   sort(V.begin(),V.end(),cmpI );
 // cout<<"DIFF "<<diff(1,11)<<endl;
  // for(i=0;i<m;i++){
  //    cout<<V[i].f<<" "<<V[i].s<<endl;
  // }cout<<endl;                 
   int res=0;
   int D;
   for(i=0;i<m;i++){
    //  cout<<V[i].f<<" "<<V[i].s<<endl;
      res = max( res , D=diff( V[i].f , V[i].s ) );
      D--;
      int G=V[i].f;
      if( diff(V[i].f,V[i].s) < V[i].s-V[i].f ) G = V[i].s;
      for(j=i+1;j<m;j++){
            if( V[j].f > G )V[j].f-=D;
            if( V[j].s > G )V[j].s-=D;     
      }n-=D;
     // cout<<"TEST: "<<V[6].f<<" "<<V[6].s<<endl;
   }
   cout<<max(n,res-1)<<endl;
   system("Pause");
   return 0;
}

#include<stack>
#include<vector>
using namespace std;

int n,m,k;
const int MOD = 4096;
int WayMatrix[101][101]; int MemMatrix[101][101];
int MatrixRet[101][101];

int main(){
   int i,j,a,b;
   scanf("%d%d%d",&n,&m,&k);
   for(i=0;i<m;i++){
      scanf("%d%d",&a,&b);
      WayMatrix[b-1][a-1]++;
      MemMatrix[b-1][a-1]++;
   }
   stack<int>S;
   int e = k;
   while(e!=1 ){
      if( e%2 ){
         S.push(1);e--;
      }else{
         S.push(2);e/=2;
      }
   }
   int u;
   while(!S.empty()){
      u=S.top();S.pop();
      if(u==1){
         for(i=0;i<n;i++)
            for(j=0;j<n;j++)
               for(k=0;k<n;k++)
                  MatrixRet[i][j] =  (MatrixRet[i][j]+WayMatrix[i][k]*MemMatrix[k][j])%MOD;
          for(i=0;i<n;i++)for(j=0;j<n;j++){WayMatrix[i][j]=MatrixRet[i][j];MatrixRet[i][j]=0;}   
      }else{
         for(i=0;i<n;i++)
            for(j=0;j<n;j++)
               for(k=0;k<n;k++)
                  MatrixRet[i][j] =  (MatrixRet[i][j]+WayMatrix[i][k]*WayMatrix[k][j])%MOD;
          for(i=0;i<n;i++)for(j=0;j<n;j++){WayMatrix[i][j]=MatrixRet[i][j];MatrixRet[i][j]=0;}   
      }
   }
   for(i=0;i<n;i++)
      printf("%d\n",WayMatrix[i][0]);
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<vector>
#include<set>
#include<queue>
using namespace std;

struct coord{
   int x,y;
   coord(){};
   coord( int p1 , int p2 ):x(p1),y(p2){};
};

int n;
unsigned char pic1[201][201];
unsigned char pic2[201][201];
vector<coord>mogucni;
FILE *in;

void Input( unsigned char *F ){
   char TMP;
   int i;
   for(i=0;i<n;i++){
      scanf("%uc%c",&F[i], &TMP);
   }
}

void FillVecKey( unsigned char ToFind ){
   int i,j;
   for(i=0;i<n;i++)
      for(j=0;j<n;j++)
         if( pic2[i][j]==ToFind )
            mogucni.push_back( coord(j,i) );
}

bool SortByXY( coord A, coord B ){
   return ( A.x>B.x || (A.x==B.x && A.y>B.y) );
}

bool IsValid( int x, int y ){
   int i,j;
   int Cx , Cy = n-1;
   for(i=y;i>=0 ;i--){
     Cx = n-1;
     for(j=x;j>=0 ;j--){
        if( pic1[Cy][Cx] != pic2[i][j] ) return false;
        Cx--;
     }
     Cy--;
   }
   return true;
}

int main()
{
  // in = fopen("Ulaz.txt","r");
   int i,j,k;
   scanf("%d",&n);
   for(i=0;i<n;i++)Input( pic1[i] );
   for(i=0;i<n;i++)Input( pic2[i] );
   char KeyToFind = pic1[n-1][n-1];
   FillVecKey( KeyToFind );
   sort( mogucni.begin(), mogucni.end() , SortByXY );
   int NM = mogucni.size();
   bool foundIt;
   for(i=0;i<NM;i++){
      foundIt = IsValid( mogucni[i].x , mogucni[i].y );
      if( foundIt ){
         printf("%d %d\n",n-mogucni[i].x-1,n-mogucni[i].y-1 );
         break;
      }
   }
  // if( DOMORE )printf("0 %d\n",n);
   system("Pause");
   return 0;
}

#include<iostream>
#include<math.h>
#include<algorithm>
#include<fstream>
#include<cstdio>
using namespace std;

long long MOD=1000;

long long pow2( long long baza , long long e ){
   if( e==0 )return 1;
   if( e%2 ){
      return (baza*pow2( baza , e-1 ))%MOD;
   }else{
      long long P = pow2( baza, e/2 );
      return (P*P)%MOD;
   }
}

long long DP( long long baza ,long long e ){
   long long d2 = (long long)ceil(e/2.00);
   if( e<=4 ){
      long long R = 0;
      for(int i=0;i<=e;i++)
         R = (R+pow2(baza,i))%MOD;
      return R;
   }
   if( e%2 )
   {
      long long A = (1+pow2(baza,d2))%MOD;
      long long B = DP( baza , e-d2 )%MOD;
      return (A * B)%MOD;
   }else{
      long long A = pow2(baza,e)%MOD;
      long long B = DP(baza,e-1)%MOD;
      return (A+B)%MOD;
   }
}

int main(){
   long long A,N;
 //  FILE *in = fopen("Ulaz.txt","r");
   cin>>A>>N>>MOD;
   cout<<DP(A,N)<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<math.h>
#include<stack>
using namespace std;

#define f first
#define s second

int DP[500][500];


int main(){
   int h,w,i,j,k,l;
   scanf("%d%d",&h,&w);
   for(i=0;i<500;i++)for(j=0;j<500;j++)DP[i][j]=99999;
   for(i=1;i<=h;i++){
      for(j=1;j<=w;j++){
         if( i==j )DP[i][j]=1;                  
         for(k=1;k<=i/2;k++){
             DP[i][j] = min( DP[i][j] , DP[i-k][j]+DP[k][j] );
         }
         for(k=1;k<=j/2;k++){
             DP[i][j] = min( DP[i][j] , DP[i][j-k]+DP[i][k] );
         }
      }
   }
   
      for(i=1;i<=h;i++){
      for(j=1;j<=w;j++){
                        cout<<DP[i][j]<<" ";
                        }cout<<endl;}
   system("Pause");
   
   
   printf("%d\n",DP[h][w] );
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
#include<set>
#include<cstdlib>
using namespace std;

struct coord{
   double x,y;
   coord(double p1,double p2):x(p1),y(p2){};
   coord(){};
   double cross( coord a, coord b ){
      return (a.x-x)*(b.y-y)-(a.y-y)*(b.x-x);
   }
};

struct segment{
   coord A,B;
   segment( coord a , coord b ):A(a),B(b){};
   segment(){};
};

bool On_Line( coord A, coord B, coord C ){
   return ( min(A.x,B.x)<=C.x && C.x<=max(A.x,B.x)  && min(A.y,B.y)<=C.y && C.y<=max(A.y,B.y) );
}

bool Intersect( coord A,coord A1, coord B,coord B1 ){
   double s1 = A.cross(A1,B);
   double s2 = A.cross(A1,B1);
   double s3 = B.cross(B1,A);
   double s4 = B.cross(B1,A1);
   if( ((s1>0 && s2<0)||(s1<0 && s2>0)) && ((s3>0 && s4<0)||(s3<0 && s4>0)) )return true;
   else if( fabs(s1)<0.01 && On_Line(A,A1,B) )return true;
   else if( fabs(s2)<0.01 && On_Line(A,A1,B1) )return true;
   else if( fabs(s3)<0.01 && On_Line(B,B1,A) )return true;
   else if( fabs(s4)<0.01 && On_Line(B,B1,A1) )return true;
   return false;
}

vector<coord>ToConnect;
vector<segment>segments;
vector<int>graph[3000];


bool visited[3000];
bool DFS( int node , vector<int> &path ){
   if( int(path.size())-2 >300 )return false;
   if( node==1 )return true;
   bool pass;
   visited[node]=true;
   for(int i=0;i<graph[node].size();i++){
      if( visited[graph[node][i]]==false ){
         path.push_back( graph[node][i] );
         pass = DFS( graph[node][i] , path );
         if( pass ) return true;
         else path.pop_back();
      } 
   }
   return false;
} 

int main(){
   int n,i,j,k;
   double x1,y1,x2,y2;
   //FILE *in = fopen("Ulaz.txt","r");
   scanf("%lf%lf%lf%lf",&x1,&y1,&x2,&y2);
   ToConnect.push_back( coord(x1,y1) );ToConnect.push_back( coord(x2,y2) );
   scanf("%d",&n);
   double ADD=0.01;
   for(i=0;i<n;i++){
      scanf("%lf%lf%lf%lf",&x1,&y1,&x2,&y2);
      if( x1+ADD < 300.009  && On_Line(coord(x1,y1),coord(x2,y2),coord(x1+ADD,y1) )==false    ) ToConnect.push_back( coord(x1+ADD,y1) );
      if( x1-ADD >=0     && On_Line(coord(x1,y1),coord(x2,y2),coord(x1-ADD,y1) )==false ) ToConnect.push_back( coord(x1-ADD,y1) );
      if( y1+ADD < 300.009  && On_Line(coord(x1,y1),coord(x2,y2),coord(x1,y1+ADD) )==false) ToConnect.push_back( coord(x1,y1+ADD) );
      if( y1-ADD >=0     && On_Line(coord(x1,y1),coord(x2,y2),coord(x1,y1-ADD ))==false) ToConnect.push_back( coord(x1,y1-ADD) );
      
      if( x2+ADD < 300.009  && On_Line(coord(x1,y1),coord(x2,y2),coord(x2+ADD,y2) )==false) ToConnect.push_back( coord(x2+ADD,y2) );
      if( x2-ADD >=0     && On_Line(coord(x1,y1),coord(x2,y2),coord(x2-ADD,y2) )==false) ToConnect.push_back( coord(x2-ADD,y2) );
      if( y2+ADD < 300.009  && On_Line(coord(x1,y1),coord(x2,y2),coord(x2,y2+ADD)  )==false) ToConnect.push_back( coord(x2,y2+ADD) );
      if( y2-ADD >=0     && On_Line(coord(x1,y1),coord(x2,y2),coord(x2,y2-ADD) )==false) ToConnect.push_back( coord(x2,y2-ADD) );
      segments.push_back( segment(coord(x1,y1) , coord(x2,y2)) );
   }
   int nodes = ToConnect.size();
   for(i=0;i<nodes;i++){
      for(j=i+1;j<nodes;j++){
         bool PASS=true;
         for(k=0;k<n && PASS;k++){
            PASS = !Intersect( ToConnect[i],ToConnect[j], segments[k].A , segments[k].B );
         }
         if(PASS){
            graph[i].push_back(j);
            graph[j].push_back(i);
         }
      }
   }
  // cout<<0<<endl;return 0;
   vector<int>PATH(1,0);
   DFS(0,PATH);
   cout<<((int)PATH.size())<<endl;
   for(i=0;i<PATH.size();i++){
      printf("%.2lf %.2lf\n", ToConnect[ PATH[i] ].x , ToConnect[ PATH[i] ].y );
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<algorithm>
using namespace std;

#define f first
#define s second

////////////////////////// MATHEMATICAL PART :P ///////////////////
struct coord{
   int x,y;
   coord( int p1,int p2):x(p1),y(p2){};
   coord(){};
};

struct segment{
   coord P1,P2;
   segment( coord p1 , coord p2 ):P1(p1),P2(p2){};
   segment(){};
};

double Xsec,Ysec;
void IntersectionCalc( double &x1, double &y1, double &x2, double &y2 , double &x3,double &y3,   double &x4,double y4 ){
   double A1 = y2 - y1;
   double B1 = x1 - x2;
   double C1 = x1*A1 + y1*B1;
   
   double A2 = y4 - y3;
   double B2 = x3 - x4;
   double C2 = x3*A2 + y3*B2;
   
   double det  = A1 * B2 - B1 * A2;
   double detX = B2 * C1 - B1 * C2;
   double detY = A1 * C2 - A2 * C1;
   
   Xsec = detX/det;
   Ysec = detY/det;
}

double cross( double nullX, double nullY , double x,double y,   double x1,double y1 ){
   return (x-nullX)*(y1-nullY) - (y-nullY)*(x1-nullX);
}

bool OnLine( double &x1,double &y1, double &x2, double &y2 , double &x, double &y ){
   return( min(x1,x2)<=x && x<=max(x1,x2) && min(y1,y2)<=y && y<=max(y1,y2) );
}

bool Intersect( double &x1, double &y1, double x2, double y2 , double x3,double y3,   double x4, double y4 ){
   double s1 = cross( x1,y1,  x2,y2 , x3,y3 );
   double s2 = cross( x1,y1,  x2,y2 , x4,y4 );
   if( ( s1<0 && s2>0)||(s1>0 && s2<0) )           { IntersectionCalc(  x1,  y1,  x2,  y2 ,  x3, y3,    x4, y4 ); return true; }
   else if( s1==0 && OnLine( x1,y1,x2,y2, x3,y3 ) ){ IntersectionCalc(  x1,  y1,  x2,  y2 ,  x3, y3,    x4, y4 ); return true; }
   else if( s2==0 && OnLine( x1,y1,x2,y2, x4,y4 ) ){ IntersectionCalc(  x1,  y1,  x2,  y2 ,  x3, y3,    x4, y4 ); return true; }
   return false;
}

double sqr( double t ){
   return t*t;
}

double DIST( double x, double y, double x1,double y1 ){
   return sqrt( sqr(x-x1) + sqr(y-y1) );
}

/////////////////////////

int n;
segment spaghetti[10000];

double hipotenusis = 2828429;
bool AvailableSec;
double Tolerance = 0.0000000000000000000000000000001;
pair<double,double>SUM( double angle ){ // sin = naspramna/hipotenuza , cos = nalegla/hipotenuza :P
   AvailableSec = false;
   double f(0),s(0);
   double x = cos( angle*M_PI/180 ) * hipotenusis;
   double y = sin( angle*M_PI/180 ) * hipotenusis;
   //cout<<"  "<<x<<" "<<y<<" ( "<<angle<<endl;
   double nX(0),nY(0);
   for( int i =0 ; i< n ; i++ ){
      bool Int = Intersect( nX,nY, x,y , spaghetti[i].P1.x,spaghetti[i].P1.y, spaghetti[i].P2.x,spaghetti[i].P2.y );
     // cout<<spaghetti[i].P1.x<<","<<spaghetti[i].P1.y<<"   "<<spaghetti[i].P2.x<<","<<spaghetti[i].P2.y<<" => ";
      if( Int== true ){
         double s1 = cross( nX,nY, x,y,  spaghetti[i].P1.x,spaghetti[i].P1.y );
         double s2 = cross( nX,nY, x,y,  spaghetti[i].P2.x,spaghetti[i].P2.y );
         //cout<<s1<<" "<<s2<<endl;
         if( s1<-Tolerance ){AvailableSec = true;s += DIST( Xsec,Ysec,spaghetti[i].P1.x,spaghetti[i].P1.y);}
         if( s1>Tolerance )f += DIST( Xsec,Ysec,spaghetti[i].P1.x,spaghetti[i].P1.y);
         
         if( s2<-Tolerance ){AvailableSec = true;s += DIST( Xsec,Ysec,spaghetti[i].P2.x,spaghetti[i].P2.y);}
         if( s2>Tolerance )f += DIST( Xsec,Ysec,spaghetti[i].P2.x,spaghetti[i].P2.y);
      }else{
         double s1 = cross( nX,nY, x,y,  spaghetti[i].P1.x,spaghetti[i].P1.y );
         if( s1<-Tolerance )s += DIST( spaghetti[i].P2.x,spaghetti[i].P2.y,spaghetti[i].P1.x,spaghetti[i].P1.y);
         if( s1>Tolerance )f += DIST( spaghetti[i].P2.x,spaghetti[i].P2.y,spaghetti[i].P1.x,spaghetti[i].P1.y);
      }
   //   cout<<f<<" "<<s<<endl;
   }
   return pair<double,double>(f,s);
}

double bsearch( double lo, double hi ){
   if( lo<=hi ){
      double mid = (lo+hi)/2;
    //  cout<<mid<<endl;
      pair<double,double> S = SUM( mid );
      //cout<<"SUM: "<<S.f<<" "<<S.s<<endl<<endl;
      if( AvailableSec == false && fabs(S.f-S.s)<Tolerance ) return bsearch( lo, mid-Tolerance );
      if( fabs(S.f-S.s)<Tolerance ) return mid;
      else if( S.f > S.s ) return bsearch( mid+Tolerance , hi );
      else return bsearch( lo, mid-Tolerance);
   }
   return -1;
}

int main(){
  // cout<<cross(0,0,10,10,5,6)<<endl;
   //FILE *in = fopen("Ulaz.txt","r");
   int i,j,k;
   int x1,y1,x2,y2;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
      spaghetti[i] = segment( coord(x1,y1) , coord( x2,y2) );
   }
   printf("%.2f\n",bsearch( 0, 90 ));
   //system("Pause");
   return 0;
}

#include<iostream>
#include<math.h>
#include<cstdio>
#include<vector>
using namespace std;


int primes[]={ 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139}; // size = 34
int DP[20001][22];

int main(){
   int a,b,k;
   int i,j,l;
   int res =0 ;
   scanf("%d%d%d",&a,&b,&k);
   for(i=0;i<34;i++)DP[  primes[i]*primes[i] ][1]=1;
   
   for(i = 1; i < 20000 ; i++ ){
         for(j=0;j<34;j++)
         {
            if( i + primes[j]*primes[j] > 20000 ) break;
            for( l = 1 ; l < k; l ++ )
               if( DP[i][l]>0 )
                    DP[ i + primes[j]*primes[j] ][ l+1 ] = DP[ i + primes[j]*primes[j] ][21] = true;
               
         }
   }
   for(i=a;i<=b;i++)res+=DP[i][21];
   cout<<res<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<cstdio>
#include<math.h>
using namespace std;

int directions[][2] = { 0,-1,  1,-1 , 1,0 , 1,1,   0,1 , -1,1,  -1,0, -1,-1 }; // N , NE , E , SE , S , SW , W , WN
                                                                               // 0   1    2   3   4     5   6   7
struct player{
       int x,y;
       int direct;
       void ClockWise(){
          direct++;
          if( direct==8 ) direct = 0;
       }
       void Counter(){
          direct--;
          if( direct==-1 ) direct = 7;
       }
};
int InGame[4];
char buff[30];
int matrica[26][26];

int main(){
   int n,m,i,j,k;
   scanf("%d%d",&n,&m);
   for(i=0;i<n+1;i++)matrica[i][0]=matrica[i][m+1]=9;
   for(i=0;i<m+2;i++)matrica[0][i]=matrica[n+1][i]=9;
   player P[4];
   for(i=1;i<=n;i++){
      scanf("%s",buff);
      for(j=1;j<=m;j++){
         if( buff[j-1]=='#' ){
            matrica[i][j] = 9;
         }else if(buff[j-1]=='N'){
            P[0].x = j, P[0].y = i, P[0].direct = 0;
         }else if(buff[j-1]=='S'){
            P[1].x = j, P[1].y = i, P[1].direct = 4;
         }else if(buff[j-1]=='W'){
            P[2].x = j, P[2].y = i, P[2].direct = 6;
         }else if(buff[j-1]=='E'){
            P[3].x = j, P[3].y = i, P[3].direct = 2;
         }
      }
   }
   for(i=0;i<10000;i++){
      bool pass = false;
      int sum=0;
      for(j=3;j>=0;j--){
         if( InGame[j]!=0){sum++;continue;}
         if( j!=0 && P[0].x == P[j].x && P[0].y == P[j].y ){
            InGame[j]=i;
            continue;
         }
         if( sum==3 )break;
         pass = true;
         for( k = 0 ; k < 8 ; k ++ ){
            if( matrica[   P[j].y + directions[ P[j].direct ][1]  ]  [  P[j].x + directions[ P[j].direct ][0]   ] == 0 ){
                P[j].y += directions[ P[j].direct ][1];
                P[j].x += directions[ P[j].direct ][0];
                break;
            }
            if( j==0 )P[j].ClockWise();
            else      P[j].Counter();
         }
      }
      if( pass == false ){
         break;
      }
   }
   if( InGame[3] == 0 )printf("NEVER\n");
   else printf("%d\n",InGame[3]);
   if( InGame[1] == 0 )printf("NEVER\n");
   else printf("%d\n",InGame[1]);
   if( InGame[2] == 0 )printf("NEVER\n");
   else printf("%d\n",InGame[2]);
   return 0;
}

// HELP BY BOSANAC
#include<cstdio>
#include<cstdlib>

int main(){
   double S = 4;int N;
   scanf("%d",&N);
   for(int i=0;i<N-2;i++){
      S = 1/S + 2;
      if(i<N-3)S += i*2 + 4;
   }
   if(N==2)printf("%.10lf\n",S);
   printf("%.10lf\n",S*2);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;

#define ull unsigned long long

struct R{
   ull num,den;
   R( ull p1,ull p2 ):num(p1),den(p2){};
   R(){};
   void check(){
      ull common = __gcd(den,num);
      den/=common;
      num/=common;
   }
   R operator+( R b ){
      ull Nden = (den*b.den)/__gcd(den,b.den);
      ull Nnum = num*(Nden/den) + b.num*(Nden/b.den);
      R www = R( Nnum , Nden );
      www.check();
      return www;
   }
   R operator*( R b ){
      ull comm1 = __gcd(num,b.den);
      ull comm2 = __gcd(b.num,den);
      num/=comm1;
      b.den/=comm1;
      b.num/=comm2;
      den/=comm2;
      R www = R(num*b.num , den*b.den);
      www.check();
      return www;
   }
   void reverse(){
      swap( den,num);
   }
};

int main(){
   ull N,farad,i,j;
   ull num=2;
   cin>>N>>farad;
   R current = R(farad,2);
   for(i=0;i<N-2;i++){
      current = current + R(farad,num);
      
      current.reverse();
      current = current + R(2,farad);
      current.reverse();
      current.check();
      num+=2;
   }
   current.num*=2;
   current.check();
   cout<<current.num<<"/"<<current.den<<endl;
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<vector>
#include<math.h>
using namespace std;

char field[1101][1101];
int DP[1001][1001];

int main(){
   int n,m,i,j;
   int MAX = 0;
   scanf("%d%d\n",&n,&m);
   for(i=0;i<n;i++){
      scanf("%s",field[i]);
      for(j=0;j<m;j++)
         DP[i][j] = field[i][j]=='#';   
   }
   for(i=2;i<n;i++){
      for(j=1;j<m-1;j++){
         if( field[i][j]=='#' )
             DP[i][j] = min( DP[i-1][j-1] , min( DP[i-1][j] , min( DP[i-1][j+1] , DP[i-2][j] ) )  )+1;
         MAX = max( DP[i][j] , MAX );
      }
   }
   cout<<MAX<<endl;
   system("Pause");
   return 0;
}


#include<iostream>
#include<cstdio>
#include<set>
using namespace std;

int coord[900][2];

int main(){
   multiset<double>diff;
   int n,i,j;
   int NM = 0;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d %d",&coord[i][0],&coord[i][1]);
      for(j=0;j<i;j++){
         diff.insert( 1.f * (coord[i][1]-coord[j][1]) / (coord[i][0]-coord[j][0]) );
      }
      for( multiset<double>::iterator it = diff.begin() ; it!=diff.end() ; it ++ )
         NM = max( (int)diff.count(*it) , NM );
      diff.clear();
   }
   printf("%d\n",NM+1);
   system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
using namespace std;

int niz[3000];
int sorted[3000];int Ssort;

int main(){
   int n,k,m,i,j;
   scanf("%d%d%d",&n,&k,&m);Ssort = n+1;
   for(i=0;i<n;i++){
      scanf("%d",&niz[i]);
      sorted[i]=niz[i];
   }  sorted[i]=0;
   sort( sorted,sorted+n+1 ) ;
   for(i=0;i<n+1;i++){
      int cuts  = m;
      for(j=0;j<n;j++){
         if( niz[j] >= sorted[i]+1 ){
            cuts--;
            if(cuts<0)break;
            j+=k-1;
         }
      }
      if( j>=n ) break;
   }
   printf("%d\n",sorted[i]);
  // system("Pause");
   return 0;
}

#include<cstdio>
#include<cstdlib>
#include<iostream>
using namespace std;


int niz[100000][3];

int main(){
   int n,i,j;
   scanf("%d",&n);
   
   for(i=0;i<n;i++)
      scanf("%d%d%d",&niz[i][0],&niz[i][1],&niz[i][2]);
   int res = 0;
   for(i=1;i<=100000;i++){
                      //    cout<<i<<endl;
      for(j=0;j<n;j++){
         if( i-niz[j][0]>=0 && (i-niz[j][0])%niz[j][2]==0 && (i-niz[j][0])/niz[j][2]<=niz[j][1] ){
            res++;break;}
      }
   }
   printf("%d\n",res);
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;

long long res=0;
int niz[100009];

void conquer( int lo1, int hi1, int lo2,int hi2 ){
   vector<int>V,V1;
   for( int i = lo1 ; i<= hi1 ; i++) V.push_back(niz[i]);
   for( int i = lo2 ; i<= hi2 ; i++) V1.push_back(niz[i]);
   int count = 0;
   int poz = lo1, i=0,j=0;
   while( i<V.size() || j<V1.size() ){
      if( i<V.size() && ( j==V1.size() || V[i]<=V1[j])  ){
         niz[poz]=V[i]; i++; poz++;
         res+=count;
      }
      if( j<V1.size() && ( i>=V.size() || V1[j]<V[i])  ){
         niz[poz]=V1[j];j++;poz++;
         count++;
      }
   } 
}

void divide( int lo, int hi ){
   int mid = (lo+hi)/2;
   if( lo+1<hi ){
      divide( lo, mid );
      divide( mid+1, hi);
      conquer( lo,mid, mid+1,hi );
   }
   if(lo<=hi)conquer( lo,mid, mid+1,hi );
}

int main(){
  // FILE *in = fopen("reli.03.in","r");
   int n;
   scanf("%d",&n);
   for(int i=0;i<n;i++)
      scanf("%d",&niz[i]);
   divide(0,n-1);
   cout<<res%10000<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<math.h>
#include<cstdio>
#include<fstream>
#include<vector>
using namespace std;

double logs[100];

int main(){
   int i;
   for(i=0;i<=100;i++)logs[i]=log2(i);
   int n;
   int a;int b;
   scanf("%d",&n);
   double RES=0;
   for(i=0;i<n;i++){
      scanf("%d%d",&a,&b);
      if(a==1)
         RES += fabs(logs[b]-logs[100]);
      else
         RES += fabs(logs[100-b]-logs[100]);
   }
   printf("%.5lf\n",RES);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
#include<set>
#include<stack>
using namespace std;

#define f first
#define s second

int n,m,k;
int visited[10005];
vector< pair<int,int> >struja[10005];
vector< pair<int,int> >non;
vector<int>times;

void DFS(int node,int mark,int time){
   int i;
   stack<int>S;
   S.push(node);
   while(!S.empty()){
      int u = S.top();S.pop();
      visited[u]=mark;
      for(i=0;i<struja[u].size();i++){
         //cout<<"FROM "<< u+1 <<" JUMP TO "<< struja[u][i].f+1<<" cost "<<struja[u][i].s<<" "<<( struja[u][i].s>time && visited[struja[u][i].f]==false )<<endl;
         if( struja[u][i].s>time && visited[struja[u][i].f]==false ){
            S.push( struja[u][i].f );
         }
      }
   }
}

bool Check(int time){
   int i;
   for(i=0;i<n;i++)visited[i]=0;
   int color = 1;
  // cout<<"TIME: "<<time<<endl;
   for(i=0;i<n;i++){
      if( visited[i]==false ){
         DFS(i,color,time);
         color++;
      }
   }
   for(i=0;i<k;i++){
      if( visited[ non[i].f ] == visited[ non[i].s ] ) return false;
   }
  // cout<<" PASS"<<endl;
   return true;
}

int bsearch( int lo, int hi ){
   int mid = (lo+hi)/2;
   bool pass;
   if( lo<=hi ){
      pass = Check(mid);
      if( pass && ( mid-1==-1 || !Check(mid-1) ) )
         return mid;
      else if( !pass )
         return bsearch( mid+1,hi);
      else
         return bsearch( lo, mid-1);
   }
}

int main(){
  // FILE *in = fopen("Ulaz.txt","r");
   int i,j;
   int a,b,c;
   scanf("%d%d%d",&n,&m,&k);
   set<int>filter;
   for(i=0;i<m;i++){
      scanf("%d%d%d",&a,&b,&c);
      struja[a-1].push_back( make_pair(b-1,c) );
      struja[b-1].push_back( make_pair(a-1,c) );
      if(filter.count(c)==0){
         times.push_back(c);
         filter.insert(c);
      }
   }
   for(i=0;i<k;i++){scanf("%d%d",&a,&b);non.push_back( make_pair(a-1,b-1) );}
   sort(times.begin(),times.end() );
   cout<<bsearch(0,times[times.size()-1] )<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<string>
#include<algorithm>
#include<fstream>
#include<math.h>
using namespace std;

char buff[101];

int main(){
   int i,j;
   scanf("%s",buff);
   int L = strlen(buff);
   int R=1;
   int C=L;
   int T;
   while( R<=L/R ){
      if( L%R==0 ){
         C = L/R;
         T = R;
      }
      R++;
   }R--;
   R=T;
   for(i=0;i<R;i++){
      for(j=0;j<C;j++){
         printf("%c",buff[i+j*R]);
      }
   }
   cout<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<vector>
#include<queue>
using namespace std;

vector<int>graph[100];
int ulaz[100];
bool took[100];

int main(){
   int n,m;
   int a,b;
   int i,j,k;
   FILE *in = fopen("Ulaz.txt","r");
   fscanf(in,"%d%d",&n,&m);
   for(i=0;i<m;i++){
      fscanf(in,"%d%d",&a,&b);
      graph[a].push_back(b);
      ulaz[b]++;
   }
   int node;
   queue<int>NULLS;
   for(i=0;i<n;i++)
      if(ulaz[i]==0){
         NULLS.push(i);

      }
   if( NULLS.empty() ){ cout<<"IMPOSSIBLE"<<endl;system("Pause");return 0;}
   vector<int>RES;
   int visited = 1;
   while( NULLS.empty()==false )
   {
      node = NULLS.front();NULLS.pop();
      RES.push_back(node);
      for(j=0;j<graph[node].size();j++){
         ulaz[ graph[node][j] ]--;
         if( ulaz[ graph[node][j] ]==0  ){
            visited++;
            NULLS.push( graph[node][j] );
         }
      }
   }
   if( visited!=n ){cout<<"IMPOSSIBLE"<<endl;  system("Pause");return 0;}
   for(i=0;i<RES.size();i++){
      cout<<RES[i]<<" ";
   }cout<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<cstdlib>
using namespace std;

bool triangle[250][250];
int DP[250][250];

int main(){
   int n,T=0;
   //FILE *in = fopen("Ulaz.txt","r");
   while(1){T++;
      scanf("%d",&n);
      if(n==0)break;
      int ROW = n*2 - 1;
      int i=0,j=0,k;
      char c;
      while(1){
         if( ROW==-1)break;
         scanf("%c",&c);
         if( c!='-' && c!='#' )continue;
         if( c=='#')triangle[j][i]=1;
         else triangle[j][i]=0;
         i++;
         if(i==ROW){
            j++,i=0;
            ROW -= 2;
         }
      }
      int res = 0;
      ROW = n*2 - 1;
      for(i=0;i<ROW;i++){
         DP[0][i]=!triangle[0][i];
         res = max(res,DP[0][i]);
      }
      ROW-=2;
      for(i=1;i<n;i++)
      {
         for(j=0;j<ROW;j++)
         {
            if( triangle[i][j]==0 ){
               if(DP[i-1][j+1]!=0 && (j+1)%2 )DP[i][j] = min(DP[i-1][j],DP[i-1][j+2])+1;
               else DP[i][j]=1;
            }else DP[i][j]=0;
            res = max(res,DP[i][j]);
         }
         ROW-=2;
      }
      DP[n-1][0]=!triangle[n-1][0];
      res = max(res,DP[n-1][0]);
      ROW = 3;
      for(i=n-2;i>=0;i--)
      {
         for(j=0;j<ROW;j++){
            if( triangle[i][j]==0 ){
               if( j>1 && j%2 && DP[i+1][j-1]!=0 ) DP[i][j]=min(DP[i+1][j-2],DP[i+1][j])+1;
               else      DP[i][j]=1;
            }else DP[i][j]=0;
            res = max(res,DP[i][j]);
         }
         ROW+=2;
      }
      printf("Triangle #%d\n",T);
      printf("The largest triangle area is %d.\n\n",res*res);
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<math.h>
#include<fstream>
using namespace std;

string S;
int NewH,NewW;
int res( int l ,int r, bool black ){
   int ret = 0;
   int H=1,W=1,i;
   int count = 0;
   int St=l+1;
   for(int i=l+1;i<r;i++){
      if( S[i]=='(')count++;
      if( S[i]==')')count--;
      if( count == 0 ){
         ret += res( St , i , !black );
         H = max(H,NewH+1), W += NewW + 1;
         St = i+1;
      }
   }
   NewH = H;
   NewW = W;
   printf("PASS\n");
   if( black == true ){
      return ret + (H) *W;
   }else
      return ret + (-H*W);
}

int main(){
   ifstream cin("Ulaz.txt");
   ofstream out("Izlaz.txt");
   int t;
   cin>>t;
   cout<<t<<endl;
   for(int i=0;i<t;i++){//cout<<i<<endl;
      cin>>S;
      long long sol = 0;
      int count = 0;
      int St = 0;
      for(int j=0;j<S.size();j++){
         if( S[j]=='(') count++;
         if( S[j]==')') count--;
         if( count==0 ){
              sol += res(St,j,true);
              St = j+1;
         }
      }
      out<<sol<<endl;
      cout<<sol<<endl;
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
using namespace std;

long long Mask = 1<<8;

long long GiveByte( int idx , long long num ){
   return ( num>>(64-(idx+1)*8) & (Mask-1) );
}

int main(){
   cout<<GiveByte(6,401)<<endl;
   cout<<(8 + ( 8 & -8 ))<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdio>
#include<cstdlib>
using namespace std;

int n,m;
int niz[10001];
int sorted[10001];
int next[10001];
int disk[510];

void prepare(){
   int i;
   for( i=0;i<n;i++){
      next[ niz[ sorted[i] ] ] = i;
      while( i<n && niz[sorted[i]]==niz[sorted[i+1]] )i++;
   }
}

void GotoNext( int val ){
   next[ val ] = next[val] + 1;
}
void GotoPrev( int val ){ next[ val ] = next[val] - 1; }
int Peek( int val ){
   return niz[sorted[next[val]]];
}

bool cmpI( int a, int b ){
   if (niz[a] < niz[b]) return true;
   if( niz[a]==niz[b] ) return a<b;
   return false;
}

int main(){
   int i,j;
   scanf("%d%d",&n,&m);
   for(i=0;i<n;i++){
      scanf("%d",&niz[i]);
      sorted[i]=i;
   }
   sort( sorted, sorted + n , cmpI );
    


   prepare();
    for(int i=0; i < n; i++ )cout<< next[film[sorted[i]]]<<endl;
    system("Pause");
   
   
   
   
   int OnDisk=0;
   int Quality;
   int res=0;
   for(i=0;i<n;i++){
      int MemPlace = -1;
      Quality = -1;
      for(j=0;j<m;j++){
         if( disk[j] == niz[i] ){          MemPlace=-1;Quality=3;break;    }
         if(  Peek( disk[j] ) != disk[j] ){ MemPlace=j; Quality=2;continue; }
         if( (MemPlace==-1 || sorted[ next[disk[j]] ] > sorted[ next[disk[MemPlace]] ]) && Quality<2 ){ MemPlace=j;Quality=1; }
      }
      if(OnDisk<m && MemPlace!=-1 ){ disk[OnDisk]=niz[i];OnDisk++;res++;  }
      else if( MemPlace!=-1 ){
         disk[MemPlace] = niz[i];
         res++;
      }
      if( Peek( niz[i] ) == niz[i] )
         GotoNext( niz[i] );
   }
   cout<<res<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<string>
#include<cstdlib>
using namespace std;

string res = "z";
string str;

void find( string a, string b , string c ){
   reverse(a.begin(),a.end());
   reverse(b.begin(),b.end());
   reverse(c.begin(),c.end());
   
   string T = a+b+c;
   if( res>T)res=T;
}

int main(){
    //ifstream cin("Ulaz.txt");
   cin>>str;
   int L = str.size(),i,j;
   for(i=0;i<L;i++){
      for(j=2;j<L-i;j++){
         string A = string(str,0,i+1);
         string B = string(str,i+1,j-1);
         string C = string(str,j+i,L-i);
        // cout<<A<<" "<<B<<" "<<C<<endl;
         find(A,B,C);
      }
   }
   cout<<res<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<algorithm>
#include<cstdlib>
#include<vector>
#include<math.h>
using namespace std;

class DisjointSet{
   private:
      int *sz;
      int *id;
      int i,j;
   public:
      DisjointSet( int size ):sz(new int[size]),id(new int[size]){
         for(int i=0;i<size;i++){
            id[i]=i;
            sz[i]=1;
         }
      };
      DisjointSet(){};
      bool Check( int a, int b ){
         for(i=a;i!=id[i];i=id[i])
            id[i] = id[ id[i] ];
         for(j=b;j!=id[j];j=id[j])
            id[j] = id[ id[j] ];
         if(i==j)return true;
         return false;
      }
      void Connect(){
         if( sz[i] < sz[j] )
            id[i]=j, sz[j]+=sz[i];
         else
            id[j]=i, sz[i]+=sz[j];
      }
};

struct edge{
   int a,b;
   double D;
   edge( int a_ , int b_ , double D_ ):a(a_),b(b_),D(D_){};
   edge(){};
};

int coord[1000][2];
vector<edge>V;
vector<edge>MST;

double sqr( double v ){
   return v*v;
}

double dist( int i , int j ){
   return sqrt(  sqr(coord[i][0]-coord[j][0]) + sqr(coord[i][1]-coord[j][1]) );
}

bool cmpV ( edge a , edge b ){
   return a.D < b.D;
}

int main(){
   int n,i,j,x,y;
   FILE *in = fopen("Ulaz.txt","r");
   fscanf(in,"%d",&n);
   for(i=0;i<n;i++){
       fscanf(in,"%d%d",&coord[i][0],&coord[i][1]);
       for(j=0;j<i;j++){
          V.push_back( edge(i,j,dist(i,j)) );
       }
   }
   sort( V.begin() , V.end() , cmpV );
   DisjointSet S(1000);
   int sel = 0;
   for(i=0;i<V.size() && sel!=n-1;i++ ){
      bool B = S.Check( V[i].a , V[i].b );
      if( B==false ){
         S.Connect();
         MST.push_back( V[i] );
         sel++;
      }
   }
   for(i=0;i<MST.size();i++){
      cout<<MST[i].a<<" "<<MST[i].b<<endl;
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<fstream>
#include<math.h>
#include<algorithm>
using namespace std;

const int MAXJ = 1000000;
int niz[MAXJ+1];

bool isprime(int v ){
   if( v%2==0 && v!=2 )return false;
   for(int i=3;i*i<=v;i+=2 )
      if( v%i==0 )return false;
   return true;
}

int main(){
   int i,j,a,b;
   scanf("%d%d",&a,&b);
   if(a==1){cout<<"1";return 0;}
   for(i=b;i>=a;i--){
      if( isprime(i) ){
         cout<<i;return 0;
      }
   }
   for(i=1;i<=b/2;i++){
      j=2;
      while(i*j<=b ){
         niz[i*j]+=i;
         j++;
      }
   }
   double min = 1<<10;
   int res = 0;
   for(;a<=b;a++){
      double F = niz[a]/a;
      if( F<min ){
         res = a;
         min = F;
      }
   }
   cout<<res<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
using namespace std;

int n,k,m;
int x[10010];
int a[500010];

void SegmentCode(){
   int j = 0,s;
   for( int i=0;i<n;i++){
      a[i] = x[j];
      s = (j+1) % k;
      x[j] = ((x[j] ^ x[s]) + 13 ) % m;
      j = s;
   }
}

int main(){
   int i,j;
 //  FILE *in = fopen("Ulaz.txt","r");
   scanf("%d%d%d",&n,&k,&m);
   for(i=0;i<k;i++)scanf("%d",&x[i]);
   SegmentCode();
   int MaxIdx=0;
   int Res=0;
   for(i=0;i<n;i++){
      int diff = i-MaxIdx-1;
      int t = a[MaxIdx]+a[i]+(n-diff);
      if( MaxIdx!=i && t > Res ){
         Res = t;
      }
      if( a[MaxIdx]-diff-1 < a[i] ){
         MaxIdx = i;
      }
   }
   for(i=0;i<n;i++){
      int diff = n-MaxIdx-1+i;
      int t = a[MaxIdx]+a[i]+(n-diff);
      if( MaxIdx!=i && t > Res ){
         Res = t;
      }
      if( a[MaxIdx]-diff < a[i] ){
         break;
      }
   }
   cout<<Res<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<cstdlib>
using namespace std;

// A = 0
// B = 1
// C = 2
// D = 3

long long L;
long long limit;
int search;
long long DP[60][4];

long long combinations( int deep, int mode ){
   if( DP[deep][mode]!= -1 )return DP[deep][mode];
   if( deep == limit && ::search==mode ) return 1;
   if( deep == limit )return 0;
   long long S=0;
   if( mode == 0 ){
      S+=combinations( deep+1, 1 );
      S+=combinations( deep+1, 2 );
   }else if( mode == 1 ){
      S+=combinations( deep+1, 0 );
      S+=combinations( deep+1, 3 );
   }else if( mode == 2 ){
      S+=combinations( deep+1, 0 );
      S+=combinations( deep+1, 3 );
   }else{
      S+=combinations( deep+1, 1 );
      S+=combinations( deep+1, 2 );
   }
  // cout<<S<<endl;
   return DP[deep][mode]=S;
}

void track( int deep, int mode, long long ostalo , string &res ){
   if( deep == limit )return;
   long long val;
 //  cout<<ostalo<<" "<<mode<<endl;
   if( mode==0 ){
      val = combinations( deep+1, 2 ); // C ( 0 ) lexicographical smaller
      if( val>=ostalo ){
         res += "0";
         track(deep+1,2,ostalo,res);
         return;
      }
      ostalo-=val;
      val = combinations( deep+1, 1 ); // B( 1 )
      if( val>=ostalo ){
         res += "1";
         track(deep+1,1,ostalo,res);
         return;
      }
   }else if( mode==1 ){
      val = combinations( deep+1, 3 ); // D ( 0 ) lexicographical smaller
      if( val>=ostalo ){
         res += "0";
         track(deep+1,3,ostalo,res);
         return;
      }
      ostalo-=val;
      val = combinations( deep+1, 0 ); // A( 1 )
      if( val>=ostalo ){
         res += "1";
         track(deep+1,0,ostalo,res);
         return;
      }
   }else if( mode==2 ){
      val = combinations( deep+1, 0 ); // A ( 0 ) lexicographical smaller
      if( val>=ostalo ){
         res += "0";
         track(deep+1,0,ostalo,res);
         return;
      }
      ostalo-=val;
      val = combinations( deep+1, 3 ); // D( 1 )
      if( val>=ostalo ){
         res += "1";
         track(deep+1,3,ostalo,res);
         return;
      }
   }else{
      val = combinations( deep+1, 1 ); // B ( 0 ) lexicographical smaller
      if( val>=ostalo ){
         res += "0";
         track(deep+1,1,ostalo,res);
         return;
      }
      ostalo-=val;
      val = combinations( deep+1, 2 ); // C( 1 )
      if( val>=ostalo ){
         res += "1";
         track(deep+1,2,ostalo,res);
         return;
      }
   }
   
}


int main(){
   char c;
   int i,j;
   for(i=0;i<4;i++) for(j=0;j<60;j++)DP[j][i]=-1;
   cin>>c>>limit>>L;
   ::search = c -'A';
   combinations(0,0);
   string s;
   track(0,0,L,s);
   if( s!="")
      cout<<s<<endl;
   else
      cout<<"impossible"<<endl;
   system("Pause");
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <vector>
#include <iomanip>
#include <set>
#include <string.h>
#include <algorithm>
using namespace std;

int n,d,m;
int mx[100][100][11];
int dp[100][100][11];

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    while( fscanf(in,"%d%d%d",&n,&d,&m) == 3 ){

        if( n == 0 && d == 0 && m == 0 )break;
           n = n + 3;

        memset( dp , 0 , sizeof(dp));
        memset( mx, 0 , sizeof(mx));

        int x,y,t,xtt = 0;
        for( int i = 0; i < m; ++i ){
            fscanf(in,"%d%d%d",&x,&y,&t);
            xtt = max( xtt,t);
            mx[y+2][x+2][t] = true;
        }

        for( int i = 1; i <= xtt; ++i ){
            for( int y1 = 0; y1 <= n; ++y1 ){
                for( int x1 = 0; x1 <= n; ++x1 ){


                    for( int y2 = 0; y2 <= n; ++y2 ){
                        for( int x2 = 0; x2 <= n; ++x2 ){
                             if( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) > d*d )continue;

                             int cnt = 0;

                             for( int x3 = min(x1,x2); x3 <= max(x1,x2); ++x3 ){
                                 for( int y3 = min(y1,y2); y3 <= max(y1,y2); ++y3 ){
                                     if( mx[y3][x3][i] ){
                                         cnt += ( x2 - x1 ) * ( y3 - y1 ) - ( y2 - y1 ) * ( x3 - x1 ) == 0;
                                     }
                                 }
                             }
                             if( dp[y2][x2][i+1] < dp[y1][x1][i] + cnt )dp[y2][x2][i+1] = dp[y1][x1][i] + cnt;
                        }
                    }


                }
            }

        }
        int sol = 0;
        for( int i = 0; i <= n; ++i )
            for( int j = 0; j <= n; ++j )
                sol = max( sol , dp[i][j][xtt+1]);


        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
using namespace std;

int main(){
    for( int a = 1; a <= 2000; ++a ){
        cout<<a<<endl;
        for( int b = 1; b <= 2000; ++b ){
            for( int c = 2; c <= 2000; ++c ){
                int d = (a+b+c) / (a*b*c - 1);
                if( a+b+c+d == a*b*c*d ) printf("%d %d %d %d\n",a,b,c,d);
            }
        }
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <algorithm>
#include <math.h>
#include <fstream>
#include <map>
#include <iomanip>
#include <set>
#include <queue>
using namespace std;

#define f first
#define s second
#define piii pair<int,pair<int,int> >
#define mk make_pair

const int inf = 99999999;

int n,m,lim;
int ok[20][20];


bool visi[20];
int cnt = 0;

void dfs( int node ){
    visi[node] = true;
    cnt ++;

    for( int i = 0; i < n; ++i ){
        if( ok[node][i] == 0 || visi[i]  ) continue;
        dfs( i );
    }
}

bool bi(){
    memset(visi,false,sizeof(visi));
    cnt = 0;
    dfs(0);
    if( n != cnt ) return false;

    for( int i = 0; i < n; ++i ){
        for( int j = i;  j < n; ++j ){
            if( ok[i][j] == 0 ) continue;

            memset( visi , false , sizeof(visi));
            int c = ok[i][j];
            cnt = ok[i][j] = ok[j][i] = 0;

            dfs( 0 );

            ok[i][j] = ok[j][i] = c;
            if( n != cnt ) return false;
        }
    }
    return true;
}

struct trio{
    int f,s,t;
    trio( int p1, int p2, int p3):f(p1),s(p2),t(p3){};
    trio();
    bool operator<( const trio &t2 ) const{
        return f < t2.f;
    }
};

int edges[50][3];
int srt[50];

bool cmp( int a, int b ){
    return edges[a][2] > edges[b][2];
}

int main(){
    int T = 0;
    while( scanf("%d%d",&n,&m) ){ T++;
        if( n == 0 && m == 0 )break;

        int cost = 0, sum = 0;
        memset( ok, 0, sizeof(ok));


        for( int i = 0; i < m; ++i ){
            int a,b,c; scanf("%d%d%d",&a,&b,&c); a--, b--;
            ok[a][b] = ok[b][a] = c;
            sum += c , cost += c;

            edges[i][0] = a;
            edges[i][1] = b;
            edges[i][2] = c;
            srt[i] = i;
        }

        if( bi() == false ){
            printf("There is no reliable net possible for test case %d.\n",T);
            continue;
        }

        sort( srt , srt + m , cmp );

        for( int i = 0; i < m; ++i ){
            int a = edges[ srt[i] ][0] , b = edges[ srt[i] ][1];
            int c = ok[a][b];
            ok[a][b] = ok[b][a] = 0;


            if( bi() ) cost -= c;
            else ok[a][b] = ok[b][a] = c;
        }


        for( int i = 0; i < (1<<m); ++i ){
            int c = 0;
            for( int k = 0; k < m; ++k ){
                if( i&(1<<k) )continue;
                int a = edges[ k ][0];
                int b = edges[ k ][1];


                c += ok[ a ][ b ];
                ok[ a ][ b ] = ok[ b ][ a ] = 0;
            }

            if( sum - c < cost ){
                if( bi() ) cost = min( cost , sum - c );
            }


            for( int k = 0; k < m; ++k ){
                if( i&(1<<k) )continue;
                int a = edges[ k ][0];
                int b = edges[ k ][1];
                int c = edges[ k ][2];

                ok[ a ][ b ] = ok[ b ][ a ] = c;
            }


        }


        printf("The minimal cost for test case %d is %d.\n",T,cost);

    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <algorithm>
#include <string.h>
#include <iomanip>
#include <queue>
using namespace std;

      void ReadNum( double &v ){
         v=0;
         int sym=1;
         char c;
         while( !isdigit(c = getchar()) )
            if( c=='-') sym=-1;

         v = c - '0';
         while( isdigit(c = getchar()) )
            v = (v*10)+(c-'0');

         double divide = 1/10.0;
         if( c=='.' )
         {
            while( isdigit( c = getchar() ) ){
               v = v+ ( (c-'0')*divide );
               divide /= 10.0;
            }
         }
         v*=sym;
      }



const double inf = 999996999999LL;

int n;
double dp[24];

double v[4];

int main(){
   // freopen("Ulaz.txt","r",stdin);

    for( int i = 0; i < 24; ++i )
        dp[i] = -inf;

    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        ReadNum(v[0]);
        ReadNum(v[1]);
        ReadNum(v[2]);
        ReadNum(v[3]);

        for( int k = 0; k < (1<<4); ++k ){

            double s = 0;
            for( int d = 0; d < 4; ++d ){
                if( k&(1<<d) ) s += v[d];
                else s -= v[d];
            }

            if( dp[k] < s ) dp[k] = s;
        }

    }

    double sol = 0;
    for( int i = 0; i < (1<<4); ++i )
        sol = max( sol , dp[i] + dp[(~i)&((1<<4)-1)] );

    printf("%.3lf\n",sol);


    return 0;
}

#include <iostream>
using namespace std;







char sol[5005] = "NONPNOPNPONOPNONPNOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPONPNONPONOPNONPNOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNPOPNONPNOPNPONOPNONPNOPNPOPNONPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNPOPNONPNOPNPONOPNONPNOPNPOPNONPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPONPNONPONOPNONPNOPNPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPOPNONPNOPNPONOPNONPNOPNPOPNONPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNPOPNONPNOPNPONOPNONPNOPNPOPNONPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPOPNONPNOPNPONOPNONPNOPNPOPNONPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPONPNONPONOPNONPNOPNPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPOPNONPNOPNPONOPNONPNOPNPOPNONPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNPOPNONPNOPNPONOPNONPNOPNPOPNONPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPOPNONPNOPNPONOPNONPNOPNPOPNONPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNOPNPONOPNONPNOPNPONOPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPONPNONPONOPNONPNOPNPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPOPNONPNOPNPONOPNONPNOPNPOPNONPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNPOPNONPNOPNPONOPNONPNOPNPOPNONPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPOPNONPNOPNPONOPNONPNOPNPOPNONPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPONPNONPONOPNONPNOPNPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPOPNOPONOPNONPNOPNPONOPNONPNOPONOPNONPONOPNPONPNONPONOPNONPNOPNPONOPNONPONOPNPONPNONPONOPNONPNOPONOPNONPONOPNPOPNONPNOPNPONOPNONPNOPNPOPNONPNOP";


int main(){
    int n;
    while( cin >> n ){
        if( n == 0 )break;

        char c = sol[n];
        sol[n] = '\0';
        printf("%s\n",sol);
        sol[n] = c;

    }
    return false;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <stack>
#include <map>
#include <cstdlib>
#include <queue>
#include <map>
using namespace std;

int n,m;
int v[105];

int dp[105][20005] , h = 10000;

int sign[105];

bool solve( int idx , int sum ){

    if( idx == n ) return sum == m;
    int &ref = dp[idx][sum+h];

    if( ref != -1 ) return ref;

    if( solve( idx + 1 , sum + v[idx] ) ){
        sign[idx] = +1;
        return dp[idx][sum+h] = 1;
    }else if( solve( idx + 1 , sum - v[idx] ) ){
        sign[idx] = -1;
        return dp[idx][sum+h] = 1;
    }

    return dp[idx][sum+h] = 0;
}

int main(){
    int tests;
    scanf("%d",&tests);

    bool end = false;

    while( tests-- ){

        if( end ) putchar('\n');
        end = true;

        scanf("%d%d",&n,&m);
        for( int i = 0; i < n; ++i ) scanf("%d",&v[i]);

        if( n == 1 )continue;


        memset( dp , -1, sizeof(dp));
        bool b = solve( 2, v[0] - v[1] );

        vector< int > s;
        s.push_back( -1 );

        for( int i = 2; i < n; ++i )
            s.push_back( sign[i] );

        int c;
        bool done = false;
        while( !done ){
            done = true , c = 1;
            for(  vector< int > :: iterator it = s.begin(); it != s.end(); ++it , ++c ){
                if( *it == +1 ){ done = false; s.erase(it); printf("%d\n",c); break; }
            }
        }

        for( int k = 0; k < s.size(); ++k )
            printf("%d\n",1);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <stack>
#include <algorithm>
#include <math.h>
#include <set>
#include <queue>
using namespace std;

int n,m;

int main(){
    while( scanf("%d%d",&n,&m) ){
        if( n == 0 && m == 0 ) break;
        if( n > m ){
            printf("%.6lf\n",0);
            continue;
        }
        printf("%.6lf\n",(m-n+1)/(double)(m+1) );
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <iomanip>
#include <set>
#include <algorithm>
#include <string>
#include <string.h>
#include <math.h>
using namespace std;

const int source = 10;
const int end = 11;
const int inf = 999999;

int w,h,n;
int c[15][3]; // x,y,r

double dist[20][20];

double euclid( int x , int y , int x1, int y1 ){
    return hypot( x1-x , y1-y );
}

void add_edge( int a, int b , double d ){
    dist[a][b] = d;
    dist[b][a] = d;
}


bool visi[20];
void dfsI( int node ){
    visi[node] = true;
    for( int i = 0; i < 12; ++i )
        if( visi[i] == false && dist[node][i] <= 0 )
            dfsI( i );
}

bool vis[20];
bool dfsII( int node ){
    vis[node] = true;

    if( node == end ) return true;

    for( int i = 0; i < 12; ++i )
        if( vis[i] == false && dist[node][i] <= 0 ){
            bool ok = dfsII( i );
            if( ok ) return true;
        }
    return false;
}

int main(){
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d%d",&w,&h,&n);

        memset( visi , false , sizeof(visi));
        for( int i = 0; i < 20; ++i )
            for( int j = 0; j < 20; ++j )
                dist[i][j] = inf;

        for( int i = 0; i < n; ++i ){
            scanf("%d%d%d",&c[i][0],&c[i][1],&c[i][2]);

            int x = c[i][0] , y = c[i][1] , r = c[i][2];

            add_edge( source , i , euclid( x , y , 0 , y ) - r  );
            add_edge( end , i , euclid( x , y , w , y ) - r );

            for( int k = 0; k < i; ++k ) add_edge( i , k , euclid( x , y , c[k][0] , c[k][1] ) - c[k][2] - r );
        }
        add_edge( source , end , euclid( 0 , 0 , w , 0 ) );
        dfsI( source );

        int sol = inf;
        for( int i = 0; i < 12; ++i ){
            if( visi[i] == false )continue;
            for( int k = 0; k < 12; ++k ){
                memset( vis , false , sizeof(vis));

                if( visi[i] && !visi[k] ){
                    bool ok = dfsII( k );
                    if( ok )
                        sol = min( sol , (int)ceil(dist[i][k]/2)  );
                }
            }
        }

        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <stack>
#include <map>
#include <algorithm>
#include <set>
#include <vector>
#include <queue>
#include <string.h>
using namespace std;

int n;
bool start[7][1005] , end[7][1005] , mid[7][1005];

char buff[100];
bool tilt[129];

void input(){
    memset( tilt, false , sizeof(tilt));

    memset( start , false , sizeof(start));
    memset( end , false , sizeof(end));
    memset( mid , false , sizeof(mid));
    scanf("%d",&n);

    for( int i = 0; i < 7; ++i ){

        int m,A,B;
        scanf("%d",&m);
        for( int k = 0; k < m; ++k ){
            char c;
            A = 0;
            while( c = getchar() ) if( c >= '0' && c <= '9' ) break;
            A = c - '0';
            while( c = getchar() ) if( c >= '0' && c <= '9' ) A = A * 10 + c - '0';
                                   else break;
            B = A;
            if( c == '-' ){
                B = 0;
                while( c = getchar() ) if( c >= '0' && c <= '9' ) break;
                B = c - '0';
                while( c = getchar() ) if( c >= '0' && c <= '9' ) B = B * 10 + c - '0';
                                       else break;
            }
            start[i][A] = true;
            end[i][B] = true;
            for( int z = A+1; z < B; ++z )mid[i][z] = true;
        }
    }

    int m; scanf("%d",&m);
    for( int i = 0; i < m; ++i ){
        scanf("%s",buff);
        int mask = 0;
        int len = strlen(buff);
        for( int k = 0; k < len; ++k )
            if( buff[k] == '1' ) mask |= 1<<k;
        tilt[mask] = true;
    }
}

int alw[1000] , sz = 0;
int dp[1005][1<<7];
const int inf = 9999999;

int main(){
    int tests,T = 1;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        input();

        for( int i = 0; i < (1<<7); ++i ){
            if( tilt[i] == false ) continue;
            for( int k = 0; k < 7; ++k ){
                if( i&(1<<k) ) continue;
                tilt[ i|(1<<k) ] = true;
            }
        }

        int ss = 0 , L = 1<<7;

        for (int i=0;i<=n;i++){
            for (int j=0;j<L;j++){
                dp[i][j] = -inf;
            }
        }
        dp[0][0] = 0;

        for( int i = 1; i <= n; ++i ){
            for( int j = 0; j < L; ++j ){
                int mask = j;
                int ac = 0;
                int need = 0;

                int finish = 0;
                int starting = 0;

                for( int B = 0; B < 7; ++B ){
                    if( mask&(1<<B) ){
                        if( start[B][i] )
                            starting ++;
                        else if( end[B][i] ){
                            mask ^= 1<<B;
                            finish ++;
                            need |= 1 << B;
                        }else if( mid[B][i] )
                            need |= 1 << B;
                    }
                }

                if( tilt[mask] ) continue;

                int uk = finish + starting;
                for( int k = 0; k < L; ++k ){
                    if( (need&k) != need ) continue;
                    if( dp[i-1][k] == -inf ) continue;

                    dp[i][j] = max( dp[i][j] , dp[i-1][k]+uk );
                }

            }
        }

        for( int i = 0; i < (1<<7); ++i )
            ss = max( ss , dp[n][i] );

        printf("Case #%d: %d\n",T++,ss);
    }


    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <stack>
#include <map>
#include <algorithm>
#include <stack>
using namespace std;

typedef long long ll;

long long dp[10][1000005];
long long dpr[10][1000005];

int n;


int main(){
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d",&n);

        memset( dp, 0, sizeof(dp));
        memset( dpr, 0, sizeof(dpr));

        dp[1][0] = 1;
        dpr[9][0] = 1;

        for( int i = 1; i <= n; ++i ){
            for( int k = 1; k <= 9; ++k ){
                for( int lo = 1; lo <= k; ++lo ){
                    dp[k][i] += dp[lo][i-1];
                }
            }

            int beg = 0;
            if( i == 1 ) beg = 1;
            for( int k = beg; k <= 9; ++k ){
                for( int hi = k; hi <= 9; ++hi ){
                    dpr[k][i] += dpr[hi][i-1];
                }
            }
        }

        ll sum1 = 0, sum2 = 0;

        for( int i = 0; i <= 9; ++i ) sum1 += dp[i][n];
        for( int i = 0; i <= 9; ++i ) sum2 += dpr[i][n];

        printf("%.6lf\n",sum2 / (double)sum1);

    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <stack>
#include <map>
#include <algorithm>
#include <stack>
using namespace std;

const int maxn = 1000000;

double sols[maxn+5] = { 1.000000 , 1.200000 , 1.327273 , 1.442424 , 1.554779 , 1.666334 , 1.777622 , 1.888811 , 1.999959 ,
                         2.111088 , 2.222209 , 2.333325 , 2.444440 , 2.555552 , 2.666665 , 2.777776 , 2.888888 , 2.999999 ,
                         3.111111 , 3.222222 , 3.333333 , 3.444444 , 3.555555 , 3.666667 , 3.777778 , 3.888889 ,
                         4.000000 , 4.111111 , 4.222222 , 4.333333 , 4.444444 , 4.555556 , 4.666667 , 4.777778 , 4.888889 };


double pattern[] = {0.000000,0.111111,0.222222,0.333333,0.444444,0.555556,0.666667,0.777778,0.888889 };

int main(){
    int tests;
    scanf("%d",&tests);

    int n;
    int id = 35;
    int v = 5;

    while( id <= maxn ){
        for( int k = 0; k < 9; ++k )
            sols[id++] = v + pattern[k];
        v++;
    }

    for( ; tests; --tests ){
        scanf("%d",&n);
        printf("%.6lf\n",sols[n-1]);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <algorithm>
#include <map>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <queue>
#include <set>
using namespace std;

const int inf = 99999999;
const int gam = -16843010;

int n,m;
int cnt[105];
char col[105];
char txt[105];

int dp[105][105][8];

int solve( int L , int R , int c ){
    c = min( c , m );
    int &ref = dp[L][R][c];

    if( ref != gam ) return ref;

    if( L > R ) return ref = 0;
    if( L == R ){
        if( c >= m ) return ref = 1;
        else return ref = -1;
    }

    int sol = inf;
    if( c >= m ){
         sol = solve( L+1, R, cnt[L+1] );
        if( sol == -1 ) sol = inf;
        else sol ++;
    }

    for( int k = L+1; k <= R; ++k ){
        if( col[L] != col[k] ) continue;

        int ss1 = solve( L+1, k-1 , cnt[L+1] );
        if( ss1 < 0 ) continue;

        int ss2 = solve( k, R , c+cnt[k] );
        if( ss2 < 0 ) continue;

        sol = min( sol , ss1 + ss2 );
    }
    if( sol != inf )return ref = sol;
    else return ref = -1;
}

int main(){
    memset( dp , -2, sizeof(dp));
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d%d",&n,&m);
    fscanf(in,"%s",txt);

    int sz = 0;
    int len = strlen(txt);

    for( int i = 0; i < len; ++i ){
        int c = 0;
        while( i+1 < len && txt[i+1] == txt[i-c] )i++,c++;
        col[sz] = txt[i-c];
        cnt[sz++] = c+1;
    }

    int s = solve( 0 , sz-1 , cnt[0] );
    printf("%d\n",s);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <stack>
#include <map>
#include <algorithm>
#include <string.h>
using namespace std;

int n;
int digs[10000] , sz = 0;
int mem[10000];

void di(){
    memset( mem, 0, sizeof(mem));

    for( int i = 0; i  < sz; ++i ){
        if( digs[i]&1 ){
            mem[i] += digs[i] / 2;
            mem[i+1] += 5;
            sz = max( sz , i+2 );
        }else{
            mem[i] += digs[i] / 2;
        }
    }

    memcpy( digs , mem , sizeof mem );
}

int szs[1005];
int sols[1005][1005];

int main(){
    digs[0] = 1 , sz = 1;
    for( int k = 1; k <= 1000; ++k ){
        memcpy( sols[k] , digs , sizeof sols[k] );
        szs[k] = sz;
        di();
    }

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d",&n);
        if( n == 0 || n == 1){
            printf("1\n");
            continue;
        }

        printf("0.");
        for( int i = 1; i < szs[n]; ++i )
            putchar('0' + sols[n][i]);
        putchar('\n');

    }


    return 0;
}

#include <iostream>
#include <cstdio>
#include <map>
#include <stack>
#include <algorithm>
#include <set>
#include <math.h>
#include <queue>
#include <cstdlib>
#include <iomanip>
using namespace std;

typedef long long ll;

//

ll m[10]; // (x,y): 0,0 ;  1,0 ;  0,1  ; 1,1
ll a[10] , c[10] , s[10];

const ll mod = 1000000007;

ll lucas( int n , int p , int q ){
    m[0] = m[1] = m[2] = m[3] = 0;
    m[1] = 1;

    a[0] = a[1] = a[2] = a[3] = 0;
    a[1] = q , a[2] = 1 , a[3] = p;

    c[0] = a[0] , c[1] = a[1] , c[2] = a[2] , c[3] = a[3];

    if( n == 0 ) return 0;
    if( n == 1 ) return 1;

    n -= 1;
    stack< int > stp;
    while( n ){
        if( n == 1 ) break;
        if( n&1 ) stp.push( 1 ) , n --;
        else stp.push( 2 ) , n >>= 1;
    }

    int u;
    while( stp.empty() == false ){
        s[0] = s[1] = s[2] = s[3] = 0;
        u = stp.top() , stp.pop();

        if( u == 1 ){
            s[0] = a[0]*c[0] + a[1] * c[2];
            s[1] = a[0]*c[1] + a[1] * c[3];
            s[2] = a[2]*c[0] + a[3] * c[2];
            s[3] = a[2]*c[1] + a[3] * c[3];
        }else{
            s[0] = a[0]*a[0] + a[1] * a[2];
            s[1] = a[0]*a[1] + a[1] * a[3];
            s[2] = a[2]*a[0] + a[3] * a[2];
            s[3] = a[2]*a[1] + a[3] * a[3];
        }

        s[0] %= mod , s[1] %= mod , s[2] %= mod , s[3] %= mod;

        memcpy( a , s , sizeof a );
    }

    return (m[0]*a[1] + m[1] * a[3])%mod;
}

int main(){

    int n;

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d",&n);

       // printf("%lld\n", (lucas(n,3,-1) - n + mod )%mod );
       cout<<(lucas(n,3,-1) - n + mod*mod + mod )%mod<<endl;
        //cout<<(lucas(n,3,-1) - lucas(n,2,-1) + mod ) % mod<<endl;



    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <fstream>
#include <vector>
#include <math.h>
#include <iomanip>
#include <set>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<ll,ll>

typedef long long ll;

int h,w;
int mh,mw;

char m[2005][2005];
char v[2005][2005];


ll prime = 698729;
ll prime2 = 1577293;

void input( char mx[2005][2005] , int h , int w ){
    char c;
    int y = 0 , x = 0;
    while( y < h && x < w ){
        while( c = getchar() ) if( c >= 'a' && c <= 'z' ) break;
        mx[y][x] = c;
        x++;
        if( x == w ) x = 0 , y ++;
    }
}

ll stp[2005] , stp2[2005];
ll dp[2005][2005];




int main(){
    freopen("Ulaz.txt","r",stdin);


    stp[0] = stp2[0] = 1;
    for( int k = 1; k <= 2000; ++k ){
        stp[k] = stp[k-1] * prime;
        stp2[k] = stp2[k-1] * prime2;
    }

    scanf("%d%d",&mh,&mw);
    input( m , mh , mw );

    scanf("%d%d",&h,&w);
    input( v , h , w );



    for( int i = 0; i < w; ++i ){
        ll key = 0;
        for( int k = 0; k < mh; ++k )
            key = key * prime + v[k][i];

        dp[mh-1][i] = key;

        for( int k = mh; k < h; ++k ){
            key -= stp[mh-1] * v[k-mh][i];
            key *= prime;
            key += v[k][i];
            dp[k][i] = key;
        }

    }
    bool ok = false;

    ll ss = 0;
    for( int i = 0; i < mw; ++i ){
        ll key = 0;
        for( int j = 0; j < mh; ++j )
            key = key * prime + m[j][i];
        ss = ss * prime2 + key;
    }

    for( int i = mh-1; i < h; ++i ){
        ll key = 0;
        for( int j = 0; j < mw; ++j )
            key = key * prime2 + dp[i][j];

        if( key == ss ) printf("(%d,%d)\n\n",i-mh+2,1) , ok = true;

        for( int j = mw; j < w; ++j ){
            key -= stp2[mw-1] * dp[i][j-mw];
            key *= prime2;
            key += dp[i][j];

            if( key == ss ) printf("(%d,%d)\n\n",i-mh+2,j-mw+2) , ok = true;
        }
    }

    if( !ok ) printf("NO MATCH FOUND...\n");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <map>
#include <set>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 100015;
const int mod = 10007;

int n;
vector< int >G[maxn];

pii dp[maxn][2];

pii solve( int node , bool prev , int dad ){

    if( dp[node][ prev ].f != -1 ) return dp[ node ][ prev ];

    pii f1 , f2; //f1 = true , f2 = false;

    f1.f = 1;
    f2.f = 0;
    f1.s = f2.s = 1;

    for( int i = 0; i < G[node].size(); ++i ){
        int nxt = G[node][i];
        if( nxt == dad ) continue;

        pii u1 = solve( nxt , true , node );
        pii u2 = solve( nxt , false , node );

        f1.f += u1.f;
        f1.s *= u1.s;

        f2.f += u2.f;
        f2.s *= u2.s;

        f1.s %= mod;
        f2.s %= mod;

    }
    pii sol = f1;
    if( f2.f < sol.f )
        sol = f2;
    else if( f2.f == sol.f )
        sol.s += f2.s;

    sol.s %= mod;

    if( prev ) return dp[ node ][ prev ] = sol;
    else return dp[ node ][ prev ] = f1;
}


int main(){
   // freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d",&n);

        for( int i = 0; i < n; ++i )G[i].clear();

        for( int i = 0; i < n-1; ++i ){
            int a,b; scanf("%d%d",&a,&b); a-- , b--;
            G[a].push_back(b);
            G[b].push_back(a);
        }

        memset( dp , -1 , sizeof(dp));
        pii m = solve( 0 , 1 , -1 );


        printf("%d %d\n",m.f,m.s);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <iomanip>
#include <set>
#include <stack>
#include <algorithm>
#include <cstdlib>
#include <string.h>
using namespace std;

int n,m;

char txt[200];
int d[200];
bool visi[200];

int main(){
    scanf("%d%d",&n,&m);

    for( int i = 0; i < n; ++i ){
        scanf("%s",txt);
        for( int j = 0; j < m; ++j ){
            if( txt[j] >= '0' && txt[j] <= '9' ) d[ txt[j] - '0' ] = m - j;
        }
    }

    for( int i = 1; i <= 9; ++i ){
        memset(visi,0,sizeof(visi));
        int sol = 1;
        for( int j = 1; j <= 9; ++j ){
            if( i == j || visi[d[j]] )continue;
            visi[d[j]] = true;
            if( d[i] > d[j] ) sol++;
        }
        printf("%d\n",sol);
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <algorithm>
#include <set>
#include <queue>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
using namespace std;

#define pii pair< int,int>
#define mk make_pair
#define f first
#define s second

const int inf = 999999999;

int w,l,n;
int gore[105][1005];
int dole[105][1005];


inline bool cmp( int a , int b ){
    for( int i = 0; i < l; ++i ){
        if( gore[a][i] + dole[a][i] != gore[b][i] + dole[b][i] )
             return false;
    }
    return true;
}

inline bool cmpr( int a , int b ){
    for( int i = 0; i < l; ++i ){
        if( gore[a][i] + dole[a][i] != gore[b][l-i-1] + dole[b][l-i-1] )
             return false;
    }
    return true;
}

int main(){

    scanf("%d%d%d",&w,&l,&n);

    for( int i = 0; i < n; ++i ){
        for( int k = 0; k < l; ++k )
            scanf("%d",&gore[i][k]);
        for( int k = 0; k < l; ++k )
            scanf("%d",&dole[i][k]);
    }



    int sol = n;
    for( int i = 0; i < n; ++i ){
        for( int j = i+1; j < n; ++j ){
            if( cmp(i,j) || cmpr(i,j) ){
                sol --;
                break;
            }
        }
    }
    printf("%d\n",sol);


    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <string.h>
#include <math.h>
using namespace std;

#define pii pair<int,int>
#define mk make_pair
#define f first
#define s second

const int inf = 99999999;

int n;
int p[1000005][3];

pii dp[2][2][8];  // (min/max, 1 or 2 , mask )

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int j = 0; j < 8; ++j ){
        dp[0][0][j] = mk(inf,inf), dp[1][0][j] = mk(-inf,-inf);
        dp[0][1][j] = mk(inf,inf), dp[1][1][j] = mk(-inf,-inf);
    }


    for( int i = 0; i < n; ++i )
        scanf("%d%d%d",&p[i][0],&p[i][1],&p[i][2]);

    for( int d = 0; d < 8; ++d ){
        for( int i = 0; i < n; ++i ){

            int ss = 0;
            for( int k = 0; k < 3; ++k ){
                if( d&(1<<k) )ss += p[i][k];
                else ss -= p[i][k];
            }

            int d1 = dp[0][0][d].f - ss;
            int d2 = dp[0][1][d].f - ss;

            if( d1 > d2  )dp[0][0][d] = min( dp[0][0][d] , mk(ss,i) );
            else dp[0][1][d] = min( dp[0][1][d] , mk(ss,i) );

            d1 = ss - dp[1][0][d].f;
            d2 = ss - dp[1][1][d].f;

            if( d1 > d2 )dp[1][0][d] = max( dp[1][0][d] , mk(ss,i) );
            else dp[1][1][d] = max( dp[1][1][d] , mk(ss,i) );
        }
    }


    int sol = 0;

    for( int d = 0; d < 8; ++d ){
        int w = 0 , prev = sol;
        if( (d&1) == 0 ) w |= 2;
        if( (d&2) == 0 ) w |= 4;
        if( (d&4) == 0 ) w |= 1;

        for( int i1 = 0; i1 < 2; ++i1 ){
            for( int i2 = 0; i2 < 2; ++i2 ){
                for( int k1 = 0; k1 < 2; ++k1 ){
                    for( int k2 = 0; k2 < 2; ++k2 ){
                        if( dp[i1][i2][d].s != dp[k1][k2][w].s ){
                            sol = max( sol , dp[i1][i2][d].f + dp[k1][k2][w].f );
                        }
                    }
                }
            }
        }



    }
    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <string.h>
#include <math.h>
#include <fstream>
using namespace std;

typedef long long ll;

const int bit = 65;

ll a,b;

ll solve( ll x ){
    x++;
    ll sol = 0;

    for( int k = 0; k < 60; ++k ){
        ll r = 1LL<<(k+1);

        ll cnt = (x / r) * (r>>1LL);

        ll o = x % r;
        o = o-(r>>1);


        cnt += max( 0LL , o );

        if( cnt&1 )sol += 1LL<<k;
        if( r > x ) break;
    }
    return sol;
}

int main(){

    cin >> a >> b;

    ll sol = solve( b ) ^ solve( a-1 );

    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <vector>
using namespace std;


int main(){

    vector< int > q;

    for( int i = 0; i < 10; ++i ){
        int n;
        scanf("%d",&n);
        q.push_back( n % 42 );
    }

    sort(q.begin(),q.end());
    q.erase( unique(q.begin(),q.end()), q.end() );

    cout<<q.size()<<endl;

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <iomanip>
#include <set>
#include <stack>
#include <algorithm>
#include <cstdlib>
using namespace std;

int sol = 9999;
int n,m,k;

int dam[15];
int res[15];


inline int cnt(){
    int r = 0;
    for( int i = 1; i <= n; ++i )
         r += dam[i] != 0;
    return r;
}


void solve( int idx ){

    if( idx == n+1 ){
        sol = min( sol , cnt() );
        return;
    }


    if( res[idx] ){
            if( dam[idx-1] ){
                dam[idx-1]--;
                solve( idx + 1 );
                dam[idx-1]++;
            }

            if( dam[idx+1] ){
                dam[idx+1]--;
                solve( idx + 1 );
                dam[idx+1]++;
            }

            if( res[idx] ){
                dam[idx]--;
                solve( idx + 1 );
                dam[idx]++;
            }

    }

    solve ( idx + 1 );

}


int main(){
    scanf("%d%d%d",&n,&m,&k);

    for( int i = 0; i < m; ++i ){
        int a; scanf("%d",&a);
        dam[a] ++;
    }

    for( int i = 0; i < k; ++i ){
        int a; scanf("%d",&a);
        res[a] ++;
    }

    solve( 1 );

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <algorithm>
#include <map>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <vector>
#include <set>
using namespace std;

bool lose( int a, int b, int c, int d ){

    if( a == b && b == c && d >= c ) return true;
    if( a == b && b == d && c >= d ) return true;
    if( a == c && c == d && b >= c ) return true;

    if( b == c && c == d && a >= b ) return true;

    return false;
}

int a[4];
int s[4];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d%d%d",&a[0],&a[1],&a[2],&a[3]);

        int m = min( a[0] , a[1] );
        m = min( m , min(a[2],a[3]) );

        a[0] -= m;
        a[1] -= m;
        a[2] -= m;
        a[3] -= m;


        if( lose( a[0] , a[1] , a[2] , a[3] ) ){
            printf("Robert wins.\n\n");
            continue;
        }


        bool ok = true;

        for( int i = 0; i <= 3 && ok; ++i ){
            for( int j = i+1; j <= 3 && ok; ++j ){
                for( int k = a[i]; ok && k >= 1; --k ){
                    for( int l = a[j]; ok && l >= 1; --l ){

                        s[i] += k , s[j] += l;
                        if( lose( a[0]-s[0] , a[1]-s[1] , a[2]-s[2] , a[3]-s[3] ) ){
                            printf("Julia wins.\n");
                            printf("%d %d %d %d\n\n",s[0],s[1],s[2],s[3]);
                            ok = false;
                        }
                        s[i] -= k , s[j] -= l;

                    }
                }
            }
        }
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <algorithm>
#include <map>
#include <iomanip>
#include <set>
#include <queue>
using namespace std;

int a  [1500000];
int cnt[1500000];
int sub[1500000];

int main(){
   // freopen("niz.in","r",stdin);
   // freopen("niz.out","w",stdout);
    a[1] = 1;
    cnt[1] = 1;

    a[2]  = 2;
    cnt[2] = 2;
    sub[2] = 1;

    int sz = 3;
    int k = 2;

    for( int i = 3; i < 1000000; ++i ){
        int c = a[k];

        a[ sz ] = i;
        cnt[ sz ] = c;
        sub[ sz ++ ] = c;


        sub[k] --;
        if( sub[k] == 0 )k++;
    }

    int n;
    scanf("%d",&n);

    int sol = 1;
    for( ; n - cnt[sol] > 0 ; sol ++ ) n -= cnt[sol];

    printf("%d\n",a[sol]);

    return 0;
}

#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstdio>
#include<math.h>
#include<string>
using namespace std;

char res[5][200];

void okviri( int x , char mark ,int y = 2 ){
   res[0][x]=mark;
   res[1][x-1] = res[1][x+1]=mark;
   if(res[2][x-2]!='*')
      res[2][x-2] = res[2][x+2]=mark;
   else
      res[2][x+2]=mark;
   res[3][x-1] = res[3][x+1]=mark;
   res[4][x] = res[4][x]=mark;
}

int main()
{
   string text;
   cin>>text;
   int i,j;
   int strsize = text.size();
   int xN = 2;
   int width = (strsize-1)*3 + 4 + strsize;
   for(i=0;i<5;i++)fill(res[i],res[i]+width,'.');
   for(int i=0;i<strsize;i++){
      if( (i+1)%3==0 )okviri(xN,'*');
      else okviri(xN,'#');
      res[2][xN]=text[i];
      xN+=4;
   }
   for(i=0;i<5;i++){
      for(j=0;j<width;j++){
         printf("%c",res[i][j]);
      }printf("\n");
   }
   //system("Pause");
   return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <algorithm>
#include <set>
#include <queue>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
using namespace std;

typedef long long ll;

int n,k;
int cnt[1000006];
int niz[1000007];
ll sum[1000006];

int main(){
    scanf("%d%d",&n,&k);

    for( int i = 0; i < k; ++i ){
        int x;scanf("%d",&x);
        cnt[x] ++;
    }

    for( int i = 1; i < n; ++i ){
        if( cnt[i] == 0 ) continue;
        niz[0] += cnt[i];
        for( int j = i; j < n; j += i )
            niz[j] += cnt[i];
    }

    for( int i = 0; i < n; ++i )
        sum[i] = sum[i-1] + niz[i];

    int q;
    scanf("%d",&q);

    for( int i = 0; i < q; ++i ){
        int a,b;
        scanf("%d%d",&a,&b);
        ll ss = sum[b];
        if( a ) ss -= sum[a-1];
        printf("%lld\n",ss);
    }


    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;


int main(){
    int r1,s;
    scanf("%d%d",&r1,&s);
    printf("%d\n",2*s - r1 );
    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <math.h>
using namespace std;

int main(){
    int n;
    scanf("%d",&n);
    
    int sol = 0;
    
    for( int m = 4; m <= n; ++m ){
        for( int i = 2; i < m-1; ++i ){
           int L = i - 1;
           int R = m - i - 1;
        
           sol += L * R;
        }
    }
    
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <string.h>
#include <cstdlib>
#include <fstream>
#include <vector>
#include <math.h>
#include <stack>
#include <map>
using namespace std;

#define f first
#define s second

typedef long long ll;

const int sq = 100000;
const  ll lim = 10000000000LL;
int k;
ll l,h;

vector< int > p;
bool visi[100005];

inline int getdiv( int v ){

    int r = v;
    int sol = 1;
    for( int k = 0; p[k]*p[k] <= r; ++k ){
        int cnt = 0;
        while( v % p[k] == 0 ){
            cnt ++;
            v /= p[k];
        }
        sol *= cnt*2 + 1;
    }
    if( v > 1 ) sol *= 3;
    return sol;
}

vector< int > KS[10005];

int main(){
    for( int i = 2; i <= 100000; ++i ){
        if( visi[i] == false ) p.push_back(i);
        else continue;
        for( int j = i; j <= 100000; j += i )
            visi[j] = true;
    }

    for( int i = 1; i < 100000; ++i ){
        int C = getdiv(i);
        if( C < 10000 )
            KS[ C ].push_back( i );
    }


    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%lld%lld",&k,&l,&h);
        //scanf("%d%I64d%I64d",&k,&l,&h);

        int lo = 0 , hi = KS[k].size() - 1 , L = -1 , R = -1;
        while( lo <= hi ){
            int mid = ( lo + hi ) >> 1;
            if( KS[k][mid] * (ll)KS[k][mid] >= l ) L = mid , hi = mid - 1;
            else lo = mid + 1;
        }
        if( L == -1 ){
             printf("0\n");
             continue;
        }

        lo = 0 , hi = KS[k].size() - 1;
        while( lo <= hi ){
            int mid = ( lo + hi ) >> 1;
            if( KS[k][mid] * (ll)KS[k][mid] <= h ) R = mid , lo = mid + 1;
            else hi = mid - 1;
        }
        if( R == -1 ){
             printf("0\n");
             continue;
        }

        printf("%d\n",R - L + 1 );
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <algorithm>
#include <set>
#include <iomanip>
#include <queue>
using namespace std;

int n,m;

int client[3];
int stock[1505][3];
bool used[1505];


int ss[55][55][55];


int main(){

    while( scanf("%d%d",&n,&m) == 2 ){
        if( n == 0 && m == 0 )break;

        memset( ss , 0 , sizeof(ss));
        memset( used , false , sizeof(used));


        scanf("%d%d%d",&client[0], &client[1], &client[2]);
        sort( client , client + 3 );

        for( int i = 0; i < m; ++i ){

            scanf("%d%d%d",&stock[i][0], &stock[i][1], &stock[i][2]);
            sort( stock[i] , stock[i] + 3 );

            ss[ stock[i][0] ][ stock[i][1] ][ stock[i][2] ] ++;

        }

        bool ok = false;

        int mn = 9999999;

        for( int i = client[0]; i <= 50 ; ++i )
            for( int j = client[1]; j <= 50; ++j )
                for( int k = client[2]; k <= 50 ; ++k )
                    if( ss[i][j][k] >= n && mn > i*j*k - client[0] * client[1] * client[2] ){
                        mn = i*j*k - client[0] * client[1] * client[2];
                        ok = true;
                    }

        if( !ok ) printf("impossible\n");
        else printf("%d\n",mn);
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstdlib>
using namespace std;

int main(){
    int t1,t2,t3;
    int c1,c2,c3;

    int team = 0;

    while( scanf("%d%d%d%d%d%d",&t1,&t2,&t3,&c1,&c2,&c3) == 6 ){

        int sol = 0;

        if( t1 ) sol += t1 + 20 * (c1-1) * 60;
        if( t2 ) sol += t2 + 20 * (c2-1) * 60;
        if( t3 ) sol += t3 + 20 * (c3-1) * 60;


        printf("team %d: %d, %d\n", ++team, (t1||0) + (t2||0) + (t3||0) , sol );

    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <vector>
using namespace std;

#define pii pair<ll,ll>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

int n;
int v[20];
int solved;

pii dp[16][1<<15];

pii solve( int prev , int mask ){

    if( dp[prev][mask].f ) return dp[prev][mask];
    if( mask == solved )
         return mk(v[prev],1);

    pii sol;
    sol.f = sol.s = 0;

    for( int i = 0; i < n; ++i ){
        if( mask&(1<<i) )continue;
        ll add = abs( v[i] - v[prev] );
        pii now =  solve( i , mask|(1<<i) );
            now.f += add + 2;

        if( sol.f == now.f )
            sol.s += now.s;
        else if( sol.f < now.f )
            sol = now;
    }
    return dp[prev][mask] = sol;
}

int main(){
    while( scanf("%d",&n) == 1 ){
        if( n == 0 )break;
        for( int i = 0; i < n; ++i )
            scanf("%d",&v[i]);

        memset( dp , 0 , sizeof(dp));
        solved = (1<<n) - 1;
        pii ss = solve( 15 , 0 );

        printf("%lld %lld\n",ss.f,ss.s);
    }

    return 0;
}

#include <iostream>
using namespace std;

int a[50];

int main(){
    a[0] = 1;
    a[1] = 1;
    for( int i = 2; i <= 30; ++i )
        a[i] = 4*a[i-1] - a[i-2];

    int n;
    while( cin >> n ){
        if( n == -1 ) break;

        if( n % 2 == 1 ) printf("0\n");
        else printf("%d\n",a[n/2 +1] );
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <algorithm>
#include <set>
#include <iomanip>
#include <math.h>
#include <vector>
using namespace std;

int sol = 0;
int k,r,m,n;
int p[105][2];
int s[105][3];

int ok[105];
vector< int > inrange[105];

void solve( int idx , int cnt , int ss ){
    if( cnt > k ) return;

    if( idx == m ){
        sol = max( sol , ss );
        return;
    }

    solve( idx + 1 , cnt , ss);

    int u = 0;

    for( int k = 0; k < inrange[idx].size(); ++k ){
        int w = inrange[idx][k];
        ok[w] ++;

        if( ok[w] == 1 ) u += s[w][2];
    }

    solve( idx + 1 , cnt + 1 , ss + u );


    for( int k = 0; k < inrange[idx].size(); ++k ){
        int w = inrange[idx][k];
        ok[w]--;

        if( ok[w] == 0 ) u -= s[w][2];
    }
}

template <class item>
item sqr( item v ){
    return v*v;
}

int main(){

    scanf("%d%d%d",&k,&r,&m);

    for( int i = 0; i < m; ++i )
        scanf("%d%d",&p[i][0],&p[i][1]);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i )
        scanf("%d%d%d",&s[i][0],&s[i][1],&s[i][2]);

    for( int i = 0; i < m; ++i ){
        for( int k = 0; k < n; ++k ){
            int d =  sqr(p[i][0] - s[k][0]) + sqr(p[i][1] - s[k][1]);
            if( d <= r*r ) inrange[i].push_back( k );
        }
    }

    solve( 0 , 0 , 0 );

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <map>
#include <algorithm>
#include <stack>
#include <fstream>
#include <set>
#include <map>
#include <math.h>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

typedef long long ll;

int tests;
char txt[1350005];

ll sol = 0;

pii solve( int a , int b , bool h ){

    pii ret = mk(1,0);

    if( a + 1 ==  b ){
         ret = mk(1,1);
    }else{

        int s = 0;
        int w = 1;
        int p;

        ret = mk(1,0);

        for( int i = a+1; i < b; ++i ){

            if( s == 0 ) p = i;

            if( txt[i] == '(' ) s++;
            else s--;

            if( s == 0 ){
                pii u = solve( p , i , !h );
                ret.f += u.f + 1;
                ret.s = max( ret.s , u.s + 1 );
            }
        }
    }

    if( !h ) sol += ret.s * (ll)ret.f;
    else sol -= ret.s * (ll)ret.f;


    return ret;
}


int main(){
    freopen("Ulaz.txt","r",stdin);

    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%s",txt);

        sol = 0;
        int s = 0 , p = 0;
        for( int i = 0; i < strlen(txt); ++i ){
            if( s == 0 ) p = i;

            if( txt[i] == '(' )s++;
            else s--;

            if( s == 0 ) solve( p , i , 0 );
        }

       // printf("%lld\n",sol);
        cout<<sol<<endl;

    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <stack>
#include <map>
#include <algorithm>
#include <set>
#include <queue>
#include <iomanip>
using namespace std;

char str[500];

int ok[305][305][6]; // 1 - a , 2 - b

// a = 0
// b  = 1
// aa = 2
// ab = 3
// ba = 4
// bb = 5

void reduce( int a , int b  ){

    if( ok[a][b][0] != -1 ) return;

    for( int k = 0; k < 6; ++k )
        ok[a][b][k] = false;


    if( a == b ){
        if( str[a] == 'a' ) ok[a][b][0] = true;
        if( str[a] == 'b' ) ok[a][b][1] = true;
        return;
    }


    for( int i = a; i < b; ++i ){

            reduce( a , i  );
            reduce( i+1 , b );

            if( ok[a][i][0] && ok[i+1][b][0] )ok[a][b][2] = true; // make 'aa' ( a + a )
            if( ok[a][i][1] && ok[i+1][b][1] )ok[a][b][5] = true; // make 'bb' ( b + b )

            if( ok[a][i][0] && ok[i+1][b][2] )ok[a][b][0] = true; // make 'a' ( a + aa )
            if( ok[a][i][1] && ok[i+1][b][3] )ok[a][b][0] = true; // make 'a' ( b + ab )

            if( ok[a][i][1] && ok[i+1][b][5] ) ok[a][b][1] = true; // make 'b' ( b + bb )
            if( ok[a][i][0] && ok[i+1][b][4] ) ok[a][b][1] = true; // make 'b' ( a + ba )

            if( ok[a][i][1] && ok[i+1][b][0] ) ok[a][b][4] = true; // make 'ba' ( b + a )
            if( ok[a][i][0] && ok[i+1][b][1] ) ok[a][b][3] = true; // make 'ab' ( a + b )
    }

}

int dp[305][305];
int solve( int a, int b ){
    if( dp[a][b] != -1 ) return dp[a][b];

    if( a == b ) return 1;
    if( ok[a][b][0] + ok[a][b][1] ) return 1;

    int sol = 99999;
    for( int i = a; i < b; ++i )
        sol = min( sol , solve(a,i) + solve(i+1,b) );
    return dp[a][b] = sol;
}

int main(){
    scanf("%s",str);
    int len = strlen(str);

    memset( ok , -1 , sizeof(ok));
    reduce( 0 , len - 1  );

    for( int i = 0; i < len; ++i )
        for( int j = i; j < len; ++j )
            if( ok[i][j][0] == -1 ) reduce(i,j);

    memset( dp , -1 , sizeof(dp));
    int ss = solve( 0 , len - 1 );
    printf("%d\n",ss);



    return 0;
}

#include <iostream>
#include <fstream>
#include <stack>
#include <set>
#include <queue>
#include <stack>
#include <math.h>
#include <map>
#include <string.h>
#include <algorithm>
using namespace std;

const int prime = 13899;

int stp[1115];
char txt[1115];


int len;
int getlow( int s, int e ){
    if( s == e ) return s;

    int mid = (s+e)>>1;
    int _s = getlow( s , mid );
    int _e = getlow( mid + 1 , e );

    for( int k = 0; _s+k<_e ; ++k ){
        if( txt[ (_s+k)%len ] < txt[ (_e+k)%len ] ) return _s;
        if( txt[ (_s+k)%len ] > txt[ (_e+k)%len ] ) return _e;
    }
    return _s;
}


int main(){

    int n;
    scanf("%d",&n);
    vector< int > keys;

    for( int i = 0; i < n ; ++i ){
        scanf("%s",txt);
        len = strlen(txt);
        int dx = getlow( 0 , len - 1 );
        int key = 0;

        for( int k = 0; k < len; ++k )
            key = key * prime + txt[ (dx+k)%len ];
        keys.push_back(key);
    }
    sort( keys.begin() , keys.end() );
    keys.erase( unique(keys.begin(),keys.end()), keys.end() );

    printf("%d\n",keys.size());

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <math.h>
using namespace std;

typedef long long ll;

const int maxv = 50700;
const int maxn = 2500700;
const int gsz= 1000;
int esz;

int maxg;

int n,m;
int v[maxn+5];
int bit[gsz+5][maxv+5];


char c;inline void readi( int &v ){while( (c=getchar())<'0' || c > '9' );v = c - '0';while( (c=getchar())>='0' && c<='9' ) v = v * 10 + c - '0';}



int main(){


    esz = maxn / gsz;


    scanf("%d",&n);
    for( int i = 0; i < n; ++i )
        readi( v[i] );


    maxg = (n-1)/esz;

    for( int k = maxg; k >= 0; --k ){
        int nxt = min( (k+1)*esz , n );

        for( int i = k*esz; i < nxt; ++i )
            for( int d = v[i]; d <= maxv; d += d & -d )
                bit[k][d] ++;
    }


    ll sol = 0;
    int z = gsz+3;
    for( int i = n-1; i >= 0; --i ){
        for( int k = v[i]; k <= maxv; k += k & -k )bit[z][k] ++;
        for( int d = v[i]-1; d >= 1; d -= d & -d ) sol += bit[z][d];
    }


    scanf("%d",&m);

    for( int i = 0; i < m; ++i ){
        int a,b,d; readi(a),readi(b);
        a--; d = a / esz;

        int pos = 0;
        int k;

        for( k = 0; pos+esz <= a; ++k , pos += esz ){
            for( int d = v[a]; d >= 1; d -= d & -d ) sol += bit[k][d];
            for( int d = b; d >= 1; d -= d & -d ) sol -= bit[k][d];
        }

        for( pos = (a/esz)*esz; pos < a; pos ++ )sol = sol - (v[pos] > v[a]) + (v[pos] > b);

        int L = (k+1)*esz;
        if( L > n ) L = n;

        for( pos = a+1; pos < L; ++pos )sol = sol - (v[pos] < v[a]) + (v[pos] < b);

        k++;

        for( ; k <= maxg; ++k ){
            for( int d = v[a]-1; d >= 1; d -= d & -d ) sol -= bit[k][d];
            for( int d = b-1; d >= 1; d -= d & -d ) sol += bit[k][d];

        }


        for( int k = v[a]; k <= maxv; k += k & -k ) bit[ d ][ k ] --;
        for( int k = b; k <= maxv; k += k & -k ) bit[ d ][ k ] ++;

        v[a] = b;
        printf("%lld\n",sol);
    }


    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;

int arr[4];

int GetV( char c ){
   if( c == 'C' ) return arr[2];
   if( c == 'B' ) return arr[1];
   if( c == 'A' ) return arr[0];
}

int main(){
    scanf("%d%d%d",&arr[0],&arr[1],&arr[2]);
    sort( arr , arr + 3 );
    
    string s;
    cin >> s;
    printf("%d %d %d",GetV( s[0] ) , GetV( s[1] ) , GetV( s[2] )  );
    putchar('\n');
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <algorithm>
#include <iomanip>
#include <set>
#include <math.h>
#include <vector>
using namespace std;

int n;
int mx[25][25];
double p[25][25];

double dp[22][(1<<20) +5];

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int i = 1; i <= n; ++i )
        for( int j = 1; j <= n; ++j ){
            scanf("%d",&mx[i][j]);
            p[i][j] = mx[i][j] / 100.0;
        }

    dp[0][0] = 1;

    for( int i = 1; i < (1<<n); ++i ){
        int cnt = __builtin_popcount(i);

        for( int k = 0; k < n; ++k ){
            if( ~i&(1<<k) )continue;
            dp[cnt][i] = max( dp[cnt][i] , dp[cnt-1][ i^(1<<k) ] * p[cnt][k+1] );
        }
    }

    printf("%.20lf\n",dp[n][ (1<<n)-1 ]*100 );

    return 0;
}

#include <iostream>
#include <stack>
#include <map>
#include <algorithm>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <math.h>
using namespace std;

typedef long long ll;

const int maxn = 1000000;

int n,m;
int v[1000005];

ll sol = 1000000*1000000LL + 8;
int dxs = 0 , use[maxn+5];

inline void check( ll s , int xs ){
    if( s < sol )
        sol = s , dxs = xs;
    else if( s == sol )
        dxs = min( dxs , xs );
}

char c;
inline void read( int &v ){
while( (c=getchar())<'0' || c >'9' );
v = c - '0';
while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
}


int main(){
    freopen("Ulaz2.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);

    read(n);
    read(m);


    for( int i = 0; i < n; ++i ) read(v[i]);



    int mid  = 0 , lo = 0, hi = 0;
    ll state = 0;

    int l = 0 , h = maxn;
    while( l <= h ){

        int q1 = (l+h) >> 1;
        int q2 = q1 + 1;
        ll s1 = 0 , s2 = 0;

        for( int k = 0; k < m; ++k ) s1 += abs( q1 - v[k] ) , s2 += abs( q2 - v[k] );

        if( s1 < s2 ) mid = q1 , h = q1 - 1;
        else mid = q2 , l = q2 + 1;
    }

    for( int k = 0; k < m; ++k ) state += abs( mid - v[k] ) , lo += v[k] < mid , hi += v[k] > mid , use[ v[k] ]++;

    check( state , 0 );


    for( int k = m; k < n; ++k ){

        use[ v[k-m] ] --;
        lo -= v[k-m] < mid , hi -= v[k-m] > mid;
        state -= abs( v[k-m] - mid );


        use[ v[k] ] ++;
        lo += v[k] < mid;
        hi += v[k] > mid;
        state += abs( mid - v[k] );



        while( lo + use[mid] < hi ){
                mid++;
                lo += use[ mid-1 ];
                state = state + lo - hi;
                hi -= use[ mid ];
        }

        while( hi + use[mid] < lo ){
                mid--;
                hi += use[mid+1];
                state = state -lo + hi;
                lo -= use[mid];
        }

        check( state , k - m + 1 );
    }

    cout<<sol<<" "<<dxs<<endl;



    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <algorithm>
#include <set>
#include <queue>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
using namespace std;

int n,m;
char mx[55][55];
int sols[5];

int main(){
    scanf("%d%d",&n,&m);

    for( int i = 0; i < n; ++i )
        scanf("%s",mx[i]);


    for( int i = 0; i < n-1; ++i ){
        for( int j = 0; j < m-1; ++j ){
            if( mx[i][j] == '#' || mx[i+1][j] == '#' || mx[i][j+1] == '#' || mx[i+1][j+1] == '#' ) continue;
            int sum = 0;
            sum = (mx[i][j]=='X') + (mx[i+1][j]=='X') + (mx[i][j+1]=='X')+ (mx[i+1][j+1]=='X');
            sols[sum] ++;
        }
    }


    for( int i = 0; i <= 4; ++i )
        cout<<sols[i]<<endl;


    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <fstream>
#include <set>
#include <queue>
#include <math.h>
#include <iomanip>
using namespace std;

typedef long long ll;

int n,m;
char mx[305][305];

const int bit = 12;
int dp[305][305][4]; // gore , dole , ljevo , desno



int main(){

    int q = (1<<bit) - 1;

    scanf("%d%d",&n,&m);

    for( int i = 0; i < n; ++i )
        scanf("%s",mx[i]);

    int v = n-1;
    int h = m-1;

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < m; ++j ){

            if( i == 0 ){
                for( int k = 0; k < bit && i-k >=0; ++k ) dp[i][j][0] |= (mx[i-k][j]=='1') << k;
                for( int k = 0; k < bit && i+k < n; ++k ) dp[i][j][1] |= (mx[i+k][j]=='1') << k;
            }else{
                dp[i][j][0] = dp[i-1][j][0] << 1;
                dp[i][j][0] |= (mx[i][j]=='1');
                dp[i][j][0] &= q;

                dp[i][j][1] = dp[i-1][j][1] >> 1;
                if( i+bit-1 < n ) dp[i][j][1] |= (mx[i+bit-1][j]=='1') << (bit-1);
                dp[i][j][1] &= q;
            }

            if( j == 0 ){
                for( int k = 0; k < bit && j-k >=0; ++k ) dp[i][j][2] |= (mx[i][j-k]=='1') << k;
                for( int k = 0; k < bit && j+k < m; ++k ) dp[i][j][3] |= (mx[i][j+k]=='1') << k;
            }else{
                dp[i][j][2] = dp[i][j-1][2] << 1;
                dp[i][j][2] |= (mx[i][j]=='1');
                dp[i][j][2] &= q;

                dp[i][j][3] = dp[i][j-1][3] >> 1;
                if( j+bit-1 < m ) dp[i][j][3] |= (mx[i][j+bit-1]=='1' ) << (bit-1);
                dp[i][j][3] &= q;

            }
        }
    }

    int sol = -1;

    for( int x = 0; x < m-1; ++x ){
        for( int y = 0; y < n-1; ++y ){

            int mn = min(x+1,y+1);
            mn = min( mn , m - x );
            mn = min( mn , n - y );

            if( (mn<<1) <= sol ) continue;


            if( mx[y][x] == mx[y+1][x+1] && mx[y][x+1] == mx[y+1][x] ){
                sol = max( sol , 2 );
                for( int exp = 1; (x+exp+1 < m && x-exp >= 0) && (y+exp+1 < n && y-exp >= 0); ++exp ){

                    bool ok = true;
                    int w = (exp<<1) + 2;

                    for( int k = 0; k < w && ok; ++k ){
                        if( k + bit-1 < w ){
                            if( dp[y-exp][x-exp+k][3] != dp[y+exp+1][x+exp+1-k][2] || dp[y-exp+k][x-exp][1] != dp[y+exp+1-k][x+exp+1][0] ) ok = false;
                            k += bit-2;
                        }else if( mx[y-exp][x-exp+k] != mx[y+exp+1][x+exp+1-k] || ( mx[y-exp+k][x-exp] != mx[y+exp+1-k][x+exp+1] ) ) ok = false;
                    }

                    if( !ok ) break;

                    if( sol < w ) sol = w;

                }
            }

            for( int exp = 1; (x+exp < m && x-exp >= 0) && (y+exp < n && y-exp >= 0); ++exp ){
                bool ok = true;
                int w = (exp<<1) + 1;

                for( int k = 0; k < w && ok; ++k ){
                        if( k + bit-1 < w ){
                            if( dp[y-exp][x-exp+k][3] != dp[y+exp][x+exp-k][2] || dp[y-exp+k][x-exp][1] != dp[y+exp-k][x+exp][0] ) ok = false;
                            k += bit-2;
                        }else if( mx[y-exp][x-exp+k] != mx[y+exp][x+exp-k] || ( mx[y-exp+k][x-exp] != mx[y+exp-k][x+exp] ) ) ok = false;
                    }

                if( !ok ) break;
                if( sol < w ) sol = w;

            }

        }
    }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <fstream>
#include <set>
#include <queue>
#include <math.h>
#include <iomanip>
using namespace std;

typedef long long ll;

int n,m;
char mx[305][305];

const int bit = 12;
int dp[305][305][4]; // gore , dole , ljevo , desno



int main(){

    int q = (1<<bit) - 1;

    scanf("%d%d",&n,&m);

    for( int i = 0; i < n; ++i )
        scanf("%s",mx[i]);

    int v = n-1;
    int h = m-1;

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < m; ++j ){

            if( i == 0 ){
                for( int k = 0; k < bit && i-k >=0; ++k ) dp[i][j][0] |= (mx[i-k][j]=='1') << k;
                for( int k = 0; k < bit && i+k < n; ++k ) dp[i][j][1] |= (mx[i+k][j]=='1') << k;
            }else{
                dp[i][j][0] = dp[i-1][j][0] << 1;
                dp[i][j][0] |= (mx[i][j]=='1');
                dp[i][j][0] &= q;

                dp[i][j][1] = dp[i-1][j][1] >> 1;
                if( i+bit-1 < n ) dp[i][j][1] |= (mx[i+bit-1][j]=='1') << (bit-1);
                dp[i][j][1] &= q;
            }

            if( j == 0 ){
                for( int k = 0; k < bit && j-k >=0; ++k ) dp[i][j][2] |= (mx[i][j-k]=='1') << k;
                for( int k = 0; k < bit && j+k < m; ++k ) dp[i][j][3] |= (mx[i][j+k]=='1') << k;
            }else{
                dp[i][j][2] = dp[i][j-1][2] << 1;
                dp[i][j][2] |= (mx[i][j]=='1');
                dp[i][j][2] &= q;

                dp[i][j][3] = dp[i][j-1][3] >> 1;
                if( j+bit-1 < m ) dp[i][j][3] |= (mx[i][j+bit-1]=='1' ) << (bit-1);
                dp[i][j][3] &= q;

            }
        }
    }

    int sol = -1;

    for( int x = 0; x < m-1; ++x ){
        for( int y = 0; y < n-1; ++y ){

            int mn = min(x+1,y+1);
            mn = min( mn , m - x );
            mn = min( mn , n - y );

            if( (mn<<1) <= sol ) continue;


            if( mx[y][x] == mx[y+1][x+1] && mx[y][x+1] == mx[y+1][x] ){
                sol = max( sol , 2 );
                for( int exp = 1; (x+exp+1 < m && x-exp >= 0) && (y+exp+1 < n && y-exp >= 0); ++exp ){

                    bool ok = true;
                    int w = (exp<<1) + 2;

                    for( int k = 0; k < w && ok; ++k ){
                        if( k + bit-1 < w ){
                            if( dp[y-exp][x-exp+k][3] != dp[y+exp+1][x+exp+1-k][2] || dp[y-exp+k][x-exp][1] != dp[y+exp+1-k][x+exp+1][0] ) ok = false;
                            k += bit-2;
                        }else if( mx[y-exp][x-exp+k] != mx[y+exp+1][x+exp+1-k] || ( mx[y-exp+k][x-exp] != mx[y+exp+1-k][x+exp+1] ) ) ok = false;
                    }

                    if( !ok ) break;

                    if( sol < w ) sol = w;

                }
            }

            for( int exp = 1; (x+exp < m && x-exp >= 0) && (y+exp < n && y-exp >= 0); ++exp ){
                bool ok = true;
                int w = (exp<<1) + 1;

                for( int k = 0; k < w && ok; ++k ){
                        if( k + bit-1 < w ){
                            if( dp[y-exp][x-exp+k][3] != dp[y+exp][x+exp-k][2] || dp[y-exp+k][x-exp][1] != dp[y+exp-k][x+exp][0] ) ok = false;
                            k += bit-2;
                        }else if( mx[y-exp][x-exp+k] != mx[y+exp][x+exp-k] || ( mx[y-exp+k][x-exp] != mx[y+exp-k][x+exp] ) ) ok = false;
                    }

                if( !ok ) break;
                if( sol < w ) sol = w;

            }

        }
    }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <set>
#include <stack>
#include <map>
using namespace std;

int n;
bool mx[550][550];

short dp[550][550][20][3];

bool mem[550][550];
int sol[550][550];

int setv( int y1, int y2 , int x1 , int x2 , bool v ){
    int ret = 0;
    for( int i = y1; i <= y2; ++i )
        for( int j = x1; j <= x2; ++j ){
            mem[i][j] = v;
            ret += bool(v != mx[i][j]);
        }
    return ret;
}

void setm( int y1, int y2 , int x1 , int x2 , bool v ){ for( int i = y1; i <= y2; ++i )for( int j = x1; j <= x2; ++j )sol[i][j] = v; }

int maxx = INT_MAX;

int solve( int y1 , int y2,  int x1, int x2 , int deep  ){


    if( y1 == y2 && x1 == x2 ){
        mem[y1][x1] = mx[y1][x1];
        return 0;
    }

    int ymid = (y2 + y1 - 1) >> 1;
    int xmid = (x2 + x1 - 1) >> 1;


    int ret = INT_MAX;
    int si = dp[y1][x1][deep][0];
    int sj = dp[y1][x2][deep][1];
    if( dp[y1][x2][deep][2] != -1 )ret= dp[y1][x2][deep][2];

    if( si == -1 )
    for( int i = 0; i < 4; ++i ){
        for( int j = 0; j < 4; ++j ){
            if( i == j ) continue;

            int q = 0;

            for( int k = 0; k <= 1; ++k ){
                int m = i;
                if( k == 1 ) m = j;

                if( m == 0 ) q += setv( y1 , ymid , x1 , xmid , k );
                if( m == 1 ) q += setv( ymid + 1 , y2 , x1 , xmid , k );
                if( m == 2 ) q += setv( y1 , ymid , xmid + 1 , x2 , k );
                if( m == 3 ) q += setv( ymid + 1 , y2 , xmid + 1 , x2 , k );
            }


            for( int k = 0; k < 4; ++k ){
                if( k == i || k == j ) continue;

                if( k == 0 ) q += solve( y1 , ymid , x1 , xmid , deep + 1 );
                if( k == 1 ) q += solve( ymid + 1 , y2 , x1 , xmid , deep + 1  );
                if( k == 2 ) q += solve( y1 , ymid , xmid + 1 , x2 , deep + 1  );
                if( k == 3 ) q += solve( ymid + 1 , y2 , xmid + 1 , x2 , deep + 1  );

            }

            if( ret > q )
                ret = q , si = i , sj = j;
        }
    }

    for( int k = 0; k <= 1; ++k ){
        int m = si;
        if( k == 1 ) m = sj;

        if( m == 0 ) setm( y1 , ymid , x1 , xmid , k );
        if( m == 1 ) setm( ymid + 1 , y2 , x1 , xmid , k );
        if( m == 2 ) setm( y1 , ymid , xmid + 1 , x2 , k );
        if( m == 3 ) setm( ymid + 1 , y2 , xmid + 1 , x2 , k );
    }

    if( x1 == xmid ){
        for( int k = 0; k < 4; ++k ){
            if( k == si || k == sj ) continue;

            if( k == 0 ) sol[y1][x1] = mx[y1][x1];
            if( k == 1 ) sol[y2][x1] = mx[y2][x1];
            if( k == 2 ) sol[y1][x2] = mx[y1][x2];
            if( k == 3 ) sol[y2][x2] = mx[y2][x2];
        }
    }

    dp[y1][x1][deep][0] = si;
    dp[y1][x2][deep][1] = sj;
    dp[y1][x2][deep][2] = ret;

    return ret;
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d",&n);

    char c;
    for( int i = 1; i <= n; ++i )
        for( int j = 1; j <= n; ++j ){
            while( c = fgetc(in) ) if( c == '0' || c == '1' ) break;
            mx[i][j] = c - '0';
        }

    memset( dp , -1, sizeof(dp));
    int ss = solve( 1 , n , 1 , n , 0 );

    printf("%d\n",ss);


    for( int i = 1; i <= n; ++i ){
        for( int j = 1; j <= n; ++j ){
            putchar(sol[i][j]+'0');
        }putchar('\n');
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <algorithm>
#include <set>
#include <queue>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
using namespace std;


int main(){

    int a,b,c;
    int r1,r2,r3;

    scanf("%d%d%d",&a,&b,&c);
    scanf("%d%d%d",&r1,&r2,&r3);

    int o = r1 + r2 + r3;
    double p1 = r1 / (double)o;
    double p2 = r2 / (double)o;
    double p3 = r3 / (double)o;

    double L = 999999;
    L = min( L , a / p1 );
    L = min( L , b / p2 );
    L = min( L , c / p3 );

    //cout<<a - L*p1<<" "<<b - L*p2<<" "<<c - L*p3<<endl;

    printf("%.10lf %.10lf %.10lf\n",a - L*p1,b - L*p2,c - L*p3 );

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <vector>
#include <algorithm>
#include <set>
#include <math.h>
#include <iomanip>
using namespace std;

int sz = 0;
double t[20005];
double srt[20005];
int v[20005];

const int lg = (int)ceil(log2(20000)) + 1;

int tree[1<<16];

const int wy = 1<<15;

void update( int node , int val ){

    tree[ node ] = max( tree[node] , val );
    node >>= 1;

    for( ; node >= 1; node >>= 1 )
        tree[node] = max( tree[node] , max( tree[node<<1] , tree[(node<<1)|1] ) );
}

int lo , hi;
int read( int node , int l , int r ){

    if( l > r || node >= wy*2 || r < lo || hi < l ) return 0;
    if( lo <= l && r <= hi )
        return tree[node];

    int mid = (l+r)>>1 , sol = 0;
    sol = max( sol , read( node*2  , l , mid )  );
    sol = max( sol , read( node*2+1, mid + 1 , r )  );

    return sol;
}

int main(){

    while( scanf("%lf",&t[sz++] ) == 1 ); sz-=2;

    reverse( t , t + sz );

    for( int k = 0; k < sz; ++k ) srt[k] = t[k];
    sort( srt , srt + sz );

    for( int k = 0; k < sz; ++k )
        v[k] = lower_bound( srt , srt + sz , t[k] ) - srt;

    int sol = 0;

    for( int k = 0; k < sz; ++k ){
        int q = 1;
        lo = wy , hi = wy+v[k]-1;
        if( wy <= hi ) q = read( 1 , wy , wy*2-1 ) + 1;

        update( wy+v[k] , q );
        sol = max( sol , q );

    }

    printf("%d\n",sol*100);



    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

bool used[1000];

class Nisoku {
    public:
        double theMax(vector <double> cards)
        {
            sort( cards.begin() , cards.end() );
            double sol = 0;
            for( int i = 0; i <= cards.size(); i +=2 ){

                double sum = 1;
                for( int k = 0; k < (i>>1); ++k )
                    sum *= cards[k] + cards[ i - k - 1];

                for( int k = i; k < cards.size(); ++k )
                    sum *= cards[k];
                sol = max( sum , sol );
            }

            return  sol ;

        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const double &Expected, const double &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { double Arr0[] = { 1.5,1.8}; vector <double> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); double Arg1 = 40.0; verify_case(0, Arg1, theMax(Arg0)); }
	void test_case_1() { double Arr0[] = {1.5, 1.8}; vector <double> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); double Arg1 = 3.3; verify_case(1, Arg1, theMax(Arg0)); }
	void test_case_2() { double Arr0[] = {8.26, 7.54, 3.2567}; vector <double> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); double Arg1 = 202.82857868; verify_case(2, Arg1, theMax(Arg0)); }
	void test_case_3() { double Arr0[] = {1.5, 1.7, 1.6, 1.5}; vector <double> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); double Arg1 = 9.920000000000002; verify_case(3, Arg1, theMax(Arg0)); }
	void test_case_4() { double Arr0[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
10, 10, 10, 10, 10, 10, 10, 10, 10, 10}; vector <double> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); double Arg1 = 1.0E50; verify_case(4, Arg1, theMax(Arg0)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    Nisoku c;
    c.__test();
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;


class BunnyPuzzle {
    public:
        int theCount(vector <int> bun)
        {
            int sol = 0;
            for( int i = 0; i < bun.size()-1; ++i ){
                    int nw = 2* bun[i+1] - bun[i];
                    int nxt = 999999999;
                    if( i+2 < bun.size() ) nxt = bun[i+2];

                    bool ok = ( bun[i+1] < nw && nw < nxt );
                    sol += ok;
            }
            reverse( bun.begin() , bun.end() );

            for( int i = 0; i < bun.size()-1; ++i ){
                    int nw = 2* bun[i+1] - bun[i];
                    int nxt = -999999999;
                    if( i+2 < bun.size() ) nxt = bun[i+2];

                    bool ok = ( bun[i+1] > nw && nw > nxt );
                    sol += ok;
            }
            return sol;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arr0[] = {5, 8}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 2; verify_case(0, Arg1, theCount(Arg0)); }
	void test_case_1() { int Arr0[] = {-1, 0, 1}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 2; verify_case(1, Arg1, theCount(Arg0)); }
	void test_case_2() { int Arr0[] = {0, 1, 3}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 3; verify_case(2, Arg1, theCount(Arg0)); }
	void test_case_3() { int Arr0[] = {-677, -45, -2, 3, 8, 29, 384, 867}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 7; verify_case(3, Arg1, theCount(Arg0)); }
	void test_case_4() { int Arr0[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 2; verify_case(4, Arg1, theCount(Arg0)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    BunnyPuzzle c;
    c.__test();
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

typedef long long ll;

const ll mod  = 1000000007;



class RabbitNumbering {
    public:
        int theCount(vector <int> mx)
        {
            sort( mx.begin() , mx.end() );

            ll sol = 1;

            for( int i = 0; i < mx.size(); ++i ){
                sol = sol * (mx[i] - i) ;
                sol %= mod;
            }
            return sol;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arr0[] = {5}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 5; verify_case(0, Arg1, theCount(Arg0)); }
	void test_case_1() { int Arr0[] = {4, 4, 4, 4}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 24; verify_case(1, Arg1, theCount(Arg0)); }
	void test_case_2() { int Arr0[] = {5, 8}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 35; verify_case(2, Arg1, theCount(Arg0)); }
	void test_case_3() { int Arr0[] = {2, 1, 2}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 0; verify_case(3, Arg1, theCount(Arg0)); }
	void test_case_4() { int Arr0[] = {25, 489, 76, 98, 704, 98, 768, 39, 697, 8, 56, 74, 36, 95, 87, 2, 968, 4, 920, 54, 873, 90}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 676780400; verify_case(4, Arg1, theCount(Arg0)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    RabbitNumbering c;
    c.__test();
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

#define ok(x,y) (x>=0&&y>=0&&y<maze.size()&&x<maze[0].size())

pii s , e;

int d[][2] = { -1,0 , 1,0,  0,1, 0,-1 };

bool visi[100][100];

class ColorfulMazeTwo {
    public:
        double getProbability(vector <string> maze, vector <int> trap)
        {
            for( int i = 0; i < maze.size(); ++i )
                for( int j = 0; j < maze[i].size(); ++j )
                    if( maze[i][j] == '$' )
                        s = mk( j , i );
                    else if( maze[i][j] == '!' )
                        e = mk( j , i );


            int n = trap.size();
            queue< pii > q;
            double sol = 0;

            for( int i = 0; i < (1<<n); ++i ){
                double p = 1;
                for( int k = 0; k < n; ++k )
                    if( i&(1<<k) ) p *= (100-trap[k])/100.0;


                memset( visi , false , sizeof(visi));
                pii u;

                while( !q.empty() )q.pop();

                q.push( s );
                visi[ s.s ][ s.f ] = true;

                while( !q.empty() ){
                    u = q.front();
                    q.pop();

                    if( u == e )break;

                    for( int k = 0; k <4; ++k ){
                        int xn = u.f + d[k][0];
                        int yn = u.s + d[k][1];


                        if( ok(xn,yn) == false || visi[yn][xn] || maze[yn][xn] == '#'  ) continue;

                        int c = maze[yn][xn] - 'A';

                        if( maze[yn][xn] == '.' || maze[yn][xn] == '!' || (i&(1<<c)) ){
                            visi[yn][xn] = true;
                            q.push( mk(xn,yn) );
                        }

                    }
                }

                if( u == e )
                    sol = max( sol , p );

            }
            return sol;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); if ((Case == -1) || (Case == 5)) test_case_5(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const double &Expected, const double &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { string Arr0[] = { ".$.",
  "A#B",
  "A#B",
  ".!." }; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = { 50, 50, 0, 0, 0, 0, 0 }; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); double Arg2 = 0.5; verify_case(0, Arg2, getProbability(Arg0, Arg1)); }
	void test_case_1() { string Arr0[] = { ".$.",
  "A#B",
  "A#B",
  ".!." }; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = { 50, 40, 0, 0, 0, 0, 0 }; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); double Arg2 = 0.6; verify_case(1, Arg2, getProbability(Arg0, Arg1)); }
	void test_case_2() { string Arr0[] = { "$A#",
  ".#.",
  "#B!" }; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = { 10, 10, 10, 10, 10, 10, 10 }; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); double Arg2 = 0.0; verify_case(2, Arg2, getProbability(Arg0, Arg1)); }
	void test_case_3() { string Arr0[] = { "$A..",
  "##.A",
  "..B!" }; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = { 50, 50, 0, 0, 0, 0, 0 }; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); double Arg2 = 0.5; verify_case(3, Arg2, getProbability(Arg0, Arg1)); }
	void test_case_4() { string Arr0[] = { "$C..",
  "##.A",
  "..B!" }; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = { 50, 50, 100, 0, 0, 0, 0 }; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); double Arg2 = 0.0; verify_case(4, Arg2, getProbability(Arg0, Arg1)); }
	void test_case_5() { string Arr0[] = { ".$.D.E.F.G.!." }; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = { 10, 20, 30, 40, 50, 60, 70 }; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); double Arg2 = 0.036000000000000004; verify_case(5, Arg2, getProbability(Arg0, Arg1)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    ColorfulMazeTwo c;
    c.__test();
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;


class ColorfulBoxesAndBalls {
    public:
        int getMaximum(int numRed, int numBlue, int onlyRed, int onlyBlue, int bothColors)
        {
            int sol = 0;
            for( int i = 0; i < numRed; ++i ){
                if( onlyRed + onlyBlue > bothColors*2 || numBlue == 0 )
                    sol += onlyRed;
                else{
                    numBlue --;
                    sol += bothColors * 2;
                }
            }

            sol += onlyBlue * numBlue;
            return sol;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arg0 = 2; int Arg1 = 3; int Arg2 = 100; int Arg3 = 400; int Arg4 = 200; int Arg5 = 1400; verify_case(0, Arg5, getMaximum(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_1() { int Arg0 = 2; int Arg1 = 3; int Arg2 = 100; int Arg3 = 400; int Arg4 = 300; int Arg5 = 1600; verify_case(1, Arg5, getMaximum(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_2() { int Arg0 = 5; int Arg1 = 5; int Arg2 = 464; int Arg3 = 464; int Arg4 = 464; int Arg5 = 4640; verify_case(2, Arg5, getMaximum(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_3() { int Arg0 = 1; int Arg1 = 4; int Arg2 = 20; int Arg3 = -30; int Arg4 = -10; int Arg5 = -100; verify_case(3, Arg5, getMaximum(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_4() { int Arg0 = 9; int Arg1 = 1; int Arg2 = -1; int Arg3 = -10; int Arg4 = 4; int Arg5 = 0; verify_case(4, Arg5, getMaximum(Arg0, Arg1, Arg2, Arg3, Arg4)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    ColorfulBoxesAndBalls c;
    c.__test();
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

int n,m;
char txt[100];

bool isok( ){
    int len = strlen(txt);
    map<int,bool> m;

    for( int i = 0; i  < len; ++i )
        for( int j = i; j < len; ++j ){
            int s = 1;
            for( int k = i; k <= j; ++k ){
                s *= txt[k];
            }
            if( m[s] ) return false;
            m[s] = true;
        }

    return true;
}

bool found = true;
int sol = 0;

vector< string > q;

void solve( int idx , int mask  ){
    txt[idx] = '\0';
    if( isok() == false ) return;
    if( idx == n ){
         sol++;
         return;
    }



    for( int c = 2; c <= 9; ++c ){

        txt[idx] = c;
        solve( idx + 1 , mask | (1<<c)  );

        if( sol >= m || found){
             found = true;
             return;
        }
    }
    return;
}

class ColorfulStrings {
    public:
        string getKth(int p1, int p2)
        {
            n = p1 , m = p2;
            if( n == 1 && p2 <= 10 ) return string(1,'0'+p2-1);
            else if( n == 1 ) return "";
            if( n > 8 ) return "";

            sol = 0;
            q.clear();
            found = false;
            solve( 0 , 0 );


            string ss = "";

            for( int k = 0; k < n; ++k )
                ss += string(1,txt[k]+'0');

            sort( q.begin() , q.end() );



            if( found == false ) return "";
            return ss;
        }


// 3 4 238
// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const string &Expected, const string &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arg0 = 1; int Arg1 = 1; string Arg2 = "52"; verify_case(0, Arg2, getKth(Arg0, Arg1)); }
	void test_case_1() { int Arg0 = 4; int Arg1 = 2000; string Arg2 = ""; verify_case(1, Arg2, getKth(Arg0, Arg1)); }
	void test_case_2() { int Arg0 = 5; int Arg1 = 1; string Arg2 = "23457"; verify_case(2, Arg2, getKth(Arg0, Arg1)); }
	void test_case_3() { int Arg0 = 2; int Arg1 = 22; string Arg2 = "52"; verify_case(3, Arg2, getKth(Arg0, Arg1)); }
	void test_case_4() { int Arg0 = 6; int Arg1 = 464; string Arg2 = "257936"; verify_case(4, Arg2, getKth(Arg0, Arg1)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    ColorfulStrings c;
    c.__test();
}
// END CUT HERE

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <map>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <queue>
#include <set>
using namespace std;

const int inf = 999999999;

struct coord{
    double x,y;
    coord(){};
    coord( double p1, double p2 ):x(p1),y(p2){};

    bool operator<( const coord & c2 ) const {
        return x < c2.x || ( x == c2.x && y < c2.y );
    }
};

struct segment{
    coord a,b;
    segment(){};
    segment( coord p1 , coord p2 ):a(p1),b(p2){}

    bool overlapp( segment );

    int ccw( coord c ){
        return (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);
    }
};


bool online( coord A , coord B , coord ref ){
   return ( min(A.x,B.x)<=ref.x && max(A.x,B.x)>=ref.x && min(A.y,B.y)<=ref.y && max(A.y,B.y)>=ref.y );
}


bool segment::overlapp( segment s ){
    if( ccw(s.a) != 0 || ccw(s.b) != 0 )return false;
    if( online( a , b , s.a ) || online( a , b , s.b ) ) return true;
    return false;
}



coord sect( coord a , coord b , coord c , coord d ){
    double A1 = b.y - a.y;
    double B1 = a.x - b.x;
    double C1 = A1*a.x + B1*a.y;

    double A2 = d.y - c.y;
    double B2 = c.x - d.x;
    double C2 = A2*c.x + B2*c.y;

    double det = A1*B2 - A2*B1;

    coord sol;

    if( fabs(det) < 0.0000001 ) return coord( inf , inf );
    else{
        double x = (B2*C1 - B1*C2) / det;
        double y = (A1*C2 - A2*C1) / det;

        sol = coord(x,y);
    }

    if( online( a,b,sol) && online( c,d,sol) )
        return sol;
    else
        return coord( inf,inf );
}


int n;
vector< segment >row;
bool kill[100];

coord tmp[5];

bool sortx( coord a , coord b ){ return a.x < b.x; }
bool sorty( coord a , coord b ){ return a.y < b.y; }

bool eq( coord a , coord b ){
    return fabs(a.x-b.x) < 0.00001 && fabs(a.y-b.y) < 0.00001;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        int x1,y1,x2,y2; scanf("%d%d%d%d",&x1,&y1,&x2,&y2);

        row.push_back(  segment( coord(x1,y1) , coord(x2,y2) )   );
    }

    bool done = false;
    while( !done ){
        done = true;

        for( int i = 0; i < row.size(); ++i ){
            for( int j = i+1; j < row.size(); ++j ){
                if( kill[i] || kill[j] ) continue;

                if( row[i].overlapp( row[j] ) ){
                    done = false;
                    kill[j] = true;

                    tmp[0] = row[i].a , tmp[1] = row[i].b;
                    tmp[2] = row[j].a , tmp[3] = row[j].b;

                    if( row[i].a.x != row[i].b.x ){
                        sort( tmp , tmp + 4 , sortx );
                        row[i].a = tmp[0];
                        row[i].b = tmp[3];
                    }else{
                        sort( tmp , tmp + 4 , sorty );
                        row[i].a = tmp[0];
                        row[i].b = tmp[3];
                    }

                }
            }
        }
    }

    vector< segment > w;

    for( int i = 0; i < row.size(); ++i ){
        if( !kill[i] )
            w.push_back( row[i] );
    }

    int sol = 0;

    for( int i = 0; i < w.size(); ++i ){
        for( int j = i+1; j < w.size(); ++j ){
            for( int k = j+1; k < w.size(); ++k ){

                coord p1 = sect( w[i].a , w[i].b , w[j].a , w[j].b );
                coord p2 = sect( w[i].a , w[i].b , w[k].a , w[k].b );
                coord p3 = sect( w[j].a , w[j].b , w[k].a , w[k].b );

                if( fabs(p1.x-inf)<0.0001 || fabs(p2.x-inf)<0.0001 || fabs(p3.x-inf)<0.0001 ) continue;
                if( eq(p1,p2) || eq(p2,p3) || eq( p1,p3) ) continue;

                sol++;



            }
        }
    }

    printf("%d\n",sol);


    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;


class FlatCatsBreeding {
    public:
        int days(int D, int K, int T)
        {
            if( T == 1 ) return 0;
            int cats = 1 , i;
            for( i = D; cats < T; i+=D ){
                cats = cats*K + cats;
            }
            i -= D;
            return i;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); if ((Case == -1) || (Case == 5)) test_case_5(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arg0 = 4; int Arg1 = 3; int Arg2 = 1; int Arg3 = 0; verify_case(0, Arg3, days(Arg0, Arg1, Arg2)); }
	void test_case_1() { int Arg0 = 4; int Arg1 = 3; int Arg2 = 4; int Arg3 = 4; verify_case(1, Arg3, days(Arg0, Arg1, Arg2)); }
	void test_case_2() { int Arg0 = 4; int Arg1 = 3; int Arg2 = 9; int Arg3 = 8; verify_case(2, Arg3, days(Arg0, Arg1, Arg2)); }
	void test_case_3() { int Arg0 = 4; int Arg1 = 3; int Arg2 = 1000000; int Arg3 = 40; verify_case(3, Arg3, days(Arg0, Arg1, Arg2)); }
	void test_case_4() { int Arg0 = 91; int Arg1 = 6; int Arg2 = 10433; int Arg3 = 455; verify_case(4, Arg3, days(Arg0, Arg1, Arg2)); }
	void test_case_5() { int Arg0 = 9; int Arg1 = 7; int Arg2 = 17079; int Arg3 = 45; verify_case(5, Arg3, days(Arg0, Arg1, Arg2)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    FlatCatsBreeding c;
    c.__test();
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;


class DistanceOnCube {
    public:
        int calculate(int S, int x1, int y1, int z1, int x2, int y2, int z2)
        {
            int ss = 999999999;

            if( x1 + S ==  x2 || x2 + S ==  x1 ){

                ss = min ( S + min( z1 + z2, S-z1 + S-z2 ) + abs( y1-y2 ) , ss );
                ss = min ( S + min( y1 + y2, S-y1 + S-y2 ) + abs( z1-z2 ) , ss );

            }else if( y1 + S ==  y2 || y2 + S ==  y1 ){

                ss = S + min( z1 + z2, S-z1 + S-z2 ) + abs( x1-x2 );
                ss = min( ss , S + min( x1 + x2, S-x1 + S-x2 ) + abs( z1-z2 ) );

            }else if( z1 + S ==  z2 || z2 + S ==  z1 ){

                ss = S + min( x1 + x2, S-x1 + S-x2 ) + abs( y1-y2 );
                ss = min( ss , S + min( y1 + y2, S-y1 + S-y2 ) + abs( x1-x2 ) );

            }else{

                ss = abs( x1-x2 ) + abs( y1-y2 ) + abs(z1-z2);

            }


            return ss;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); if ((Case == -1) || (Case == 5)) test_case_5(); if ((Case == -1) || (Case == 6)) test_case_6(); if ((Case == -1) || (Case == 7)) test_case_7(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arg0 = 4; int Arg1 = 2; int Arg2 = 2; int Arg3 = 0; int Arg4 = 3; int Arg5 = 3; int Arg6 = 0; int Arg7 = 2; verify_case(0, Arg7, calculate(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)); }
	void test_case_1() { int Arg0 = 4; int Arg1 = 3; int Arg2 = 2; int Arg3 = 0; int Arg4 = 4; int Arg5 = 3; int Arg6 = 2; int Arg7 = 4; verify_case(1, Arg7, calculate(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)); }
	void test_case_2() { int Arg0 = 4; int Arg1 = 1; int Arg2 = 1; int Arg3 = 0; int Arg4 = 1; int Arg5 = 1; int Arg6 = 4; int Arg7 = 6; verify_case(2, Arg7, calculate(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)); }
	void test_case_3() { int Arg0 = 4; int Arg1 = 2; int Arg2 = 3; int Arg3 = 0; int Arg4 = 2; int Arg5 = 3; int Arg6 = 0; int Arg7 = 0; verify_case(3, Arg7, calculate(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)); }
	void test_case_4() { int Arg0 = 87; int Arg1 = 87; int Arg2 = 10; int Arg3 = 3; int Arg4 = 44; int Arg5 = 11; int Arg6 = 0; int Arg7 = 47; verify_case(4, Arg7, calculate(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)); }
	void test_case_5() { int Arg0 = 49; int Arg1 = 0; int Arg2 = 13; int Arg3 = 43; int Arg4 = 49; int Arg5 = 10; int Arg6 = 45; int Arg7 = 62; verify_case(5, Arg7, calculate(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)); }
	void test_case_6() { int Arg0 = 48; int Arg1 = 13; int Arg2 = 0; int Arg3 = 5; int Arg4 = 8; int Arg5 = 48; int Arg6 = 1; int Arg7 = 59; verify_case(6, Arg7, calculate(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)); }
	void test_case_7() { int Arg0 = 77; int Arg1 = 17; int Arg2 = 20; int Arg3 = 77; int Arg4 = 2; int Arg5 = 35; int Arg6 = 0; int Arg7 = 111; verify_case(7, Arg7, calculate(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    DistanceOnCube c;
    c.__test();
}
// END CUT HERE

#include <iostream>
#include <cstdio>
#include <stack>
#include <algorithm>
#include <map>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <vector>
#include <set>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

const int maxn = 2000001;

int n;
int x[20] , y[20] , r[20];


int main(){
    freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i )
        scanf("%d%d%d",&x[i],&y[i],&r[i]);

    long long half = 0;


    for( int i = 1; i <= maxn; ++i ){

        vector< pii > e;

        for( int k = 0; k < n; ++k ){
            if( y[k] <= i && i-y[k] < r[k] ){
                e.push_back( mk( x[k] , 1 ) );
                e.push_back( mk( x[k] + r[k] - (i-y[k] ) , 0 )  );
            }
        }


        sort( e.begin() , e.end() );

        int cnt = 0;

        for( int k = 0; k < e.size(); k ++ ){
            if( e[k].s == 1 ) cnt ++;
            else cnt --;

            if( k+1 < e.size() ){
                if( cnt&1 ){

                   if(  e[k].s &&  e[k+1].s  ) half += (e[k+1].f - e[k].f)*2;
                   if(  e[k].s && !e[k+1].s  ) half += (e[k+1].f - e[k].f)*2 -1;
                   if( !e[k].s && !e[k+1].s  ) half += (e[k+1].f - e[k].f)*2;
                   if( !e[k].s &&  e[k+1].s  ) half += (e[k+1].f - e[k].f)*2 +1;

                }
            }
        }

    }

    cout<<half/2;
    if( half&1 ) cout<<".5\n";
    else cout<<".0\n";

    return 0;
}

#include <iostream>
#include <math.h>
#include <cstdlib>
#include <fstream>
#include <queue>
#include <stack>
#include <map>
#include <string.h>
#include <set>
#include <algorithm>
using namespace std;


struct data{
    char c;
    int cnt;
    data( char p1 , int p2 ):c(p1),cnt(p2){};
    data(){};
};

char buff[2000];
vector< data > s1,s2, tmp1,tmp2;



void input( vector< data > &s ){
    int n;
    scanf("%d",&n);
    scanf("%s",buff);

    int len = strlen(buff);

    for( int i = 0; i < len; ++i ){

        char c = buff[i];
        int v = 0;

        int k;
        for( k = i+1; k < len && buff[k] >= '0' && buff[k] <= '9'; ++k )
            v = v*10 + buff[k] - '0';

        i = k - 1;
        s.push_back( data(c,v) );
    }

}


map< int , int > dp[205][205][2];
map< int , int > mp[205][205][2];

int solve( int idxa, int idxb , int took , bool froma ){

  //  cout<<idxa<<" "<<idxb<<" "<<took<<" [ "<<froma<<" ] "<<endl;


    if( mp[idxa][idxb][froma][took]  ) return dp[idxa][idxb][froma][took] ;
    mp[idxa][idxb][froma][took]  = true;


    if( idxa == s1.size() && idxb == s2.size() ) return dp[idxa][idxb][froma][took] = 0;

    int sol = 9999999;


    data A = data(' ',0) , B = data(' ' ,0);

    if( idxa < s1.size() ) A = s1[idxa];
    if( idxb < s2.size() ) B = s2[idxb];

    if( froma ) A.cnt -= took;
    else B.cnt -= took;



    if( idxb == s2.size() ){
        int r = A.cnt*2;
        int prv = idxa;
        for( idxa++ ; idxa < s1.size(); idxa ++ ) r += s1[idxa].cnt * 2;
        return dp[prv][idxb][froma][took] = r;
    }



    if( idxa == s1.size() ){
        int r = B.cnt;
        int prv = idxb;
        for( idxb++ ; idxb < s2.size(); idxb ++ ) r += s2[idxb].cnt;
        return dp[idxa][prv][froma][took] = r;
    }


    if( A.c == B.c ){
        if( A.cnt < B.cnt ){
             if( !froma )sol = min( sol , solve( idxa + 1 , idxb , took + A.cnt , false ) );
             else sol = min( sol , solve( idxa + 1 , idxb , A.cnt , false ) );
        }else if( A.cnt > B.cnt ){
            if( froma )sol = min( sol , solve( idxa , idxb + 1 , took + B.cnt , true ) );
            else sol = min( sol , solve( idxa , idxb + 1 , B.cnt , true ) );
        }else
            sol = min( sol , solve( idxa + 1 , idxb + 1 , 0 , true )  );
    }

  //  cout<<sol<<endl;


    if( took && froma == true )sol = min( sol , solve( idxa , idxb + 1, took ,true ) + B.cnt   );
    else sol = min( sol , solve( idxa , idxb + 1, 0 ,0 ) + B.cnt   );

    if( took && froma == false )sol = min( sol , solve( idxa + 1 , idxb, took ,false  ) + A.cnt*2 );
    else sol = min( sol , solve( idxa + 1 , idxb, 0 ,0  ) + A.cnt*2 );

    return dp[idxa][idxb][froma][took] = sol;


}


void transform( vector< data > &from , vector< data > &to ){
    for( int i = 0; i < from.size(); ++i ){
        int cnt = from[i].cnt;

        int k = i + 1;
        for( k = i+1; k < from.size(); ++k ){
            if( from[k].c != from[i].c ) break;
            cnt += from[k].cnt;
        }
        to.push_back( data( from[i].c , cnt) );
        i = k - 1;
    }
}


int main(){

    int tests;
    scanf("%d",&tests);

    int z = 0;

    for( ; tests; --tests){


        s1.clear();
        s2.clear();
        tmp1.clear();
        tmp2.clear();

        input( tmp1 );
        input( tmp2 );

        transform( tmp1 , s1 );
        transform( tmp2 , s2 );


        for( int i = 0; i <= s1.size(); ++i )
            for( int j = 0; j <= s2.size(); ++j )
                dp[i][j][0].clear() , mp[i][j][0].clear() , dp[i][j][1].clear() , mp[i][j][1].clear();


        int s = solve( 0 , 0 , 0 , 0 );


        cout<<s<<endl;

    }

    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:gather
*/
#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <fstream>
#include <vector>
#include <math.h>
#include <iomanip>
#include <set>
#include <string.h>
#include <string>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

typedef long long ll;
const int maxn = 100005;

int n;
int cows[maxn];
vector< pii > g[maxn];

ll cnt[maxn];
ll sum[maxn];

ll dfs( int node , int dad ){
    ll sol = cows[node];
    for( int i = 0; i < g[node].size(); ++i ){
        if( dad == g[node][i].f ) continue;
        sol += dfs( g[node][i].f , node );
    }
    return cnt[node] = sol;
}

ll dfsI( int node , int dad , ll dist ){
    ll sol = 0;
    if( cows[node] ) sol = cows[node] * dist;
    for( int i = 0; i < g[node].size(); ++i ){
        if( dad == g[node][i].f ) continue;
        sol += dfsI( g[node][i].f , node , dist + g[node][i].s );
    }
    return sol;
}

ll all = 0;
ll sol = 9999999999999999LL;

void dfsII( int node, int dad , ll ss ){
    sol = min( sol , ss );

    for( int i = 0; i < g[node].size(); ++i ){
        if( dad == g[node][i].f ) continue;

        ll N = cnt[ g[node][i].f ];
        dfsII( g[node][i].f , node , ss - N*g[node][i].s + (all-N)*g[node][i].s );
    }
}

int main(){
    freopen("gather.in","r",stdin);
    freopen("gather.out","w",stdout);

    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        scanf("%d",&cows[i]);
        all += cows[i];
    }

    for( int i = 0; i < n-1; ++i ){
        int a,b,c; scanf("%d%d%d",&a,&b,&c); a-- , b--;
        g[a].push_back( mk(b,c) );
        g[b].push_back( mk(a,c) );
    }

    dfs( 0 , -1);
    ll s = dfsI( 0 , -1 , 0 );
    dfsII( 0 , -1 , s );

    printf("%lld\n",sol);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <algorithm>
#include <map>
#include <iomanip>
#include <set>
#include <queue>
using namespace std;

typedef long long ll;

int n;
int a,b;


int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&a,&b);

        printf("%d ",tests);

        if( a >= b ){
            printf("Hura\n");
            continue;
        }

        int sol = 1%b;
        for( int i = 2; i <= a; ++i ){
            sol = (sol*(ll)i)%b;
            if( sol == 0 ) break;
        }

        if( sol == 0 )printf("Hura\n");
        else printf("Ouch\n");
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <stack>
#include <set>
#include <queue>
#include <map>
#include <vector>
#include <string>
using namespace std;

#define pq priority_queue

struct trio{
    int a,b,c;
    trio(){};
    trio( int p1, int p2, int p3 ):a(p1),b(p2),c(p3){};
    bool operator<( const trio &t2 ) const {
        return c > t2.c;
    }
};

const int inf = 16843009;

int n,m,d;
int cost[200];
string word[200];
map< string , int > hash;

vector< int >g[200];

bool bases[200];
int done[200];
bool ex[200];


void input(){
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        cin >> word[i] >> cost[i];
        hash[ word[i] ] = i;
    }

    scanf("%d",&m);
    for( int i = 0; i < m; ++i ){
        string a,b;  cin >> a >> b;
        int ka = hash[a] , kb = hash[b];
        g[ka].push_back( kb );
        g[kb].push_back( ka );
    }

    scanf("%d",&d);
    for( int i = 0; i < d; ++i ){
        string a; cin >> a;
        int ka = hash[a];
        bases[ka] = true;
        ex[ka] = true;
    }
}

void update(){
    memset( done , 0 , sizeof(done));
    for( int i = 0; i < n; ++i ){
        if( bases[i] == false ) continue;
        done[i] ++;
        for( int j = 0; j < g[i].size(); ++j )
            done[ g[i][j] ] ++;
    }
}


bool finished(){
    for( int i = 0; i < n; ++i ) if( done[i] == false ) return false;
    return true;
}

bool bb[200];
int sol = 999999999;
set< int >::iterator it;
set< int > q;

int START;
bool WARNING = false;

void solve( int sum  ){
    int END = clock();
    double time = (END-START)/CLOCKS_PER_SEC;

    if( time >= 0.9 ){
        WARNING = true;
        return;
    }

    if( sum >= sol ) return;
    if( finished() ){
        if( sol > sum ){
            sol = sum;
            memcpy( bb , bases , sizeof bb );
        }
        return;
    }

    int *fin = new int[200];


    vector< int > Q;
    for( int i = 0; i < n; ++i ){
        fin[i] = false;
        if( bases[i] == false && done[i] )
            Q.push_back( i );
    }

    int ln = Q.size();

    for( int i = 0; i < 50; ++i ){
        int r = rand() % ln;
        if( fin[r] ) continue;
        fin[r] = true;

        int v = Q[r];
        //q.erase(it);
        bases[ v ] = true;
        for( int k = 0; k < g[v].size(); ++k )done[ g[v][k] ]++;

        solve( sum + cost[v] );
        if( WARNING ) return;

        for( int k = 0; k < g[v].size(); ++k )done[ g[v][k] ]--;
        bases[ v ] = false;
        //q.insert(v);
    }
}



int main(){
    srand( (unsigned)time(0));
    START = clock();
    freopen("Ulaz.txt","r",stdin);
    input();
    update();

//    vector< int > todo;
//    for( int i = 0; i < n; ++i ){
//        if( bases[i] == false && done[i] )
//            q.insert(i);
//    }
    if( n <= 100 ){
        solve(0);
        int cnt = 0;
        for( int i = 0; i < n; ++i )
            if( bb[i] && !ex[i] )
                cnt++;
        cout<<cnt<<endl;
        for( int i = 0; i < n; ++i )
            if( bb[i] && !ex[i] )
                printf("%s\n",word[i].c_str());

        cout<<sol<<endl;
    }else{
        vector< int > chose;
        int sol = INT_MAX;

        int ss = 0;
        while( !finished() ){
            vector< int > qq = getrand();
        }
    }
    return 0;
}

#include <cstdio>
#include <iostream>
using namespace std;

int n;
int w[21];

int main(){
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ) scanf("%d",&w[i]);

    int sol = 100000 * 21;
    for( int i = 0; i < (1<<n); ++i ){
        int curr = 0;
        for( int j = 0; j < n; ++j )
            if( i&(1<<j) ) curr += w[j];
            else curr -= w[j];

        if( curr < 0 ) curr = -curr;
        if( sol > curr ) sol = curr;
    }
    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
using namespace std;

const int maxn = 105;

struct coord{
    int x,y,z;
    coord(){};
    coord( int p1, int p2, int p3 ):x(p1),y(p2),z(p3){};
};

int n;
coord p[maxn];

int ccw( coord c, coord a, coord b ){
    return (a.x-c.x)*(b.y-c.y) - (b.x-c.x)*(a.y-c.y);
}

int ct( coord p, coord q, coord r, coord s ){
  return (q.z-p.z)*ccw(p,r,s) - (r.z-p.z)*ccw(p,q,s) +
         (s.z-p.z)*ccw(p,q,r);
}

bool ok[maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        int a,b,c;
        p[i] = coord(a,b,c);
    }

    for( int i = 0; i < n; ++i ){
        for( int j = i+1; j < n; ++j ){
            for( int k = j+1; k < n; ++k ){
                if( ccw( p[i], p[j], p[k] ) >= 0 ) continue;

                int l;
                for( l = 0; l < n; ++l )
                    if( ct( p[i], p[j], p[k], p[l] ) > 0 ) break;

                if( l == n ) ok[i] = ok[j] = ok[k] = 1;
            }
        }
    }

    for( int i = 0; i < n; ++i ){
        if( ok[i] ) printf("Yes\n");
        else printf("No\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <math.h>
#include <fstream>
#include <iomanip>
using namespace std;

const int maxn = 205;
const double eps = 1e-10;
//const double deps = 1e-10;

int n;
int v0[maxn],v1[maxn],v2[maxn];
double x[maxn],y[maxn],z[maxn];

bool prepare( int row ){
    for( int i = 0; i < n; ++i ){
        if( i == row ) continue;
        int dx = i - (i > row );
        x[dx] = 1.0/v0[row] - 1.0/v0[i];
        y[dx] = 1.0/v1[row] - 1.0/v1[i];
        z[dx] = 1.0/v2[row] - 1.0/v2[i];

        if( fabs(x[dx])<eps && fabs(y[dx])<eps && fabs(z[dx]) < eps ){
            //printf("%.10lf %.10lf %.10lf\n",x[dx],y[dx],z[dx]);
            return 0;
        }
    }
    return 1;
}

int h,w;
double table[maxn][maxn];

void make_table(){
    memset( table, 0, sizeof(table));
    w = 3;
    for( int i = 0; i < n-1; ++i ){
        table[i][0] = x[i];
        table[i][1] = y[i];
        table[i][2] = z[i];
        table[i][w++] = 1;
    }

    h = n-1;
    table[h][0] = table[h][1] = table[h][2] = 1;
    table[h][w++] = 1;
    h++;

    table[h][0] = 1, table[h][w++] = -1; h++;
    table[h][1] = 1, table[h][w++] = -1; h++;
    table[h][2] = 1, table[h][w++] = -1; h++;

    table[h][0] = table[h][1] = table[h][2] = -1;
    table[h][w++] = 1;

    for( int i = 0; i < n-1; ++i ) table[i][w] = eps;
    table[n-1][w] = 150000000;
    double ep = 0.1;
    table[n][w] = ep;
    table[n+1][w] = ep;
    table[n+2][w] = ep;
}


int first_neg(){
    int sol = 2*h;
    for( int i = 0; i < w; ++i ){
        int cntneg = 0,row = -1;
        for( int j = 0; j <= h; ++j )
            if( table[j][i] < -eps ) cntneg ++, row = j;
            else if( table[j][i] > eps ) cntneg += 5;
        if( cntneg == 1 ) sol = min( sol , row );
    }
   // cout<<"SOL_NEG: "<<sol<<endl;
    if( sol == 2*h ) sol = -1;
    return sol;
}

int pivcol_neg(){
    int row = first_neg();
    if( row == -1 ) return -1;

   // cout<<row<<" ";

    int dx = -1;
    for( int i = 0; i < w; ++i )
        if( dx == -1 || table[row][i] > table[row][dx] )
            dx = i;
   // cout<<" :: " <<dx<<endl;
    return dx;
}

int simplex(){

    int pivcol = pivcol_neg();
   // cout<<"NEG: "<<pivcol<<endl;

    if( pivcol == -1 ){
        for( int i = 0; i < w; ++i )
            if( pivcol == -1 || table[n][pivcol] >= table[n][i] )
                if( table[n][i] < -eps )pivcol = i;
        if( pivcol == -1 || table[n][pivcol] >= 0 ) return 0;
    }

   // cout<<"OK "<<pivcol<<" "<<table[n][pivcol]<<endl;
    if( pivcol == -1 ) return 0;

    int pivrow = -1;
    double low;

    for( int i = 0; i < h; ++i ){
        if( table[i][pivcol] == 0 || table[i][pivcol] <= eps ) continue;
        double rowval = table[i][w] / table[i][pivcol];
        if( pivrow == -1 || low >= rowval ) pivrow = i, low = rowval;
    }

    if( pivrow == -1 ) return 0;

    //printf("[Row/Col] : [%d/%d] %.10lf\n",pivrow,pivcol,table[pivrow][pivcol]);

    double div = table[pivrow][pivcol];
    for( int i = 0; i <= w; ++i )
        table[pivrow][i] /= div;

    for( int i = 0; i <= h; ++i ){
        if( i == pivrow ) continue;
        double mul = table[i][pivcol];
        for( int j = 0; j <= w; ++j )
            table[i][j] -= mul*table[pivrow][j];
    }

    return 1;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);

    scanf("%d",&n);

    for( int i = 0; i < n; ++i )
        scanf("%d%d%d",&v0[i],&v1[i],&v2[i]);

    for( int i = 0; i < n; ++i ){

        if( !prepare( i ) ){
            printf("No\n");
            continue;
        }
        make_table();

//         ofstream out("Izlaz2.txt");
//        for( int i = 0; i <= h; ++i ){
//            for( int j = 0; j <= w; ++j )
//                cout<<table[i][j]<<" ";
//            cout<<endl;
//        }cout<<endl;

        int t = 200;
        int r;
        while( (r = simplex()) && t-- ){
//                    cout<<"RUN: "<<t<<endl;
//            for( int i = 0; i <= h; ++i ){
//                for( int j = 0; j <=w; ++j )
//                    cout<<table[i][j]<<" ";
//                cout<<endl;
//            }cout<<endl;
        }

//        cout<<"RUN: "<<t<<endl;
//            for( int i = 0; i <= h; ++i ){
//                for( int j = 0; j <=w; ++j )
//                    cout<<table[i][j]<<" ";
//                cout<<endl;
//            }cout<<endl;

        bool ok = t > 0;
        double a(0),b(0),c(0);
        for( int i = 0; i < h; ++i ){
            a += table[i][0],
            b += table[i][1],
            c += table[i][2];
        }

        //cout<<a<<" "<<b<<" "<<c<<endl;

        for( int i = 0; i < w; ++i )
            if( table[h][i] < -0.0000001 ) ok = 0;

        //cout<<"OK: "<<ok<<endl;

        if( fabs(a-1)<eps && fabs(b-1)<eps && fabs(c-1)<eps && ok ) printf("Yes\n");
        else printf("No\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
using namespace std;

const int maxn = 105;

int n;
int v[maxn],u[maxn],w[maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);

    scanf("%d",&n);

    for( int i = 0; i < n; ++i )
        scanf("%d %d %d\n",&v[i],&u[i],&w[i]);

    int sel = 0;
    for( int i = 0; i < n; ++i ){
        if( i == sel ) continue;
        double a = (1./v[sel]) - 1./v[i];
        double b = (1./u[sel]) - 1./u[i];
        double c = (1./w[sel]) - 1./w[i];

        int s = 2;

        if( a )printf("%.10lfx ",a),s = 0;
        else if( b ) printf("%.10lfy ",b), s = 1;
        else if( c ) printf("%.10lfz ",c), s = 2;

        if( b && s == 0 ){
            s = 0;
            if( b < 0 ) printf("- %.10lfy ",-b);
            else printf("+ %.10lfy ",b);
        }else if( c && s <= 1 ){
            s = 1;
            if( c < 0 ) printf("- %.10lfz ",-c);
            else printf("+ %.10lfz ",c);
        }

        if( c && s == 0 ){
            if( c < 0 ) printf("- %.10lfz ",-c);
            else printf("+ %.10lfz ",c);
        }

        printf("<= 0.000000000001\n");
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
#include <math.h>
#include <vector>
#include <stack>
using namespace std;

typedef long long ll;

int n,m;
char loco[5], tmp[5];
int mat[255][255];
ll dp[10000];

int hashit( int s, int a, int b, int c, int d ){
    return s*41*41*41*41 + a*41*41*41 + b*41*41 + c*41 + d;
}

int cnt = 1;
map<int,int>mp;

ll solve( bool prv, int ab, int aa, int bb, int ba ){
    if( ab < 0 || aa < 0 || bb < 0 || ba < 0 ) return 0;

    int dx = n - ab - aa - bb - ba;
    if( dx == m ){
        if( prv ) return loco[0] == 'B';
        else return loco[0] == 'A';
    }

    int key = hashit(prv,ab,aa,bb,ba);
    if( mp[key] == 0 ) mp[key] = cnt ++;
    key = mp[key];

    ll &sol = dp[key];
    if( sol != -1 ) return sol;

    sol = 0;

    if( prv == 0 ){
        sol += solve( 0, ab, aa-1, bb, ba );
        sol += solve( 1, ab-1, aa, bb, ba );
    }else{
        sol += solve( 0, ab, aa, bb, ba-1 );
        sol += solve( 1, ab, aa, bb-1, ba );
    }
    return sol;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);
    scanf("%s",loco);

    for( int i = 0; i < n; ++i ){
        scanf("%s",tmp);
        mat[ tmp[0] ][ tmp[1] ] ++;
    }

    memset( dp, -1, sizeof(dp));
    ll sol = solve( loco[1] != 'A' , mat['A']['B'], mat['A']['A'], mat['B']['B'], mat['B']['A'] );

    if( sol == 0 ) printf("NO\n");
    else printf("YES\n%I64d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <stack>
#include <set>
using namespace std;

#define mk make_pair
#define f first
#define s second

int h,w;

vector< pair<string,string> > path;

int solve( int dx, string x ){
    cout<<dx<<" "<<x<<endl;
    if( dx == w ){
        if( x == "0000" ) cout<<" :::::::::: FOND :::::::::: "<<endl;
        return x == "0000";
    }

    int sol = 0;

    for( int i = 0; i < path.size(); ++i ){
        if( path[i].f != x ) continue;
        sol += solve( dx + 1 , path[i].s );
    }
    return sol;

}

int main(){
    scanf("%d",&w);

    path.push_back( mk("start","1221") );
    path.push_back( mk("start","1001") );
    path.push_back( mk("1221","1001") );
    path.push_back( mk("1001","1100") ); path.push_back( mk("1100","1001") );
    path.push_back( mk("1001","0110") ); path.push_back( mk("0110","1001") );
    path.push_back( mk("1001","0011") ); path.push_back( mk("0011","1001") );
    path.push_back( mk("1001","0000") );

    path.push_back( mk("0011","1221") );
    path.push_back( mk("1100","1221") );
    path.push_back( mk("1221","1221") );

    path.push_back( mk("1001","1122") );
    path.push_back( mk("1122","1122") );
    path.push_back( mk("1122","1100") );
    path.push_back( mk("1122","0011") );

    path.push_back( mk("1122","0000") );


    int sol = solve( 0 , "start" );
    printf("%d\n",sol*2);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <set>
#include <string.h>
#include <vector>
#include <algorithm>
#include <fstream>
using namespace std;

#define mk make_pair
#define f first
#define s second
#define mk make_pair

int h,w;
int d[][2] = { 0,1 , -1,0, 0,-1, 1,0 };

const int maxh = 5;
const int maxw = 100;

bool visi[maxh][maxw];
char point[maxh][maxw];
char revpoint[maxh][maxw];

int cnt = 0;

set< string > p;
vector< pair<string,string > > edge;

bool vis[11][11];
char call[11][11];

void paint(){
    memset( vis, 0, sizeof(vis));

    for( int i = 0; i < h; ++i )
        for( int j = 0; j < w; ++j )
            call[i][j] = '0';

    for( int i = 0; i < w; ++i ){
        for( int j = 0; j < h; ++j ){
            int x = point[j][i];
            if( x != 0 ) continue;
            int r = j, c = i;
            c ++;
            bool end = 0;
            while( c != i ){
                if( c == w-1 && r == h-1 ) end = 1;
                int x = point[r][c];

                r += d[x][0];
                c += d[x][1];
            }
            //cout<<i<<": "<<j<<" "<<r<<endl;
            call[j][i] = call[r][i] = '2' - end;
        }
    }

}


int rec( int r, int c ){
    if( r < 0 || c < 0 || r >= h || c >= w ) return 0;

    if( cnt == h*w+1 && r == 0 && c == 0 ){

//        for( int i = 0; i < h; ++i ){
//            for( int j = 0; j < w; ++j )
//                cout<<char(point[i][j] + '0');
//            cout<<endl;
//        }cout<<endl;

        paint();

//        for( int i = 0; i < h; ++i ){
//            for( int j = 0; j < w; ++j )
//                cout<<char(call[i][j]);
//            cout<<endl;
//        }cout<<endl<<endl<<endl;

        string prv = "F";
        for( int j = 0; j < w; ++j ){
            string now = "";
            for( int i = 0; i < h; ++i )
                now += string(1,call[i][j]);

            //if( j ){
                edge.push_back( mk(prv,now) );
            //}
            prv = now;
        }

        return 1;

    }
    if( visi[r][c] ) return 0;
    visi[r][c] = 1;

    int ret = 0,from = 0, to = 4;
    if( r == 0 && c == 0 ) from = 0, to = 1;

    for( int i = from; i < to; ++i ){
        int rn = r + d[i][0];
        int cn = c + d[i][1];

        cnt ++;
        point[r][c] = i;
        ret += rec( rn, cn );
        cnt --;
    }

    visi[r][c] = 0;
    return ret;
}

int main(){


    while ( cin >> h >> w ){
        if( h == -1 ) break;
        cnt = 1;
        p.clear();
        cout<<h<<" , "<<w<<" == "<<rec(0,0)*2<<endl;


        sort( edge.begin(), edge.end() );
        edge.erase( unique(edge.begin(),edge.end()),edge.end());

    }

    ofstream out("Izlaz2.txt");
        for( int i = 0; i < edge.size(); ++i ){
            out<<"path.push_back( mk( \""<<edge[i].f<<"\" , \""<<edge[i].s<<"\" ) ); "<<endl;
        }
        out.close();

    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

const int mod = 1000000000;

vector< pair<string,string> >path;

void push2(){
    path.push_back( mk( "F" , "11" ) );
    path.push_back( mk( "11" , "00" ) );
    path.push_back( mk( "11" , "11" ) );
}

void push3(){
    path.push_back( mk( "F" , "101" ) );
    path.push_back( mk( "011" , "101" ) );
    path.push_back( mk( "101" , "000" ) );
    path.push_back( mk( "101" , "011" ) );
    path.push_back( mk( "101" , "110" ) );
    path.push_back( mk( "110" , "101" ) );
}

void push4(){
    path.push_back( mk( "F" , "1001" ) );
    path.push_back( mk( "F" , "1221" ) );
    path.push_back( mk( "0011" , "1001" ) );
    path.push_back( mk( "0011" , "1221" ) );
    path.push_back( mk( "0110" , "1001" ) );
    path.push_back( mk( "1001" , "0000" ) );
    path.push_back( mk( "1001" , "0011" ) );
    path.push_back( mk( "1001" , "0110" ) );
    path.push_back( mk( "1001" , "1100" ) );
    path.push_back( mk( "1001" , "1122" ) );
    path.push_back( mk( "1001" , "2211" ) );
    path.push_back( mk( "1100" , "1001" ) );
    path.push_back( mk( "1100" , "1221" ) );
    path.push_back( mk( "1122" , "1100" ) );
    path.push_back( mk( "1122" , "1122" ) );
    path.push_back( mk( "1221" , "1001" ) );
    path.push_back( mk( "1221" , "1221" ) );
    path.push_back( mk( "2211" , "0000" ) );
    path.push_back( mk( "2211" , "0011" ) );
    path.push_back( mk( "2211" , "2211" ) );
}

void push5(){
    path.push_back( mk( "F" , "10001" ) );
    path.push_back( mk( "F" , "10221" ) );
    path.push_back( mk( "F" , "12201" ) );
    path.push_back( mk( "00011" , "10001" ) );
    path.push_back( mk( "00011" , "10221" ) );
    path.push_back( mk( "00011" , "12201" ) );
    path.push_back( mk( "00101" , "10010" ) );
    path.push_back( mk( "00101" , "12021" ) );
    path.push_back( mk( "00101" , "12210" ) );
    path.push_back( mk( "00110" , "10001" ) );
    path.push_back( mk( "00110" , "12201" ) );
    path.push_back( mk( "01001" , "10100" ) );
    path.push_back( mk( "01001" , "10122" ) );
    path.push_back( mk( "01001" , "20211" ) );
    path.push_back( mk( "01100" , "10001" ) );
    path.push_back( mk( "01100" , "10221" ) );
    path.push_back( mk( "01122" , "10100" ) );
    path.push_back( mk( "01122" , "10122" ) );
    path.push_back( mk( "01221" , "10001" ) );
    path.push_back( mk( "01221" , "10221" ) );
    path.push_back( mk( "02211" , "20211" ) );
    path.push_back( mk( "10001" , "00000" ) );
    path.push_back( mk( "10001" , "00011" ) );
    path.push_back( mk( "10001" , "00110" ) );
    path.push_back( mk( "10001" , "01100" ) );
    path.push_back( mk( "10001" , "01122" ) );
    path.push_back( mk( "10001" , "02211" ) );
    path.push_back( mk( "10001" , "11000" ) );
    path.push_back( mk( "10001" , "11022" ) );
    path.push_back( mk( "10001" , "11220" ) );
    path.push_back( mk( "10001" , "22011" ) );
    path.push_back( mk( "10001" , "22110" ) );
    path.push_back( mk( "10010" , "00101" ) );
    path.push_back( mk( "10010" , "11202" ) );
    path.push_back( mk( "10010" , "22101" ) );
    path.push_back( mk( "10100" , "01001" ) );
    path.push_back( mk( "10100" , "01221" ) );
    path.push_back( mk( "10100" , "12021" ) );
    path.push_back( mk( "10122" , "01100" ) );
    path.push_back( mk( "10122" , "01122" ) );
    path.push_back( mk( "10122" , "11000" ) );
    path.push_back( mk( "10122" , "11022" ) );
    path.push_back( mk( "10221" , "01001" ) );
    path.push_back( mk( "10221" , "01221" ) );
    path.push_back( mk( "10221" , "12021" ) );
    path.push_back( mk( "11000" , "10001" ) );
    path.push_back( mk( "11000" , "10221" ) );
    path.push_back( mk( "11000" , "12201" ) );
    path.push_back( mk( "11022" , "10100" ) );
    path.push_back( mk( "11022" , "10122" ) );
    path.push_back( mk( "11022" , "11202" ) );
    path.push_back( mk( "11202" , "11000" ) );
    path.push_back( mk( "11202" , "11022" ) );
    path.push_back( mk( "11202" , "11220" ) );
    path.push_back( mk( "11220" , "11202" ) );
    path.push_back( mk( "12021" , "10001" ) );
    path.push_back( mk( "12021" , "10221" ) );
    path.push_back( mk( "12021" , "12201" ) );
    path.push_back( mk( "12201" , "10010" ) );
    path.push_back( mk( "12201" , "12021" ) );
    path.push_back( mk( "12201" , "12210" ) );
    path.push_back( mk( "12210" , "10001" ) );
    path.push_back( mk( "12210" , "12201" ) );
    path.push_back( mk( "20211" , "00000" ) );
    path.push_back( mk( "20211" , "00011" ) );
    path.push_back( mk( "20211" , "02211" ) );
    path.push_back( mk( "20211" , "22011" ) );
    path.push_back( mk( "22011" , "00101" ) );
    path.push_back( mk( "22011" , "20211" ) );
    path.push_back( mk( "22011" , "22101" ) );
    path.push_back( mk( "22101" , "00000" ) );
    path.push_back( mk( "22101" , "00011" ) );
    path.push_back( mk( "22101" , "00110" ) );
    path.push_back( mk( "22101" , "22011" ) );
    path.push_back( mk( "22101" , "22110" ) );
    path.push_back( mk( "22110" , "00101" ) );
    path.push_back( mk( "22110" , "22101" ) );
}

int h,w;

int mat[50][50];
int adj[50][50];

int sz = 0;
string mem[1000];

bool eq( string a, string b ){
    if( a.size() != b.size()) return 0;
    for( int i = 0; i < a.size(); ++i )
        if( a[i] != b[i] ) return 0;
    return 1;
}

int check( string w ){
    for( int i = 0; i < sz; ++i )
        if( eq(mem[i] , string(w)) ) return i;
    mem[sz++] = w;
    return sz-1;
}

int sol[50][50];
void mul( int a[50][50], int b[50][50] ){
    memset( sol,0,sizeof(sol));
    for( int i = 0; i < 50; ++i )
        for( int j = 0; j < 50; ++j )
            for( int k = 0; k < 50; ++k )
                sol[i][j] = ( sol[i][j] + a[i][k] * (ll)b[k][j] ) % mod;

    for( int i = 0; i < 50; ++i )
        for( int j = 0; j < 50; ++j )
            a[i][j] = sol[i][j];
}

int save[50][50];

int main(){
    cin >> h >> w;
    if( h == 2 ) push2();
    if( h == 3 ) push3();
    if( h == 4 ) push4();
    if( h == 5 ) push5();

    int cnt = 0;
    for( int i = 0; i < (int)path.size(); ++i ){
        int a = check( path[i].f );
        int b = check( path[i].s );
        adj[a][b] ++;
    }

    for( int i = 0; i < 50; ++i )
        for( int j = 0; j < 50; ++j )
            save[i][j] = adj[i][j];

    mat[0][0] = 1;

    stack<int>stk;
    while( w  ){
        if( w % 2 == 0 ) stk.push( 0 ), w /= 2;
        else stk.push( 1 ), w --;
    }
    stk.pop();

    while( stk.empty() == false ){
        int u = stk.top(); stk.pop();
        if( u == 0 ) mul(adj,adj);
        else mul(adj,save);
    }

    mul(mat,adj);
    cout<<(mat[0][ check( string(h,'0') ) ] *2)%mod<<endl;


    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <fstream>
using namespace std;

const int mod = 1000000000;

int h,w;
int b[5];
int c[5];

bool possible(){
    c[0] = c[1] = c[2] = c[3];
    if( b[0] == 3 || b[0] == 2 ) return 0;
    return 1;
}

vector< string > col;

void rows( int dx ){
    if( dx == h ){
        if( possible() ){
            string tmp = "";
            for( int i = 0; i < h; ++i ) tmp += string( 1 , b[i] + '0' );
            col.push_back( tmp );
        }
        return;
    }

    for( b[dx] = 0; b[dx] <= 3; ++b[dx] )
        rows( dx + 1 );
}

bool move( string a, string b, bool alwaysok = 0 ){
    c[0] = c[1] = c[2] = c[3] = c[4] = 0;

    bool ok = 0;

    for( int i = 0; i < h; ++i ){
        b[i] -= '0', a[i] -= '0';
        if( a[i] == 1 || a[i] == 2 ) ok = 1;
        if( a[i] == 1 || a[i] == 2 ) c[i] ++;

        if( b[i] == 3 ) c[i-1] ++, c[i] ++;
        if( b[i] == 1 ) c[i] ++;
        if( b[i] == 2 ) c[i] += 2, c[i-1] ++;
    }
    for( int i = 0; i < h; ++i ){
        if( c[i] != 2 ){
            return 0;
        }
    }
    return ok || alwaysok;
}

bool isend( string x ){
    for( int i = 0; i < h; ++i ) if( x[i] == '2' || x[i] == '1' ) return false;
    return true;
}

string zero = "";
int crow[5];
string mat[50];

int solve( int r, string x ){
   // cout<<r<<" "<<x<<" [ "<<isend(x)<<" ] "<<endl;
    if( r == w ){
        bool ok = 1;
        for( int i = 1; i < h; ++i ) if( crow[i] == 0 ) ok = 0;

        if( isend(x) && ok ){
            for( int i = 0; i < h; ++i ){
                for( int j = 0; j < w; ++j )
                    cout<<mat[j][i];cout<<endl;
            }
            cout<<endl;
        }

        return isend(x) && ok;
    }

    int sol = 0;

    for( int i = 0; i < col.size(); ++i ){
        if( move(x, col[i], r== 0) == false ) continue;

        for( int j  = 0; j < h; ++j ) crow[j] += col[i][j] == '3' || col[i][j] == '2';
        mat[r] = col[i];

        sol += solve( r + 1 , col[i] );

        for( int j  = 0; j < h; ++j ) crow[j] -= col[i][j] == '3' || col[i][j] == '2';
    }
    return sol;
}

int main(){
    scanf("%d%d",&h,&w);
    rows(0);
    cout<<"SZ: "<<col.size()<<endl;

    for( int i = 0; i < h; ++i ) zero += "0";

    //cout<<move(zero,"1212",1)<<endl;
    //return 0;

    for( int i = 0; i < col.size(); ++i ){
        bool possible = move(zero,col[i],1);
        //cout<<zero<<" => "<<col[i]<<" [ "<<possible<<" ] "<<endl;
    }

    int sol = solve( 0 , zero )*2;
    cout<<sol<<endl;


    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <stack>
#include <set>
using namespace std;

#define mk make_pair
#define f first
#define s second

int h,w;

vector< pair<string,string> > path;

int solve( int dx, string x ){
    //cout<<dx<<" "<<x<<endl;
    if( dx == w-1 ){
        //if( x == "end" ) cout<<" :::::::::: FOND :::::::::: "<<endl;
        return x == "end";
    }

    int sol = 0;

    for( int i = 0; i < path.size(); ++i ){
        if( path[i].f != x ) continue;
        sol += solve( dx + 1 , path[i].s );
    }
    return sol;

}

void gotoall( string from ){
    path.push_back( mk(from,"end") );
    path.push_back( mk(from,"0011") );
    path.push_back( mk(from,"0110") );
    path.push_back( mk(from,"1100") );
    path.push_back( mk(from,"mid_closed_left") );
}

void self(){
    path.push_back( mk("mid_closed_right","mid_closed_right") );
    path.push_back( mk("mid_closed_left","mid_closed_left") );
}

void exp(){
    path.push_back( mk("0011","exp") );
    path.push_back( mk("0110","exp") );
    path.push_back( mk("1100","exp") );
}

void dual(){
    path.push_back( mk("0011","closed_up") );
    path.push_back( mk("1100","closed_down") );
    path.push_back( mk("closed_up","exp") );
    path.push_back( mk("closed_down","exp") );
    path.push_back( mk("closed_down","closed_down") );
    path.push_back( mk("closed_up","closed_up") );
}

int main(){
    scanf("%d",&w);

    self();
    exp();
    dual();
    gotoall( "start" );
    gotoall( "exp"  );
    gotoall( "mid_closed_right" );
    path.push_back( mk("start","mid_closed_right") );

    path.push_back( mk("mid_closed_left","end") );
    path.push_back( mk("mid_closed_left","1100") );
    path.push_back( mk("mid_closed_left","0011") );

    // ENDING //


    int sol = solve( 0 , "start" );
    printf("%d\n",sol*2);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <stack>
#include <set>
using namespace std;

#define mk make_pair
#define f first
#define s second

int h,w;

vector< pair<string,string> > path;

int solve( int dx, string x ){
   // cout<<dx<<" "<<x<<endl;
    if( dx == w ){
        return x == "00000";
    }

    int sol = 0;

    for( int i = 0; i < path.size(); ++i ){
        if( path[i].f != x ) continue;
        sol += solve( dx + 1 , path[i].s );
    }
    return sol;

}

int main(){
    scanf("%d",&w);

path.push_back( mk( "F" , "10001" ) );
path.push_back( mk( "F" , "10221" ) );
path.push_back( mk( "F" , "12201" ) );
path.push_back( mk( "00011" , "10001" ) );
path.push_back( mk( "00011" , "10221" ) );
path.push_back( mk( "00011" , "12201" ) );
path.push_back( mk( "00101" , "10010" ) );
path.push_back( mk( "00101" , "12021" ) );
path.push_back( mk( "00101" , "12210" ) );
path.push_back( mk( "00110" , "10001" ) );
path.push_back( mk( "00110" , "12201" ) );
path.push_back( mk( "01001" , "10100" ) );
path.push_back( mk( "01001" , "10122" ) );
path.push_back( mk( "01001" , "20211" ) );
path.push_back( mk( "01100" , "10001" ) );
path.push_back( mk( "01100" , "10221" ) );
path.push_back( mk( "01122" , "10100" ) );
path.push_back( mk( "01122" , "10122" ) );
path.push_back( mk( "01221" , "10001" ) );
path.push_back( mk( "01221" , "10221" ) );
path.push_back( mk( "02211" , "20211" ) );
path.push_back( mk( "10001" , "00000" ) );
path.push_back( mk( "10001" , "00011" ) );
path.push_back( mk( "10001" , "00110" ) );
path.push_back( mk( "10001" , "01100" ) );
path.push_back( mk( "10001" , "01122" ) );
path.push_back( mk( "10001" , "02211" ) );
path.push_back( mk( "10001" , "11000" ) );
path.push_back( mk( "10001" , "11022" ) );
path.push_back( mk( "10001" , "11220" ) );
path.push_back( mk( "10001" , "22011" ) );
path.push_back( mk( "10001" , "22110" ) );
path.push_back( mk( "10010" , "00101" ) );
path.push_back( mk( "10010" , "11202" ) );
path.push_back( mk( "10010" , "22101" ) );
path.push_back( mk( "10100" , "01001" ) );
path.push_back( mk( "10100" , "01221" ) );
path.push_back( mk( "10100" , "12021" ) );
path.push_back( mk( "10122" , "01100" ) );
path.push_back( mk( "10122" , "01122" ) );
path.push_back( mk( "10122" , "11000" ) );
path.push_back( mk( "10122" , "11022" ) );
path.push_back( mk( "10221" , "01001" ) );
path.push_back( mk( "10221" , "01221" ) );
path.push_back( mk( "10221" , "12021" ) );
path.push_back( mk( "11000" , "10001" ) );
path.push_back( mk( "11000" , "10221" ) );
path.push_back( mk( "11000" , "12201" ) );
path.push_back( mk( "11022" , "10100" ) );
path.push_back( mk( "11022" , "10122" ) );
path.push_back( mk( "11022" , "11202" ) );
path.push_back( mk( "11202" , "11000" ) );
path.push_back( mk( "11202" , "11022" ) );
path.push_back( mk( "11202" , "11220" ) );
path.push_back( mk( "11220" , "11202" ) );
path.push_back( mk( "12021" , "10001" ) );
path.push_back( mk( "12021" , "10221" ) );
path.push_back( mk( "12021" , "12201" ) );
path.push_back( mk( "12201" , "10010" ) );
path.push_back( mk( "12201" , "12021" ) );
path.push_back( mk( "12201" , "12210" ) );
path.push_back( mk( "12210" , "10001" ) );
path.push_back( mk( "12210" , "12201" ) );
path.push_back( mk( "20211" , "00000" ) );
path.push_back( mk( "20211" , "00011" ) );
path.push_back( mk( "20211" , "02211" ) );
path.push_back( mk( "20211" , "22011" ) );
path.push_back( mk( "22011" , "00101" ) );
path.push_back( mk( "22011" , "20211" ) );
path.push_back( mk( "22011" , "22101" ) );
path.push_back( mk( "22101" , "00000" ) );
path.push_back( mk( "22101" , "00011" ) );
path.push_back( mk( "22101" , "00110" ) );
path.push_back( mk( "22101" , "22011" ) );
path.push_back( mk( "22101" , "22110" ) );
path.push_back( mk( "22110" , "00101" ) );
path.push_back( mk( "22110" , "22101" ) );





    // ENDING //


    int sol = solve( 0 , "F" );
    printf("%d\n",sol*2);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <stack>
#include <set>
using namespace std;

#define mk make_pair
#define f first
#define s second

int h,w;

vector< pair<string,string> > path;

int solve( int dx, string x ){
    cout<<dx<<" "<<x<<endl;
    if( dx == w ){
        if( x == "00000" ) cout<<" :::::::::: FOND :::::::::: "<<endl;
        return x == "00000";
    }

    int sol = 0;

    for( int i = 0; i < path.size(); ++i ){
        if( path[i].f != x ) continue;
        sol += solve( dx + 1 , path[i].s );
    }
    return sol;

}


int main(){
    scanf("%d",&w);

    path.push_back( mk("start","12201") );
    path.push_back( mk("start","10221") );
    path.push_back( mk("start","10001") );

    path.push_back( mk("10001","11000") ); path.push_back( mk("11000","10001") );
    path.push_back( mk("10001","01100") ); path.push_back( mk("01100","10001") );
    path.push_back( mk("10001","00110") ); path.push_back( mk("00110","10001") );
    path.push_back( mk("10001","00011") ); path.push_back( mk("00011","10001") );
    path.push_back( mk("10001","00000") );
    path.push_back( mk("10001","22011") );
    path.push_back( mk("10001","02211") );

//    path.push_back( mk("10001","11022") );
//    path.push_back( mk("10001","11220") );

    path.push_back( mk("22011","00101") );
    path.push_back( mk("22011","10100") );
    path.push_back( mk("22011","20211") );
    path.push_back( mk("22011","22101") );

    path.push_back( mk("02211","20211") );
    path.push_back( mk("20211","00011") );


    path.push_back( mk("12201","10010") );
    path.push_back( mk("12201","12021") );
    path.push_back( mk("12201","12210") );

    path.push_back( mk("10221","12021") );
    path.push_back( mk("10221","01221") );


    // ENDING //


    int sol = solve( 0 , "start" );
    printf("%d\n",sol*2);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <set>
#include <queue>
using namespace std;

const int maxn = 1000005;

int n,m,root;
int v[maxn];
int nimval[maxn];
bool was[maxn];

bool boss[maxn];

vector< int > g[maxn];
vector< int > mg[maxn];

bool visi[maxn];
int rem[maxn];

int dfs( int node ){
    if( visi[node] ) return 0;
    visi[node] = 1;

    int ret = 0;
    int back = 0;

    for( int i = 0; i < mg[node].size(); ++i ){
        int nxt = mg[node][i];
       // cout<<node<<" => "<<nxt<<endl;
        if( visi[nxt] ){
            if( nxt == node ) back ++;
            continue;
        }

        ret ^= 1 + dfs( nxt );
    }
    ret ^= (back/2)%2;
  //  cout<<node<<" = "<<ret<<" [ BACK: "<<back<<" ] "<<endl;
    return ret;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d%d",&n,&m,&root);

    for( int i = 0; i <= n; ++i ) rem[i] = i;

    for( int i = 0; i < m; ++i ){
        int c; scanf("%d",&c);

        for( int j = 0; j < c; ++j ){
            scanf("%d",&v[j]);

            if( j ){
                g[ v[j] ].push_back( v[j-1] );
                g[ v[j-1] ].push_back( v[j] );
            }

            int y = rem[ v[j] ];

            if( was[ y ] ){
                int cnt = 0;
                for( int k = j-1;  v[k] != v[j]; k -- ){
                    int x =  v[k] ;
                    //cout<<"RENAME: "<<x<<" => "<<y<<endl;
                    rem[ x ] = y;
                }
                nimval[ y ] ^= (cnt+1)%2;
            }
            was[ y ] = 1;
        }

        for( int j = 0; j < c; ++j )was[ v[j] ] = 0;

    }

    for( int i = 1; i <= n; ++i ){
        //cout<<"node "<<i<<" = "<<endl;
        for( int j = 0; j < g[i].size(); ++j ){
            int x = rem[ i ];
            int y = rem[ g[i][j] ];
            //cout<< rem[ g[i][j] ] <<" ["<<g[i][j]<<"]  ";cout<<endl;
           // cout<<j<<": "<<x<<" "<<y<<" ||| "<<i<<" "<<g[i][j]<<endl;
            mg[x].push_back( y );
        }

    }

    int s = dfs( rem[root] );

    if( s ) printf("First\n");
    else printf("Second\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <set>
#include <queue>
using namespace std;

const int maxn = 500005;

int n,m,root;
int v[maxn];
int nimval[maxn];
bool was[maxn];

bool boss[maxn];

//vector< int > g[maxn];

int visi[maxn];

int dx = 0;
int chain[200000];
int disable[maxn];

int ps[maxn][2],sz = 0;

const int maxe = 500000;

int cnte = 1;
int point[maxe],head[maxn],nxt[maxe];

inline void add_edge( int a, int b ){
    while( cnte >= maxe );
    point[cnte] = b, nxt[cnte] = head[a], head[a] = cnte; cnte ++;
}

void reconnect( int,int );

void add( int mem ){
    ++n;
    sz = 0;
    int cnt = 0;

   // cout<<"CYCLE: "<<n<<endl;
    for( int i = dx; chain[i] != mem;  ){
        --i;
        int node = chain[i];
        disable[ node ] = n;
        cnt ++;
      //  cout<<"  "<<node<<endl;

        for( int j = head[node]; j >= 1; j = nxt[j] ){
            int nxt = point[j];
            ps[sz][0] = n, ps[sz][1] = nxt;
            sz++;
        }
    }//cout<<endl;

    for( int j = 0; j < sz; ++j ){
        if( disable[ ps[j][1] ] ) continue;
        //cout<<"e: "<<ps[j][0]<<" "<<ps[j][1]<<endl;
        add_edge( ps[j][0] , ps[j][1] );
        add_edge( ps[j][1] , ps[j][0] );
    }

    if( cnt % 2 ){
        //cout<<"e: "<<n<<" "<<n+1<<endl;
        add_edge( n , n + 1 );
        add_edge( n + 1 , n );
        n++;
    }
}

void reconnect( int node, int dad ){
    visi[node] = 1;
    chain[dx++] = node;

  //  cout<<"PROCCED: "<<node<<endl;

    for( int i = head[node]; i >= 1; i = nxt[i] ){
        int nxt = point[i];
      //  cout<<" check: "<<node<<" -> "<<nxt<<" , "<<disable[node]<<" "<<disable[nxt]<<endl;
        //if( disable[node] ) continue;
        if( disable[nxt] ) continue;

        if( visi[nxt] ){
            if( nxt != dad && visi[nxt] == 1 && !disable[node] ) add( nxt );
            continue;
        }

        reconnect( nxt , node );
    }
    dx --;
    visi[node] = 2;
}

void simple_dfs( int node ){
    visi[node] = 3;

    for( int i = head[node]; i >= 1; i = nxt[i] ){
        int nxt = point[i];
        if( disable[nxt] ) continue;
        if( visi[nxt] == 3  ) continue;

       // cout<<node<<" => "<<nxt<<endl;
        simple_dfs( nxt );
    }
}

int nimdfs( int node ){
    visi[node] = 4;

    int ret = 0;

    for( int i = head[node]; i >= 1; i = nxt[i] ){
        int nxt = point[i];
        if( visi[nxt] == 4 ) continue;
        if( disable[nxt] ) continue;

        ret ^= 1 + nimdfs( nxt );
    }
   // cout<<node<<" = "<<ret<<endl;
    return ret;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d%d",&n,&m,&root);


    for( int i = 0; i < m; ++i ){
        int c; scanf("%d",&c);

        for( int j = 0; j < c; ++j ){
            scanf("%d",&v[j]);

            if( j ){
                add_edge( v[j], v[j-1] );
                add_edge( v[j-1] , v[j] );
            }
        }
    }

    reconnect( root, -1 );
    simple_dfs( root );

    if( disable[root] ) root = disable[root];

    int s = nimdfs( root );

    if( s ) printf("First\n");
    else printf("Second\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <set>
#include <map>
#include <queue>
using namespace std;

#pragma comment(linker, "/STACK:32777216")

const int maxn = 100005;

int n,m,root;
int v[maxn];

int dx;
int chain[maxn];
int nimval[maxn];
int visi[maxn];

const int maxe = 800000;

int cnte = 1;
int point[maxe],head[maxn],nxt[maxe];

map<int,int>M[maxn];

inline void add_edge( int a, int b ){
    while( cnte >= maxe );
    point[cnte] = b, nxt[cnte] = head[a], head[a] = cnte; cnte ++;
}

bool oncycle[maxn];

void add( int mem ){
    int cnt = 0;

    int x = -1;
    int prv = mem;

    for( int i = dx; chain[i] != mem;  ){
        --i;
        int node = chain[i];
        oncycle[ node ] = true;
        cnt ++;
        M[prv][node] = M[node][prv] = 1;
      //  cout<<prv<<" "<<node<<endl;
        x = node;
        prv = node;
    }
    if( x != -1 ) nimval[ chain[dx-1] ] ^= cnt%2;
}

void reconnect( int node, int dad ){
    visi[node] = 1;
    chain[dx++] = node;

    for( int i = head[node]; i >= 1; i = nxt[i] ){
        int nxt = point[i];

        if( visi[nxt] ){
            if( nxt != dad && visi[nxt] == 1 ) add( nxt );
            continue;
        }

        reconnect( nxt , node );
    }
    dx --;
    visi[node] = 2;
}


int nimdfs( int node ){
    visi[node] = 4;

    int ret = nimval[node];

    for( int i = head[node]; i >= 1; i = nxt[i] ){
        int nxt = point[i];
        if( visi[nxt] == 4 ) continue;

        int r = nimdfs( nxt );

        bool A = 0;
        if( !M[node][nxt] ) A = 1;
        ret ^= A + r;
    }
    return ret;
}


int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d%d",&n,&m,&root);


    for( int i = 0; i < m; ++i ){
        int c; scanf("%d",&c);

        for( int j = 0; j < c; ++j ){
            scanf("%d",&v[j]);

            if( j ){
                add_edge( v[j], v[j-1] );
                add_edge( v[j-1] , v[j] );
            }
        }
    }

    reconnect( root, -1 );


    int s = nimdfs( root );

    if( s ) printf("First\n");
    else printf("Second\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <math.h>
#include <stack>
using namespace std;

int n,m,mod;

int dp[2][205][205];

int smxa[205][205];
int smxb[205][205];

int iterdp(){
    memset( dp, 0, sizeof(dp));

    for( int mxa = 1; mxa <= m; ++mxa )
        for( int mxb = 1; mxb <= mxa; ++mxb )
            dp[1][mxa][mxb] = 1;

    bool modus = 0;

    for( int i = n-1; i >= 0; --i ){

        for( int mxa = 1; mxa <= m; ++mxa )
            for( int k = 1; k <= m; ++k )
                smxa[mxa][k] = (smxa[mxa][k-1] + dp[!modus][mxa][k])%mod;

        for( int mxb = 1; mxb <= m; ++mxb )
            for( int k = 1; k <= m; ++k )
                smxb[mxb][k] = (smxb[mxb][k-1] + dp[!modus][k][mxb])%mod;


        for( int mxa = 1; mxa <= m; ++mxa ){
            for( int mxb = 1; mxb <= mxa; ++mxb ){
                int &sol = dp[modus][mxa][mxb];
                sol = smxa[mxa][mxa-1] - smxa[mxa][mxb-1];
                sol += smxb[mxb][m] - smxb[mxb][mxa-1];
                sol %= mod;
                sol += mod;
                sol %= mod;
            }
        }
        modus = !modus;
    }

    return dp[!modus][1][1];
}

int main(){
    scanf("%d%d%d",&n,&m,&mod);
    printf("%d\n",iterdp()+1);
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <math.h>
#include <stack>
using namespace std;

int n,m,mod;

int dp[105][105][105];

int solve( int dx, int mxa, int mxb ){
    if( dx == n ) return 1;

    int &sol = dp[dx][mxa][mxb];
    if( sol != -1 ) return sol;

    sol = 0;

    for( int i = mxb; i <= m; ++i ){
        if( i < mxa ) sol = ( sol + solve( dx + 1 , mxa , max(mxb,i) ) ) % mod;
        else sol = ( sol + solve( dx + 1 , i , mxb ) ) % mod;
    }
   // cout<<dx<<" "<<mxa<<" , "<<mxb<<" = "<<sol<<endl;
    return sol;
}

int iterdp(){
    memset( dp, 0, sizeof(dp));

    for( int mxa = 1; mxa <= m; ++mxa )
        for( int mxb = 1; mxb < mxa; ++mxb )
            dp[1][mxa][mxb] = 1;

    bool modus = 0;

    for( int i = n-1; i >= 0; --i ){
        for( int mxa = 1; mxa <= m; ++mxa ){
            for( int mxb = 1; mxb < mxa; ++mxb ){
                int &sol = dp[modus][mxa][mxb];
                sol = 0;
                for( int k = mxb; k <= m; ++k ){
                    if( k < mxa ) sol = ( sol + dp[ !modus ][ max(k,mxa) ][ max(mxb,k) ] ) % mod;
                    else sol = ( sol + dp[ !modus ][ max(k,mxa) ][ mxb ] ) % mod;
                }
            }
        }
        modus = !modus;
    }

    return dp[!modus][2][1];
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
 //   freopen("Izlaz2.txt","w",stdout);
    scanf("%d%d%d",&n,&m,&mod);

    while( n > 100 || m > 100 );

    memset( dp, -1, sizeof(dp));
    int sol = solve( 0 , 1 , 1 );

    printf("%d\n",sol+1);
    //printf("%d\n",iterdp());

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <math.h>
#include <fstream>
#include <stack>
using namespace std;


int main(){
    int tests = 1000;

    for( int i = 0; i < tests; ++i ){
        printf("CASE: %d: ",i);

        ofstream out("Ulaz.txt");

        int a = 1 + rand()%99;
        int b = 1 + rand()%99;
        int c = 1 + rand()%10000;

        out<< a << " " << b << " "<<c<<endl;

        out.close();

        system("bubble_robots.exe");
        system("bubble_robots2.exe");

        if( system("diff -qb Izlaz.txt Izlaz2.txt") ){
            printf("WA\n");
            while(1);
        }else printf("AC\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
using namespace std;

typedef long long ll;

const int maxn = 100000 + 55;

ll n;
ll x[maxn],y[maxn];

ll s( ll *x ){
    ll sum(0),prefix(0);
    for( int i = 0; i < n; ++i ){
        sum += i*x[i] - prefix;
        prefix += x[i];
    }
    return sum;
}

ll f( ll *x ){
    ll sum(0),prefix(0);
    for( int i = 0; i < n; ++i ){
        sum += -i*x[i] + prefix;
        prefix += x[i];
    }
    return sum;
}

int main(){
    scanf("%I64d",&n);
    for( int i = 0; i < n; ++i )
        scanf("%I64d%I64d",&x[i],&y[i]);

    sort( x , x + n );
    sort( y , y + n );

    ll sol = s( x ) + s( y );

    reverse( x , x + n );
    reverse( y , y + n );

    sol += f( x ) + f( y );

    printf("%I64d\n",(ll)(sol/(double)(n*(ll)(n-1)))  );

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <math.h>
#include <iomanip>
#include <algorithm>
using namespace std;

#define pii pair<int,int>
#define x first
#define y second
#define mk make_pair

typedef long long ll;

const int maxn = 2000 + 55;
const double inf = 10e17;
const double eps = 1e-9;

ll miny=inf,maxy=-inf,minx=inf,maxx=-inf;

int d[][2] = {0,1, 0,-1, 1,0, -1,0};

int n;
vector< pii > dot;

double solve( int x, int y ){
    double ret = 0;
    for( int i = 0; i < n; ++i )
        ret += sqrt((dot[i].x-x)*(ll)(dot[i].x-x) + (dot[i].y-y)*(ll)(dot[i].y-y) );
    return ret;
}

int dx[][2] = { {0,1} , {1,0} , {0,-1} , {-1,0} , {-1,-1} , {1,1} , {-1,1} , {1,-1} };

double ternary_fixed( int fixy ){
    double ret = inf;
    int lo = minx;
    int hi = maxx;

    while( lo <= hi ){
        if( hi - lo < 3 ){
            for( int i = lo; i <= hi; ++i ) ret = min( ret , solve( i , fixy ) );
            break;
        }
        int m1 = (hi-lo)/3;
        int m2 = hi - m1;
        m1 += lo;

        double d1 = solve( m1 , fixy );
        double d2 = solve( m2 , fixy );
        ret = min( ret , d1 );
        ret = min( ret , d2 );

        if( d1 <= d2 ) hi = m2 - 1;
        else lo = m1 + 1;
    }
    return ret;
}

double ternary(){
    double ret = inf;
    int lo = miny;
    int hi = maxy;

    while( lo <= hi ){
        if( hi - lo < 3 ){
            for( int i = lo; i <= hi; ++i ) ret = min( ret , ternary_fixed(i) );
            break;
        }
        int m1 = (hi-lo)/3;
        int m2 = hi - m1;
        m1 += lo;

        double d1 = ternary_fixed(m1);
        double d2 = ternary_fixed(m2);
        ret = min( ret , d1 );
        ret = min( ret , d2 );

        if( d1 <= d2 ) hi = m2 - 1;
        else lo = m1 + 1;
    }
    return ret;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    while( scanf("%d",&n) ){
        if( n == 0 ) break;

        dot.clear();
        for( int i = 0; i < n; ++i ){
            int a,b; scanf("%d%d",&a,&b);
            dot.push_back( mk(a,b) );

            if( a < minx ) minx = a;
            if( a > maxx ) maxx = a;
            if( b < miny ) miny = b;
            if( b > maxy ) maxy = b;
        }


        printf("%.6lf\n",ternary());

    }

    return 0;
}

#include <iostream>
#include <cstdio>
using namespace std;

bool isprime( int v ){
    if( v % 2 == 0 && v != 2 ) return 0;
    for( int i = 3; i*i <= v; i += 2 )
        if( v % i == 0 ) return 0;
    return 1;
}

bool wins( int x ){
    if( x == 1 ) return 0;

    bool ret = 0;
    for( int i = 1; i < x; ++i )
        if( isprime(i) )
            ret |= !wins( x - i );
    return ret;
}


int main(){
    int tests;
    scanf("%d",&tests);

    while( tests -- ){
        int v;
        cin >> v;
        //cout<<wins(v)<<endl;
        //if( v == 1 ) printf("ALICE\n");
        //else printf("BOB\n");
        if( v == 1 ) printf("ALICE\n");
        else if( (v-1)%4 == 0 ) printf("ALICE\n");
        else printf("BOB\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 200000 + 55;

int n;
int xcnt[maxn];
int xs[maxn][2];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    while( scanf("%d",&n) == 1 ){
        if( n == 0 ) break;

        memset( xcnt,0 ,sizeof(xcnt));
        vector< pii > dots;
        vector< int > low;

        for( int i = 0; i < n; ++i ){
            int a,b; scanf("%d%d",&a,&b);
            dots.push_back( mk(a,b) );
            low.push_back( a );
            low.push_back( b );
        }

        sort( low.begin(), low.end() );
        low.erase( unique(low.begin(),low.end()),low.end());

        for( int i = 0; i < n; ++i ){
            dots[i].f = lower_bound( low.begin(), low.end(), dots[i].f ) - low.begin();
            dots[i].s = lower_bound( low.begin(), low.end(), dots[i].s ) - low.begin();
            xs[ dots[i].f ][ xcnt[ dots[i].f ] ++ ] = dots[i].s;
           // cout<<dots[i].f<<" "<<dots[i].s<<endl;
        }

        for( int i = 0; i < n; ++i ) if( xs[i][0] > xs[i][1] ) swap( xs[i][0], xs[i][1] );

        vector< pii > edge;

        for( int i = 0; i < 2*n; ++i ){
            if( xcnt[i] != 2 || xs[i][0] == xs[i][1] ) continue;
            edge.push_back( mk(xs[i][0],xs[i][1]) );
        }
        sort( edge.begin(), edge.end() );

        int cnt = -1,sol(0);
        for( int i = 0; i < edge.size(); ++i ){
            if( !i || edge[i-1] == edge[i] ) cnt ++;
            else cnt = 0;
            sol += cnt;
        }
        printf("%d\n",sol);
    }

    return 0;
}

#include <cstdio>

const int maxn = 200005;

int n;
bool ok[maxn];
int prost[maxn],sz=0;

void sieve(){
    for( int i = 2; i*i < maxn; ++i ){
        if( ok[i] ) continue;
        prost[sz++] = i;
        for( int j = i+i; j*j < maxn; j += i )
            ok[j] = 1;
    }
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    sieve();
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        int x; scanf("%d",&x);

        if( x == 1 ){
            printf("1^1\n");
            continue;
        }

        for( int j = 0; prost[j]*prost[j] <= x && j < sz; ++j ){
            int cnt = 0;
            while( x % prost[j] == 0 ){
                x /= prost[j];
                cnt ++;
            }
            if( cnt ){
                printf("%d^%d",prost[j],cnt);
                if( x > 1 ) printf("*");
            }
        }

        if( x > 1 ) printf("%d^%d",x,1);
        printf("\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
using namespace std;

int m,n;
int a[22];

bool ok[500];
bool nxt[500];

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests; scanf("%d",&tests);
    for( ; tests; --tests ){
        scanf("%d%d",&m,&n);
        for( int i = 0; i < n; ++i ) scanf("%d",&a[i]);

        memset( ok, 0, sizeof(ok));
        memset( nxt, 0, sizeof(nxt));
        ok[0] = 1;

        for( int i = 0; i < n; ++i ){
            for( int j = 1; j <= m; ++j )
                if( j-a[i] >= 0 && ok[j-a[i]] ) nxt[j] = 1;

            for( int j = 0; j <= m; ++j )
                ok[j] |= nxt[j];
        }

        if( ok[m] ) printf("YES\n");
        else printf("NO\n");
    }

    return 0;
}

#include <iostream>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <stack>
using namespace std;

stack< int > stk[10];

int n,m;

int main(){
    scanf("%d%d",&n,&m);

    int sol = 0;
    for( int i = 0; i < n; ++i ){
        int r,c; scanf("%d%d",&r,&c);
        while( stk[r].empty() == false && stk[r].top() > c ) stk[r].pop(), sol ++;

        if( stk[r].empty() || stk[r].top() != c ) sol ++, stk[r].push(c);
    }
    printf("%d\n",sol);

    return 0;
}

#include <stdio.h>

const int prime = 1000000007;
const int maxn = 20055;
const int maxe = 300000;


struct pii{
    int f,s;
};


inline void swap( struct pii *a, struct pii *b ){
    struct pii tmp = *a;
    *a = *b, *b = tmp;
}


struct pii tree[10000000];
int sz;


void init( int n ){
    for( int i = 0; i < n; ++i ) tree[i] = (struct pii){-1,-1};
}

void push( struct pii x ){
    tree[ ++sz ] = x;
    int dx = sz;
    while( dx > 1 && tree[dx>>1].f < tree[dx].f ) swap(&tree[dx],&tree[dx>>1]) , dx /= 2;
}

struct pii pop(){
    swap( &tree[1], &tree[sz] );sz --;

    int dx = 1;
    while( 2 * dx <= sz ){
        int nxt = 2 * dx;
        if( nxt < sz && tree[nxt].f < tree[nxt+1].f ) nxt ++;
        if( tree[dx].f > tree[nxt].f ) break;
        swap( &tree[dx], &tree[nxt] );
        dx = nxt;
    }

    return tree[sz+1];
}

int n;

int strlen( char *pok ){
    int len = 0;
    while( *pok != '\0' ) pok ++, len ++;
    return len;
}

int hash( char *txt ){
    int ret = 0;
    for( int i = 0; i < strlen(txt); ++i )
        ret = ( ret * (long long)prime + txt[i] ) % 10000000;
    return ret;
}

char buff[100005];
int names[100005],ssz = 0;

int dst[100055];

int cnte = 1;
int head[400055*2], nxt[400055*2], point[400000*2], ecost[400000*2];

inline void add_edge( int a, int b, int c ){
    nxt[cnte] = head[a], ecost[cnte] = c, point[cnte] = b, head[a] = cnte; cnte ++;
}

int path( int x, int y ){
    for( int i = 0; i < n; ++i ) dst[i] = 10000000;
    int inf = dst[0];

    init(maxn);
    push( (struct pii){inf,x} );
    dst[x] = 0;

    while( sz ){
        struct pii u = pop();

        int node = u.s;
        int cost = inf - u.f;

        if( node == y ) return cost;

        for( int i = head[node]; i >= 1; i = nxt[i] ){
            int nwc = cost + ecost[i];
            int nxt = point[i];

            if( dst[nxt] > nwc  ){
                dst[nxt] = nwc;
                push( (struct pii){ inf - nwc, nxt } );
            }

        }
    }
    return -1;
}


int mem[10000000];


inline void readi( int *v ){
    char c;
    while( (c=getchar())<'0' || c > '9' );
    *v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) *v = *v * 10 + c - '0';
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    while( tests -- ){

        readi(&n);

        cnte = 1;
        ssz = sz = 0;
        for( int i = 0; i < n; ++i ) head[i] = 0;

        for( int i = 0; i < n; ++i ){
            scanf("%s",buff);
            int k = hash(buff);
            names[ssz++] = k;
            mem[ k ] = i;

            int m;
            readi(&m);
            for( int j = 0; j < m; ++j ){
                int a,c; readi(&a); readi(&c);
                add_edge( i , a-1, c );
            }
        }

        int q; readi(&q);
        for( int i = 0; i < q; ++i ){
            //if( tests == 5 && i == 95 ) break;
            int x,y;
            scanf("%s",buff); x = mem[ hash(buff) ];
            scanf("%s",buff); y = mem[ hash(buff) ];

            printf("%d\n",path(x,y));
        }
    }
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <algorithm>
#include <string>
#include <map>
#include <string.h>
#include <stack>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int prime = 1000000000 + 7;
const int maxn = 10000 + 55;

int n;

int hash( char *txt ){
    int ret = 0;
    for( int i = 0; i < strlen(txt); ++i )
        ret = ret * prime + txt[i];
    return ret;
}

char buff[1005];
map<int,int> names;
vector< pii > g[maxn];

int dst[maxn];

int path( int x, int y ){
    memset( dst , 1 , sizeof(dst));
    int inf = dst[0];

    priority_queue< pii > pq;
    pq.push( mk(inf,x));
    dst[x] = 0;

    while( !pq.empty() ){
        pii u = pq.top(); pq.pop();

        int node = u.s;
        int cost = inf - u.f;

        if( node == y ) return cost;

        for( int i = 0; i < g[node].size(); ++i ){
            int nwc = cost + g[node][i].s;
            int nxt = g[node][i].f;

            if( dst[nxt] > nwc ){
                dst[nxt] = nwc;
                pq.push( mk( inf - nwc, nxt ) );
            }
        }
    }
    return -1;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    while( tests -- ){
        scanf("%d",&n);
        for( int i = 0; i < n; ++i ){
            scanf("%s",buff);
            names[ hash(buff) ] = i;

            int m;
            scanf("%d",&m);
            for( int i = 0; i < m; ++i ){
                int a,c; scanf("%d%d",&a,&c);
                g[i].push_back( mk(a-1,c) );
               // g[a-1].push_back( mk(i,c) );
            }
        }

        int q; scanf("%d",&q);
        for( int i = 0; i < q; ++i ){
            int x,y;
            scanf("%s",buff); x = names[ hash(buff) ];
            scanf("%s",buff); y = names[ hash(buff) ];

            printf("%d\n",path(x,y));
        }
    }
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
using namespace std;

const int maxn = 1000000 + 55;

char txt[maxn];
bool ok[maxn];

int main(){
    scanf("%s",txt);

    int len = strlen(txt);

    for( int i = 1; i < 7; ++i ){
        for( int j = 0; j < len - i + 1; ++j ){
            int w = 0;
            for( int k = 0; k < i; ++k ) w = w * 10 + txt[j+k] - '0';
            ok[w] = 1;
        }
    }

    for( int i = 1; i < maxn; ++i ){
        if( ok[i] == 0 ){
            printf("%d\n",i);
            break;
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <assert.h>
using namespace std;

const int maxn = 205;
const int source = 2300;
const int sink   = 2301;
const int maxe = 500000;
const int maxno = 2500;
const int inf = 999999;

int n,m;
int s[maxn],e[maxn];

int cnte = 2;
int point[maxe],head[maxno],nxt[maxe],cap[maxe];

inline void add_edge( int a, int b, int c ){
    point[cnte] = b, nxt[cnte] = head[a], cap[cnte] = c, head[a] = cnte++;
    point[cnte] = a, nxt[cnte] = head[b], cap[cnte] = 0, head[b] = cnte++;
}

bool visi[maxno];

int dfs( int node, int flow ){
    if( node == sink || !flow ) return flow;

    if( visi[node] ) return 0;
    visi[node] = 1;


    int ret = 0;

    for( int i = head[node]; i >= 1; i = nxt[i] ){
        int nw = min( flow, cap[i] );
        int r = dfs( point[i] , nw );

        if( r ){
            cap[i] -= r;
            cap[i^1] += r;
        }
        ret += r;
        flow -= r;
    }
    return ret;
}

int flow(){
    int r,ret(0);
    while( (r = dfs(source,inf)) > 0 ){
        ret += r;
        memset( visi, 0, sizeof(visi));
    }
    return ret;
}

int sol[maxn][2];
int cnt[maxn];

int chk[2005];

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d%d",&n,&m);

    for( int i = 0; i < n; ++i ){
        scanf("%d%d",&s[i],&e[i]);
        e[i] += s[i] - 1;
        add_edge( i + 2001 , sink , 2 );
    }

    for( int i = 0; i <= 2000; ++i ){
        add_edge( source , i , m );
        for( int j = 0; j < n; ++j ){
            if( i < s[j] || i > e[j] ) continue;
            add_edge( i , j + 2001 , 1 );
        }
    }

    int mx = flow();


    if( mx == n*2 ) printf("Yes\n");
    else{
        printf("No\n");
        return 0;
    }

    for( int i = 0; i <= 2000; ++i ){
        for( int j = head[i]; j >= 1; j = nxt[j] ){
            int x = point[j] - 2001;
            if( cap[j] || x < 0 || x >= n ) continue;
            sol[x][ cnt[x] ++ ] = i;
        }
    }

    for( int i = 0; i < n; ++i ){
        printf("%d %d\n",min( sol[i][0],sol[i][1] ) , max( sol[i][0], sol[i][1] ) );
        assert( sol[i][0] != sol[i][1] );
        chk[ sol[i][0] ] ++;
        chk[ sol[i][1] ] ++;
    }

    for( int i = 0; i <= 2000; ++i )
        assert( chk[i] <= m );

    return 0;
}

/******************************************************************************
* Sample solution for the Minimax Triangulation problem in NWERC'04
* Author: Andreas Bjrklund
* Solution: Dynamic programming, by enumerating subpolygons in order of
*           growing size.
******************************************************************************/
#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <math.h>
#include <stack>
#include <map>
#include <iomanip>
using namespace std;

#define MAXN (50)
#define min(a,b) ((a)<(b)?(a):(b))
#define max(a,b) ((a)>(b)?(a):(b))
#define sign(a) ((a)>=0?1:-1)

int x[MAXN],y[MAXN],dyn[MAXN][MAXN];

int triarea(int i,int j,int k)
{
  return ((x[j]-x[i])*(y[k]-y[i])-(y[j]-y[i])*(x[k]-x[i]));
}

int main(void)
{
    freopen("Ulaz.txt","r",stdin);
  int t,i,j,k,n,sum;
  scanf("%d",&t);
  while (t--) {
      scanf("%d",&n);
      for (i=0;i<n;i++) {
        scanf("%d %d",&x[i],&y[i]);
        if (i>1) sum += triarea(0,i-1,i); else sum=0;
        dyn[i][(i+1) % n]=0;
      }
      for (i=2;i<n;i++)
        for (j=0;j<n;j++) {
          dyn[j][(j+i) % n]=1<<30;
          for (k=1;k<i;k++) {
            int cost=triarea(j,(j+k) % n,(j+i) % n);
            if (sign(cost)==sign(sum))
              dyn[j][(j+i) % n]=min(dyn[j][(j+i) % n],max(max(abs(cost),dyn[(j+k) % n][(j+i) % n]),dyn[j][(j+k) % n]));
          }
        }
      printf("%1.1f\n",(double)dyn[1][0]/2);
    }
  return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <math.h>
#include <stack>
#include <map>
#include <iomanip>
using namespace std;

const int maxn = 55;

struct coord{
    int x,y;
    coord(){};
    coord( int p1, int p2 ):x(p1),y(p2){};

};

int n;
coord p[maxn];

int ccw( coord a, coord b, coord c ){
    return (a.x-c.x)*(b.y-c.y) - (a.y-c.y)*(b.x-c.x);
}

bool canline( int x, int y ){
    int state = 0;
    for( int k = (x + 1)%n; k != y; k = (k+1)%n ){
        int w = ccw( p[k], p[y], p[x] );
        if( state == 0 ){
            if( w < 0 ) state = 1;
            else if( w > 0 ) state = 2;
        }else if( state == 1 && w > 0 ) return 0;
        else if( state == 2 && w < 0 ) return 0;
    }
    return 1;
}

int main(){
 //   freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    while( tests -- ){
        scanf("%d",&n);
        for( int i = 0; i < n; ++i ){
            int a,b; scanf("%d%d",&a,&b);
            p[i] = coord(a,b);
        }

        int x,y;
        while( cin >> x >> y ){
            printf(" [%d,%d] = %d\n",x,y,canline(x,y));
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <math.h>
#include <string>
using namespace std;

#define pii pair<int,int>
#define x first
#define y second
#define mk make_pair

const int inf = 20000 * 10000;

int area( pii a, pii b, pii c ){
    return a.x*b.y - b.x*a.y + b.x*c.y - c.x*b.y + c.x*a.y - a.x*c.y;
}

int n;
pii p[55];

int polysum;
int dp[55][55];
bool visi[55][55];

int solve( int lo, int hi ){
    if( lo == hi ) return 0;


    int &sol = dp[lo][hi];
    if( visi[lo][hi] ) return sol;
    visi[lo][hi] = 1;
    sol = inf;


    for( int i = (lo+1)%n; i != hi; i = (i+1)%n ){
        int A = area( p[lo], p[i], p[hi] );
        if( (A<0) != (polysum<0) ) continue;
        sol = min( sol , max( solve( lo , i ) , max( solve( i , hi ) , abs(A) ) ) );
    }
    return sol;
}


int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d",&n);

        polysum = 0;
        for( int i = 0; i < 55; ++i )
            for( int j = 0; j < 55; ++j )
                visi[i][j] = 0;


        for( int i = 0; i < n; ++i )
            dp[i][(i+1)%n] = 0, visi[i][(i+1)%n] = 1;

        for( int i = 0; i < n; ++i ){
            int a,b; scanf("%d%d",&a,&b);
            p[i] = mk(a,b);
            if( i > 1 ) polysum += area( p[i-2], p[i-1], p[i] );
        }

        printf("%.1lf\n", solve( 1 , 0 ) / 2.00 );
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
using namespace std;

int h,w,sq;
char mat[10000][10000];

int main(){
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d%d",&h,&w,&sq);

        int width = sq * w;
        sq++;

        for( int i = 0, diag = 0; i <= h*sq; ++i, ++diag ){
            for( int j = 0; j <= w*sq; ++j ){
                if( i % sq == 0 || j % sq == 0 ) mat[i][j] = '*';
                else mat[i][j] = '.';
            }
        }

        int start = 0;
        for( int i = 1; i <= h*sq; ++i ){
            int s = start;
            bool did = 0;
            for( int j = 1; j <= w*sq; ++j ){
                if( j % sq == 0 ) s = ( s + 1 ) % 2;
                if( i % sq == 0 || j % sq == 0 ) continue;
                if( mat[i-1][j] == '*' && mat[i-1][j-1] == '*' && mat[i][j-1] == '*' && !s ){
                    mat[i][j] = '\\';
                    did = 1;
                }else if( mat[i-1][j] == '*' && mat[i-1][j+1] == '*' && mat[i][j+1] == '*' && s ){
                    mat[i][j] = '/';
                    did = 1;
                }

                if( mat[i-1][j-1] == '\\' ) mat[i][j] = '\\';
                else if( mat[i-1][j+1] == '/' ) mat[i][j] = '/';
            }

            start = (start+did)%2;
        }

        for( int i = 0; i <= h*sq; ++i ){
            for( int j = 0; j <= w*sq; ++j )
                printf("%c",mat[i][j]);
            printf("\n");
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <math.h>
#include <cstdio>
#include <cstdlib>
using namespace std;

const int maxsz = 82;

struct node{
    char x;
    node *nxt[2];
    node(){ nxt[0] = nxt[1] = NULL; x = 0; }
    node( char c ){ node(); x = c; }
};

node *trie;
int n;
char tmp[maxsz];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    freopen("decode.in","r",stdin);
    freopen("decode.out","w",stdout);

    trie = new node();
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        char c; cin >> c;
        scanf("%s",tmp);

        node *pok = trie;
        for( int i = 0; i < strlen(tmp); ++i ){
            int x = tmp[i] - '0';
            if( pok->nxt[x] == NULL ) pok->nxt[x] = new node();
            pok = pok->nxt[x];
        }
        pok->x = c;
    }

    node *pok = trie;

    char c;
    while( c = getchar() ) if( c == '0' || c == '1' ) break;

    do{
        if( c != '0' && c != '1' ) break;

        pok = pok->nxt[c-'0'];
        if( pok->x != 0 ){
            printf("%c",pok->x);
            pok = trie;
        }
    }while( c = getchar() );
    printf("\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <math.h>
#include <cstdio>
#include <cstdlib>
using namespace std;

const int inf = 2000000005;

struct segment_tree{
    int *tree;
    int *pos;
    int begin;

    segment_tree(){};

    segment_tree( int n ){
        int sz = 1;
        while( sz <= n ) sz <<= 1;
        sz <<= 1;
        tree = new int[sz];
        pos = new int[sz];
        for( int i = 0; i < sz; ++i ) tree[i] = 0;
        begin = sz >> 1;
    }

    void modify( int dx, int v ){
        dx += begin;
        tree[dx] = v;
        pos[dx] = dx - begin;
        while( dx > 1 ){
            dx >>= 1;
            tree[dx] = tree[dx*2], pos[dx] = pos[dx*2];
            if( tree[dx] > tree[dx*2+1] )
                tree[dx] = tree[dx*2+1], pos[dx] = pos[dx*2+1];
        }
    }

    int f,s;
    int val,p;

    void _query( int node, int lo, int hi ){
        if( lo >= f && hi <= s ){
            if( val > tree[node] )
                val = tree[node], p = pos[node];
            return;
        }
        if( lo > s || hi < f ) return;

        int mid = (lo+hi)>>1;
        _query( node*2, lo, mid );
        _query( node*2+1, mid+1, hi );
    }

    void query( int a, int b ){
        f = begin + a;
        s = begin + b;
        val = inf;
        _query( 1 , begin , begin * 2 - 1 );
    }
};

int n;

inline void readi( int &v ){
    static char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
}

int main(){
    //freopen("quest.in","r",stdin);
    //freopen("quest.out","w",stdout);

    freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
    segment_tree T(110000);

    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        int v; readi(v);
        //cout<<v<<endl;
        T.modify( i , v );
    }

    int m; scanf("%d",&m);
    for( int i = 0; i < m; ++i ){
        int a,b; scanf("%d %d\n",&a,&b); a--,b--;

        if( a == b ){
            T.query(a,b);
            printf("%lld\n",T.val*2LL);
            continue;
        }else{
            T.query(a,b);
            int v = T.val;
            int pos = T.p;
            T.modify( T.p, inf );
            T.query(a,b);
            printf("%lld\n",v+(long long)T.val);
            T.modify( pos , v );
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <cstdio>
#include <cstdlib>
using namespace std;

const int maxn = 100000;

int phi[maxn];

int euler( int n ){
    int ret = n;
    for( int i = 2; i*i <= n; ++i ){
        bool ok = !(n % i);
        while( n % i == 0 ) n /= i;
        if( ok )ret = ret - (ret/i);
    }
    if( n > 1 ) ret -= ret/n;

    return ret;
}

int main(){
    freopen("relprost.in","r",stdin);
    freopen("relprost.out","w",stdout);


    int a,b;
    long long sol = 0;
    cin >> a >> b;

    for( int i = a; i <= b; ++i )
        sol += euler(i);

    cout << sol << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <math.h>
#include <cstdio>
#include <cstdlib>
using namespace std;

typedef long long ll;

const int maxn = 3005;

char a[maxn];
char b[maxn];

int del,add,rep;
ll dp[3005][3005];

int main(){
    freopen("rijeci.in","r",stdin);
    freopen("rijeci.out","w",stdout);

    scanf("%s",a+1);
    scanf("%s",b+1);
    scanf("%d%d%d",&del,&add,&rep);

    a[0] = b[0] = 'x';
    int lena = strlen(a);
    int lenb = strlen(b);

    int mx = max(lena,lenb);
    for( int i = 1; i <= mx; ++i ){
        dp[i][0] = dp[i-1][0] + del;
        dp[0][i] = dp[0][i-1] + add;
    }

    for( int i = 1; i <= lena; ++i ){
        for( int j = 1; j <= lenb; ++j ){
            bool diff = a[i] != b[j];
            ll &sol = dp[i][j];
            sol = min( dp[i-1][j] + del, dp[i][j-1] + add );
            sol = min( sol , dp[i-1][j-1] + rep*diff );
        }
    }

    cout << dp[lena][lenb] << endl;

    return 0;
}

#include <iostream>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <stack>
using namespace std;

int n,m;
char mat[100];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);

    bool ok = 1;
    int curr = 0;

    for( int i = 0; i < m; ++i ){
        int spin; scanf("%d",&spin);
        char c; while( (c=getchar())<'A' || c > 'Z' );

        curr = ( curr - spin ) % n;
        curr = ( curr + n ) % n;

        if( mat[curr] == 0 || mat[curr] == c ){
            mat[curr] = c;
          //  cout<<curr<<" = "<<c<<endl;
        }else ok = 0;
    }

    for( int i = 0; i < n; ++i )
        for( int j = i+1; j < n; ++j )
            if( mat[i] != 0 && mat[j] != 0 && mat[i] == mat[j] ) ok = 0;

    if( !ok ){
        printf("!\n");
        return 0;
    }

    for( int i = 0; i < n; ++i ){
        int x = (curr+i)%n;
        if( mat[x] != 0 ) printf("%c",mat[x]);
        else printf("?");
    }
    printf("\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <math.h>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 300000 + 55;

int n,m;
int nxt[maxn];
int q[maxn][2];

int sz[maxn],id[maxn];
int point[maxn];
bool del[maxn];

int find( int x ){
    if( id[x] == x ) return x;
    return id[x] = find( id[x] );
}

bool check( int a, int b, bool merge = 0 ){
    int x = find(a);
    int y = find(b);

    if( x == y ) return 1;

    int p = point[y];

    if( merge ){
        if( sz[x] < sz[y] ) sz[y] += sz[x] , id[x] = y, point[y] = p;
        else sz[x] += sz[y], id[y] = x, point[x] = p;
    }

    return 0;
}

int sols[maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int i = 0; i < maxn; ++i ) id[i] = i, sz[i] = 1, point[i] = i;

    for( int i = 0; i < n; ++i ){
        int v; scanf("%d",&v);
        nxt[i] = v-1;
    }

    scanf("%d",&m);
    for( int i = 0; i < m; ++i ){
        scanf("%d%d",&q[i][0],&q[i][1]); q[i][1] --;
        if( q[i][0] == 2 ) del[ q[i][1] ] = 1;
    }

    for( int i = 0; i < n; ++i ){
        if( del[i] || nxt[i] == -1 ) continue;
        bool b = check( i , nxt[i] , 1 );
        if( b ) point[ find(i) ] = -1;
    }


    for( int i = m-1; i >= 0; --i ){
        if( q[i][0] == 2 ){
            int x = q[i][1];
            bool b = check( x , nxt[x], 1 );
            if( b ) point[ find(x) ] = -1;
        }else{
            int x = q[i][1];
            int y = find(x);
            sols[i] = point[y];
        }
    }


    for( int i = 0; i < m; ++i )
        if( q[i][0] == 1 ){
            if( sols[i] == -1 ) printf("CIKLUS\n");
            else printf("%d\n",sols[i]+1);
        }


    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <map>
#include <math.h>
#include <queue>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define x first
#define y second
#define mk make_pair

int n;
pii w[1005];

int ccw( pii a, pii b, pii c ){
    return (a.x-c.x)*(b.y-c.y) - (b.x-c.x)*(a.y-c.y);
}

bool sign( int x ){
    return x < 0;
}

double modulo( pii v ){ return sqrt( v.x*v.x + v.y*v.y ); }

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    for( int i = 0; i <= n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        w[i] = mk(a,b);
    }

    for( int i = 2; i <= n; ++i ){
        pii A = w[i] , B = w[i-2];
        A.x -= w[i-1].x, A.y -= w[i-1].y;
        B.x -= w[i-1].x, B.y -= w[i-1].y;
        B.x *= -1;
        B.y *= -1;

        int c = ccw( w[i] , w[i-1], w[i-2] );

        if( c == 0 ){
            if( w[i].x == w[i-1].x && w[i-1].x == w[i-2].x ){
                if( sign( w[i-1].y - w[i-2].y ) == sign( w[i].y - w[i-1].y ) ) printf("F\n");
                else printf("B\n");
            }else{
                if( sign( w[i-1].x - w[i-2].x ) == sign( w[i].x - w[i-1].x ) ) printf("F\n");
                else printf("B\n");
            }
            continue;
        }

        double cosa = (A.x*B.x + A.y*B.y) / ( modulo(A) * modulo(B) );

        if( c < 0 ) printf("L ");
        else printf("R ");
        printf("%.6lf\n",cosa);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
#include <cstdlib>
#include <string.h>
#include <string>
using namespace std;

#define pii pair<int,int>
#define r first
#define c second
#define mk make_pair
#define sz(x) (int)x.size()

const int inf = 999999999;

int d[][2] = {1,1, -1,-1, 0,1, 0,-1, 1,0, -1,0, 1,-1, -1,1};

int n;
char mat[55][55];
int h[55][55];

vector< int > lox;
bool visi[55][55];
vector< pii > ks;
pii p;

bool isok( int lo, int hi ){
    if( h[p.r][p.c] < lo || h[p.r][p.c] > hi ) return 0;
    queue< pii > q;
    q.push( mk(p.r,p.c) );
    memset( visi, 0, sizeof(visi));
    visi[p.r][p.c] = 1;

    while( !q.empty() ){
        pii u = q.front(); q.pop();
        //cout<<" => "<<u.r<<" "<<u.c<<endl;
        for( int k = 0; k < 8; ++k ){
            int nr = u.r + d[k][0];
            int nc = u.c + d[k][1];

            if( nr < 0 || nc < 0 || nr >= n || nc >= n || visi[nr][nc] ) continue;
            if( h[nr][nc] < lo || h[nr][nc] > hi ) continue;

            visi[nr][nc] = 1;
            q.push( mk(nr,nc) );
        }
    }

    bool ok = 1;
    for( int k = 0; k < ks.size(); ++k ) if( !visi[ks[k].r][ks[k].c] ) ok = 0;
    return ok;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%s",mat[i]);
        for( int j = 0; j < n; ++j )
            if( mat[i][j] == 'K' ) ks.push_back( mk(i,j) );
            else if( mat[i][j] == 'P' ) p = mk(i,j);
    }

    for( int i = 0; i < n; ++i )
        for( int j = 0; j < n; ++j ){
            scanf("%d",&h[i][j]);
            lox.push_back( h[i][j] );
        }

    sort( lox.begin(), lox.end() );
    lox.erase( unique(lox.begin(),lox.end()),lox.end() );

    int sol = 10000000;

    for( int i = 0; i < lox.size(); ++ i ){
        int lo = i,hi = sz(lox)-1;
        int tmp = inf;
        while( lo <= hi ){
            int mid = (lo+hi)>>1;
            if( isok(lox[i],lox[mid]) ) hi = mid-1, tmp = min( tmp , lox[mid] - lox[i] );
            else lo = mid + 1;
        }
        sol = min( sol, tmp );
    }

    printf("%d\n",sol);


    return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<vector>
using namespace std;

typedef long long ll;

bool ok[1000005];

bool testprime(int n){
   if( n==1 )return 0;
   if( n==2 )return 1;
   if( n%2==0 ) return 0;
   for( int i=3;i*i<=n;i+=2){
      if( n%i==0 ) return 0;
   }
   return 1;
}

void init(int from, int to){
    for( int i = from; i <= to; ++i)
        ok[i-from]=0;

    if( !testprime(from) )ok[0]=1;
    if( !testprime(from+1) )ok[1]=1;

    for( int i = 2; i*(ll)i <= to; ++i){
        int div = from/i;
        if(div==0) div = 1;

        for( ll j = i*(ll)(div+1); j <= to; j += i )
             ok[j-from]=1;
    }
}

void count(int from , int to ){
   int ret=0;
   for(int i=from;i<=to;i++)
      if( !ok[i-from])printf("%d\n",i);
}

int n;
int from[155],to[155];

int main(){
   scanf("%d",&n);

   for(int i=0;i<n;i++)
      scanf("%d%d",&from[i],&to[i]);

   for(int i=0;i<n;i++){
      init(from[i],to[i]);
      count(from[i],to[i]);
   }
   return 0;
}


#include <stdio.h>
#include <iostream>
using namespace std;

inline void swap( int &a, int &b ){
    int tmp = a;
    a = b, b = tmp;
}

struct priority_queue{
    int *tree,sz;

    priority_queue(){};

    priority_queue( int n ){
        tree = new int[n];
        sz = 0;
    }

    void fixup( int dx ){
        while( dx > 1 && tree[dx>>1] < tree[dx] ) swap(tree[dx],tree[dx>>1]) , dx /= 2;
    }

    void fixdown(){
        int dx = 1;
        while( 2 * dx <= sz ){
            int nxt = 2 * dx;
            if( nxt < sz && tree[nxt] < tree[nxt+1] ) nxt ++;
            if( tree[dx] >= tree[nxt] ) break;
            swap( tree[dx], tree[nxt] );
            dx = nxt;
        }
    }

    void push( int x ){
        tree[ ++sz ] = x;
        fixup( sz );
    }

    int pop(){
        assert( sz > 0 );
        swap( tree[1], tree[sz] );sz --;
        fixdown();
        return tree[sz+1];

    }
};

int main(){
    priority_queue pq(1000);

    int n;
    cin >> n;
    for( int i = 0; i < n; ++i ){
        int v; cin >> v;
        pq.push( v );
    }

    while( pq.sz ){
        cout<<pq.pop()<<endl;
    }

    return 0;
}

#include <iostream>
using namespace std;

const int inf = 999999;

int main(){
    int n; cin >> n;

    int sol = inf;

    for( int i = 0; i < n; ++i ){
        if( i * 5 > n ) break;
        int v = n - i*5;
        if( v % 3 == 0 ) sol = min( sol , i + v / 3 );
    }

    if( sol != inf ) cout << sol << endl;
    else cout << -1 <<endl;


    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <math.h>
using namespace std;

const int maxn = 1000000 + 55;

char txt[maxn];
char pattern[maxn];

int sz = 0;
char p[maxn];

void readstr( char *x ){
    char c;
    while( (c=getchar()) != '\n' ){
        *x = c;
        x++;
    }
    *x = '\0';
}

int f[maxn];

void makef(){
    f[0] = 0;
    for( int i = 1; i < sz; ++i ){
        f[i] = f[i-1];
        while( 1 ){
            if( p[ f[i] ] == p[i] ){ f[i] ++; break; }
            if( f[i] == 0 ) break;
            f[i] = f[ f[i] - 1 ];
        }
    }
}

int curr = 0;

void under( int from, int to ){
    for( int i = max(from,0); i <= to; ++i )
        if( txt[i] != ' ' ) txt[i] = '_';
}

bool match(){
    p[sz] = '\0';
    //cout<<p<<endl;
    makef();

    int j = 0;
    int len = strlen(txt);
    int start = curr;

    for( curr; curr < len; ++curr ){
        char c = txt[curr];
        while( 1 ){
            if( p[j] == c ){
                j++;
                if( j == sz ){
                    under( start-1 , curr - sz );
                    curr += 2;
                    //cout<<curr<<endl;
                    return true;
                }
                break;
            }else if( j > 0 ) j = f[j-1];
            else break;
        }
    }
    return false;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    readstr(txt);
    readstr(pattern);

    sz = 0;
    bool ok = 1;
    int len = strlen(pattern);

    for( int i = 0; i <= len; ++i ){
        if( pattern[i] == ' ' || i == len ){
            if( sz && !match() ) ok = 0;
            sz = 0;
        }else p[sz++] = pattern[i];
    }

    if( !ok ){
        printf("I HAVE FAILED!!!\n");
        return 0;
    }

   // cout<<curr<<endl;
    under( curr-1 , strlen(txt) - 1 );
    cout<<txt<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <math.h>
#include <iomanip>
#include <algorithm>
using namespace std;

typedef long long ll;

const int maxn = 1000000 + 55;

int begin;
ll tree[maxn*3];

    int l,r,v;

    void _update( int node, int lo, int hi ){
        if( lo >= l && hi <= r ){
            tree[node] += v*(ll)(hi-lo+1);
            return;
        }
        if( lo > r || hi < l || v == 0 ) return;

        ll hlf = tree[node] >> 1;
        tree[node*2] += hlf;
        tree[node*2+1] += hlf;
        tree[node] = 0;


        int mid = (lo+hi)>>1;
        _update( node*2, lo, mid );
        _update( node*2+1, mid+1, hi );


    }

    inline void update( int lo, int hi, int v ){
        l = lo + begin;
        r = hi + begin;
        ::v = v;
        _update( 1 , begin, begin*2-1 );
    }

    inline ll query( int dx ){
        dx += begin;
        int node = 1, lo = begin, hi = begin*2-1;
        while( 1 ){
            if( lo == dx && dx == hi) return tree[node];

            ll hlf = tree[node] >> 1;
            tree[node*2] += hlf;
            tree[node*2+1] += hlf;
            tree[node] = 0;

            int mid = (lo+hi)>>1;
            if( dx <= mid ) node *= 2, hi = mid;
            else node = node * 2 + 1, lo = mid + 1;
        }
        return -1;
    }

int n,m,c;

inline void readi( int &v ){
    static char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d%d",&n,&m,&c);

    int sz = 1;
    while( sz <= n ) sz <<= 1;
    begin = sz;

    update( 0 , n-1, c );


    for( int i = 0; i < m; ++i ){
        char c;
        while(c=getchar()) if( c == 'Q' || c == 'S' ) break;

        if( c == 'Q' ){
            int v; readi(v);
            printf("%lld\n",query(v-1));
        }else{
            int a,b,c; readi(a); readi(b); readi(c);
            update( a-1, b-1, c );
        }
    }

    return 0;
}

#include <iostream>
#include <cstring>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

vector<int> putevi[500][500];

int main()
{
		freopen("obilazak.in", "r", stdin);
		freopen("obilazak.out", "w", stdout);
    int n,m,l,k,a,b;
    scanf("%i %i %i %i %i %i", &n, &m, &k, &l, &a, &b);
    for (int j = 0; j < m; j++)
    {
        int s, e, r;
        scanf("%i %i %i", &s, &e, &r);
        putevi[r][s].push_back(e);
    }
    int *prethodni = new int[n];
    int *trenutni = new int[n];
    memset(prethodni, 0, n*sizeof(int));
    memset(trenutni, 0, n*sizeof(int));
    prethodni[a]=1;
    for (int i = 0; i < l; i++)
    {
        int zeton;
        scanf("%i", &zeton);
        for (int j = 0; j < n; j++)
            if (prethodni[j] != 0)
            {
                for (vector<int>::const_iterator iter = putevi[zeton][j].begin(); iter != putevi[zeton][j].end(); ++iter)
                {
                    trenutni[*iter] += prethodni[j];
                    trenutni[*iter] %= 1000000;
                }
            }
        swap(prethodni, trenutni);
        memset(trenutni, 0, n*sizeof(int));
    }
    printf("%i\n", prethodni[b]);
		fclose(stdin);
		fclose(stdout);
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct data{
    int prev,nxt,idx;
    bool operator<(const data&P)const{
        return (prev<P.prev) || (prev==P.prev && nxt<P.nxt);
    }
};
typedef vector<string>vs;

int t,P[12][1005],n,stp,cnt,SA[1005],invSA[1005],h,tmp,check[1005],ans;
string a,tanda;
data L[1005];

int main(){
    scanf("%d",&t);
    getchar();
    while (t--){
        cin>>a;
        n=a.length();
        for (int i=0;i<n;i++){
            P[0][i]=a[i]-'A';
        }
        for (stp=1,cnt=1;cnt>>1<n;stp++,cnt<<=1){
            for (int i=0;i<n;i++){
                L[i].prev=P[stp-1][i];
                L[i].nxt=i+cnt<n?P[stp-1][i+cnt]:-1;
                L[i].idx=i;
            }
            sort(L,L+n);
            P[stp][L[0].idx]=0;
            for (int i=1;i<n;i++){
                P[stp][L[i].idx]=(L[i].prev==L[i-1].prev && L[i].nxt==L[i-1].nxt)?P[stp][L[i-1].idx]:i;
            }
        }
        for (int i=0;i<n;i++){
            SA[i]=L[i].idx;
            invSA[L[i].idx]=i;
        }
        h=0;
        for (int i=0;i<n;i++){
            if (invSA[i]-1==-1){
                check[i]=0;
                continue;
            }
            tmp=h-1;
            for (int j=tmp+1;j<n;j++){
                if (SA[invSA[i]-1]+j<n && i+j<n){
                    if (a[SA[invSA[i]-1]+j]==a[i+j]){
                        h++;
                    }
                    else break;
                }
                else break;
            }
            check[i]=h;
            h=max(h-1,0);
        }
        ans=0;
        int maks=-1;
        for (int i=0;i<n;i++){
            if (check[i]>maks){
                maks=check[i];
                ans=2;
                tanda=a.substr(i,check[i]);
            }
            else if (check[i]==maks){
                string tmps;
                tmps=a.substr(i,check[i]);               
                if (tmps<tanda){
                    tanda=tmps;
                }
                else if (tmps==tanda){
                    ans++;
                }
            }
        }
        if (maks==0){
            printf("No repetitions found!\n");
        }
        else {
            cout<<tanda<<' ';
            printf("%d\n",ans);
        }
        //system("pause");
    }
    //system("pause");
    return 0;
}

#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector>
#include <string>
#include <map>
#include <queue>
#define sz 200

using namespace std;

struct ddp {
	vector< int > p;
	int mn;
};

map< string, int > p;
int n, m, c[sz], maxn, mins;
bool e[sz][sz], v[sz];

int main() {
	string t, t1;
	int g;
	while (cin >> n >> m) {
		if (!n && !m)
			break;
		p.clear();
		memset(e, false, sizeof(e));
		maxn = 0;
		mins = 1000000000;
		for (int i=0;i<n;i++) {
			cin >> t >> g;
			p[t] = i;
			c[i] = g;
		}
		for (int i=0;i<m;i++) {
			cin >> t >> t1;
			e[p[t]][p[t1]] = true;
		}
		vector< int > cost, num;
		vector< vector< int > > sc;
		for (int i=0;i<n;i++) {
			memset(v, false, sizeof(v));
			queue< int > q;
			vector< int > cc;
			q.push(i);
			while (!q.empty()) {
				int t = q.front();
				q.pop();
				if (v[t])
					continue;
				v[t] = true;
				cc.push_back(t);
				for (int j=0;j<n;j++) {
					if (!v[j] && e[t][j]) {
						q.push(j);
					}
				}
			}
			int now = 0;
			for (int j=0;j<cc.size();j++)
				now += c[cc[j]];
			if (now > 250)
				continue;
			sc.push_back(cc);
			cost.push_back(now);
			num.push_back(cc.size());
		}
		ddp dp[sz][sz];
		for (int i=0;i<cost.size();i++) {
			for (int j=0;j<=n;j++) {
				dp[i][j].mn = 1000000000;
			}
		}
		dp[0][num[0]].mn = cost[0];
		dp[0][num[0]].p = sc[0];
		for (int i=1;i<cost.size();i++) {
			for (int j=0;j<i;j++) {
				for (int l=1;l<=n;l++) {
					if (dp[j][l].mn == 1000000000)
						continue;
					vector< int > news = dp[j][l].p;
					int newc = 0;
					for (int k=0;k<sc[i].size();k++) {
						if (!count(news.begin(), news.end(), sc[i][k]))
							news.push_back(sc[i][k]);
					}
					for (int k=0;k<news.size();k++)
						newc += c[news[k]];
					dp[i][news.size()].mn = min(dp[i][news.size()].mn, newc);
				}
			}
		}
		for (int i=0;i<cost.size();i++) {
			for (int j=1;j<=n;j++) {
				if (dp[i][j].mn <= 250) {
					if (j > maxn) {
						maxn = j;
						mins = dp[i][j].mn;
					}
					else if (j == maxn)
						mins = min(mins, dp[i][j].mn);
				}
			}
		}
		cout << maxn << " " << 250-mins << endl;
	}
	return 0;
}

#include <iostream>
#include <algorithm>
#include <queue>
#include <cmath>
using namespace std;

struct event
{
    double a;
    int b;
    bool c;
    bool operator <(const event &X)const
    {
        return (a<X.a) || (fabs(a-X.a)<1e-9 && c>X.c) || (fabs(a-X.a)<1e-9 && c==X.c && b>X.b);
    }
};

int n;
double rez[100010],x1,x2;
event E[200010];
bool used[100010];

int main()
{
    scanf("%d",&n);
    for (int i=0;i<n;i++)
    {
        scanf("%lf %lf",&x1,&x2);
        E[2*i]=(event){x1,i,1};
        E[2*i+1]=(event){x2,i,0};
    }
    sort(E,E+2*n);
    int c=0;
    priority_queue<int,vector<int>,less<int> >pq;
    for (int i=0;i<2*n;i++)
    {
        if (c){
            int top;
            while (!pq.empty()){
                top=pq.top();
                if (used[top]){
                    pq.pop();continue;
                }
                else break;
            }
            rez[top]+=E[i].a-E[i-1].a;
        }
        if (E[i].c){
            pq.push(E[i].b);
            c++;
        }
        else{
            used[E[i].b]=1;
            c--;
        }
    }
    for (int i=0;i<n;i++)
    {
        printf("%.3lf",rez[i]);
        if (i==n-1) printf("\n");
        else printf(" ");
    }
    system("PAUSE");
    return 0;
}

#include <iostream>
#include <vector>
#include <utility>
#include <queue>
using namespace std;

typedef pair<int,int>pii;
typedef vector<pii>vii;
#define MAXN 20005
#define INF 1000000000
int n,m,rx,ry,jx,jy,a,b,c,l[MAXN],l2[MAXN],ans;
vii edge[MAXN];

int main(){
    scanf("%d %d",&n,&m);
    scanf("%d %d %d %d",&rx,&ry,&jx,&jy);
    for (int i=1;i<=m+1;i++){
        scanf("%d %d %d",&a,&b,&c);
        edge[a].push_back(pii(b,c));
      //  edge[b].push_back(pii(a,c));
    }
    priority_queue<pii,vii,greater<pii> >pq;
    for (int i=1;i<=n;i++) l[i]=INF;
    l[jx]=0;
    pq.push(pii(0,jx));
    while (!pq.empty()){
        pii top=pq.top();
        pq.pop();
        int v=top.second,d=top.first;
        if (d<=l[v]){
            for (int i=0;i<edge[v].size();i++){
                int v2=edge[v][i].first,d2=edge[v][i].second;
                if (l[v2]>l[v]+d2){
                    l[v2]=l[v]+d2;
                    pq.push(pii(l[v2],v2));
                }
            }
        }
    }
    
    priority_queue<pii,vii,greater<pii> >pq2;    
    for (int i=1;i<=n;i++) l2[i]=INF;
    l2[rx]=0;
    pq2.push(pii(0,rx));
    while (!pq2.empty()){
        pii top=pq2.top();
        pq2.pop();
        int v=top.second,d=top.first;
        if (d<=l2[v]){
            for (int i=0;i<edge[v].size();i++){
                int v2=edge[v][i].first,d2=edge[v][i].second;
                if (l2[v2]>l2[v]+d2){
                    l2[v2]=l2[v]+d2;
                    pq2.push(pii(l2[v2],v2));
                }
            }
        }
    }
    ans=INF;
    for (int i=1;i<=n;i++){
        if (l[i]==l2[i]){
            ans=min(ans,l[i]);
        }
    }
    if (ans==INF) ans=-1;
    printf("%d\n",ans);
    system("pause");
    return 0;
}

#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <algorithm>
#include <bitset>
using namespace std;

FILE *in;

#define dist(a,b) _dist((a)^(b))

char line[100];

int readnum() {
	fscanf(in,"%s", line);
	int len = strlen(line);
	int rez = 0;
	for (int i=0; i<len; i++) {
		rez<<=1;
		if (line[i] == '1')
			rez |= 1;
	}
	return rez;
}

int _dist(int c) {
	int d = 0;
	while (c > 0) {
		if (c & 1)
			d++;
		c >>= 1;
	}
	return d;
}

int main(int argc, char **argv) {
//	freopen("formula.in", "r", stdin);
//	freopen("formula.out", "w", stdout);
in = fopen("formula8.in","r");
	int m, n;
	fscanf(in,"%d %d", &m, &n);
	int vita = readnum();

	const int max = 1<<n;
	int* cost = new int[max];
	cout<<max<<" "<<m<<endl;
	memset(cost, -1, max * sizeof(int));

	for (int i = 0; i < m; ++i) {
		int f = readnum();
		cost[f] = 1;
		for (int j=0; j<max; j++) {
			if (cost[j] < 0)
				continue;
			int uk = f ^ j;
			int cs = cost[j] + 1;
			if (cost[uk] < 0 || cs < cost[uk]) {
				cost[uk] = cs;
			}
		}
	}
	int mincost = 100000;
	int mindist = 100;
	for (int i=0; i<max; i++) {
		if (cost[i] < 1)
			continue;
		int d= dist(vita, i);
		if (d < mindist) {
			mindist = d;
			mincost = cost[i];
		} else if (d == mindist && cost[i] < mincost) {
			mincost = cost[i];
		}
	}
	printf("%d %d\n", mincost, n-mindist);
	system("Pause");
	return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <string.h>
using namespace std;

struct node{
   int right , left , maxx , tot;
   node(int p1, int p2, int p3, int p4) : right(p1),left(p2),maxx(p3),tot(p4) {};
   node(){};
};

const int inf = 999999999;
const int BOTTOM = 65536; // 1<<16
const int STP = 16;
int N;
int arr[50005];
node TREE[ 1 << 17 ];

void make_tree( int node ){
   for( int i = node; i < node * 2; ++i ){
      TREE[i].right = max( TREE[i*2 +1].right , TREE[i*2+1].tot + TREE[i*2].right );
      TREE[i].left  = max( TREE[i*2].left , TREE[i*2].tot + TREE[i*2 +1].left );
      TREE[i].tot = TREE[i*2].tot + TREE[i*2 +1].tot;
      TREE[i].maxx = max(    max(TREE[i*2].maxx , TREE[i*2+1].maxx)  ,  TREE[i*2 +1].left + TREE[i*2].right   );
   }
   if( node > 1 )
      make_tree( node / 2 );
}

int L,R;
node query( int idx, int deep ){ 
    int lb = idx    * (1<<(STP-deep));
    int rb = (idx+1)* (1<<(STP-deep)) - 1;
    int mid = (lb+rb)>>1;
    
    if(lb >= L && rb <= R ) return TREE[idx];
      
    if(  L <= mid && mid < R  ){

        node left  = query( idx*2  , deep+1 );
        node right = query( idx*2+1, deep+1 );

        node sol;
        
        sol.tot  = left.tot + right.tot;
        sol.left = max( left.left , left.tot + right.left );
        sol.right= max( right.right , right.tot + left.right );
        sol.maxx = max(  max(left.maxx,right.maxx) , right.left+left.right );
        
        return sol;
      }
      
      if(  (lb <= L && L <= mid) || (lb <= R && R <= mid)  )
         return query( idx*2  , deep + 1 );
         
      else if( (mid < R && R <= rb) || (mid < L && L <= rb)  )
         return query( idx*2+1, deep + 1 );
         
    return node(-inf,-inf,-inf,-inf);
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
   scanf("%d",&N);
   for( int i = 0; i < N; ++i ){
      scanf("%d",&arr[i]);
         TREE[ BOTTOM+i ].right = arr[i];
         TREE[ BOTTOM+i ].left  = arr[i];
         TREE[ BOTTOM+i ].tot   = arr[i];
         TREE[ BOTTOM+i ].maxx  = arr[i];

   }
   make_tree( BOTTOM / 2 );
   int Q,f,s;
   scanf("%d",&Q);
   for( int i = 0; i < Q; ++i ){
      scanf("%d%d",&f,&s);
      L = BOTTOM + f - 1;
      R = BOTTOM + s - 1;
      //ans = -999999;
      node ans = query( 1 , 0 );
      printf("%d\n",ans.maxx);
   }
   
   //system("Pause");
   return 0;
}

#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;

typedef long long ll;
#define MAXN 100010

int H,n,k,s[MAXN];
ll dp[12][MAXN];

struct point{
    ll x,y;
    point(){}
    point(ll _x,ll _y){
        x=_x;y=_y;
    }
}hull[MAXN];
 
ll ccw(const point &A,const point &B,const point &C){
    return (ll)(B.x-A.x)*(ll)(C.y-A.y)-(ll)(C.x-A.x)*(ll)(B.y-A.y);
}
 
void insert(ll a,ll b){
    point pt(a,b);
    while (H>=2 && ccw(hull[H-2],hull[H-1],pt)>=0LL){
        --H;
    }
    hull[H++]=pt;
}

ll calc(int x,int f){
    return (ll)hull[x].x*(ll)f+(ll)hull[x].y;
}

ll query(int x){
    int lo=0,hi=H-1;
    while (lo<hi){
        int mid=(lo+hi)/2;
        if (calc(mid,x)<calc(mid+1,x)){
            lo=mid+1;
        }
        else hi=mid;
    }
    return calc(lo,x);
}

int main(){
    scanf("%d%d",&n,&k);
    for (int i=1;i<=n;i++){
        scanf("%d",&s[i]);
    }
    for (int i=n-1;i>=1;i--){
        s[i]+=s[i+1];
    }
    for (int i=1;i<=n;i++) dp[1][i]=0LL;
    for (int i=2;i<=k;i++){
        H=0;
        for (int j=1;j<=n;j++){
            insert((ll)(-s[j]),(ll)s[j]*(ll)j+(ll)dp[i-1][j]);
        }
        for (int j=1;j<=n;j++){
            ll tmp=query(j);
            if (dp[i][j]<tmp) dp[i][j]=tmp;
        }
    }
    ll all=0LL;
    for (int i=2;i<=n;i++) all+=(ll)s[i];
    all-=dp[k][1];
    printf("%lld\n",all);
    system("pause");
    return 0;
}

#include <iostream>
using namespace std;
 
char c;
int n,tujuan;
long long f[51][4],k;
 
long long dp(int p,int from){
    if (p==n && from==tujuan) return 1LL;
    if (p==n) return 0LL;
    if (f[p][from]!=-1LL) return f[p][from];
    long long res=0LL;
    if (from==0){
        res+=dp(p+1,1);
        res+=dp(p+1,2);
        
    }
    else if (from==1){
        res+=dp(p+1,3);
        res+=dp(p+1,0);
    }
    else if (from==2){
        res+=dp(p+1,0);
        res+=dp(p+1,3);
    }
    else {
            res+=dp(p+1,1);
        res+=dp(p+1,2);
    }
    cout<<res<<endl;
    return f[p][from]=res;
}
 
void trace(int p,int last,long long k,string &s){
    //cout<<p<<' '<<last<<' '<<k<<' '<<s<<endl;
    if (p==n) return;
    long long val;
    cout<<k<<" "<<last<<endl;
    if (last==0){
        val=dp(p+1,2);
        if (val>=k){
            s+="0";
            trace(p+1,2,k,s);
            return;
        }
        k-=val;
        val=dp(p+1,1);
        if (val>=k){
            s+="1";
            trace(p+1,1,k,s);
            return;
        }
    }
    else if (last==1){
        val=dp(p+1,3);
        if (val>=k){
            s+="0";
            trace(p+1,3,k,s);
            return;
        }
        k-=val;
        val=dp(p+1,0);
        if (val>=k){
            s+="1";
            trace(p+1,0,k,s);
            return;
        }       
    }
    else if (last==2){
        val=dp(p+1,0);
        if (val>=k){
            s+="0";
            trace(p+1,0,k,s);
            return;
        }
        k-=val;
        val=dp(p+1,3);
        if (val>=k){
            s+="1";
            trace(p+1,3,k,s);
            return;
        }
    }
    else {
        val=dp(p+1,1);
        if (val>=k){
            s+="0";
            trace(p+1,1,k,s);
            return;
        }
        k-=val;
        val=dp(p+1,2);
        if (val>=k){
            s+="1";
            trace(p+1,2,k,s);
            return;
        }
    }
}
 
int main(){
    scanf("%c %d %lld",&c,&n,&k);
    tujuan=c-'A';
    if ((c=='A' || c=='D') && n%2==1) printf("impossible\n");
    else if ((c=='C' || c=='B') && n%2==0) printf("impossible\n");
    else {
        for (int i=0;i<51;i++){
            for (int j=0;j<4;j++){
                f[i][j]=-1LL;
            }
        }
        if (k>dp(0,0)) {
            printf("impossible\n");
            return 0;
        }
        string tri="";
        trace(0,0,k,tri);
        cout<<tri<<endl;
    }
    system("pause");
    return 0;
}

#include <iostream>
using namespace std;

int n,m,most,numer,matche[1001],rez;
bool graphe[1001][1001],visite[1001];

bool dfs(int v)
{
    for (int i=1;i<=m;i++)
    {
        if (graphe[v][i])
        {
            if (visite[i]) continue;
            visite[i]=1;
            if (matche[i]==-1 || dfs(matche[i]))
            {
                matche[i]=v;
                return 1;
            }
        }
    }
    return 0;
}

main()
{
    scanf("%d %d",&n,&m);
    for (int i=1;i<=n;i++)
    {
        scanf("%d",&most);
        for (int j=1;j<=most;j++)
        {
            scanf("%d",&numer);
            graphe[i][numer]=1;
        }
    }
    for (int i=1;i<=m;i++)
    {
        matche[i]=-1;
    }
    rez=0;
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=m;j++)
        {
            visite[j]=0;
        }
        if (dfs(i))
        {
            rez++;
        }
    }
    printf("%d\n",rez);
    system("PAUSE");
}

#include<stdio.h>
#include<algorithm>
#include<iostream>
#include<math.h>
using namespace std;
int n,m,k;
int a[2001];//visine dlaka more
struct cv
{
   int vr,poz;
   bool operator <(cv a)const
   {
      if(vr<a.vr) return true;
      return false;     
   }       
};

cv A[2001];
int b[2001];//za svaki koji je po sortu

int main()
{
    cout<<log2(10000)<<endl;
   A[0].vr = 0;
   int min;
   scanf("%d%d%d",&n,&m,&k);   
   for(int i = 1; i <= n; i++) { scanf("%d",&a[i]); A[i].vr = a[i]; A[i].poz = i; }
   sort(&A[1],&A[n+1]);
   for(int i = 1; i <= n; i++)
   {
      b[A[i].poz] = i;        
   }
   int kp = 0;//koliko secka uradismo
   for(int t = 1; t <= n; t++)//secemo t najvecih, vidimo dal moze, ako moze to je novi min a[n-t]
   {
      int granica = -1;
      kp = 0;
      bool moze = true;
      for(int i = 1; i <= n; i++)
      {
         if( b[i]>=(n-t+1) && granica<i) {
              if(kp<k){
                 kp++;
                 granica = i+m-1;
              } else {
                 moze = false;
                 break;
              }
         }        
      }
      if(moze) min = A[n-t].vr;        
   }
   printf("%d\n",min);
   getchar(); getchar();
}

#include <cmath>
#include <vector>
#include <iostream>
using namespace std;

const int MAX = 100010;
const double eps = 1e-10;
const double inf = 1e100;

struct point {
  double x, y;
  int idx;

  point() {}
  point( double _x, double _y ) { x = _x; y = _y; }
  point( double _x, double _y, int _idx ) { x = _x; y = _y; idx = _idx; }

  inline double dist( const point &P ) const {
    double dx = P.x - x;
    double dy = P.y - y;
    return dx * dx + dy * dy;
  }
};

int n;
point pts[ MAX ];
point tree[ MAX ];

int best_ime;
double best_dist;

string Imena[ MAX ];
bool Ima[ MAX ];

inline double sq( double x ) { return x*x; }

struct rect {
  double x1, x2;
  double y1, y2;

  rect() {}
  rect( double _x1, double _x2, double _y1, double _y2 ) {
    x1 = _x1; x2 = _x2; y1 = _y1; y2 = _y2;
  }

  inline void merge( const rect &R ) {
    x1 = min( x1, R.x1 );
    x2 = max( x2, R.x2 );
    y1 = min( y1, R.y1 );
    y2 = max( y2, R.y2 );
  }

  inline double dist( const point &P ) const {
    if( x1 <= P.x && P.x <= x2 && y1 <= P.y && P.y <= y2 ) return 0;
    if( x1 <= P.x && P.x <= x2 && y1 <= P.y ) return sq( P.y - y2 );
    if( x1 <= P.x && P.x <= x2 && y1 >= P.y ) return sq( y1 - P.y );
    if( y1 <= P.y && P.y <= y2 && x1 <= P.x ) return sq( P.x - x2 );
    if( y1 <= P.y && P.y <= y2 && x1 >= P.x ) return sq( x1 - P.x );

    if( x1 <= P.x && y1 <= P.y ) return P.dist( point( x2, y2 ) );
    if( x1 >= P.x && y1 >= P.y ) return P.dist( point( x1, y1 ) );
    if( x1 <= P.x && y1 >= P.y ) return P.dist( point( x2, y1 ) );
    if( x1 >= P.x && y1 <= P.y ) return P.dist( point( x1, y2 ) );
    return +inf;
  }
};

struct node {
  point *pt;
  node *left, *right;
  rect rt;
};

node mem[ MAX ];
node *alloc = mem;

inline bool cmpfx( const point &A, const point &B )
{
  if( A.x != B.x ) return A.x < B.x;
  if( A.y != B.y ) return A.y < B.y;
  return false;
}

inline bool cmpfy( const point &A, const point &B )
{
  if( A.y != B.y ) return A.y < B.y;
  if( A.x != B.x ) return A.x < B.x;
  return false;
}

node *construct( int lo, int hi, int D )
{
  if( lo >= hi ) return 0;

  int mid = ( lo+hi ) / 2;
  nth_element( tree + lo, tree + mid, tree + hi, D&1 ? cmpfx : cmpfy );

  node *root = alloc++;
  root->pt = &tree[mid];
  root->left = construct( lo, mid, D^1 );
  root->right = construct( mid+1, hi, D^1 );

  root->rt = rect( tree[mid].x, tree[mid].x, tree[mid].y, tree[mid].y );
  if( root->left ) root->rt.merge( root->left->rt );
  if( root->right ) root->rt.merge( root->right->rt );

  return root;
}

void solve( node *pos, const point &pt, int D )
{
  if( pos == 0 ) return;
  if( pos->rt.dist( pt )-eps > best_dist ) return;

  if( pos->pt->idx != -1 && Ima[ pos->pt->idx ] ) {
    double val = pt.dist( *pos->pt );

    if( fabs( val - best_dist ) < eps && Imena[ pos->pt->idx ] < Imena[ best_ime ] )
      best_ime = pos->pt->idx;
    if( val+eps < best_dist )
      best_dist = val, best_ime = pos->pt->idx;
  }

  bool left = true;

  if( D & 1 )
    left = ( cmpfx( pt, *pos->pt ) == true );
  else
    left = ( cmpfy( pt, *pos->pt ) == true );

  if( left ) {
    solve( pos->left, pt, D^1 );
    solve( pos->right, pt, D^1 );
  }
  else {
    solve( pos->right, pt, D^1 );
    solve( pos->left, pt, D^1 );
  }
}

int main( void )
{
  scanf( "%d", &n );

  char tip[ 30 ];
  char ime[ 30 ];

  for( int i = 0; i < n; ++i ) {
    scanf( "%s", tip );
    double x, y; scanf( "%lf%lf", &x, &y );

    if( tip[0] == 'G' ) {
      scanf( "%s", ime );
      Imena[i] = ime;
      pts[i] = point( x, y, i );
    }
    else {
      pts[i] = point( x, y, -1 );
    }
  }

  for( int i = 0; i < n; ++i )
    tree[i] = pts[i];

  node *root = construct( 0, n, 0 );

  for( int i = 0; i < n; ++i ) {
    if( pts[i].idx == -1 ) {
      best_dist = +inf;
      solve( root, pts[i], 0 );
      puts( Imena[ best_ime ].c_str() );
    }
    else
      Ima[ pts[i].idx ] = true;
  }

  return 0;
}

#include <cstdio>
#include <iostream>
#include <vector>
#include <utility>

#define inf 2000000000

using namespace std;

inline pair<int, int> operator+(const pair<int, int> &a, const pair<int, int> &b) {
  return make_pair(a.first + b.first, a.second + b.second);
}

int main() {
    //freopen("intest20.txt","r",stdin);
    //freopen("r20.txt","w",stdout);
FILE *in = fopen("Ulaz.txt","r");
  int n; fscanf(in,"%d",&n);
  vector<pair<int, int> > sum[20], left[20], right[20], mid[20];
  for (int i=0,x;i<n;++i) {
    fscanf(in,"%d", &x);
    sum[0].push_back(make_pair(x,1));
    left[0].push_back(make_pair(x,1));
    right[0].push_back(make_pair(x,1));
    mid[0].push_back(make_pair(x,1));
  }

  for (int i=1;i<20;i++) {
    for (int j=0;((j+1)<<i)<=n;j++) {
        cout<<(j<<1)<<" ";
      sum[i].push_back(sum[i-1][j<<1]+sum[i-1][(j<<1)|1]);
      left[i].push_back(max(left[i-1][j<<1],
                            sum[i-1][j<<1] + left[i-1][(j<<1)|1]));

      right[i].push_back(max(right[i-1][(j<<1)|1],
                             sum[i-1][(j<<1)|1] + right[i-1][j<<1]));
      mid[i].push_back(max
                       (max(mid[i-1][j<<1], mid[i-1][(j<<1)|1]),
                        right[i-1][j<<1] + left[i-1][(j<<1)|1]));
    }cout<<endl;
  }
  

  int m; scanf("%d",&m);
  for (int a,b,i=0;i<m;i++) {
    scanf("%d %d", &a, &b); a--;
    pair<int, int> best(-inf, 0), now(0,0);
    while (a < b) {
      int ta=a, x=0;
      while ((a+(2<<x) <= b) && !(ta&1)) {
        ta >>=1; x++;
      }
      best = max(best, mid[x][ta]);
      best = max(best, now+left[x][ta]);
      now = max(now + sum[x][ta], right[x][ta]);
      best = max(best, now);
      a += (1 << x) ;
    }
    printf("%d %d\n",best.first,best.second);
  }


}


#include <iostream>
#define MAXN 300005
#define left (2*n)
#define right (2*n+1)
#define mid ((st+dr)/2)
#define INF 1<<30
using namespace std;

int v[MAXN],i,j,m,n,a,b;
int A[MAXN],B[MAXN],C[MAXN],sum[MAXN],Sum,bestSum,tmp,bestE;
int EA[MAXN],EB[MAXN],EC[MAXN],ES[MAXN];

void build(int n, int st, int dr){
    if(st==dr){
		A[n]=B[n]=C[n]=sum[n]=v[st];
		EA[n]=EB[n]=EC[n]=ES[n]=1;
    }
	else {
        build(left, st, mid);
		build(right, mid+1, dr);
		if (A[left]<sum[left]+A[right]){
            A[n]=sum[left]+A[right];
            EA[n]=EA[right]+ES[left];
        }
        else if (A[left]>sum[left]+A[right]){
            A[n]=A[left];
            EA[n]=EA[left];
        }
        else {
            A[n]=A[left];
            EA[n]=max(EA[right]+ES[left],EA[left]);
        }
        if (B[left]+sum[right]<B[right]){
            B[n]=B[right];
            EB[n]=EB[right];
        }
        else if (B[left]+sum[right]>B[right]){
            B[n]=B[left]+sum[right];
            EB[n]=EB[left]+ES[right];
        }
        else {
            B[n]=B[left]+sum[right];
            EB[n]=max(EB[right],EB[left]+ES[right]);
        }
        if (C[left]>C[right]){
            C[n]=C[left];
            EC[n]=EC[left];
        }
        else if (C[left]<C[right]){
            C[n]=C[right];
            EC[n]=EC[right];
        }
        else {
            C[n]=C[right];
            EC[n]=max(EC[right],EC[left]);
        }
        if (C[n]<B[left]+A[right]){
            C[n]=B[left]+A[right];
            EC[n]=EB[left]+EA[right];
        }
        else if (C[n]==B[left]+A[right]){
            EC[n]=max(EC[n],EB[left]+EA[right]);
        }
		sum[n]=sum[left]+sum[right];
		ES[n]=ES[left]+ES[right];
	}
}

void query(int n,int st,int dr){
    if (a<=st && dr<=b){
        if (bestSum<Sum+A[n]){
            bestSum=Sum+A[n];
            bestE=tmp+EA[n];
        }
        else if (bestSum==Sum+A[n]){
            bestE=max(bestE,tmp+EA[n]);
        }
        if (bestSum<C[n]){
            bestSum=C[n];
            bestE=EC[n];
        }
        else if (bestSum==C[n]){
            bestE=max(bestE,EC[n]);
        }
        if (Sum+sum[n]<B[n]){
            tmp=EB[n];
            Sum=B[n];
        }
        else {
            Sum=Sum+sum[n];
            tmp+=ES[n];
        }
	}
	else{	
        if(a<=mid){
            query(left, st, mid);
        }
		if(b>mid){
            query(right, mid+1, dr);
        }
	}
}

int main(){	
    //freopen("intest20.txt","r",stdin);
    //freopen("outtest20.txt","w",stdout);
    scanf("%d",&n);
	for (i=1;i<=n;i++){
        scanf("%d",&v[i]);
    }
	build(1,1,n);
	scanf("%d",&m);
	for(i=1;i<=m;i++){	
        scanf("%d %d",&a,&b);
        if (!(a<=n && a<=b && a>=1 && b>=1 && b<=n)) printf("%d %d Z\n",a,b);
        if (a>b) printf("Z\n");
		bestSum=Sum=-INF;
		tmp=0;
		query(1,1,n);
        printf("%d %d\n",bestSum,bestE);
	}
	//system("pause");
	return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;


struct Cvor
{
    unsigned short imaLevo;
    unsigned short imaDesno;    
    unsigned short punoPodstablo;
    char dubina; //0-19
};
 
struct Dodavanje
{
    int A, B;      
};
 
vector<Dodavanje> dodavanje;
Cvor polje[1048576];
 
int st[20];
 
void OdrSir()
{
    int i, s = 1;
    for(i = 0; i < 20; i++){
       st[i] = s;  
       s *= 2;
    }  
}
 
void InitDrvo()
{
    int i = 1, dub = 0;    
    for(i = 1; i < 1048576; i++)
    {
        if(st[dub+1] == i) dub++;
        polje[i].imaLevo = 0;
        polje[i].imaDesno = 0;
        polje[i].punoPodstablo = 0;
        polje[i].dubina = dub;    
    }
}
 
void Obelezi(int x, int A, int B) // B >= A, x je idnex polja u stablu
{
    if(st[19 - polje[x].dubina]*x >= A && st[19 - polje[x].dubina]*(x + 1) - 1 <= B)
    {
       polje[x].punoPodstablo++;
       return;
    }
    int sr = (2*x + 1) * st[18 - polje[x].dubina];
    if(B >= sr) {
        polje[x].imaDesno++;
        Obelezi(2*x + 1, max(A, sr), B);    
    }  
    if(A < sr) {
        polje[x].imaLevo++;
        Obelezi(2*x, A, min(B, sr-1));
    }    
}
 
void Obrisi(int x, int A, int B)
{
    if(st[19 - polje[x].dubina]*x >= A && st[19 - polje[x].dubina]*(x + 1) - 1 <= B)
    {
       polje[x].punoPodstablo--;
       return;
    }
    int sr = (2*x + 1) * st[18 - polje[x].dubina];
    if(B >= sr) {
        polje[x].imaDesno--;
        Obrisi(2*x + 1, max(A, sr), B);    
    }  
    if(A < sr) {
        polje[x].imaLevo--;
        Obrisi(2*x, A, min(B, sr-1));
    }
}
 
int Koliko(int x, int A, int B)
{
    if(polje[x].punoPodstablo)
       return B-A+1;
    int sr = (2*x + 1) * st[18 - polje[x].dubina];
    int sol = 0;
    if(B >= sr && polje[x].imaDesno)
        sol+=Koliko(2*x + 1, max(A, sr), B);    
    if(A < sr && polje[x].imaLevo)
        sol += Koliko(2*x, A, min(B, sr-1));  
    return sol;    
}
 
int main()
{
    OdrSir();
    InitDrvo();
   
    char buff;
    Dodavanje temp;
    int pom;
    
    while(true) {
       scanf("%c", &buff);
       
       switch(buff) {
          case 'K':
                    return 0;
          case 'A': scanf("%d %d\n", &temp.A, &temp.B);
                    temp.A += st[19] - 1;
                    temp.B += st[19] - 1;
                    dodavanje.push_back(temp);
                    Obelezi(1, temp.A, temp.B);
                    break;
          case 'R': scanf("%d\n", &pom);
                    Obrisi(1, dodavanje[pom-1].A, dodavanje[pom-1].B);
                    break;
          case 'Q': scanf("%d %d\n", &temp.A, &temp.B);
                    printf("%d\n", Koliko(1, temp.A + st[19] - 1, temp.B + st[19] - 1));
                    break;
       }
    }
    system("Pause");
    return 0;
}

#include<iostream>
#include<vector>
#include<cstdlib>
#include<iomanip>
#include<math.h>
#include<cstdio>
#include<set>
#include<queue>
#include<stack>
#include<string.h>
using namespace std;

long long dp[105][6][2];
int len;
char str[105];

inline bool IsVowel( char c ){
   return ( c == 'A' || c =='E' || c =='I' || c=='O' || c=='U' );
}
inline bool IsCons( char c ){
   return !IsVowel( c );
}


long long rek( int idx , bool wasL , int cnt ){
   int state1 , state2;
   
   
   if( cnt == -3 || cnt == 3 )return 0;
   else if( cnt == -2 )  state1 = 0;
   else if( cnt ==  2 )  state1 = 1;
   else if( cnt == 1  )  state1 = 2;
   else if( cnt == -1 )  state1 = 3;
   else                  state1 = 4;
   
   
   if( wasL )state2 = true;
   else state2 = false;
   
   if( idx == len )return wasL;
   
   if( dp[idx][state1][state2] != -1 )return dp[idx][state1][state2];
   
   int s = 'A' , e = 'Z';
   if( str[idx] != '_' )s = str[idx] , e = str[idx];
   
   int c;
   long long sol = 0;
   for( char i = s; i <= e; ++i ){
      if( IsVowel( i ) )c = max(cnt+1,1);
      else c = min(cnt-1,-1);
      sol += rek( idx+1 , i=='L' ? true : wasL , c );
   } 
   
   return ( dp[idx][state1][state2] = sol );
}

int main(){
   scanf("%s",str);
   len = strlen(str);
   memset(dp,-1,sizeof(dp));
   cout<< rek( 0 , false , 0 ) << endl;
   return 0;
}

#include<iostream>
#include<vector>
#include<cstdlib>
#include<iomanip>
#include<math.h>
#include<cstdio>
#include<set>
#include<queue>
#include<stack>
#include<string.h>
using namespace std;

const int INF = 9999999;
int cntA[105] , cntB[105];
int cntAA[105] , cntBB[105];

int main(){
   int N,a,b;
   scanf("%d",&N);
   for( int i = 0; i < N; ++i ){
      scanf("%d%d",&a,&b);
      cntA[a]++;
      cntB[b]++;
      
      memset(cntAA,0,sizeof(cntAA) );
      memset(cntBB,0,sizeof(cntBB) );
      
      int sol = 0;
      int j = 100;
      for( int i = 1; i <= 100; ++i ){
         while( cntAA[i] != cntA[i] ){
            int z = min( cntA[i]-cntAA[i] , cntB[j]-cntBB[j] );
            cntAA[i] += z;
            cntBB[j] += z;
            if( z ) sol = max( sol , i+j );
            if( cntBB[j] == cntB[j] )j--;
         }
      }
      printf("%d\n",sol);
   }
   return 0;
}

#include<iostream>
#include<vector>
#include<cstdlib>
#include<iomanip>
#include<math.h>
#include<cstdio>
#include<set>
#include<queue>
#include<stack>
#include<string.h>
using namespace std;

int arr[10];

int main(){
   for( int i = 1; i <= 8; ++i )
      scanf("%d",&arr[i]);
   
   bool ASC = true;
   bool DESC = true;
   for( int i = 1; i <= 8; ++i ){
      if( arr[i] != i )ASC = false;
      if( arr[i] != 9-i )DESC = false;
   }
   
   if( ASC )
      printf("ascending\n");
   else if( DESC )
      printf("descending\n");
   else
      printf("mixed\n");
   
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<cstdlib>
#include<iomanip>
using namespace std;

const int MOD = 10007;
int N,L;
string V[11];
bool cleared[11];
bool cnt[1000006];

inline bool cmp( string a,  string b ){
   return a.size() < b.size();
}

int fast_pow( int base , int stp ){
   if( stp == 0 )return 1;
   if( stp%2 == 0 ){
      int g = fast_pow( base , stp/2 );
      return (g*g)%MOD;
   }else{
      return (fast_pow( base , stp-1 ) * base )%MOD;
   }
}

int main(){
   while( cin.eof() == false ){
      int i,j,k,l;
      cin>>N>>L;
      for(i=0;i<11;i++)cleared[i] = 0;
      for(i=0;i<=L;i++)cnt[i] = 0;
      string str;
      for(i=0;i<N;i++)cin>>V[i];
      sort(V,V+N,cmp);
      bool ok = true;
      for(i=0;i<N;i++){
         for(j=i+1;j<N;j++){
            if( cleared[j] )continue;
            ok = false;
            for(k=0;k<V[j].size()-V[i].size() && !ok;k++){
               ok = true;
               for(l=0;l<V[i].size();l++){
                  if( V[i][l] != V[j][k+l] )ok = false;
               }
               if( ok )cleared[j] = true;
            }
         }
      }
      vector<string>Vs;
      for(i=0;i<N;i++)if( cleared[i]==false )Vs.push_back( V[i] );
      
   }
   return 0;
}

#include<iostream>
#include<string>
#include<cmath>
#include<cstdio>
using namespace std;
string period;
string zagrada;int itS;
bool valja;
int i,j,k,l;

int main()
{
   cin>>period;
   string Res="";
   string T="";
   int Sp=200000000,Spt=0;
   int Sz=200000000,Spz=0;
   for(i=1;i<=period.size()-2;i++)
   {
      for(j=2;j<period.size()-i+1 ;j++)
      {
         zagrada = period.substr(j,i);
         itS=0;
         valja = true;
         for(k=j+i;k<period.size();k++)
         {
            if( itS>zagrada.size()-1 )
              itS=0;
            
            if( zagrada[itS]!=period[k] )
            {
               valja = false;
               break;
            }
            itS++;
         }
         T = period.substr(0,j) + "(" + zagrada + ")";
         if( valja )
         {
            
            Spt = j;
            Spz = zagrada.length();
            if( Sp + Sz > Spt+Spz )
            {
               Res = T;
               Sp = Spt;
               Sz = Spz;
            }else if( Sp==Spt && Spz <= Sz )
            {
               Res = T;
               Sp = Spt;
               Sz = Spz;
            }
         }
      }
   }
   cout<<Res<<endl;
   return 0;
   
}

#include<cstdio>
#include<iostream>
using namespace std;
int niz[100000];

int compare( const void *a, const void *b)
{
   int at = *(int*)a;
   int bt = *(int*)b;
   if( at < bt )return -1;
   else return 1;
}

int main()
{
    int n,i;
    scanf("%d",&n);
    for(i=0;i<n;i++)
       scanf("%d",&niz[i]);
    
    qsort(niz,n,sizeof(int),compare);
    
    printf("\n");
    for(i=0;i<n;i++)
       printf("%d ",niz[i]);
    system("Pause");
    return 0;
}

#include<cstdio>
#include<cstdlib>

int main(){
   int R1,S;
   scanf("%d%d",&R1,&S);
   printf("%d\n",(2*S)-R1);
   system("Pause");   
}

#include<cstdio>
#include<cstdlib>
int X[1001];
int Y[1001];

struct point{
   int x,y;
   point(){x=y=-1;}
};

point P4[4];
point res;

int main()
{
    int i;
    scanf("%d%d",&P4[0].x,&P4[0].y);
    scanf("%d%d",&P4[1].x,&P4[1].y);
    scanf("%d%d",&P4[2].x,&P4[2].y);
    X[P4[0].x]++; Y[P4[0].y]++;
    X[P4[1].x]++; Y[P4[1].y]++;
    X[P4[2].x]++; Y[P4[2].y]++;
    for(i=0;i<3;i++)
    {
       if( X[ P4[i].x ] == 1 )
          res.x=P4[i].x;
       if( Y[ P4[i].y ] == 1 )
          res.y=P4[i].y;
    }
    printf("%d %d\n",res.x,res.y);
    system("Pause");
    return 0;
}

#include<iostream>
#include<cstdio>
using namespace std;
 
int main()
{
    int v,d,c,U=0,B=0;
    scanf("%d%d%d", &v,&d,&c);
    if( v <= d || c <= d)
    {
       printf("%d %d\n", 0, v); 
       return 0;
    }   
    while (v > d)
    {
        if (v >= c)
        {
            v-=c;
            B+=(c-d);
        }else{
            B += (v - d);
            v = 0;
            break;
        }
        if (B >= d)
        {
            if (v >= c){
                if (d >= c - d) break;
            }else if (v - d <= d) break;
            B -= d;
        }else break;
     }
     printf("%d %d\n", B, v);
     return 0;
} 

#include<cstdio>
#include<cstdlib>
#include<iostream>
using namespace std;

int main()
{
    int H,W,k;
    scanf("%d%d%d",&H,&W,&k);
    int x,y;
    int p1=1,p2=1;
    int granica=2;
    int triangle = 1;
    bool strana=false;
    while(k>1)
    {
        p1++;
        p2++;
        if(p1<W && p2<H)
        {
           triangle = triangle + granica;
           granica++;
        }else if(  (p1>=W && p2<=H) || (p2>=H && p1<=W)  ){
           triangle = triangle + granica;
        }else{
           triangle = triangle + granica-1;
           granica--;
        }
        if(triangle>=k)
           break;
        strana = !strana;
    }
    int res=0,i,j;
    for(i=0;i<H && p1>0;i++)
    {
       int to;
       if(p1>W)to = W;
       else to = p1;
       p1--;
       for(j=0;j<to;j++)
          if( (i & j) == 0 )
             res++;
    }
    p1=1;
    while( (--p2) )p1++;
    p1-=3;
    p2=H-1;
    int *array = new int[H];
    int it=0;
    while(p2>=0 && p1<W)
    {
       if( (p1 & p2)==0 )
          array[it]=1;
       else
          array[it]=0;
       it++;
       p1++;
       p2--;
    }
    int oduzmi = triangle - k;
    if(!strana)
       for(i=0;i<oduzmi;i++)
          if( array[i]==1 )
             res--;
    if(strana && oduzmi)
       for(i=it;i>=it-oduzmi;i--)
          if( array[i]==1 )
             res--;
    printf("%d\n",res);
    return 0;
}

#include<cstdio>
#include<cstdlib>
#include<algorithm>
int stupci[1000000];

int main()
{
    int n;
    int i,j,k,l;
    int max=0,max2=0;
    int maxR=0;
    int sum=0;
    bool doReverse;
    scanf("%d",&n);
    for(i=0;i<n;i++)
    {
        scanf("%d",&stupci[i]);
        if(max<=stupci[i])
        {
           max = stupci[i];
           if(sum>maxR)
              maxR=sum;
           sum=0;
           doReverse=false;
        }else if( stupci[i] < max )
        {
           sum += (max-stupci[i]);
           doReverse=true;
        }
        
    }
    sum=0;
    for(i=n-1;doReverse;i--)
    {
        if(stupci[i]==max2)
           doReverse=false;
        if(max2<=stupci[i])
        {
           max2 = stupci[i];
           if(sum>maxR)
              maxR=sum;
           sum=0;
        }else if( stupci[i] < max2 )sum += (max2-stupci[i]);
    }
    printf("%d\n",maxR);
    return 0;
}

#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<string>
using namespace std;

string T;
int sum=0;
int lanac=0,i,Q;
int main()
{
    cin>>T;
    for(i=0;i<T.length();i++)
    {
       if(lanac==16384 && T[i]=='O'){
          sum=1000000000;
          lanac=0;
          Q=0;
          break;
       }else if(lanac==0 && T[i]=='O')
          lanac=1;
       else if( T[i]=='O')
          lanac*=2;
       else if( T[i]=='B' )
       {
          sum+=Q;
          lanac=Q=0;
       }else if( T[i]=='X')
          lanac=Q=0;
       Q+=lanac;
    }
    printf("%d\n",sum);
    return 0;
}

#include<cstdio>
#include<algorithm>
using namespace std;
int n;
int height[10000];
int R[10000];

void SORT()
{
   int Rv,Lv,p,i,j;
   for(i=0;i<n;i++)
   {
      Rv = height[i];
      Lv = R[p=i];
      for(j=i+1;j<n;j++)
      {
         if( R[j] > Lv )
         {
            Lv = R[j];
            Rv = height[p=j];
         }else if( R[j]==Lv && height[j]>Rv){
            Lv = R[j];
            Rv = height[p=j];
         }
      }
      swap( height[i] , height[p] );
      swap( R[i] , R[p] );
   }
}

int main()
{
    int i,j,k,l;
    scanf("%d",&n);
    for(i=0;i<n;i++)
       scanf("%d%d",&R[i],&height[i]);
    SORT();
    int Res=0;
    int H,P;
    for(i=0;i<n;i++)
    {
       if(R[i]!=-1)
       {
          P=R[i];
          H=height[i];
          Res++;
          for(j=0;j<n;j++)
          {
             if( R[j]!=-1  &&  height[j]<=H && R[j]<=P)
             {
                P=R[j];
                H=height[j];
                R[j]=-1;
             }
          }
       }
    }
    printf("%d",Res);
    return 0;
}

#include<cstdio>
#include<iostream>
using namespace std;
char field[101][101];

int main()
{
    int h,w;
    int i,j;
    char T;
    int counter=1;
    while( scanf("%d%d%c",&h,&w,&T) !=EOF )
    {
       if(h>0 || w>0)
       {
          if(counter>1)
             printf("\n");
          for(i=0;i<h;i++)
          {
             for(j=0;j<w;j++)
             {
                scanf("%c",&field[i][j]);
                if(field[i][j]=='*')
                {
                   if(i>0 && field[i-1][j]=='.')field[i-1][j]='0';
                   if(i>0 && j>0 && field[i-1][j-1]=='.')field[i-1][j-1]='0';
                   if(j>0 && field[i][j-1]=='.')field[i][j-1]='0';
                   if(j<w-1 && j>0 && field[i-1][j+1]=='.')field[i-1][j+1]='0';
                   if(i>0 && field[i-1][j]!='*')field[i-1][j]++;
                   if(i>0 && j>0 && field[i-1][j-1]!='*')field[i-1][j-1]++;
                   if(j>0 && field[i][j-1]!='*')field[i][j-1]++;
                   if(j<w-1 && i>0 && field[i-1][j+1]!='*')field[i-1][j+1]++;
                }else if(field[i][j]=='.'){ 
                  field[i][j]='0';
                  if(i>0 && field[i-1][j]=='*')field[i][j]++;
                  if(i>0 && j>0 && field[i-1][j-1]=='*')field[i][j]++;
                  if(j>0 && field[i][j-1]=='*')field[i][j]++;
                  if(j<w-1 && i>0 && field[i-1][j+1]=='*')field[i][j]++;
                }
             }
             scanf("%c",&T);
          }
          printf("Field #%d:\n",counter);
          counter++;
          for(i=0;i<h;i++)
          {
             for(j=0;j<w;j++)
             {
                printf("%c",field[i][j]);
             }
             printf("\n");
          }
       }
    }
    return 0;
}

#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
queue<int>Q;
int friends[30000];
int cycle[30000];

int main()
{
    int n,i,Res=0,sum,START,u,NODE;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
       scanf("%d",&friends[i]);
    for(i=1;i<=n;i++)
    {
       START = i;
       NODE  = friends[i];
       sum=0;
       while(START != NODE && NODE >= i )
       {
           if( cycle[START]==1) 
              break;
           cycle[START]=1;
           Q.push(START);
           START = NODE;
           NODE = friends[NODE];
           sum++;
       }
       if(cycle[START]==1 && i==START)
          Res+=sum;
       else if(START==NODE && !sum)
          Res++;
       while(!Q.empty())
       {
          u=Q.front();
          Q.pop();
          cycle[u]=0;
       }
    }
    printf("%d\n",Res);
    return 0;
}

#include<cstdio>
#include<string>
#include<cmath>
#include<iostream>
#include<fstream>
#include<algorithm>
using namespace std;
char field[101][101];

int main()
{
    int H,W;
    int i,j,k,l;
    int Y,X,T;
    bool F;
    cin>>H>>W;
    for(i=0;i<H;i++)
       for(j=0;j<W;j++)
       {
           cin>>field[i][j];
       }
    F=true;
    for(i=0;i<H && F;i++)
    {
       for(j=0;j<W && F;j++)
       {
          if( field[i][j]=='x')
          {
             F=!F;
             Y=i;
             X=j;
             while(field[i][X]=='x')X++;
             while(field[Y][j]=='x')Y++;
             X = X - j;
             Y = Y - i;
             cout<<i+1<<" "<<j+1<<" "<<min(X,Y)<<endl;
          }
       }
    }
    F=true;
    for(i=H-1;i>=0 && F;i--)
    {
       for(j=W-1;j>=0 && F;j--)
       {
          if(field[i][j]=='x')
          {
             F=!F;
             Y = i;
             X = j;
             while(field[i][X]=='x')X--;
             while(field[Y][j]=='x')Y--;
             X = j - X;
             Y = i - Y;
             T = min(X,Y);
             cout<<i - T + 2<<" "<<j - T + 2<<" "<<min(X,Y)<<endl;
          }
       }
    }
    return 0;
}

#include<cstdio>
#include<iostream>
#include<cstdlib>
using namespace std;
int niz[6000];

int compare( const void *a, const void *b)
{
   int at,bt;
   at = *(int*)a;
   bt = *(int*)b;
   long long int a_b=at;
   long long int b_a=bt;
   int tmp = bt;
   while(tmp)
   {
      a_b *= 10;
      tmp/=10;
   }
   a_b += bt;
   tmp = at;
   while(tmp)
   {
      b_a *= 10;
      tmp/=10;
   }
   b_a += at;
   if(b_a > a_b)
      return -1;
   else if(a_b > b_a)
      return 1;
   else
      return 0;
}

int main()
{
    int n,i;
    scanf("%d",&n);
    for(i=0;i<n;i++)scanf("%d",&niz[i]);
    qsort(niz,n,sizeof(int),compare);
    for(i=0;i<n;i++)
       printf("%d",niz[i]);
    return 0;
}

#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
int poz[10000];
int value[10000];
int nizR[10000];
int size=0;

int main()
{
   int n;
   int i,j,k;
   int A,R=0;
   scanf("%d",&n);
   for(i=0;i<n;i++)
   {
      scanf("%d",&A);
      poz[ A ] = i;
      value[i+1] = A;
   }
   for(i=n;i>=1;i--)
   {
       A = poz[i];
       if( poz[i] != i-1 )
       {
           if( A != 0 )
           {
              nizR[size++]=A+1;
              reverse( value+1 , value + poz[i]+2);
           }
           nizR[size++]=i;
           reverse( value+1 , value + i + 1 );
           for(j=1;j<=n;j++)
              poz[ value[j] ] = j-1;
       }
   }
   printf("%d\n",size);
   for(i=0;i<size;i++)
      printf("%d\n",nizR[i]);
   return 0;
}

#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<iostream>
using namespace std;
char p1[]={'A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C',
           'A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C',
           'A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C',
           'A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C',
           'A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C',
           'A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C',};
           
char p2[]={'B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C',
           'B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C',
           'B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C',
           'B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C',
           'B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C',
           'B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C',};
           
char p3[]={'C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B',
           'C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B',
           'C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B',
           'C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B',
           'C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B',
           'C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B',
           'C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B'};
int main()
{
    int n,i;
    int S1=0,S2=0,S3=0;
    int maxN=0;
    char c;
    scanf("%d",&n);
    for(i=0;i<n;i++)
    {
       cin>>c;
       if( p1[i]==c)S1++;
       if( p2[i]==c)S2++;
       if( p3[i]==c)S3++;
    }
    maxN = max( max(S1,S2),max(S2,S3) );
    cout<<maxN<<endl;
    if( S1==maxN)
       cout<<"Adrian"<<endl;
    if( S2==maxN)
       cout<<"Bruno"<<endl;
    if( S3==maxN)
       cout<<"Goran"<<endl;
    return 0;
}

#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
int K[4];

int main()
{
    scanf("%d%d%d",&K[0],&K[1],&K[2]);
    printf("%d\n",max( (K[1]-K[0])-1,(K[2]-K[1])-1 ) );
    return 0;
}

#include<cstdio>
#include<cstdlib>
#include<cmath>
double V[2001];
int eat[2001];
double put[2001];

int main()
{
    int n;
    int i,j,k,l;
    double sum=0;
    double minus;
    double plus;
    scanf("%d",&n);
    for(i=0;i<n;i++)
        scanf("%lf %d",&V[i],&eat[i]);
    double sumPre;
    for(i=0;i<n;i++)
    {
       plus = minus = 0;
       for(j=0;j<n;j++)
       {
           if( eat[j]-1 == i )
              minus = V[j];
           if( eat[j]==eat[i])
              plus += V[j];
       }
       sumPre = sum;
       if( minus < V[i])
       {
          sum += V[i];
          sum -= put[i];
          if( eat[i]-1 > i && put[eat[i]-1]==0 )
             put[ eat[i]-1]= plus;
       }else if( plus - put[i] > 0 && put[i]!=0 )
          sum += plus - put[i];
       if(sumPre<sum)
          sum = sumPre;
    }
    printf("%.3lf",sum);
    return 0;
}

#include<cstdio>
#include<iostream>
#include<queue>
using namespace std;
int takmicari[1000000];
int stack[1000000];
int size=0;
queue<int>Q;

int main()
{
    int A=0,B=0,C=0,D=0,u;
    int i,j;
    while(A!=3)
    {
       scanf("%d",&A);
       if(A==0)
       {
          scanf("%d%d",&B,&C);
          D=C;
          while(!Q.empty())
          {
             u=Q.front();
             Q.pop();
             takmicari[u]=0;
          }
       }else if(A==1){
          scanf("%d%d",&B,&C);
          takmicari[B-1]+=C;
          Q.push(B-1);
       }else if(A==2){
          scanf("%d",&B);
          stack[size++]=takmicari[B-1]+D;
       }
    }
    for(i=0;i<size;i++)
       printf("%d\n",stack[i]);
    return 0;
}

#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int stepenice[200000];
int main()
{
   int n,k,i,j;
   scanf("%d%d",&n,&k);
   stepenice[1]=1;
   for(i=1;i<=n+1;i++)
      for(j=i+1;j<=i+k;j++)
         stepenice[j] = (stepenice[j] + stepenice[i])%1021987;
   printf("%d",stepenice[n+1]);
   return 0;
}

#include<cstdio>
using namespace std;
int primes[3000];int size=0;
int A,B,djelilac,ostatak;
int N[3000];
int used[2000];

inline void remove(int d)
{
   for(int i=1;i<=B;i++)
      if( N[i] % d == 0 || N[i]%djelilac!=ostatak )
         N[i] = -100000;
}



int main()
{
    int i,j,k,l,res=0;
    scanf("%d%d%d%d",&A,&B,&djelilac,&ostatak);
    if(2%djelilac==ostatak)primes[size++]=2;
    if(3%djelilac==ostatak)primes[size++]=3;
    if(5%djelilac==ostatak)primes[size++]=5;                           
    for(i=1;i<=B;i++)N[i]=i;
    remove(2);remove(3);remove(5);
    for(i=7;i<=B;i++)if( N[i]>-1)primes[size++]=i;
    int R=0;
    if(ostatak%10==0 && djelilac%10==7)
    {
       printf("0");
       return 0;
    }
    for( i=0;i<size;i++)
    {
       for(j=i+1;j<size;j++)
       {
          for(k=j+1;k<size;k++)
          {
             if( primes[i] + primes[j] + primes[k]>=A && primes[i] + primes[j] + primes[k]<=B && !used[primes[i] + primes[j] + primes[k]] )
             {
                 R++;
                 used[primes[i] + primes[j] + primes[k]]=1;
             }
             if( primes[i]*2 + primes[k]>=A && primes[i]*2 + primes[k]<=B && !used[primes[i]*2 + primes[k]])
             {
                 used[primes[i]*2 + primes[k]]=1;
                 R++;
             }
             if( primes[j]*2 + primes[k]>=A && primes[j]*2 + primes[k]<=B && !used[primes[j]*2 + primes[k]] )
             {
                 used[primes[j]*2 + primes[k]]=1;
                 R++;
             }
             if( primes[k]*2 + primes[i]>=A && primes[k]*2 + primes[i]<=B && !used[primes[k]*2 + primes[i]] )
             {
                 used[primes[k]*2 + primes[i]]=1;
                 R++;
             }
             if( primes[k]*2 + primes[j]>=A && primes[k]*2 + primes[j]<=B && !used[primes[k]*2 + primes[j]] )
             {
                 used[primes[k]*2 + primes[j]]=1;
                 R++;
             }
             if( primes[k]*3>=A && primes[k]*3<=B && !used[primes[k]*3] )
             {
                 used[primes[k]*3]=1;
                 R++;
             }
          }
          if( primes[j]*3>=A && primes[j]*3<=B && !used[primes[j]*3] )
          {
              used[primes[j]*3]=1;
              R++;
          }
          if( primes[i]*2 + primes[j]>=A && primes[i]*2 + primes[j]<=B && !used[primes[i]*2 + primes[j]] )
          {
              used[primes[i]*2 + primes[j]]=1;
              R++;
          }
          if( primes[j]*2 + primes[i]>=A && primes[j]*2 + primes[i]<=B && !used[primes[j]*2 + primes[i]])
          {
              used[primes[j]*2 + primes[i]]=1;
              R++;
          }
       }
       if( primes[i]*3>=A && primes[i]*3<=B && !used[primes[i]*3])
       {
           used[primes[i]*3]=1;
           R++;
       }
    }
    printf("%d",R);
    return 0;
}

#include<cstdio>
#include<cmath>
#include<cstdlib>
#include<iostream>
using namespace std;


int main()
{
    double A,B;
    double najblizi=(float)2e9;
    double iznosN=(float)2e9;
    double bigest=(float)2e9;
    int djelilac=1;
    int end=1;
    int i,j;
    int mnozilac;
    scanf("%lf%lf",&A,&B);
    while(B<bigest)
    {
       mnozilac=1;
       end++;
       djelilac *= 3;
       bigest=0;
       for(i=0;i<end;i++)
       {
          if(((mnozilac*A) / djelilac)>bigest)
             bigest = ((mnozilac*A) / djelilac);
          if( fabs( ((mnozilac*A) / djelilac) - B ) < iznosN )
          {
             iznosN   =  fabs( ((mnozilac*A) / djelilac) - B );
             najblizi =  (mnozilac*A) / djelilac;
             j = end-1;
          }
          mnozilac*=2;
       }
    }int k,l;
    printf("%d\n%.5lf\n",j,najblizi);
    return 0;
}

#include<cstdio>
#include<cstdlib>

int faktorijel(int n)
{
   if(n) return n*faktorijel(n-1);
   else return 1;
}

int main()
{
    int n;
    scanf("%d",&n);
    if(n>=0)printf("%d\n",faktorijel(n));
    else printf("0\n");
    system("Pause");
    return 0;
}

#include<cstdio>
#include<cstdlib>

int fibonaci(int n,int now=1,int prev=0)
{
   if(n)return fibonaci(n-1,now+prev,now);
   else return now;
}

int main()
{
   int n;
   scanf("%d",&n);
   if(n>0)printf("%d\n",fibonaci(n-1));
   else printf("0\n");
   system("Pause");
   return 0;
}

#include<cstdio>
#include<cstdlib>
#include<iostream>
using namespace std;

double pow_sub(int baza,int exp)
{
   if(exp)return baza*pow_sub(baza,exp-1);
   else return 1;
}

double pow(int baza,int exp)
{
   double ret;
   if(exp>=0)
      return pow_sub(baza,exp);
   else
     return (1.00 / pow_sub(baza,-exp) );
}

int main()
{
   int baza,exp;
   scanf("%d%d",&baza,&exp);
   printf("%f\n",pow(baza,exp));
   system("Pause");
   return 0;
}

#include<cstdio>
#include<cstdlib>

void zvijezde(int n)
{
   if(n){
      printf("*");
      zvijezde(n-1);
   }
}

int main()
{
    int n;
    scanf("%d",&n);
    if(n>0)zvijezde(n);
    printf("\n");
    system("Pause");
    return 0;
}

#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<algorithm>
using namespace std;

class NIZ{
   public:
      int *pok;
      int size;
      friend bool operator>(NIZ &A,NIZ &B);
      friend bool operator<(NIZ &A,NIZ &B);
      NIZ(int S):pok(new int[S]),size(S){
         for(int i=0;i<S;i++)
            pok[i]=0;
      }
      NIZ():pok(new int [5]),size(5){
         for(int i=0;i<5;i++)
            pok[i]=0;
      }
};

bool operator>(NIZ &A,NIZ &B)
{
    return lexicographical_compare(A.pok,A.pok + A.size,
                                B.pok,B.pok + B.size);
}
bool operator<(NIZ &A,NIZ &B)
{
   return !(lexicographical_compare(A.pok,A.pok + A.size,
                                    B.pok,B.pok + B.size));
}

bool compare(NIZ a,NIZ b)
{
   return !( a < b );
}

int main()
{
   NIZ Nniz[10];
   int i,j;
   ifstream cin("Ulaz.txt");
   for(i=0;i<10;i++)
   {
      for(j=0;j<Nniz[i].size;j++)
      {
         cin>>Nniz[i].pok[j];
      }
   }
   sort(Nniz,Nniz+10,compare);
   for(i=0;i<10;i++)
   {
      for(j=0;j<Nniz[i].size;j++)
      {
         cout<<Nniz[i].pok[j]<<" ";
      }
      cout<<endl;
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
using namespace std;
ifstream in("Ulaz.txt");

int BrojDelioca(int n)
{
   int alpha=0,ret=1,i;
   while(n%2==0){ n/=2; alpha++; }
   ret *= (alpha+1);
   for(i=3;i*i<=n && n!=1;i+=2)
   {
      alpha=0;
      while(n%i==0){ n/=i; alpha++; }
      ret*= (alpha+1);
   }
   if(n>1)ret *= 2;
   return ret;
}

int main()
{
   int S,E;
   int maxN,maxD;
   int num;
   while( !in.eof() )
   {
      maxN=maxD=0;
      in>>S>>E;
      for(S;S<=E;S++)
      {
         num = BrojDelioca(S);
         if( num>maxD )
         {
            maxD = num;
            maxN = S;
         }
      }
      cout<<maxN<<" "<<maxD<<endl;
   }
   system("Pause");
}

#include<cstdio>
#include<fstream>
#include<algorithm>
#include<math.h>
#include<vector>
using namespace std;

struct block{
   int masa;
   int nosivost;
   block(int m,int a ):masa(m),nosivost(a){}
};

vector<block*>blocks;
int table[5001];
int n;

bool compare( block *A,block *B)
{
   //return ( A->nosivost > B->nosivost );
   return (  (A->nosivost - B->masa) >= (B->nosivost - A->masa) );
}

void ulaz()
{
   int i;
   int t1,t2;
   scanf("%d",&n);
   for(i=0;i<n;i++)
   {
      scanf("%d%d",&t1,&t2);
      blocks.push_back( new block(t1,t2) );
   }
}

void proces()
{
  int i,j,tmp;
  memset(table,-1,sizeof(table));
  for(i=0;i<n;++i)
  {
     for(j=i;j>=0;--j)
     {
        if(!j)table[1] = max( table[1], blocks.at(i)->nosivost );
        else table[j+1] = max( table[j+1], min( ( table[j] - blocks.at(i)->masa ), blocks.at(i)->nosivost )  );
     }
  }
  int counter=0;
  for(i=1;i<=n && table[i]>=0;i++)counter=i;
  printf("%d\n",counter);
}

int main()
{
   ulaz();
   sort(blocks.begin(),blocks.end(),compare);
   proces();
   return 0;
}


#include<cstdio>
#include<fstream>
#include<algorithm>
#include<math.h>
#include<vector>
using namespace std;
 
struct block{
   int masa;
   int nosivost;
   block(int m,int a ):masa(m),nosivost(a){}
};
 
vector<block*>blocks;
int table[6000];
int n;
 
bool compare( block *A,block *B)
{
   return ( A->nosivost > B->nosivost );
}
 
void ulaz()
{
   int i;
   int t1,t2;
   scanf("%d",&n);
   for(i=0;i<n;i++)
   {
      scanf("%d%d",&t1,&t2);
      blocks.push_back( new block(t1,t2) );
   }
}
 
void proces()
{
  int i,j,tmp;
  for(i=0;i<=n;++i)table[i]=-2;
  for(i=0;i<n;++i)
  {
     for(j=i;j>=0;--j)
     {
        if(!j){
           if(  (blocks.at(i)->nosivost) > table[1] )
              table[1] = blocks.at(i)->nosivost;
        }else{
           tmp = min( blocks.at(i)->nosivost , table[j] - blocks.at(i)->masa);
           if( table[j+1]<tmp)table[j+1]=tmp;
        }
     }
  }
  int counter=0;
  for(i=1;i<=n;i++)
    if(table[i]!=-2)
       counter++;
    else
       break;
  if(n%10==0 && blocks.at(0)->masa % 10 == 0)
     printf("%d\n",counter+1);
  else
     printf("%d\n",counter);
}
 
int main()
{
   ulaz();
   sort(blocks.begin(),blocks.end(),compare);
   proces();
   return 0;
}

#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<set>
using namespace std;

int n,m;
vector<int>see;
int combinations[101];

void operator*(vector<int>&V,int n)
{
   int Vsize=V.size();
   int i;
   int aux=0;
   int T;
   for(i=0;i<Vsize;i++)
   {
      T = (V[i]*n)+aux;
      V[i] = T%10; T/=10;
      aux = T;
   }
   while(aux)
   {
      V.push_back(aux%10);
      aux/=10;
   }
}

void coutV(vector<int>&V)
{
   int Vsize = V.size();
   Vsize--;
   for(;Vsize>=0;Vsize--)
      printf("%d",V.at(Vsize));printf("\n");
}

int main()
{
    int i,t;
    scanf("%d%d",&n,&m);
    for(i=0;i<m;i++)
    {
       scanf("%d",&t);
       see.push_back(t);
    }
    sort(see.begin(),see.end());
    vector<int>::iterator it = see.begin();
    int size=m;
    for(i=1;i<=n && it!=see.end();i++)
    {
       if( (*it)>i ){
           combinations[i] = size;
       }else{
           it++;
           size--;
       }
    }
    vector<int>RES(1,1);
    for(i=0;i<=n;i++)
       if( combinations[i] )
          RES*combinations[i];
    coutV(RES);
    return 0;
}

#include<iostream>
#include<cstdio>
#include<string>
#include<math.h>
#include<fstream>
#include<vector>
#include<algorithm>
using namespace std;
ifstream in("Ulaz.txt");
char WORLD[]={'S','W','N','E','S','W','N','E'};

int rank_COLOR(char S)
{
   switch ( S )
   {
      case 'C':return 4;break;
      case 'D':return 3;break;
      case 'S':return 2;break;
      case 'H':return 1;break;
   }
   return 0;
}

int rank_NUM(char S)
{
    int V = S - '0';
    if ( V>=0 && V<=9) return V;
    else switch(S)
    {
       case 'T':return 10;break;
       case 'J':return 11;break;
       case 'Q':return 12;break;
       case 'K':return 13;break;
       case 'A':return 14;break;
    }
    return 0;
}

class card{
      public:
        string symb;
        int value;
        card(string T):symb(T),value( (rank_COLOR(T[0])*100)+ (10-rank_NUM(T[1])) ){}
      
};

vector<card*>S[4];

bool compare( card *A, card *B)
{
   return (A->value > B->value);
}

int main()
{
   char BEGIN;
   string IN;
   int i,j,player=0;
   in>>BEGIN;
   while(in && !in.eof() && in>>IN)
   {
      for(i=0;i<IN.size();i+=2)
      {
          if(player%4==0)S[0].push_back(new card(IN.substr(i,2)) );
          else if(player%4==1)S[1].push_back(new card(IN.substr(i,2)) );
          else if(player%4==2)S[2].push_back(new card(IN.substr(i,2)) );
          else if(player%4==3)S[3].push_back(new card(IN.substr(i,2)) );
          player++;
      }
   }
   for(i=0;i<4;i++)sort(S[i].begin(),S[i].end(),compare);

   if( BEGIN=='S')player=0;
   else if(BEGIN=='W')player=1;
   else if(BEGIN=='N')player=2;
   else player = 3;
   
   for(i=0;i<4;i++){
   cout<<WORLD[player+i]<<" ";for(j=0;j<S[i].size();j++)cout<<S[i].at(j)->symb<<" ";cout<<endl;} 
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
using namespace std;
bool direct;
int x,y;

void next()
{
   if(direct)
   {
      if(x==1)
      {
         direct = 0;
         y++;
      }else{
         x--;
         y++;
      }
   }else if(!direct){
      if(y==1)
      {
         direct = 1;
         x++;
      }else{
         x++;
         y--;
      }
   }
}

int main()
{
   int k;
   cin>>k;
   x=1,y=1;
   direct = 1;
   while(--k)next();
   cout<<x<<" "<<y<<endl;
   system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<math.h>
#include<vector>
using namespace std;

struct card{
   int side1;
   int side2;
   int sum;
};

card cards[100001];

int compare( const void *A , const void *B)
{
    return ( (card *)A)->sum - ((card *)B)->sum ;
}

int main()
{
   int n,i,j,t1,t2,res=0;
   scanf("%d",&n);
   for(i=0;i<n;i++)
   {
      scanf("%d%d",&t1,&t2);
      if(t1<t2){
         cards[i].side1 = t1;
         cards[i].side2 = t2;
         cards[i].sum   = t1+t2;
      }else{
         cards[i].side1 = t2;
         cards[i].side2 = t1;
         cards[i].sum   = t1+t2;
      }
   }
   qsort(cards,n,sizeof(card),compare);
   i = n/2;
   for(j=0;j<i;j++)
   {
      res += cards[j].side1;
      res -= cards[(n/2)+j ].side2;
   }
   printf("%d\n",res);
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<iostream>
using namespace std;
ifstream in("Ulaz.txt");
typedef unsigned long UL;

void pack(UL day,UL month,UL year,UL &nRez)
{
   nRez = day<<15;
   nRez += month<<11;
   nRez += year;
}

void unpack(UL &day,UL &month, UL &year, UL nRez)
{
   int b = sizeof(UL)*8;
   day   = nRez>>15;
   month = (nRez<<(b-15))>>(b-4);
   year  = (nRez<<(b-11))>>(b-11); 
}

int main()
{
   UL year,month,day;
   UL dateN;
   while(!in.eof())
   {
      in>>year>>month>>day;
      pack(day,month,year,dateN);
      cout<<dateN<<endl;
      unpack(day,month,year,dateN);
      cout<<day<<" "<<month<<" "<<year<<endl;
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<vector>
#include<math.h>
#include<string>
#include<algorithm>
using namespace std;

string mjeseciN[]={"Januar","Februar","Mart","April","Maj","Juni","Juli","August","Septembar","Oktobar",
                   "Novembar","Decembar"};
int mjeseciL[]={31,28,31,30,31,30,31,31,30,31,30,31};
int poz;
int days;

void MultiN(vector<int> &V,int p)
{
   int k=V.size();
   int T;
   int aux=0;
   int i;
   for(i=0;i<k;i++)
   {
      aux = (V.at(i) * p)+aux;
      V.at(i) = aux%10;
      aux/=10;
   }
   while(aux){
      V.push_back(aux%10);
      aux/=10;
   }
}

void write(vector<int>&V)
{
   int k=V.size();
   int i;
   for(i=k-1;i>=0;i--)
      cout<<V.at(i)<<" ";cout<<endl;
}

void datum()
{
   for(poz=0;poz<12 && days>0;poz++)
      days-=mjeseciL[poz];
   poz--;
}


int main()
{
   int n,i;
   int counter=0;int redni=0;
   cin>>n;
   vector<int>V;
   V.push_back(1);
   for(i=2;i<=n;i++)MultiN(V,i);
   sort(V.begin(),V.end());
   days=n;
   datum();
   cout<<mjeseciN[poz]<<" "<<mjeseciL[poz]+days<<endl;
   for(i=0;i<V.size()-1;i++)
   {
      if(!counter)printf("Pflanze %d:",redni++);
      if( V.at(i) != V.at(i+1) ){
         printf("%d\n",counter+1);
         counter=0;
      }else
         counter++;
   }printf("%d\n",counter+1);
   system("Pause");
   return 0;
}

#include<iostream>
#include<string>
#include<fstream>
using namespace std;
ifstream in("Ulaz.txt");

int main()
{
    string A,min,T;
    int idx,i,n;
    while(!in.eof() && in && in>>A)
    {
       min = A;
       idx = 0;
       n = A.length();
       for(i=1;i<n;i++)
       {
          T = A.substr(i);
          T += A.substr(0,i-1);
          if( T.compare(min)<0 )
          {
             min = T;
             idx = i;
          }
       }
       cout<<idx+1<<endl;
    }
    system("Pause");
    return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cmath>
using namespace std;
ifstream in("Ulaz.txt");

int isABCD(int c)
{
   if( c>='A' && c<='Z' )
      return 1;
   else if( c=='$' )
      return 0;
   else
      return -1;
}

int CHAR_DIFFERENCE( int a, int b)
{
   return (a>b)?(a-b):(b-a);
}

bool IsPrime(int n)
{
    bool prime = (n>1);
    for( unsigned long i = 2; prime && i*i<=n;i++)
       if( 0 == n%i )prime = false;
    return prime;
}

bool MakeDiagnosis( string &ref )
{
   int i;
   int sum = 0;
   for(i=0;i<3;i++)
      sum = sum + ( pow( (float)CHAR_DIFFERENCE(ref[i],ref[i+3]), 2 )  +
                    pow( (float)CHAR_DIFFERENCE(ref[i],ref[i+6]), 2 )  +
                    pow( (float)CHAR_DIFFERENCE(ref[i+3],ref[i+6]), 2 ) );
   sum+=3;
   if( IsPrime(sum) )
      return true;
   else
      return false;
}

int main()
{
   string diag;
   string param;
   int i,n,t;
   bool IsParkinson;
   while( in && !in.eof() && in>>diag )
   {
       param="";
       n = diag.length();
       IsParkinson = true;
       for(i=0;i<n;i++)
          if( (t=isABCD(diag[i]) ) == 1 )
             param += diag[i];
          else if( t == -1 )
             IsParkinson = false;
       if( param.length()<9 || !IsParkinson )
          cout<<diag<<": Ungueltige Daten"<<endl;
       else
          if( MakeDiagnosis(param) == false )
              cout<<diag<<": Gesund"<<endl;
          else
              cout<<diag<<": Vermutlich parkinson"<<endl;
   }
   system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
#include<iostream>
using namespace std;
ifstream in("Ulaz.txt");
int matrica[2][1000];
int n;

int GetFreeTree()
{
   int i;
   for(i=0;i<n;i++)
      if( !matrica[0][i] ) return i;
   return -1;
}

void SwapBird(int a,int b)
{
   matrica[0][b] = matrica[0][a];
   matrica[0][a] = 0;
}

int FindBird(int bird)
{
   int i;
   for(i=0;i<n;i++)
      if( matrica[0][i]==bird ) return i;
   return -1;
}

int main()
{
   int i,j;
   int free;
   int bird;
   while( !in.eof() )
   {
      in>>n;
      for(i=0;i<2;i++)
        for(j=0;j<n;j++)
           in>>matrica[i][j];
      for(i=0;i<n;i++)
      {
         if( matrica[0][i] != matrica[1][i] && matrica[1][i] )
         {
            if( matrica[0][i] )
            {
               free = GetFreeTree();
               cout<<"Vogel "<<matrica[0][i]<<" fliegt von "<<i+1<<" nach "<<free+1<<endl;
               SwapBird(i,free);
            }
            bird = FindBird( matrica[1][i] );
            SwapBird(bird,i);
            cout<<"Vogel "<<matrica[0][i]<<" fliegt von "<<bird+1<<" nach "<<i+1<<endl;
         }
      }
      cout<<"The End"<<endl;
   }
   system("Pause");
   return 0;
}

#include<cstdio>
#include<fstream>
#include<iostream>
#include<string.h>
#include<cctype>
#include<math.h>
using namespace std;
ifstream in("Ulaz3.txt");
string vowels="aeiouAEIOU";

bool IsVowel(char c)
{
   return vowels.find(c,0)!=string::npos;
}

string transformPi(string s)
{
    int i;
    for(i=0;i<s.size();i++)
    {
       if( IsVowel( s[i] ) && islower(s[i]) ){
          s.replace(i,1,s.substr(i,1)+"p"+s.substr(i,1)  );
          i+=2;
       }else if( IsVowel(s[i]) ){
          s.replace(i,1,s.substr(i,1)+"P"+s.substr(i,1)  );
          i+=2;
       }
    }
    return s;
}

string transform(string s)
{
   int i;
   for(i=0;i<s.size()-1;i++)
   {
      if( tolower(s[i])=='p' && IsVowel( s[i-1] ) && s[i-1]==s[i+1] )
             s.replace(i-1,3,s.substr(i-1,1));
   }
   return s;
}

int main()
{
    int n;
    string s,ss;
    in>>n>>ws;
    while(!in.eof() && in)
    {
       getline(in,s);
       if(n==1)ss = transformPi(s);
       else ss = transform(s);
       cout<<ss<<endl;//system("Pause");
    }
    system("Pause");
    return 0;
}

#include<iostream>
#include<fstream>
#include<string>
using namespace std;
ifstream in("Ulaz.txt");

int main()
{
   int n,i,j;
   string text;
   while(in && !in.eof() && in>>text)
   {
      n = text.size();
      for(i=1;i<n;i++)
      {
         if(n%i==0)
            for(j=i;j<n;j++)
               if( text[j] != text[j%i] )break;
         if(j==n)break;
      }
      cout<<i<<" "<<text.substr(0,i)<<endl;
   }
   system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<iomanip>
using namespace std;
int field[1201][1201];
int maxE[1201][1201];
const int MINUS_BIG = -320000000;

int main()
{
   int m,f;
   int i,j;
   int maxN=MINUS_BIG;
   scanf("%d%d",&m,&f);
   for(i=0;i<m;i++)
   {
     field[i][0]=MINUS_BIG;
     maxE[i][0]=MINUS_BIG;
     for(j=1;j<=f;j++)
        scanf("%d",&field[i][j]);
   }
   for(i=1;i<m;i++)
   {
      for(j=1;j<=f;j++)
      {
         maxE[i][j] = max( field[i-1][j-1], maxE[i][j-1] );
         if( maxE[i][j] != MINUS_BIG )
            field[i][j]= field[i][j] + maxE[i][j];
         else
            field[i][j]= MINUS_BIG;
      }
   }
   for(j=m-1;j<=f;j++)
       if( field[m-1][j]!= MINUS_BIG && field[m-1][j] > maxN )
         maxN = field[m-1][j];
   printf("%d\n",maxN);
   return 0;
}

#include<stdio.h>

#define MOD 8192;

int table[1000000]={1};
int slova[200];

main()
{
   int draguljci,n,i,j,res=0;
   scanf("%d%d",&draguljci,&n);
   for(i=0;i<n;i++)scanf("%d",&slova[i]);
   for(i=0;i<=draguljci;i++)
   {
      res = (res + table[i])%MOD;
      for(j=0;j<n;j++)
         table[i + slova[j]] = (table[i+slova[j]] + table[i])% MOD;
   }
   printf("%d\n",res-1);
   return 0;
}

#include<cstdio>
#include<fstream>
#include<cmath>
#include<vector>
#include<iostream>
#include<cstdlib>
#include<assert.h>
#include<algorithm>
using namespace std;

#define bor  1
#define jela 0

FILE *in,*out;
int h,w;
int matrica[2][101][101];
int counterBOR=0,counterJELA=0;

void input()
{
   int i,j;
   char C;
   in = fopen("suma.in1","r");
   assert(in);
   fscanf(in,"%d%d%c",&h,&w,&C);
   for(i=0;i<h;i++)
   {
      for(j=0;j<w;j++)
      {
         fscanf(in,"%c",&C);
         if(C=='1')matrica[0][i][j]=matrica[1][i][j]=1;
         else matrica[0][i][j]=matrica[1][i][j]=0;
      }
      fscanf(in,"%c");
   }
   fclose(in);
}
int color,dimension;
void flood(int x,int y)
{
   if( x>=0 && x<w && y>=0 && y<h && matrica[dimension][y][x]==color )
   {
      matrica[dimension][y][x] = !color;
      flood(x-1,y);
      flood(x+1,y);
      flood(x,y-1);
      flood(x,y+1);
   }
}

void proces()
{
   int i,j;
   for(i=0;i<h;i++)
   {
      for(j=0;j<w;j++)
      {
         if( matrica[0][i][j] == 1 ){
            color = bor;
            dimension=0;
            flood(j,i);
            counterBOR++;
         }else if(matrica[1][i][j]==0){
            color = jela;
            dimension=1;
            flood(j,i);
            counterJELA++;
         }
      }
   }
}

void output()
{
   printf("%d\n",min(counterJELA,counterBOR) );
}

int main()
{
   input();
   proces();
   output();
   system("Pause");
   return 0;
}

#include<iostream>
#include<vector>
#include<cstdio>
#include<math.h>
#include<fstream>
#include<cstdlib>
#include<set>
#include<queue>
#include<iomanip>
#include<cctype>
#include<string>
#include<stack>
#include<assert.h>
#include<climits>
using namespace std;

int main()
{
   int n,k,j,i;
   vector<bool>field(2000,true);
   vector<int>NotPrimes;
   scanf("%d%d",&n,&k);
   for(i=2;i<=n;i++)
   {
     if( field[i] )
     {
        NotPrimes.push_back(i);
        j=2;
        while(i*j<=n ){
           
           if( field[i*j] )NotPrimes.push_back(i*j);
           field[i*j]=false;
           j++;
        }
     }
   }
   printf("%d\n",NotPrimes.at(k-1));
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdio>
#include<fstream>
using namespace std;

string RomeZ = "MDCLXVI";
int   RomeV[]={1000,500,100,50,10,5,1};

int main()
{
    int Vpre;
    int V;
    int len;
    int i,j;
    bool OK=false;
    string Rome;
    while(cin>>Rome)
    {
       len = Rome.length();
       Vpre=0;
       V = 0;
       for(i=0;i<7;i++)
          if(Rome[0]==RomeZ[i])
          {
             OK = 1;
             break;
          }
       Vpre = RomeV[i];
       for(i=1;i<len && OK ; i++)
       {
          for(j=0;j<7;j++)
             if( RomeZ[j] == Rome[i] )break;
          if( j==7)OK=0;
          if( RomeV[j] > Vpre )
             V -= Vpre;
          else
             V += Vpre;
          Vpre = RomeV[j];
       }
       if( OK )
       {
          cout<<V+Vpre<<endl;
       }else
          cout<<"ERROR"<<endl;
    }
    system("Pause");
    return 0;
}

#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<iostream>
using namespace std;
short field[1025][1025];
short gore[1025][1025];
short ljevo[1025][1025];
short rupa[1025][1025];

int main()
{
   int n,m,i,j;
   int y,x;
   //FILE *in = fopen("Ulaz.txt","r");
   scanf("%d%d",&n,&m);
   for(i=0;i<m;i++)
   {
      scanf("%d%d",&y,&x);
      field[x][y]=1;
   }
   int counterL,counterU;
   for(i=0;i<n;i++)
   {
      counterL=counterU=0;
      for(j=0;j<n;j++)
      {
         counterL++;
         counterU++;
         if( field[i][j]==1 )counterL=0;
         ljevo[i][j]=counterL;
         
         if( field[j][i]==1 )counterU=0;
         gore[j][i]=counterU;
      }
      if( field[0][i]==1) rupa[0][i]=0;
      else rupa[0][i]=1;
      
      if( field[i][0]==1) rupa[i][0]=0;
      else rupa[i][0]=1;
   }
   for(i=0;i<n;i++){
      for(j=0;j<n;j++){
         cout<<rupa[i][j]<<" ";
      }cout<<endl;
   }
   int maxN=0;
   for(i=1;i<n;i++)
   {
      for(j=1;j<n;j++)
      {
         if( min(ljevo[i][j],gore[i][j]) > rupa[i-1][j-1] ){ cout<<"A"<<endl;
            rupa[i][j]=rupa[i-1][j-1]+1;
         }else{   cout<<"B"<<endl;
            rupa[i][j]=min(ljevo[i][j],gore[i][j]); 
         }
            cout<<i<<" "<<j<<" => "<<rupa[i][j]<<endl;
         if( field[i][j]==1) rupa[i][j]=0;
         if( rupa[i][j]>maxN )
            maxN = rupa[i][j];
         
      }
     
   }
   printf("%d\n",maxN);
   system("Pause");
   return 0;
}

#include<cstdio>
#include<string>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<iostream>
using namespace std;
char field[1000][1000];
char copyS[1000];

int main()
{
    int h,w;
    int proH,proW;
    int i,j,k,l;
    char c;
    FILE *in = fopen("Ulaz.txt","r");
    fscanf(in,"%d%d%d%d%d",&h,&w,&proH,&proW);
    for(i=0;i<h;i++)
    {
       for(j=0;j<w;j++)fscanf(in,"%c",&field[i][j]);fscanf(in,"%d");
       for(j=0;j<w;j++)for(k=0;k<proW;k++)copyS[(j*proW)+k]=field[i][j];
       copyS[(proW*w)]='\0';
       for(j=0;j<proH;j++)printf("%s\n",copyS);
    }
    system("Pause");
    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
using namespace std;


int main()
{
   int n,h,w,d,i,T;
   scanf("%d%d%d",&n,&h,&w);
   d = sqrt(h*h + w*w);
   for(i=0;i<n;i++)
   {
      scanf("%d",&T);
      if( T<=d )cout<<"DA"<<endl;
      else cout<<"NE"<<endl;
   }
   system("Pause");
   return 0;
}

#include<cstdio>
#include<iostream>
#include<algorithm>
#include<math.h>
#include<fstream>
#include<vector>
using namespace std;
ifstream in("Ulaz.txt");
ofstream out("Izlaz.txt");

bool IsPrime(int n)
{
   int i;
   bool validation=1;
   if(n>2 && !(n%2) )validation=0;
   for(i=3;i*i<=n && validation;i+=2)
      if( !(n%i) )validation = 0;
   return validation;
}

int main()
{
    int num,i,j;
    while(!in.eof() && in>>num)
    {
       if( IsPrime(num) )out<<num<<" -- prim."<<endl;
       else out<<num<<" -- not prim"<<endl;
    }
    int maxS=5000000;
    int counter=0;
    vector<bool>primes(maxS+1,true);
    for(i=2;i*i<=maxS;i++)
    {
       if( primes.at(i) )
       {
          j=2;
          while(i*j<=maxS){
              primes.at(i*j)=false;
              j++;
          }
       }
    }
    out<<endl<<"Zwiling-prime:"<<endl;
    for(i=2;i<maxS-1;i++)
    {
       if( primes.at(i) && primes.at(i+2) )
       {
          out<<i<<" -- "<<i+2<<endl;
          counter++;
       }
    }
    out<<"U intervalu [1-5000000] ima "<<counter<<" zwiling-primes\n";
    system("Pause");
    return 0;
}

#include<cstdio>
#include<fstream>
#include<iostream>
using namespace std;
ifstream in("Ulaz.txt");
int h,w;
char matrica[500][500];
bool prazna[500];

void to1()
{
   for(int i=0;i<w;i++)
      prazna[i]=1;
}

int main()
{
    int i,j,k,l;
    int counter;
    int fak;
    int x,y,n;
    in>>h>>w>>n;
    for(i=0;i<n;i++)
    {
       in>>y>>x;
       y--;
       x--;
       matrica[y][x] = 'x';
    }
    int max=0;
    for(i=0;i<h;i++)
    {
        to1();
        for(j=i;j<h;j++)
        {
           fak = (j - i)+1;
           for(k=0;k<w;k++)
           {
              if( matrica[j][k]=='x' )
                 prazna[k] = 0;
           }
           l=0;
           for(k=0;k<w;k++)
           {
              if(!prazna[k])l=0;
              if( fak * l > max )
                 max = fak*l;
              l++;
           }
           
        }
    }
    cout<<max<<endl;
    system("Pause");
    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<vector>

using namespace std;

vector<string>INPUT;
vector<string>RES;
string Name;
string MyInput;
string MyOutput;

void UnesiTest(string IN)
{
   string T;
   ifstream in(IN.c_str());
   while(!in.eof())
   {
      in>>T;
      INPUT.push_back(T);
      in>>T;
      RES.push_back(T);
   }
}

bool compare( string in,string out)
{
   ifstream A(in.c_str());
   ifstream B(out.c_str());
   string LineA,LineB;
   while( !A.eof() && !B.eof() )
   {
      getline(A,LineA);
      getline(B,LineB);
      if( LineA != LineB )
      {
         A.close();
         B.close();
         return false;
      }
   }
   return true;
}

int main()
{
   int i;
   string comand;
   cout<<"INPUT program name:"<<endl;
   cin>>Name;
   cout<<"Your input file:"<<endl;
   cin>>MyInput;
   cout<<"Your output file:"<<endl;
   cin>>MyOutput;
   UnesiTest("Test_files.txt");
   for(i=0;i<INPUT.size();i++)
   {
      comand = "RENAME "+INPUT.at(i)+","+MyInput;
      system(comand.c_str());
      system(Name.c_str());
      if( compare( RES.at(i) , MyOutput) )cout<<i+1<<". OK"<<endl;
      else cout<<i+1<<". WRONG RESULT"<<endl;
      comand = "RENAME "+MyInput+","+INPUT.at(i);
      system(comand.c_str());
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<vector>
#include<cstdio>
#include<math.h>
#include<fstream>
#include<cstdlib>
#include<set>
#include<queue>
#include<iomanip>
#include<cctype>
#include<string>
#include<stack>
#include<assert.h>
#include<climits>
using namespace std;
int sastojke[20][2];
int minN=(int)3e9;
int n;

void rek(int redni,int kiselo,int gorko)
{
   if( abs( gorko - kiselo ) < minN )
     minN = abs( gorko - kiselo );
   int i;
   for(i=redni+1;i<n;i++)
      rek(i,kiselo*sastojke[i][0],gorko+sastojke[i][1]);
}

int main()
{
   int i;
   scanf("%d",&n);
   for(i=0;i<n;i++)scanf("%d%d",&sastojke[i][0],&sastojke[i][1]);
   for(i=0;i<n;i++)
     rek(i,sastojke[i][0],sastojke[i][1]);
   printf("%d\n",minN);
   return 0;
}

#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int perm[10];

int main()
{
   int n,i,j;
   scanf("%d",&n);
   for(i=1;i<=n;i++)
      perm[i-1]=i;
   for(i=0;i<n*(n-1);i++)
   {
      for(j=0;j<n;j++)
         cout<<perm[j]<<" ";cout<<endl;
      next_permutation(perm,perm+n);
   }
   system("Pause");
   return 0;
}

#include<cstdio>
#include<cstdlib>

int main()
{
   int n,i;
   bool IsPrime=1;
   scanf("%d",&n);
   if(n>2 && n%2==0)IsPrime=0;
   for(i=3;i*i<=n && IsPrime;i+=2)
      if( n % i == 0 )IsPrime=0;
   if(IsPrime)printf("Prost\n");
   else printf("Nije prost\n");
   system("Pause");
   return 0;
}

#include<iostream>
#include<math.h>
#include<fstream>
#include<cstdio>
#include<climits>
#include<vector>
using namespace std;
ifstream in("Ulaz.txt");
ofstream out("Izlaz.txt");

void Puta2( vector<int> &V )
{
   int Vsize = V.size();
   int aux=0,dodaj,T,i;
   for(i=0;i<Vsize;i++)
   {
      T = V.at(i)*2;
      V.at(i) = T%10;T/=10;
      V.at(i)+=aux;
      aux = T;
   }
   if(aux)V.push_back(aux);
}

void Ispisi(vector<int> &V)
{
   int i;
   for(i=V.size()-1;i>=0;i--)
      out<<V.at(i);
      out<<endl;
}

int main()
{
   int n,i;
   vector<int>a;
   while( !in.eof() && in>>n)
   {
       a.clear();
       a.push_back(1);
       for(i=0;i<n-1;i++)
          Puta2(a);
       Ispisi(a);
       out<<endl;
   }
   system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<iostream>
#include<math.h>
#include<queue>
#include<fstream>
using namespace std;
int hash[100000];
int fak[10000];
int redniB[10000];
vector<int>V[10000];

int main()
{
   int n,MOD,i;
   int a;
   scanf("%d%d",&n,&MOD);
   queue<int>Q;
   for(i=0;i<n;i++)
   {
      scanf("%d",&fak[i]);
      redniB[fak[i]] = i+1;
      Q.push(fak[i]);
   }
   int T;
   int u;
   int it=0;
   int maxN=-1;
   while(!Q.empty())
   {
      u = Q.front();Q.pop();
      for(i=0;i<n;i++)
      {
          T = (u * fak[i])%MOD;
          if( !hash[T] ){
             hash[T] = 1;
             Q.push(T);
             if(V[T].empty()){
                V[T].push_back(i+1);
                V[T].push_back(redniB[u]);
             }else
                V[T].push_back(i+1);
             if( T > maxN ){
                maxN = T;
             }
          }
      }
   }
   printf("%d\n",maxN);
   sort(V[maxN].begin(),V[maxN].end());
   for(i=0;i<V[maxN].size();i++)
     printf("%d ",V[maxN].at(i));
   printf("\n");
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<math.h>
using namespace std;
int lcs_table[1001][1001];
int array[1001];
int array_sorted[1001];

int lcs(int *field1, int n,
        int *field2, int m  )
{
   int i,j;
   int t;
   for(i=0;i<n;i++)
   {
      t = 0;
      for(j=0;j<m;j++)
      {
         if(field1[i]==field2[j])t++;
         if( i>0 && lcs_table[i-1][j]>t)t = lcs_table[i-1][j];
         lcs_table[i][j]  = t;
      }
   }
   return lcs_table[n-1][m-1];
}

int main()
{
   int n,i;
   cin>>n;
   for(i=0;i<n;i++)
   {
      scanf("%d",&array[i]);
      array_sorted[i] = array[i];
   }
   sort(array_sorted,array_sorted+n);
   printf("%d\n",( n - ( lcs(array,n,array_sorted,n) ) ) );
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<cmath>
#include<string>
#include<vector>
#include<algorithm>
using namespace std;
ifstream in("Ulaz3.txt");
bool used[27];

class stringD{
   public:
      string A;
      stringD(string T):A(T){}
      stringD(){}
};

stringD field[101];
vector<stringD*>words;
int n;

bool compare( stringD *A, stringD *B)
{
   return ( A->A > B->A);
}

bool IsPalindrome(string &S)
{
   int n = S.length()/2;
   int m = S.length();
   for(int i=0;i<n;i++)
      if( S[i] != S[m-i-1] )
        return false;
   return true;
}

void proces()
{
   int poz;
   int i,j;
   string ADD;
   for(i=0;i<n;i++)
   {
      poz=0;
      for(j=0;j<n+1;j++)// HORIZONTAL
      {
         if( field[i].A[j] == '.' && poz != j ){
            words.push_back(   new stringD( field[i].A.substr(poz,j-poz) )   );
            poz = j+1;
         }else if( field[i].A[j]=='.')
            poz++;
      }
      ADD="";
      for(j=0;j<n+1;j++)// VERTIKAL
      {
         if( field[j].A[i] == '.' && ADD.length()>0 ){
            words.push_back(   new stringD(ADD)   );
            ADD="";
         }else if( field[j].A[i]=='.')
            ADD=field[j].A[i];
         else
            ADD += field[j].A[i];
         if(ADD==".")ADD="";
      }
   }
   int size = 0;
   vector<string>RES;
   sort( words.begin() , words.end() , compare);
   for(i = 0; i <words.size();i++)
      if( size <= words.at(i)->A.length() && IsPalindrome(words.at(i)->A) &&
         (words.at(i)->A != words.at((!i)?(i+1):(i-1) )->A)  ){
              if( !size ) size = words.at(i)->A.length();
              RES.push_back( words.at(i)->A );
      }
   sort( RES.begin(),RES.end() );
   cout<<size<<endl;
   size=0;
   for(i=0;i<RES.size();i++)
   {
       cout<<RES.at(i)<<endl;
       for(j=0;j<RES.at(i).length();j++)
       {
          if( !used[ RES.at(i)[j] % 26 ] )
          {
             size += (int)RES.at(i)[j];
             used[ RES.at(i)[j] % 26] = true;
          }
       }
   }
   cout<<size<<endl;
}

int main()
{
    int i,j,k,l;
    in>>n;
    for(i=0;i<n;i++){
       in>>field[i].A;
       field[i].A+=".";
    }
    field[i].A=(string)"......................................................" +
               (string)"..................................................... ";
    proces();
    system("Pause");
    return 0;
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<math.h>
using namespace std;
int coins[]={1,2,5,10,20,50};int size=6;
int field[100000];
int n;

int main()
{
   int i,j;
   scanf("%d",&n);
   field[0]=1;
   for(i=0;i<size;i++)
      for(j=0;j<=n;j++)
         field[j+coins[i]]+=field[j];
   printf("%d\n",field[n]);
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
#include<string>
using namespace std;
ifstream in("Ulaz4.txt");
int createN[100];
int size=0;
char sace[1000][1000];

void create(bool start,int len,int j)
{
    for(int i=0;i<len;i++)
    {
        sace[(i*2)+(start)][(j*2)+1]='_';
        sace[(i*2)+(start)+1][(j*2)]='/';
        sace[(i*2)+(start)+1][(j*2)+2]='\\';
        sace[(i*2)+(start)+2][(j*2)]='\\';
        sace[(i*2)+(start)+2][(j*2)+2]='/';
        sace[(i*2)+(start)+2][(j*2)+1]='_';
    }
}

int main()
{
   int i,j,x,y,longest=0;
   bool uvuci,uvuci2;
   char C;
   in>>createN[size++];
   while( C!='+' && C!='-' )
   {
      in>>createN[size++];
      if(longest<createN[size-1])
         longest = createN[size-1];
      in>>C;
      in.putback(C);
   }in>>C;
   if(C=='+')uvuci=false;
   else uvuci=true;
   uvuci2=uvuci;
   for(i=0;i<size;i++)
   {
      create(uvuci,createN[i],i);
      uvuci = !uvuci;
   }
   while( !in.eof())
   {
      in>>x>>y;
      if(uvuci2==true && x%2)
         sace[(y*2)][((x-1)*2)+1]='Q';
      else if(uvuci2==false && !(x%2) )
         sace[(y*2)][((x-1)*2)+1]='Q';
      else 
         sace[(y*2)-1][((x-1)*2)+1]='Q';
   }
   for(i=0;i<longest*2+5;i++)
   {
       for(j=0;j<size*3;j++)
       {
          cout<<sace[i][j]<<" ";
       }cout<<endl;
   }
   system("Pause");
   return 0;
}

#include<cstdio>
#include<cstdlib>
#include<fstream>
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

struct box{
   int *dimensions;
   int redni;
   box(){
      dimensions = new int[250];
   }
};

int n,d;
box boxes[300];

int compare( const void *A,const void *B)
{
   box A_ = *(box*)A;
   box B_ = *(box*)B;
   return (A_.dimensions[0] - B_.dimensions[0]);
}

void read(ifstream &in)
{
   int i,j;
   in>>n>>d;
   for(i=0;i<n;i++)
   {
      boxes[i].redni = i+1;
      for(j=0;j<d;j++)
         in>>boxes[i].dimensions[j];
   }
}

bool Pase( box &A, box &B )
{
   for (int i=0;i<d;i++)
   {
      if( A.dimensions[i] > B.dimensions[i] )
         return false;
   }
   return true;
}

void reconstruct( vector<int> &red,int i)
{
   if(red[i]+1)reconstruct(red,red[i]);
   cout<<boxes[i].redni<<" ";
}

void proces()
{
   int i,j,now=0;
   bool CanIn;
   for(i=0;i<n;i++)sort(boxes[i].dimensions,boxes[i].dimensions+d);
   qsort(boxes,n,sizeof(box),compare);
   vector<int>proslji;
   vector<int>duzina;
   int iMAX=0;
   proslji.push_back(-1);
   duzina.push_back(1);
   for(i=1;i<n;i++)
   {
      proslji.push_back(-1);
      duzina.push_back(1);
      for(j=0;j<i;j++)
      {
         if( Pase(boxes[j],boxes[i]) && (duzina[j]+1 > duzina[i]) )
         {
            proslji.pop_back();
            proslji.push_back(j);
            duzina.pop_back();
            duzina.push_back(duzina[j]+1);
         }
      }
      if( duzina[iMAX]<duzina[i] )
         iMAX = i;
   }
   cout<<duzina[iMAX]<<endl;
   reconstruct(proslji,iMAX);
   cout<<endl;
}

int main()
{
    ifstream in("Ulaz1.txt");
    while( !in.eof() )
    {
       read(in);
       proces();
       cout<<"*************************************"<<endl<<endl;
       system("Pause");
   }
    system("Pause");
    return 0;
}

#include<iostream>
#include<vector>
#include<cstdio>
#include<math.h>
#include<fstream>
#include<cstdlib>
#include<set>
#include<queue>
#include<iomanip>
#include<cctype>
#include<string>
#include<stack>
#include<assert.h>
#include<climits>
using namespace std;
int values[4];

int main()
{
   cin>>values[0]>>values[1]>>values[2]>>values[3];
   sort(values,values+4);
   cout<<(min(values[0],values[1]) * min(values[2],values[3]) );
   return 0;
}

#include<iostream>
#include<fstream>
#include<cstdio>
#include<algorithm>
#include<math.h>
using namespace std;
ifstream in("Ulaz.txt");
int skup[101];

int sqrt3(int n)
{
   int T =ceil( pow(n,(0.33333333333333333333333333333333)));
   return T;
}

int main()
{
   int n,i,j,k,l;
   in>>n;
   for(i=0;i<n;i++)
   {
      in>>skup[i];
      skup[i] = skup[i]*skup[i]*skup[i];
   }
   for(i=0;i<n;i++)
   {
      for(j=0;j<n && skup[j]<=skup[i] ;j++)
      {
         for(k=j;k<n && (skup[j] + skup[k])<=skup[i]; k++ )
         {
            for(l=k;l<n && (skup[j]+skup[l]+skup[k]<=skup[i]); l++)
            {
               if( (skup[j]+skup[l]+skup[k])==skup[i]){
                  cout<<sqrt3(skup[i])<<"^3 = "<<sqrt3(skup[j])<<"^3 + "<<sqrt3(skup[k])<<"^3 + "<<sqrt3(skup[l])<<"^3"<<endl;
               }
            }
         }
      }
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
using namespace std;
int coins[]={500,100,50,10,5,1};

int main()
{
   int S;
   cin>>S;
   S = 1000 - S;
   int sum=0,Nc=0,i;
   while(sum!=S)
   {
      for(i=0;i<5;i++)
         if( sum+coins[i]<=S )break;
      Nc++;
      sum+=coins[i];
   }
   cout<<Nc<<endl;
   system("Pause");
   return 0;
}

#include<cstdio>
#include<iostream>
#include<algorithm>
#include<vector>
#include<math.h>

using namespace std;

#define OLD 5
#define NEW 2

struct coord{
   int x,y;
   coord(int x_,int y_):x(x_),y(y_){}
};

FILE *in, *out;

int h,w;
char c;
coord *start;
int matrica[40000][1000];

void input()
{
     in = fopen("lab5.in", "r");
     assert(in);
     fscanf(in,"%d%d",&h,&w);
     for(int i=0;i<h;i++)
     {
         for(int j=0;j<w;j++)
         {
             fscanf(in,"%c",&c);
             if( c == '#' )matrica[i][j] = 6;
             else if( c == '.' )matrica[i][j]=OLD;
             else{
                start = new coord(j,i);
                matrica[i][j]=OLD;}
         }
         fscanf(in,"%d");
     }
    fclose(in);
}

void flood(int x,int y)
{
    if( x>=0 && y>=0 && x<w && y<h && matrica[y][x] == OLD )
    {
       matrica[y][x] = NEW;
       flood(x-1,y);
       flood(x+1,y);
       flood(x,y-1);
       flood(x,y+1);
    }
}

void output()
{
    int i,j;
    int res=0;
    for(i=0;i<h;i++)
    {
       if( matrica[i][0]==NEW )res++;
       if( matrica[i][w-1]==NEW)res++;
    }
    for(i=0;i<w;i++)
    {
       if(matrica[0][i]==NEW)res++;
       if(matrica[h-1][i]==NEW)res++;
    }
    out = fopen("lab.out","w");
    fprintf(out,"%d\n",res);
    fclose(out);
}

int main()
{
    input();
    flood(start->x, start->y);
    output();
    return 0;
}

#include<iostream>
#include<cstdio>
#include<set>
#include<math.h>
#include<cctype>
#include<fstream>
using namespace std;
ifstream in("Ulaz.txt");
set<char>menge;
multiset<char>multimenge;

int main()
{
    char C;
    while(!in.eof())
    {
       in>>C;
       if( isalpha(C) ){
          menge.insert(toupper(C));
          multimenge.insert(toupper(C));
       }
    }
    for(set<char>::iterator it=menge.begin();it!=menge.end();it++)
       cout<<*it<<" ";cout<<endl;
    for(multiset<char>::iterator it=multimenge.begin();it!=multimenge.end();it++)
       cout<<*it<<" ";cout<<endl;
    system("Pause");
    return 0;
}

#include<cstdio>
#include<cstdlib>
#include<climits>
#include<iostream>
#include<algorithm>
using namespace std;
int coins[100];
int table[10000];

int main()
{
    int n,S,i,j;
    scanf("%d",&n);
    for(i=0;i<n;i++)scanf("%d",&coins[i]);
    scanf("%d",&S);
    for(i=1;i<=S;i++){
       table[i]=INT_MAX;
       for(j=0;j<n;j++){
          if( coins[j]<=i ) table[i] = min( table[i] , table[i-coins[j]]+1 );
       }
    }
    cout<<table[S]<<endl;
    system("Pause");
    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<vector>
#include<cctype>
using namespace std;

#define ogradaC  9
#define vukC     2
#define ovcaC    1
#define prosaoC  5

struct bice{  
    int x,y;
    bice(int x1,int y1):x(x1),y(y1){}
};

FILE *in,*out;
int h,w;
int matrica[300][300];
int ResVuk=0;
int ResOvca=0;
vector<bice*>vuk_ovca[2];

void input()
{
    in = fopen("Ulaz.txt","r");
    int i,j;
    char C;
    fscanf(in,"%d%d%d",&h,&w);
    for(i=0;i<h;i++)
    {
       for(j=0;j<w;j++)
       {
          fscanf(in,"%c",&C);
          if( C == '#' )
             matrica[i][j]=ogradaC;
          else if( C=='o' ){
             matrica[i][j]=ovcaC;
             vuk_ovca[0].push_back( new bice(j,i) );
          }else if( C=='v' ){
             matrica[i][j]=vukC;
             vuk_ovca[1].push_back( new bice(j,i) );
          }
       }
       fscanf(in,"%d");
    }
    fclose(in);
}

int ovcaCounter,vukCounter;
void flood(int x,int y)
{
   if( x>=0 && x<w && y>=0 && y<h && 
      (matrica[y][x] ==  ovcaC || matrica[y][x] == vukC || matrica[y][x] == 0 )  )
   {
      if( matrica[y][x]     == vukC ) vukCounter++;
      else if(matrica[y][x] ==ovcaC ) ovcaCounter++;
      matrica[y][x] = prosaoC;
      flood( x-1,y);
      flood( x+1,y);
      flood( x,y+1);
      flood( x,y-1);
   }
}

void proces()
{
    int *Len = new int[2];
    Len[0]= vuk_ovca[0].size();
    Len[1]= vuk_ovca[1].size();
    int x,y;
    int i,j;
    for(j=0;j<2;j++)
    {
       for(i=0;i<Len[j];i++)
       {
          if( matrica[ (y=vuk_ovca[j].at(i)->y) ][ x=vuk_ovca[j].at(i)->x ] != prosaoC )
          {
             vukCounter=0;
             ovcaCounter=0;
             flood(x,y);
             if( vukCounter>=ovcaCounter)
                ResVuk += vukCounter;
             else
                ResOvca+= ovcaCounter;
          }
       }
    }
    cout<<ResOvca<<" "<<ResVuk<<endl;
}

int main()
{
    input();
    proces();
    system("Pause");
    return 0;
}

#include<cstdio>
#include<algorithm>
#include<iostream>
#include<fstream>
#include<math.h>
using namespace std;
ifstream in("Ulaz.txt");
ofstream out("Izlaz.txt");

int main()
{
    int n,T,i,k;
    int nrPages;
    while( !in.eof() && in>>n )
    {
       T = n;
       while(n%4)n++;
       nrPages = n / 4;
       out<<"Anordnung fuer "<<T<<" Seiten:\n";
       for(i=1;i<=nrPages;i++)
       {
          k = 2*(i-1);
          out<<"Seite "<<i<<" vorne: ";
          if(n-k>T)out<<"leer,";
          else out<<n-k<<",";
          out<<k+1<<endl;
          
          out<<"Seite "<<i<<" hinten: ";
          if(k+2>T)out<<"leer,";
          else out<<k+2<<",";
          if(n-k-1>T)out<<"leer"<<endl;
          else out<<n-k-1<<endl;
       }
       out<<endl;
    }
    system("Pause");
    return 0;
}

// NAJVECI ZAJEDNICKI DJELILAC
#include<cstdio>
#include<iostream>
#include<cmath>
#include<fstream>
using namespace std;

int main()
{
    int a,b,r;
    cin>>a>>b;
    while(b!=0)
    {
       r = a % b;
       a = b;
       b = r;
    }
    cout<<a<<endl;
    system("Pause");
    return 0;
}

#include<cstdio>
#include<algorithm>
#include<iostream>
#include<fstream>
#include<math.h>
#include<iomanip>
#include<vector>
using namespace std;

struct event{
   int S,E;
   event(int a,int b):S(a),E(b){}
};

int n;
vector<event*>A;

bool compare( event *T1,event *T2)
{
   return ( T1->E < T2->E );
}

int main()
{
   int i;
   int a,b;
   scanf("%d",&n);
   for(i=0;i<n;i++)
   {
      scanf("%d%d",&a,&b);
      A.push_back( new event(a,b) );
   }
   sort(A.begin(),A.end(),compare);
   int END=0;
   int counter=0;
   for(i=0;i<n;i++)
   {
      if( A[i]->S >= END ){
          END = A[i]->E;
          counter++;
      }
   }
   printf("%d\n",counter);
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
using namespace std;
bool smjer=true;
int h,w;
long long k;
int x=1,y=1;

void next()
{
   if(smjer)
   {
      if( x==w ){
         y++;
         smjer = !smjer;
      }else if(y==1){
         x++;
         smjer = !smjer;
      }else{
         y--;
         x++;
      }
   }else{
      if(y==h){
         x++;
         smjer = !smjer;
      }else if(x==1){
         y++;
         smjer = !smjer;
      }else{
         y++;
         x--;
      }
   }
}

int main()
{
   int i,res=0;
   scanf("%d%d",&h,&w);
   scanf("%lld",&k);
   for(i=0;i<k;i++)
   {
      if( ((x-1) & (y-1)) == 0 )res++;
      next();
   }
   cout<<res<<endl;
   system("Pause");
   return 0;
}

#include<cstdio>
#include<queue>
#include<set>
#include<iostream>
using namespace std;

int abs(int a)
{
   if(a<0)return (-a);
   else return a;
}

int main()
{
   set<int>elem;
   int n,i;
   int prev,now;
   bool IsJo;
   while( scanf("%d",&n)!=EOF )
   {
      IsJo=true;
      for(i=0;i<n;i++)
      {
         scanf("%d",&now);
         if(IsJo)
         {
            if(i && abs(now-prev)>=n)
               IsJo=false;
            else if(i)
               elem.insert( abs(now-prev) );
         }
         prev = now;
      }
      if( elem.size()+1==n )
         printf("Jolly\n");
      else
         printf("Not jolly\n");
      elem.clear();
   }
   return 0;
}

#include<cstdio>
#include<cstdlib>

int hoteli[100]={990, 1010, 1970, 2030, 2940, 3060, 3930, 4060, 4970, 5030, 5990, 6010, 7000 };
int size = 13;
int A,B;
int counter=0;

void rek(int now)
{
   if(now==7000)
      counter++;
   else
      for(int i=0;i<size;i++)
         if( hoteli[i]-now >= A && hoteli[i]-now<=B)
            rek(hoteli[i]);
}

int main()
{
   int n,i,j;
   scanf("%d%d%d",&A,&B,&n);
   for(i=0;i<n;i++)scanf("%d",&hoteli[size++]);
   printf("%d\n",counter);
   system("Pause");
   return 0;
}

#include<iostream>
#include<fstream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<queue>
#include<stack>
#include<math.h>
using namespace std;

struct edge{
       short dist,node;
       edge(){};
       edge(int &a,int &b):dist(a),node(b){};
};

vector< edge > cnt[8501];
short visited[8501];

int mark=0;
int res=0;
int END;
void DFS(short point,int dist)
{
   if( dist > res ){
      res = dist;
      END = point;
   }     
   visited[point]=mark;
   short Vsize = cnt[point].size();
   for(short i=0;i<Vsize;i++)
      if( visited[ cnt[point][i].node ] != mark )
         DFS( cnt[point][i].node, dist + cnt[point][i].dist );
}

int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   int n;
   int i,j;
   int a,b,c;
   scanf("%d",&n);
   for(i=0;i<n-1;i++)
   {
      scanf("%d%d%d",&a,&b,&c);
      cnt[a].push_back( edge(c,b) );
      cnt[b].push_back( edge(c,a) );
   }
   mark++;
   DFS(1,0);
   mark++;
   res = 0;
   DFS(END,0);
   printf("%d\n",res);
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
#include<cstring>
using namespace std;
#define MAXS 200
#define DIG 25

char buff[DIG];
short A[DIG],B[DIG];
long long DP[DIG][MAXS][2][2];
long long S;

void InputBig( short *field )
{
   scanf("%s",buff);
   static int n,i;
   n = strlen( buff );
   for(i=0;i<n;i++)
      field[ DIG-i-1 ] = buff[n-i-1] - '0';
}

long long rek( int poz, int sum , int dA , int dB )
{
   if( poz == DIG )
      return sum==S;
   long long &ref = DP[poz][sum][dA][dB];
   if( ref != -1 )return DP[poz][sum][dA][dB];
   ref = 0;
   for(int i=0;i<10;i++)
      if( ( dA==0 || i>=A[poz] ) && ( dB==0 || i<=B[poz] ) )
        ref += rek( poz+1, sum+i, dA & ( A[poz]==i ) , dB & (B[poz]==i) );
   return ref;
}

int main()
{
   InputBig(A);
   InputBig(B);
   for(S=0;S<=90;S++){cout<<S<<endl;
   memset(DP,-1,sizeof(DP) );
   long long t= rek(0,0,1,1);
   printf("%lld", t );
   cout<<" ("<<t*t<<")"<<endl;
}
   system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
using namespace std;

short D1[3];
short D2[3];

int main()
{
   scanf("%d%d%d",&D1[0],&D1[1],&D1[2]);
   scanf("%d%d%d",&D2[0],&D2[1],&D2[2]);
   sort(D1,D1+3);
   sort(D2,D2+3);
   if( D1[0]<D2[0] && D1[1]<D2[1] && D1[2]<D2[2] ||
       D1[0]>D2[0] && D1[1]>D2[1] && D1[2]>D2[2] )
          printf("DA\n");
   else
          printf("NE\n");
   //system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<iostream>
#include<string>
#include<fstream>
#include<set>
using namespace std;

int result(string &A)
{
   int sizeN = A.size(),i,j,k,ret = 1;
   bool add;
   string T;
   for( i=1 ; i<=sizeN ; i++ )
   {
      for( j=0 ; j<sizeN-i+1 ; j++ )
      {
         T = (A.substr(j,i) );
         add = true;
         for(k=j-1;k>=0 && add;k--)
            if( T == A.substr(k,i) )
               add = false;
         if( add == true )
            ret++; 
      }
      cout<<i<<endl; 
   }
   return ret;
}

int main()
{
   ifstream in("SUBSTR4.IN");
   int n;
   in>>n;
   string A;
   while(n--)
   {
      in>>A;
      cout<<result(A)<<endl;
   }
   system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<iostream>
#include<string>
#include<fstream>
#include<set>
#include<queue>
#include<stack>
#include<vector>
using namespace std;

vector<string> indexing;

int result(string &A)
{
   int sizeN = A.size(),i,j,k,ret = 1;
   bool add;
   string T;
   for( i=1 ; i<=sizeN ; i++ )
   {
      for( j=0 ; j<sizeN-i+1 ; j++ )
      {
         T = (A.substr(j,i) );
         add = true;
         for(k=0;k<indexing.size() && add;k++){
            if( T == indexing[k] )
               add = false;
         }
         if( add ){
            indexing.push_back(T);
            ret++;
         }
      }
      indexing = vector<string>(); 
   }
   return ret;
}

int main()
{
   ifstream in("SUBSTR2.IN");
   int n;
   in>>n;
   string A;
   while(n--)
   {
      in>>A;
      cout<<result(A)<<endl;
   }
   system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<iostream>
#include<string>
#include<fstream>
#include<set>
using namespace std;

int result(string &A)
{
   int sizeN = A.size();
   int i,j;
   set<string>subs;
   for( i=1 ; i<=sizeN ; i++ )
      for( j=0 ; j<sizeN-i+1 ; j++ )
         subs.insert(A.substr(j,i) ); 
   return subs.size()+1;
}

int main()
{
   ifstream in("SUBSTR2.IN");
   int n;
   in>>n;
   string A;
   while(n--)
   {
      in>>A;
      cout<<result(A)<<endl;
   }
   system("Pause");
   return 0;
}

#include<cstdio>
#include<fstream>
#include<iostream>
#include<string.h>
#include<cctype>
#include<math.h>
using namespace std;
string vowels="aeiou";

bool IsVowel(char c)
{
   return vowels.find(c,0)!=string::npos;
}

string transform(string s)
{
   int i;
   for(i=0;i<s.size()-1;i++)
   {
      if( tolower(s[i])=='p' && IsVowel( s[i-1] ) && s[i-1]==s[i+1] )
             s.replace(i-1,3,s.substr(i-1,1));
   }
   return s;
}

int main()
{
    int n;
    string s,ss;
    getline(cin,s);
    ss = transform(s);
    cout<<ss<<endl;
    //system("Pause");
    return 0;
}

#include<iostream>
#include<fstream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<iomanip>
#include<math.h>
#include<queue>
#include<set>
#include<stack>
using namespace std;


int main()
{
   int Winer=-1,Points=-1;
   int T,sum,i,j;
   for(i=0;i<5;i++)
   {
      sum = 0;
      for(j=0;j<4;j++)
      {
         scanf("%d",&T);
         sum+=T;
      }
      if( sum > Points )
      {
         Winer  = i+1;
         Points = sum;
      }
   }
   cout<<Winer<<" "<<Points<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<set>
using namespace std;
int coins[101];
int DP_GY[7000000];
int trace[7000000];

int main()
{
   int n,i,j;
   int x,y;
   //FILE *in = fopen("Ulaz.txt","r");
   //fscanf(in,"%d",&n);
   //for(i=0;i<n;i++)fscanf(in,"%d",&coins[i]);
   //fscanf(in,"%d%d",&x,&y);
   
   scanf("%d",&n);
   for(i=0;i<n;i++)scanf("%d",&coins[i]);
   scanf("%d%d",&x,&y);
   int Greedy_version;
   for(i=0;i<=y;i++)
   {
      Greedy_version = DP_GY[i];
      DP_GY[i]=999999999;
      for(j=0;j<n;j++)
      {
         if( DP_GY[i+ coins[j] ] == 0 )
             DP_GY[i + coins[j]] = Greedy_version + 1;
         if( coins[j] <= i )
            if( DP_GY[i-coins[j]] + 1 < DP_GY[i] ){
               DP_GY[i] = DP_GY[i-coins[j]] + 1;
               trace[i] = j;
            }
      }
      if(DP_GY[i] == 999999999){
         DP_GY[i] = 0;
         trace[i] = -1;
      }
      if( DP_GY[i] != Greedy_version )
         break;
   }
   printf("%d\n",i);
   int it=i;
   multiset<int>keys;
   while( trace[it]+1 )
   {
      keys.insert(trace[it]);
      it -= coins[trace[it]];
   }
   for(i=0;i<n;i++)
   {
      printf("%d ", keys.count(i) );
   }printf("\n");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<ctime>
#include<iomanip>
using namespace std;
long long DP[10000];


int fibRek(int n)
{
   if(n<=1)return n;
   return ( fibRek(n-1) + fibRek(n-2) );
}

long long  fibDyn(int n)
{
   static int size = 1;
   static int i;
   if(n>size)
      for(i=size+1;i<=n;i++)
         DP[i] = DP[i-1]+DP[i-2];
   return DP[n];
}

int main()
{
   int n=50,i;
   DP[1]=1;
   time_t S,E;
   printf("  N       FibRec(N)       Zeit(FibRec(N))       FibIt(N)       Zeit(FibIt(N)) \n");
   printf(".......                                                           \n");
   for(i=0;i<=n;i++)
   {
      cout<<setw(2)<<i;
      S = time(NULL);
      cout<<setw(17)<<fibRek(i);
      cout<<setw(22)<<time(NULL)-S;
      
      S = time(NULL);
      cout<<setw(15)<<fibDyn(i);
      cout<<setw(20)<<time(NULL)-S<<endl;
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
using namespace std;

short cifre(int n)
{
   short ret=0;
   while( n )
   {
      ret += n%10;
      n/=10;
   }
   return ret;
}

int main()
{
   short n,k;
   scanf("%hd%hd",&n,&k);
   int i;
   int res=0;
   for(i=0;i<=n;i++)
      if( cifre(i)==k )
         res++;
      printf("%d\n",res);
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
using namespace std;
#define MAXN 999999999
int udarci[101];
int DP[6000];

int main()
{
    int dist,n;
    int i,j;
    FILE *in = fopen("Ulaz.txt","r");
    fscanf(in,"%d%d",&dist,&n);
    for(i=1;i<=n;i++)fscanf(in,"%d",&udarci[i]);
    for(i=1;i<=dist;i++)
    {
       DP[i]=MAXN;
       for(j=1;j<=n;j++)
       {
          if( udarci[j]<=i )
             DP[i]=min(DP[i],DP[i-udarci[j]]+1);
       }
    }
    if(DP[dist]==MAXN)
       printf("Roberta acknowledges defeat.\n");
    else   
       printf("Roberta wins in %d strokes.\n",DP[dist]);
    system("Pause");
    return 0;
}

#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstdio>
#include<math.h>
using namespace std;

int n;
float m,b;

float f(float x)
{
   return (m*x + b);
}

int main()
{
   int i,count=0;
   float xi,yi,fi;
   //FILE *in = fopen("Ulaz.txt","r");
   scanf("%f%f%d",&m,&b,&n);
   for(i=0;i<n;i++)
   {
      scanf("%f%f",&xi,&yi);
      fi = f(xi);
      if( xi>=0 && fabs(fi-yi)<0.00001 )
         count++;
   }
   printf("%d\n",count);
   //system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<fstream>
#include<iostream>
using namespace std;
int niz[100000];

int main()
{
   int n,i,j;
   int x,y,d;
   //FILE *in = fopen("Ulaz.txt","r");
   scanf("%d",&n);
   long long sum=0;
   for(i=0;i<n;i++)
   {
      scanf("%d%d%d",&x,&y,&d);
      for(j=x;j<x+d;j++){
         niz[j]+=d;
         sum+=d;
      }
   }
   double granica1 = sum / 3.00;
   double granica2 = granica1 * 2;
   double res1 = 0;
   double sumiranje1=0;
   double sumiranje2=0;
   double res2 = 0;
   int it=0;
   while( sumiranje1 + niz[it] <= granica1 )
   {
      sumiranje1 += niz[it];
      res1++;
      it++;
   }
   if( sumiranje1 < granica1 )
   {
      res1 += ( granica1 - sumiranje1 ) / niz[it];
      sumiranje1 = sumiranje1 + ( granica1 - sumiranje1 );
      it++;
   }
   it=0;
   while( sumiranje2 + niz[it] <= granica2 )
   {
      sumiranje2 += niz[it];
      res2++;
      it++;
   }
   if( sumiranje2 < granica2 )
   {    
      res2 += ( granica2 - sumiranje2 ) / niz[it];
      sumiranje2 = sumiranje2 + ( granica1 - sumiranje2 );
   }
   cout.precision(2);
   cout.setf(ios::fixed,ios::floatfield);
   cout<<res1<<endl;
   cout<<res2<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
using namespace std;


struct line{
   float a,c;
   line( float i1,float i2):a(i1),c(i2){};
   line(){};
};

vector<line>lines;

bool comp( line A, line B)
{
  return (A.a > B.a );
}

int main()
{
   int n,i,j;
   float a1,a2;
   float res=99999999,T;
   //FILE *in = fopen("Ulaz.txt","r");
   scanf("%d",&n);
   for(i=0;i<n;i++)
   {
      scanf("%f%f",&a1,&a2);
      lines.push_back( line(a2,a1) );
   }
   sort( lines.begin(),lines.end(),comp);
      T = (( lines[1].c - lines[0].c ) / ( lines[0].a - lines[1].a ));
      if( T < res )
        res = T;
   cout.precision(2);
   cout<<fixed<<res<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;
#define ll long long




struct razlomak{
   ll b,n;
   razlomak(int a1,int a2):b(a1),n(a2){};
   razlomak(){};
};

ll ggt(ll a,ll b)
{
   ll r;
   while(b!=0)
    {
       r = b;
       b = a%b;
       a = r;
    }
    return a;
}

ll lcm(ll a,ll b)
{
   return ( (a*b)/ggt(a,b) );
}


razlomak operator+( razlomak &A,razlomak &B)
{
   razlomak ret;
   ll naz = lcm(A.n , B.n);
   A.b = A.b * (naz / A.n);
   B.b = B.b * (naz / B.n);
   ret.b = A.b + B.b;
   ret.n = naz;
   
   naz = ggt( ret.b , ret.n );
   if( naz != 0 )
   {
      ret.b /= naz;
      ret.n /= naz;
   }
   return ret; 
}

void input( razlomak &R )
{
   string S;
   ::cin>>S;
   int i;
   ll brojnik=0,nazivnik=0;
   ll fak=1;
   for(i=S.size()-1;i>=0 && S[i]!='/';i--)
   {
      nazivnik += (S[i]-'0') * fak;
      fak*=10;
   }
   fak = 1;
   for( i=i-1;i>=0;i--)
   {
      brojnik += (S[i]-'0') * fak;
      fak*=10;
   }
  R.b = brojnik;
  R.n = nazivnik;
}

razlomak A,B;

void prepare()
{
   if( A.n < B.n )
     swap(A,B);
}


int main()
{
   int i;
   ll r;
   input(A);
   input(B);
   prepare();
   razlomak res;
   res = A + B;
   cout<<res.b<<"/"<<res.n<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;
#define ll long long


bool IsPrime( long long n )
{
   static long long i;
   if(n>2 && !(n%2) )return false;
   for(i=3;i*i<=n;i+=2)
      if( !(n%i) )
           return false;
   return true;
}

ll nextPrime(ll &A)
{
   bool found = false;
   for( ll i = A+1; !found ; i++)
      if( IsPrime(i) )
         return i;
}

int main()
{
   ll A;
   cin>>A;
   cout<<nextPrime(A);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
#include<iomanip>
using namespace std;
int DP[1001][1001];
int n,m;

void makeRange(int x,int y,int k)
{
    int i;
    int r,l;
    k++;
    if(x-k>=0)DP[y][x-k+1]++;else DP[y][0]++;
    if(x+k<n )DP[y][x+k]--;else DP[y][n]--;
    for(i=1;i<k;i++)
    {
        l=x-k+i;
        r=x+k-i;
        if(l<0)l=0;
        if(r>n)r=n;
        if(y+i<n)
        {
           DP[y+i][l+1]++;
           DP[y+i][r]--;
        }
        if(y-i>=0)
        {
           DP[y-i][l+1]++;
           DP[y-i][r]--;
        }
    }
}

int main()
{
   int i,j;
   int x,y,k;
   scanf("%d%d",&n,&m);
   n++;
   for(i=0;i<m;i++)
   {
      scanf("%d%d%d",&y,&x,&k);     
      makeRange(y,x,k);
   }
   int sum=0,max=0;
   for(i=0;i<=n;i++)
   {
     for(j=0;j<=n;j++)
     {
        sum+=DP[ i ][ j ];
        if(sum>max)max=sum;
     }
   }
   printf("%d\n",max);
   system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
using namespace std;

short D1[3];
short D2[3];

int main()
{
   scanf("%d%d%d",&D1[0],&D1[1],&D1[2]);
   scanf("%d%d%d",&D2[0],&D2[1],&D2[2]);
   sort(D1,D1+3);
   sort(D2,D2+3);
   if( D1[0]<D2[0] && D1[1]<D2[1] && D1[2]<D2[2] ||
       D1[0]>D2[0] && D1[1]>D2[1] && D1[2]>D2[2] )
          printf("DA\n");
   else
          printf("NE\n");
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
using namespace std;

short cifre(int n)
{
   short ret=0;
   while( n )
   {
      ret += n%10;
      n/=10;
   }
   return ret;
}

int main()
{
   short n,k;
   scanf("%hd%hd",&n,&k);
   int i;
   int res=0;
   for(i=0;i<=n;i++)
      if( cifre(i)==k )
         res++;
      printf("%d\n",res);
   //system("Pause");
   return 0;
}

#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstdio>
#include<math.h>
#include<iomanip>
#include<vector>
using namespace std;

bool IsPrime( long long n )
{
   static long long i;
   if(n>2 && !(n%2) )return false;
   for(i=3;i*i<=n;i+=2)
      if( !(n%i) )
           return false;
   return true;
}

int main()
{
   int n,i;
   long long a;
   scanf("%d",&n);
   for(i=0;i<n;i++)
   {
      cin>>a;
      if( IsPrime(a) )printf("NE\n");
      else printf("DA\n");
   }
   //system("Pause");
   return 0;
}

#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstdio>
#include<math.h>
using namespace std;

int n;
float m,b;

float f(float x)
{
   return (m*x + b);
}

int main()
{
   int i,count=0;
   float xi,yi,fi;
   //FILE *in = fopen("Ulaz.txt","r");
   scanf("%f%f%d",&m,&b,&n);
   for(i=0;i<n;i++)
   {
      scanf("%f%f",&xi,&yi);
      fi = f(xi);
      if( xi>=0 && fabs(fi-yi)<0.00001 )
         count++;
   }
   printf("%d\n",count);
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
using namespace std;

bool isVowel(char &c)
{
   if(c=='a' || c=='e' || c=='i' || c=='o' || c=='u' )
      return true;
   return false;
}

int main()
{
   char I;
   int n,i,count=0;
   scanf("%d%d",&n);
   for(i=0;i<n;i++){
      scanf("%c",&I);
      if(isVowel(I))
        count++;
   }
   printf("%d\n",count);
   //system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
#include<iostream>
using namespace std;

struct coord{
       int x,y;
       coord(int a,int b):x(a),y(b){};
       coord(){};
};

int n;
int kvadrat[5][5];
short HASH[26];
vector<coord>fale;
vector<short>brojevi;

bool IsMagic()
{
   bool ret=true;
   int sumX,sumY;
   int diag1=0,diag2=0;
   int S,i,j;
   for(i=0;i<n && ret;i++)
   {
     sumX=sumY=0;
     diag1+=kvadrat[i][i];
     diag2+=kvadrat[n-i-1][i];
     for(j=0;j<n && ret;j++)
     {
        sumX+=kvadrat[i][j];
        sumY+=kvadrat[j][i];
     }
     if(!i)S = sumX;
     if( S!=sumX || S!=sumY )
        ret = false;
   }
   if(ret && ( S!=diag1 || S!=diag2) )
      ret = 0;
   return ret;
}

void ulaz()
{
   int i,j;
   FILE *in = fopen("Ulaz.txt","r");
   fscanf(in,"%d",&n);
   for(i=0;i<n;i++)
   {
      for(j=0;j<n;j++)
      {
         fscanf(in,"%d",&kvadrat[i][j]);
         if( kvadrat[i][j] == 0 )
            fale.push_back( coord(j,i) );
         HASH[ kvadrat[i][j] ]=1;
      }
   }
}
short Vsize;
bool found = false;
void solve( int poz )
{
   if( found == false )
   {
      if( poz == fale.size() ){
         if( IsMagic() )found = true;
      }else{
         for(int i=0;i<Vsize;i++)
         {
            if( !HASH[ brojevi[i] ] ){
               HASH[ brojevi[i] ] = 1;
               kvadrat[ fale[poz].y ] [ fale[poz].x ] = brojevi[i];
               solve( poz+1 );
               if( !found )
               {
                  HASH[ brojevi[i] ] = 0;
                  kvadrat[ fale[poz].y ] [ fale[poz].x ] = 0;
               }
            }
         }
      }
   }
}

void proces()
{
   int i,j;
   for(i=1;i<=n*n;i++)
      if( HASH[i]==0 )
        brojevi.push_back(i);
   Vsize = brojevi.size();
   solve( 0 );
}

void out()
{
   if(found)
   {
      int i,j;
      for(i=0;i<n;i++){
         for(j=0;j<n;j++)
            printf("%d ",kvadrat[i][j]);
         printf("\n");
      }
   }else
      printf("-1\n");
}

int main()
{
   ulaz();
   proces();
   out();
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
using namespace std;
#define ll long long

ll cifre(ll n)
{
   ll ret=0;
   while( n )
   {
      ret += n%10;
      n/=10;
   }
   return ret;
}

int main()
{
   ll n,k,i;
   cin>>i>>n>>k;
   int res=0;
   for(;i<=n;i++)
      if( cifre(i)==k )
         res++;
   printf("%d\n",res);
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<algorithm>
#include<cstdio>
#include<math.h>
using namespace std;
//ofstream out("Izlaz.txt");
int main()
{
   float time;
   scanf("%f",&time);
   cout.precision(3);
   int R = (time/60)/60;
   for(int i=0;i<13;i++)
   {
      double now = 0;
      double cilj = i;
      double T;
      double res = 0;
      while( fabs( now-cilj) > 0.000001 )
      {
         T = cilj;
         res += ( ((cilj-now)*5) ) * 60;
         cilj += ( ((cilj-now)*5)/60 );
         now = T;
      } 
      res = 60*60*i + res;
      if( res > time ){
         cout<<fixed<<res<<endl;
         break;
      }
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
using namespace std;


struct line{
   float a,c;
   line( float i1,float i2):a(i1),c(i2){};
   line(){};
};

vector<line>lines;

bool comp( line A, line B)
{
  return (A.a > B.a );
}

int main()
{
   int n,i,j;
   float a1,a2;
   float res=99999999,T;
   //FILE *in = fopen("Ulaz.txt","r");
   scanf("%d",&n);
   for(i=0;i<n;i++)
   {
      scanf("%f%f",&a1,&a2);
      lines.push_back( line(a2,a1) );
   }
   sort( lines.begin(),lines.end(),comp);
      T = (( lines[1].c - lines[0].c ) / ( lines[0].a - lines[1].a ));
      if( T < res )
        res = T;
   cout.precision(2);
   cout<<fixed<<res<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;
#define ll long long




struct razlomak{
   ll b,n;
   razlomak(int a1,int a2):b(a1),n(a2){};
   razlomak(){};
};

ll ggt(ll a,ll b)
{
   ll r;
   while(b!=0)
    {
       r = b;
       b = a%b;
       a = r;
    }
    return a;
}

ll lcm(ll a,ll b)
{
   return ( (a*b)/ggt(a,b) );
}


razlomak operator+( razlomak &A,razlomak &B)
{
   razlomak ret;
   ll naz = lcm(A.n , B.n);
   A.b = A.b * (naz / A.n);
   B.b = B.b * (naz / B.n);
   ret.b = A.b + B.b;
   ret.n = naz;
   
   naz = ggt( ret.b , ret.n );
   if( naz != 0 )
   {
      ret.b /= naz;
      ret.n /= naz;
   }
   return ret; 
}

void input( razlomak &R )
{
   string S;
   ::cin>>S;
   int i;
   ll brojnik=0,nazivnik=0;
   ll fak=1;
   for(i=S.size()-1;i>=0 && S[i]!='/';i--)
   {
      nazivnik += (S[i]-'0') * fak;
      fak*=10;
   }
   fak = 1;
   for( i=i-1;i>=0;i--)
   {
      brojnik += (S[i]-'0') * fak;
      fak*=10;
   }
  R.b = brojnik;
  R.n = nazivnik;
}

razlomak A,B;

void prepare()
{
   if( A.n < B.n )
     swap(A,B);
}


int main()
{
   int i;
   ll r;
   input(A);
   input(B);
   prepare();
   razlomak res;
   res = A + B;
   cout<<res.b<<"/"<<res.n<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;
#define ll long long


bool IsPrime( long long n )
{
   static long long i;
   if(n>2 && !(n%2) )return false;
   for(i=3;i*i<=n;i+=2)
      if( !(n%i) )
           return false;
   return true;
}

ll nextPrime(ll &A)
{
   bool found = false;
   for( ll i = A+1; !found ; i++)
      if( IsPrime(i) )
         return i;
}

int main()
{
   ll A;
   cin>>A;
   cout<<nextPrime(A);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<string>
#include<vector>
#include<iomanip>
#include<set>
using namespace std;

string A,B,A1,B1;
set<string>S1;
set<string>S2;


void calc_sub(string A,string B,set<string> &insertIN)
{
   int open;
   int i,j;
   for(i=0;i<B.size();i++)
   {
      open = 0;
      for(j=i;j<B.size() && open>=0;j++)
      {
         if( B[j]=='(' )
            open++;
         else if( B[j]==')' )
            open--;
         
         if( open==0 )
              insertIN.insert( A.substr(i,j-i+1) ); 
      }
   }
}


int main()
{
   ifstream in("Ulaz.txt");
   in>>A>>A1>>B>>B1;
   calc_sub(A,A1,S1);
   calc_sub(B,B1,S2);
   set<string>::iterator it1=S1.begin();
   short res = 0,tmp;
   for( ; it1!=S1.end();it1++ )
      if( S2.count( *it1 ) == 1 && (tmp= (*it1).size() ) > res )
        res = tmp;
   printf("%d\n",res);
   system("Pause");
   return 0;
}

#include<iostream>
#include<string>
#include<fstream>
#include<cstdio>
#include<algorithm>
#include<math.h>
using namespace std;

short DP[100][100];
string DP_S[100][100];

string RES;
int LCS( string &A,string &B)
{
   int size1=A.size();
   int size2=B.size();
   int i,j;
   A=" "+A;
   B=" "+B; 
   for(i=1;i<=size1;i++)
   {
      for(j=1;j<=size2;j++)
      {
         if( A[i] == B[j] ){
            DP[i][j] = DP[i-1][j-1]+1;
            DP_S[i][j] = DP_S[i-1][j-1] + A[i];
         }else{
            DP[i][j] = max(DP[i-1][j],DP[i][j-1]);
            if( DP[i][j] == DP[i-1][j] )
               DP_S[i][j] = DP_S[i-1][j];
            else
               DP_S[i][j] = DP_S[i][j-1];
         }
      }
   }
   RES = DP_S[size1][size2];
   return DP[size1][size2];
}

int main()
{
   string A,B;
   ifstream in("SEKV.IN");
   in>>A>>B;
   
   int L = LCS(A,B);
   
   ofstream out("SEKV.OUT");
   out<<L<<endl;
   out<<RES<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<string>
#include<fstream>
#include<cstdio>
#include<algorithm>
#include<math.h>
using namespace std;

short DP[100][100];

string RES;
int LCS( string &A,string &B)
{
   int size1=A.size();
   int size2=B.size();
   int i,j;
   A=" "+A;
   B=" "+B; 
   for(i=1;i<=size1;i++)
   {
      for(j=1;j<=size2;j++)
      {
         if( A[i] == B[j] ){
            DP[i][j] = ((DP[i-1][j-1]+1)%10000)+30000;
         }else{
            DP[i][j] = max(DP[i-1][j],DP[i][j-1]);
            if(DP[i][j]==DP[i-1][j])
               DP[i][j] = (DP[i][j]%10000)+10000;
            else
               DP[i][j] = (DP[i][j]%10000)+20000;
         }
      }
   }
   i=size1; j=size2;
   while( DP[i][j]!=0 )
   {
      if( DP[i][j]/10000 == 3 ){
         RES+=A[i];
         i--;j--;
      }else if(DP[i][j]/10000 == 2)j--;
       else i--;
   }
   reverse(RES.begin(),RES.end());
   return DP[size1][size2];
}

int main()
{
   string A,B;
   ifstream in("SEKV.IN");
   in>>A>>B;
   
   int L = LCS(A,B);
   
   ofstream out("SEKV.OUT");
   out<<L%10000<<endl;
   out<<RES<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<algorithm>
#include<vector>
using namespace std;
short DP[150][150];

short ED( string A,string B)
{
   A = " "+A;
   B = " "+B;
   int i,j;
   for(i=0;i<=A.size();i++)
     DP[i][0]=i;
   for(i=0;i<=B.size();i++)
     DP[0][i]=i;
   
   short cost;
   for(i=1;i<=A.size();i++)
   {
      for(j=1;j<=B.size();j++)
      {
         if( A[i]==B[j] )
            cost = 0;
         else
            cost = 1;
         DP[i][j] = min( DP[i-1][j-1]+cost,min(DP[i-1][j]+1,DP[i][j-1]+1) );
      }
   }
   return DP[A.size()][B.size()];
}

int main()
{
   int n,i;
   string A,B;
   //ifstream cin("Ulaz.txt");
   cin>>n;
   for(i=1;i<=n*2;i++){
      if(!(i%2)){
         cin>>B;
         cout<<ED(A,B)<<endl;
      }else
         cin>>A;
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<fstream>
#include<cstdio>
#include<algorithm>
#include<math.h>
using namespace std;

char str[9];
short matrica[9][9];

bool Xhash[9][10];
bool Yhash[9][10];
bool Bhash[9][10];

short giveBox( short y,short x)
{
   return (y/3)*3 + (x/3);
}


void input()
{
   FILE *in = fopen("Ulaz.txt","r");
   int i,j;
   int poz;
   for(i=0;i<9;i++)
   {
      fgets(str,19,in);
      poz = 0;
      for(j=0;j<=16;j++)
      {
         if( str[j]!=' ' )
         {
            matrica[i][poz] = str[j] - '0';
            Xhash[poz][ matrica[i][poz] ] = 1;
            Yhash[i][ matrica[i][poz] ] = 1;
            Bhash[ giveBox(i,poz) ] [ matrica[i][poz] ] = 1;
            poz++;
         }
      }
   }
}

bool solved = false;
bool solve( int x, int y )
{
   int i,j;
   if ( !solved )
   {
      bool status;
      while( (y<9 || x<=9) && !matrica[y][x]==0  )
      {x++;
         if ( x==9 ){
            y++;
            x=0;
         }
      }
         if( y == 9 && !solved && !matrica[8][8]==0 ){
             solved = true;
             return true;
         }
         short box = giveBox( y,x ),i;
         for(i=1;i<=9;i++)
         {
            if( Xhash[x][i]==0 && Yhash[y][i]==0 && Bhash[box][i]==0 && matrica[y][x]==0 )
            {
               Xhash[x][i] = 1;
               Yhash[y][i] = 1;
               Bhash[box][i] = 1;
               matrica[y][x] = i;
               status = solve(x,y);
               if( status == false )
               {
                  Xhash[x][i] = 0;
                  Yhash[y][i] = 0;
                  Bhash[box][i]=0;
                  matrica[y][x]=0;
               }
            }
         }
   }
   if( solved == true )
      return true;
   else
      return false;
}

int main()
{
  input();
  int i,j;
  for(i=0;i<9;i++)
  {
     for(j=0;j<9;j++)
     {
        if( !matrica[i][j] )
        {
           solve(j,i);
           i  = 9;
           break;
        }
     }
  }
  for(i=0;i<9;i++)
  {
     for(j=0;j<9;j++)
     {
        cout<<matrica[i][j]<<" ";
     }cout<<endl;
  }
  system("Pause");
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
using namespace std;

bool isVowel(char &c)
{
   if(c=='a' || c=='e' || c=='i' || c=='o' || c=='u' )
      return true;
   return false;
}

int main()
{
   char I;
   int n,i,count=0;
   scanf("%d%d",&n);
   for(i=0;i<n;i++){
      scanf("%c",&I);
      if(isVowel(I))
        count++;
   }
   printf("%d\n",count);
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<algorithm>
#include<cstdio>
#include<math.h>
using namespace std;
//ofstream out("Izlaz.txt");
int main()
{
   float time;
   scanf("%f",&time);
   cout.precision(3);
   int R = (time/60)/60;
   for(int i=0;i<13;i++)
   {
      double now = 0;
      double cilj = i;
      double T;
      double res = 0;
      while( fabs( now-cilj) > 0.000001 )
      {
         T = cilj;
         res += ( ((cilj-now)*5) ) * 60;
         cilj += ( ((cilj-now)*5)/60 );
         now = T;
      } 
      res = 60*60*i + res;
      if( res > time ){
         cout<<fixed<<res<<endl;
         break;
      }
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<vector>
using namespace std;
#define ll long long

ll  DP[510][31000];
ll  value[31000];
ll  sumW[31000];
ll  t,k,w;

int sum_interval(int S,int E)
{
   int ret=0;
   for(;S<=E;S++)
      ret += value[S];
   return ret;
}

void ulaz(FILE *pok)
{
   fscanf(pok,"%d%d%d",&t,&k,&w);
   for(int i=1;i<=t;i++)
   {
      fscanf(pok,"%d",&value[i]);
      if(i<=w)
         sumW[i] = (value[i] + sumW[i-1] );
      else
         sumW[i] = ( value[i] + sumW[i-1] ) - value[i-w ];
   }
}

void proces()
{
   int i,j;
   for(i=1;i<=k;i++)
      for(j=1;j<=t;j++)
         if( j-w>=0 )
            DP[i][j] =  max(sumW[j],max( DP[i-1][j-w]+sumW[j],DP[i][j-1]) );
         else
            DP[i][j] =  max(sumW[j],DP[i][j-1]);
   printf("%d\n",DP[k][t]);
}

int main()
{
   FILE *in = fopen("Ulaz.txt","r");
   int n;
   fscanf(in,"%d",&n);
   while(n--)
   {
      ulaz(in);
      proces();
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<fstream>
using namespace std;

int h,w;
struct coord{
       short x,y;
       coord(int a,int b):x(a),y(b){};
       coord(){}
       bool ok(){ return( y<h && y>=0 && x>=0 && x<w );}
       friend coord operator + (coord &a, coord &b){
          return coord( (a.x+b.x) , (a.y+b.y) );
       }
};

coord L1,L2,T,T1;
char  bio  [1501][1501];
char  otopljeno[1501][1501];
char field[1501][1501];

queue<coord>Labud1,Labud2;
queue<coord>Voda1,Voda2;


int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   scanf("%d%d",&h,&w);
   int count=0;
   int i,j;
   for(i=0;i<h;i++)
   {
      scanf("%s",field[i]);
      for(j=0;j<w;j++)
      {
         if( field[i][j]=='L' )
         {
            if( !(count++) ) L1 = coord(j,i);
            else             L2 = coord(j,i);
            field[i][j]='.';
         }
         if(field[i][j]=='.'){otopljeno[i][j] = 1;Voda2.push( coord(j,i) );}
      }
   }
   int dan;
   coord smjer[]={ coord(0,1),coord(1,0),coord(-1,0),coord(0,-1) };
   bio[ L1.y ][ L1.x ] = 1;
   Labud2.push( L1 );
      
      
   for(dan=0 ; !bio[L2.y][L2.x];++dan)
   {
      for( ;!Voda2.empty(); Voda2.pop() ) Voda1.push( Voda2.front() );
      for( ;!Labud2.empty()   ; Labud2.pop()    ) Labud1.push   ( Labud2.front() );
      
      for( ; !Voda1.empty(); Voda1.pop() )
      {
         T = Voda1.front();
         field[T.y][T.x]='.';
         for(i=0;i<4;i++)
         {
            T1 = T + smjer[i];
            if( !T1.ok() || otopljeno[T1.y][T1.x] ) continue;
            otopljeno[T1.y][T1.x]=1;
            Voda2.push(T1);
         }
      }
      for( ; !Labud1.empty(); Labud1.pop() )
      {
         T = Labud1.front();
         for(j=0;j<4;j++)
         {
            T1 = T + smjer[j];
            if( !T1.ok() || bio[T1.y][T1.x] ) continue;
            bio[T1.y][T1.x]=1;
            if( field[T1.y][T1.x]=='.')Labud1.push(T1);
            if( field[T1.y][T1.x]=='X')Labud2.push(T1);
         }
      }
   } 
   printf("%d\n",dan-1);
   return 0;
}

#include<iostream>
#include<string>
#include<fstream>
#include<cstdio>
#include<algorithm>
#include<math.h>
using namespace std;

short DP[100][100];
string DP_S[100][100];

string RES;
int LCS( string &A,string &B)
{
   int size1=A.size();
   int size2=B.size();
   int i,j;
   A=" "+A;
   B=" "+B; 
   for(i=1;i<=size1;i++)
   {
      for(j=1;j<=size2;j++)
      {
         if( A[i] == B[j] ){
            DP[i][j] = DP[i-1][j-1]+1;
            DP_S[i][j] = DP_S[i-1][j-1] + A[i];
         }else{
            DP[i][j] = max(DP[i-1][j],DP[i][j-1]);
            if( DP[i][j] == DP[i-1][j] )
               DP_S[i][j] = DP_S[i-1][j];
            else
               DP_S[i][j] = DP_S[i][j-1];
         }
      }
   }
   RES = DP_S[size1][size2];
   return DP[size1][size2];
}

int main()
{
   string A,B;
   cin>>A>>B;
   
   int L = LCS(A,B);
   
   cout<<L<<endl;
   cout<<RES<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<string>
#include<fstream>
#include<cstdio>
#include<algorithm>
#include<math.h>
using namespace std;

short DP[100][100];

string RES;
int LCS( string &A,string &B)
{
   int size1=A.size();
   int size2=B.size();
   int i,j;
   A=" "+A;
   B=" "+B; 
   for(i=1;i<=size1;i++)
   {
      for(j=1;j<=size2;j++)
      {
         if( A[i] == B[j] ){
            DP[i][j] = ((DP[i-1][j-1]+1)%10000)+30000;
         }else{
            DP[i][j] = max(DP[i-1][j],DP[i][j-1]);
            if(DP[i][j]==DP[i-1][j])
               DP[i][j] = (DP[i][j]%10000)+10000;
            else
               DP[i][j] = (DP[i][j]%10000)+20000;
         }
      }
   }
   i=size1; j=size2;
   while( DP[i][j]!=0 )
   {
      if( DP[i][j]/10000 == 3 ){
         RES+=A[i];
         i--;j--;
      }else if(DP[i][j]/10000 == 2)j--;
       else i--;
   }
   reverse(RES.begin(),RES.end());
   return DP[size1][size2];
}

int main()
{
   string A,B;
   ifstream in("SEKV.IN");
   in>>A>>B;
   
   int L = LCS(A,B);
   
   ofstream out("SEKV.OUT");
   out<<L%10000<<endl;
   out<<RES<<endl;
   //system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
#include<iostream>
using namespace std;

struct coord{
       int x,y;
       coord(int a,int b):x(a),y(b){};
       coord(){};
};

int n;
int kvadrat[5][5];
short HASH[26];
vector<coord>fale;
vector<short>brojevi;

bool IsMagic()
{
   bool ret=true;
   int sumX,sumY;
   int diag1=0,diag2=0;
   int S,i,j;
   for(i=0;i<n && ret;i++)
   {
     sumX=sumY=0;
     diag1+=kvadrat[i][i];
     diag2+=kvadrat[n-i-1][i];
     for(j=0;j<n && ret;j++)
     {
        sumX+=kvadrat[i][j];
        sumY+=kvadrat[j][i];
     }
     if(!i)S = sumX;
     if( S!=sumX || S!=sumY )
        ret = false;
   }
   if(ret && ( S!=diag1 || S!=diag2) )
      ret = 0;
   return ret;
}

void ulaz()
{
   int i,j;
   FILE *in = fopen("Ulaz.txt","r");
   fscanf(in,"%d",&n);
   for(i=0;i<n;i++)
   {
      for(j=0;j<n;j++)
      {
         fscanf(in,"%d",&kvadrat[i][j]);
         if( kvadrat[i][j] == 0 )
            fale.push_back( coord(j,i) );
         HASH[ kvadrat[i][j] ]=1;
      }
   }
}
short Vsize;
bool found = false;
void solve( int poz )
{
   if( found == false )
   {
      if( poz == fale.size() ){
         if( IsMagic() )found = true;
      }else{
         for(int i=0;i<Vsize;i++)
         {
            if( !HASH[ brojevi[i] ] ){
               HASH[ brojevi[i] ] = 1;
               kvadrat[ fale[poz].y ] [ fale[poz].x ] = brojevi[i];
               solve( poz+1 );
               if( !found )
               {
                  HASH[ brojevi[i] ] = 0;
                  kvadrat[ fale[poz].y ] [ fale[poz].x ] = 0;
               }
            }
         }
      }
   }
}

void proces()
{
   int i,j;
   for(i=1;i<=n*n;i++)
      if( HASH[i]==0 )
        brojevi.push_back(i);
   Vsize = brojevi.size();
   solve( 0 );
}

void out()
{
   if(found)
   {
      int i,j;
      for(i=0;i<n;i++){
         for(j=0;j<n;j++)
            printf("%d ",kvadrat[i][j]);
         printf("\n");
      }
   }else
      printf("-1\n");
}

int main()
{
   ulaz();
   proces();
   out();
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<string>
#include<vector>
#include<iomanip>
#include<stack>
using namespace std;
short DP[25000][25000];

int NJZ( string A,string B)
{
   A = " " + A;
   B = " " + B;
   int maxN = 0;
   int poz = 1;
   int S = max(A.size(),B.size());
   int i,j;
   for(i=0;i<=S;i++)
      DP[i][0]=DP[0][i]=0;
   for(i=1;i<=A.size();i++)
   {
      for(j=1;j<B.size();j++)
      {
         if( A[i]==B[j] )
            DP[i][j] = DP[i-1][j-1]+1;
         else
            DP[i][j]=0;
         if( DP[i][j] > maxN )
            maxN = DP[i][j];
      }
   }
   return maxN;
}

int main()
{
   ifstream in("Ulaz.txt");
   string A,B;
   in>>A>>B;
   cout<<NJZ(A,B)<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<iomanip>
using namespace std;
int value[1000];
int size[1000];
int DP[1000][1000];

int main()
{
   int n,i,S,j;
  // FILE *in = fopen("Ulaz.txt","r");
   scanf("%d%d",&n,&S);
   for(i=1;i<=n;i++)scanf("%d%d",&size[i],&value[i]);
   for(i=1;i<=n;i++){
      for(j=1;j<=S;j++){
          if( size[i]>j)
             DP[i][j] = DP[i-1][j];
          else
             DP[i][j] = max( DP[i-1][j] , value[i] + DP[i-1][j-size[i]]);
      }
   }
   for(i=0;i<=n;i++)
   {
      for(j=0;j<=S;j++)
      {
         printf("%2d ",DP[i][j]);
      }printf("\n");
   }
   printf("MAX value = %d\n",DP[n][S]);
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
using namespace std;

struct pairI{
      int a, b;
      pairI(int b,int c):a(b),b(c){};
};

int n;
int niz1[10001];
int niz2[10001];
int hash1[10001];
int hash2[10001];

int imgV[10001];int size1=0;
int imgVpred[10001];int size2=0;

void input()
{
  // FILE *in = fopen("Ulaz.txt","r");
   int i;
   scanf("%d",&n);
   for(i=0;i<n;i++)
      scanf("%d",&niz1[i]);
   for(i=0;i<n;i++){
   scanf("%d",&niz2[i]);
      hash2[ niz2[i] ] = i;
   }
   for(i=0;i<n;i++)
      hash1[i] = hash2[ niz1[i] ] ;
}

bool comp( pairI A , pairI B )
{
   return ( A.a > B.a);
}

bool compR( pairI A , pairI B )
{
   return ( A.a < B.a);
}

void nrp()
{
   int j,i;
   int imax = 0;
   imgV[size1++] = 1;
   imgVpred[size2++] = -1;
   for(i=1;i<n;i++)
   {
      imgV[size1++]=1;
      imgVpred[size2++]=-1;
      for(j=0;j<i;j++)
      {
         if( hash1[j]+1 == hash1[i] && imgV[j]+1>imgV[i] )
         {
            imgV[size1-1] = imgV[j] + 1;
            imgVpred[size2-1] = j;
         }
      }
      if( imgV[i] >= imgV[ imax ] ) imax = i;
   }
   int topRight = hash1[imax],topLeft;
   cout<<n-imgV[imax]<<endl;
   while( imgVpred[imax] != -1 )
   {
      hash1[ imax ] = -9;
      imax = imgVpred[imax];
   }topLeft = hash1[imax];
   hash1[imax]= -9;
   vector<pairI>R,L;
   for(i=0;i<n;i++)
      if( hash1[i] != -9 ){
         if( hash1[i] < topLeft )
            L.push_back( pairI( hash1[i],niz1[i] ) );
         else
            R.push_back( pairI( hash1[i],niz1[i] ) );
      }
   sort(L.begin(),L.end(),comp);
   sort(R.begin(),R.end(),compR);
   for(i=0;i<L.size();i++)
      cout<<"l "<<L[i].b<<endl;
   for(i=0;i<R.size();i++)
      cout<<"r "<<R[i].b<<endl;
}

int main()
{
   input();
   nrp();
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdlib>
#include<queue>
#include<vector>
#include<fstream>
using namespace std;
ifstream in("Ulaz.txt");
int graph[20000][20000];

int main()
{
    int n,m,k,l,start,end;
    int i,j;
    int x,y,edge;
    int coin;
    int brojilac=0;
    int size;
    in>>n>>m>>k>>l>>start>>end;
    for(i=0;i<m;i++)
    {
        in>>y>>x>>edge;
        graph[y][x] = edge+1;
    }
    vector<int>coins;
    vector<int>pozition;
    vector<int>copy;
    for(i=0;i<l;i++)
    {
       in>>coin;
       coin++;
       coins.push_back(coin);
    }
    pozition.push_back(start);
    while(coins.size() && pozition.size() )
    {
        coin = coins.at(0);
        coins.erase(coins.begin() );
        size = pozition.size();
        for(j=0;j<size;j++)
        {
            start = pozition.at(0);
            pozition.erase(pozition.begin());
            
            for(i=0;i<n;i++)
            {
               if( graph[start][i] == coin )
               {
                   if(coins.size()==0)
                      brojilac++;
                   else
                      pozition.push_back(i);
               }
            }
        }
    }
    cout<<brojilac<<endl;
    system("Pause");
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<cstdlib>
#include<set>
#include<vector>
using namespace std;
ifstream in("Ulaz.txt");
vector<int>red[3];
set<int>poz;
set<int>::iterator pok;
int n;
int result=0;

int count(int Vpoz,int elem)
{
    int counter=0;
    poz.clear();
    for(int i=0;i<red[Vpoz].size();i++)
    {
       if( red[Vpoz].at(i)==elem)
       {
          counter++;
       }
       if( red[0].at(i)==elem || red[1].at(i)==elem || red[2].at(i)==elem)
          poz.insert(i);
    }
    return counter;
}

bool brisi()
{
     int i=0;
     result+=poz.size();
     n-=poz.size();
     for(pok = poz.begin();pok!=poz.end();pok++)
     {
         red[0].erase( red[0].begin()+ (*pok-i) );
         red[1].erase( red[1].begin()+ (*pok-i) );
         red[2].erase( red[2].begin()+ (*pok-i) );
         i++;
     }
}

int main()
{
    int input,i;
    in>>n;
    for(i=0;i<n;i++){
        in>>input;
        red[0].push_back(input);
    }
    for(i=0;i<n;i++){
        in>>input;
        red[1].push_back(input);
    }
    for(i=0;i<n;i++){
        in>>input;
        red[2].push_back(input);
    }
    bool dalje=true;
    bool uradjeno;
    while(dalje)
    {
       uradjeno = false;
       for(i=0;i<red[0].size();i++)
       {
           if( count(0,red[0].at(i))==0)
           {
               brisi();
               uradjeno = true;
           }
           else if( count(1,red[0].at(i))==0)
           {
               brisi();
               uradjeno = true;
           }
           else if( count(2,red[0].at(i))==0)
           {
               brisi();
               uradjeno = true;
           }
           
       }
       if(uradjeno == false)
          dalje = false;
    }
    cout<<result<<endl;
    system("Pause");
}

#include<iostream>
#include<fstream>
#include<cstdlib>
#include<vector>
#include<climits>
using namespace std;
ifstream in("Ulaz.txt");
int used[10000];
int interval[10000][2];
int n;
vector<int>indexes;

void solve(int poz)
{
    int i,j;
    int max1=0,max2=0;
    int poz1=-1,poz2=-1;
    int brojilac=0;
    int num=0;
    for(i=interval[poz][0];i<=interval[poz][1];i++)
    {
       brojilac=0;
       if( used[i]==0 )
       {
           for(j=0;j<n;j++)
           {
               if( interval[j][0]<=i && interval[j][1]>=i )
                  brojilac++;
           }
       }else
          num++;
       if( brojilac>max1)
       {
           poz1=i;
           max1=brojilac;
       }else if( brojilac >max2)
       {
          poz2=i;
          max2=brojilac;
       }
    }
    if(num==0)
    {
        if(poz1!=-1)
        {
           indexes.push_back(poz1);
           used[poz1]=1;
        }
        if(poz2!=-1)
        {
            indexes.push_back(poz2);
            used[poz2]=1;
        }
    }else if(num==1){
        if(max1>max2)
        {
           indexes.push_back(poz1);
           used[poz1]=1;
        }else{
           indexes.push_back(poz2);
           used[poz2]=1;
        }
    }
}

void sort()
{
     int i,j;
     int min,poz=-1;
     int temp[2];
     for(i=0;i<n;i++)
     {
        min = INT_MAX;
        for(j=i;j<n;j++)
        {
            if( interval[j][0] < min )
            {
                min = interval[j][0];
                poz = j;
            }
        }
        temp[0]=interval[i][0];
        temp[1]=interval[i][1];
        interval[i][0]=interval[poz][0];
        interval[i][1]=interval[poz][1];
        interval[poz][0] = temp[0];
        interval[poz][1] = temp[1];
     }
}

int main()
{
    int i;
    in>>n;
    for(i=0;i<n;i++)in>>interval[i][0]>>interval[i][1];
    sort();
    for(i=0;i<n;i++)
         solve(i);
    cout<<indexes.size()<<endl;
    for(i=0;i<indexes.size();i++)
       cout<<indexes.at(i)<<" ";
       cout<<endl;
    system("Pause");
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<string>
#include<algorithm>
#include<vector>
#include<ctime>
#include<climits>
using namespace std;

int start;

ifstream in("Ulaz.txt");
int minUp[100];
int minDown[100];
vector<int>A;
vector<int>B;

int main()
{
    start = clock();
    int i,j,k,l;
    string As;
    string Bs;
    getline(in,As);
    getline(in,Bs);
    for(i=0;i<As.length();i++)
    {
       A.push_back(As[i] - '0');
       B.push_back(Bs[i] - '0');
    }
    int Best;
    int BestPoz;
    int mem;
    int temp;
    bool MoguceNaci=true;
    bool NasaoPreko=false;
    bool NemaPromjene;
// MINIMALNI PREKO //
    for(i=0;i<As.length() && MoguceNaci && !NasaoPreko ;i++)
    {
        Best = 99;
        BestPoz = -1;
        for(j=0;j<As.length();j++)
        {
            if( B[j] >= A[i] && B[j]!=-1 && B[j]<Best )
            {
                Best = B[j];
                BestPoz = j;
            }
        }
        minUp[i] = B[BestPoz]; 
        B[BestPoz] = -1;
        if( Best == 99 )
           MoguceNaci = false;
        if( minUp[i] > A[i] && MoguceNaci == true )
        {
            NasaoPreko = true;
        }
    }
    if( NasaoPreko == true )
    {
        mem = i;
        for(j=0;j<As.length();j++)
        {
           if( B[j] != -1 )
           {
               minUp[i] = B[j];
               i++;
           }
        }
        sort(&minUp[mem],&minUp[i]);
    }else
    {
         NemaPromjene = true;
         for(i = As.length()-1;i>=0;i--)
         {
            for(j=i+1;j<As.length();j++)
            {
                if( minUp[j] > minUp[i] )
                {
                    temp = minUp[i];
                    minUp[i] = minUp[j];
                    minUp[j] = temp;
                    i=0;j=As.length();
                    NemaPromjene = false;
                }
            }
         }
    }
    
    
    if( MoguceNaci == false || NemaPromjene == true)
       cout<<"0"<<endl;
    else
    {
        for(i=0;i<As.length();i++)
        {
           cout<<minUp[i];
        }
        cout<<endl;
    }
////////////////////
MoguceNaci=true;
NasaoPreko=false;
bool WasStart=false;
// MINIMALNI ISPOD //
    for(i=0;i<As.length() && MoguceNaci && !NasaoPreko ;i++)
    {
        Best = -1;
        BestPoz = -1;
        for(j=0;j<As.length();j++)
        {
            if( minUp[j] <= A[i] && minUp[j]!=99 && minUp[j]>Best && WasStart  || 
                minUp[j] <= A[i] && minUp[j]!=99 && minUp[j]>Best && !WasStart && minUp[j]!=0)
            {
                Best = minUp[j];
                BestPoz = j;
            }
        }
        WasStart = true;
        minDown[i] = minUp[BestPoz]; 
        minUp[BestPoz] = 99;
        if( Best == -1 )
           MoguceNaci = false;
        if( minDown[i] < A[i] && MoguceNaci == true )
        {
            NasaoPreko = true;
        }
    }
    if( NasaoPreko == true )
    {
        mem = i;
        for(j=0;j<As.length();j++)
        {
           if( minUp[j] != 99 )
           {
               minDown[i] = minUp[j];
               i++;
           }
        }
        sort(&minDown[mem],&minDown[i]);
        reverse(&minDown[mem],&minDown[i]);
    }else
    {
         NemaPromjene = true;
         for(i = As.length()-1;i>=0;i--)
         {
            for(j=i+1;j<As.length();j++)
            {
                if( minUp[j] < minUp[i] )
                {
                    temp = minUp[i];
                    minUp[i] = minUp[j];
                    minUp[j] = temp;
                    i=0;j=As.length();
                    NemaPromjene = false;
                }
            }
         }
    }
    
    
    if( MoguceNaci == false || NemaPromjene == true)
       cout<<"0"<<endl;
    else
    {
        for(i=0;i<As.length();i++)
        {
           cout<<minDown[i];
        }
        cout<<endl;
    }
////////////////////
    cout<<"TIME:"<<clock() -start<<endl;
    system("Pause");
}

#include"Class_Counter.h"

int main()
{
    counter A;
    counter B;
    delete &B;
    delete &A;
    cout<<"MAIN"<<endl;
    system("Pause");
}

#include<iostream>
#include<fstream>
#include<cstdio>
#include<ctime>
using namespace std;

int wins[1500000];
int search[100];


int main()
{
    int start = clock();
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    int max=0;
    int k,m;
    int i,j,l;
    cin>>k>>l>>m;
    for(i=0;i<m;i++)
    {
       cin>>::search[i];
       if( ::search[i]>max )
          max = ::search[i];
    }
    wins[1] = 1;
    wins[k] = 1;
    wins[l] = 1;
    for(i=0;i<max;i++)
    {
        if(wins[i]==1)
        {
           if(wins[i+1]!=1)
              wins[i+1]=2;
           if(wins[i+k]!=1)
              wins[i+k]=2;
           if(wins[i+l]!=1)
              wins[i+l]=2;
        }
        if(wins[i]==2)
        {
           wins[i+1]=1;
           wins[i+k]=1;
           wins[i+l]=1;
        }
    }
    for(i=0;i<m;i++)
    {
       if( wins[ ::search[i] ] == 1)
          cout<<"A";
       else
          cout<<"B";
    }
    cout<<endl;
    cout<<clock()-start<<endl;
}

#include<iostream>
#include<cstdlib>
#include<cassert>
using namespace std;

class niz{
      public:
          niz();
          niz(int size);
          void push(int n);
          void pop(int poz);
          void sizeUp(int Nsize);
          void at(int poz);
      private:
          int *memory;
          int velicina;
          int elem;
};

niz::niz():memory(new int[10]),velicina(10),elem(0)
{
    assert( memory != 0 );
}

niz::niz(int size):memory(new int[size]),velicina(size),elem(0)
{
    assert( memory != 0 );
}

void niz::push(int n)
{
    if(elem<velicina)
    {
        memory[elem] = n;
        elem++;
    }else
        cout<<"I'm really full and can't have any elems anymore.\n";
}

void niz::pop(int poz)
{
     if( poz < velicina )
     {
         for(int i=poz;i<velicina-1;i++)
             memory[i] = memory[i+1];
         elem--;
     }else
         cout<<"I can't delete something that i don't have...\n";
}

void niz::at(int poz)
{
     cout<<memory[poz]<<endl;
}

int main()
{
    system("Pause");
}

#include<iostream>
#include<fstream>
#include<fstream>
#include<climits>
using namespace std;

int main()
{
    int n;
    int result=0;
    cin>>n;
    while(n>=0)
    {
       result++;
       result += n/2;
       n-=3;
    }
    cout<<result%1000000<<endl;
    system("Pause");
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<vector>
#include<cmath>
using namespace std;

ifstream in("Kablovi7.in");
int mark[20000];
vector<int>X;
vector<int>Y;

float euklido(float x,float y,float x1,float y1)
{
    return sqrt( pow( x-x1,2) + pow(y-y1,2) );
}

int main()
{
    int n;
    int i,j,k,l;
    int x,y;
    in>>n;
    for(i=0;i<n;i++)
    {
        in>>x>>y;
        X.push_back(x);
        Y.push_back(y);
    }
    vector<int>A;
    vector<int>B;
    vector<float>edge;
    vector<int>p;
    for(i=0;i<n;i++)
    {
       for(j=0;j<n;j++)
       {
          if(i!=j)
          {
             A.push_back(i);
             B.push_back(j);
             edge.push_back( euklido(X.at(i),Y.at(i),X.at(j),Y.at(j) ) );
          }
       }
       mark[i] = i;
    }
    float min;
    int poz;
    int u,z;
    float sum=0;
    while(!edge.empty())
    {
        min = INT_MAX;
        poz = -1;
        for(i=0;i<edge.size();i++)
        {
            if( edge.at(i)<min )
            {
               poz = i;
               min = edge.at(i);
            }
        }
        if( mark[ A.at(poz) ] != mark[ B.at(poz) ] )
        {
            u = mark[A.at(poz)];
            z = mark[ B.at(poz) ];
            for(i=0;i<n;i++)
            {
                if( mark[i] == z )
                   mark[i] = u;
            }
            sum += edge.at(poz);
        }
        A.erase( A.begin() + poz);
        B.erase( B.begin() + poz);
        edge.erase( edge.begin() + poz);
    }
    cout.setf(ios::showpoint);
    cout.setf(ios::fixed);
    cout.precision(2);
    cout<<sum<<endl;
    system("Pause");
}

#include <stdlib.h>
#include <stdio.h>

void s2int(char s[], int b[])
{
   int i, j;
   for (i=0; i<100; b[i]=0, i++);
   for (i=0; s[i]!=0; i++);
   for (i--, j=0 ; i>=0; b[j]=s[i]-'0', i--, j++); 
}

int lt(int n1[], int n2[])
{
   int i, manji;
   for (i=99; i>0; i--)
   {
      if (n1[i]<n2[i]) return 1;
      else if (n1[i]>n2[i]) return 0;
   }   
   return n1[0]<n2[0];
}

int le(int n1[], int n2[])
{
   int i, manji;
   for (i=99; i>0; i--)
   {
      if (n1[i]<n2[i]) return 1;
      else if (n1[i]>n2[i]) return 0;
   }   
   return n1[0]<=n2[0];
}

void duplo(int n[])
{
    int i, prenos, tmp;
    for (prenos=0, i=0; i<99; i++)
    {
       tmp = n[i] * 2;
       n[i] = tmp%10 + prenos;
       prenos = tmp / 10;
    }   
}

void minus(int n1[], int n2[], int rez[])
{
   int i, j, ponovo;
   for (i=0; i<=99; i++)
   {
      if (n2[i]<=n1[i]) 
         rez[i]=n1[i]-n2[i];
      else
      { 
         j=i+1;  
         do 
         {  
            ponovo=0;
            n1[j]--; 
            if (n1[j]==-1) 
            {
               n1[j]=9; j++; ponovo=1;
            }   
         }   
         while (ponovo);
         rez[i]=10+n1[i]-n2[i];
      }   
   }   
}

void pola(int n[])
{
    int i, prenos, tmp;
    for (prenos=0, i=99; i>=0; i--)
    {
       tmp = prenos*10 + n[i];
       n[i] = tmp/2;
       prenos = tmp%2;
    }   
}

void inc(int n[])
{
    int i;
    for (i=0; i<=99; i++)
    {
       n[i]++;
       if (n[i]<10) break;
       n[i]=0; 
    }   
}

int main()
{
    char ns[100];
    int n[100]={0}, p[100]={2}, kod[100]={0};
    int i, start; 
    FILE *fin = fopen("koder.in", "r");
    FILE *fout = fopen("koder.out", "w");
    
    fscanf(fin, "%s", ns);
    fscanf(fin, "%d", &start);
    
    s2int(ns,n);
               
    if (start==1)
    {
        while (lt(p,n)) duplo(p);
        pola(p);    
        minus(n,p,kod);
        duplo(kod);
    }
    else
    {
        while (le(p,n)) duplo(p);
        pola(p);
        minus(n,p,kod);
        duplo(kod);
        inc(kod);
    }

    for (i=99; !kod[i]; i--);
    for(; i>=0; i--) fprintf(fout, "%d", kod[i]);
     
    fclose(fin);
    fclose(fout);
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<cmath>
#include<string>
#define TES
using namespace std;
int number[100];
int result[100];
string cifre;
int length;

void divide(int n,int round = 0)
{
   float divide = ceil( number[length-1]/2.00 );
   if( divide != number[length-1]/2.00)
       if(round == 0)
          number[length-1] = number[length-1] - 1;
       else 
          number[length-1] = number[length-1] + 1;
   int a=0,counter=0,begin=0,minus,start;
   int i,j,k,l;
   bool p=false;
   bool resize = false;
   bool nuls;
   if(number[0]== 1)
      resize = true;
   for(i=0;i<length;i++)
   {
       a += number[i];
       if (number[i]!=0 && p ==false)
       {
          start = i;
          p=true;
       }           
       if( a / n > 0 )
       {
           result[begin] = a / n;
           minus = (a / n) * n;
           a = 0;
           begin++;
           p = false;
           nuls = true;
           for( j=counter+start;j>=start && minus!=0;j--)
           {
               number[j] = number[j] - (minus % 10);
               minus /=10;
               if(number[j]!=0)
                  nuls = false;
           }
           if(nuls == true && number[i+1]<2 )
           {
              result[begin] = 0;
              begin++;
           }
           counter = 0;
           i=-1;
       }else if(p==true){
           a *= 10;
           counter++;
       }     
   }
   if(resize==true)length --;
   for(i=0;i<length;i++)
       number[i] = result[i];
}

int main()
{
    char a;
    int counter;
    int i,j,k,l;
    cin>>cifre;
    for(i=0;i<cifre.length();i++)
       number[i] = cifre[i] - '0';
    length = cifre.length();
    int modus;
    int result = 1;
    int razlika = 1;
    cin>>modus;
    while(number[0]!=1 || length >1)
    {
       if(modus == 1)
       {
           if( ceil( number[length-1] / 2.00 ) != number[length-1] / 2.00)
           {
               divide(2);
               modus = 2;
               result += razlika;
               razlika *= 2;
           }else{
               divide(2,1);
               modus = 1;
               result += razlika;
               razlika *=2;
           }
       }
       else
       {
           if( ceil( number[length-1] / 2.00 ) != number[length-1] / 2.00)
           {
               divide(2,1);
               modus = 1;
               razlika *= 2;
           }else{
               divide(2,1);
               modus = 2;
               razlika *=2;
           }
       }
    }
    cout<<result<<endl;
    system("Pause");
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<string>
using namespace std;
ifstream in("Ulaz.txt");
int niz[100000];

int main()
{
    string K1,K2;
    int n1,n2;
    int step;
    int i,j,k,l;
    in>>n1>>n2;
    in>>K1>>K2;
    reverse(&K1[0],&K1[n1]);
    in>>step;
    for(i=0;i<n1;i++)niz[i]=1;
    while(step)
    {
       for(i=0;i<n1+n2-1;i++)
          if( niz[i] == 1 && niz[i+1]==0)
          {
             swap(niz[i],niz[i+1]);
             i++;
          }
       step--;
    }
    k=0;l=0;
    for(i=0;i<n1+n2;i++)
       if(niz[i]==1)
       {
          cout<<K1[k];
          k++;
       }else{
          cout<<K2[l];
          l++;
       }
    cout<<endl;
    system("Pause");
}

#include<iostream>
#include<cmath>
using namespace std;

int main()
{
    cout<<log3(1000.00);
    system("Pause");
}

#include<iostream>
#include<cstdlib>
#include<fstream>
using namespace std;
ifstream in("Ulaz.txt");
char matrica[100][100];
int w;

int dijagonal_right(int n)
{
     int i,j;
     char S;
     for(i=0;i<w-2;i++)
     {
        S = matrica[i][n];
        if( matrica[i+1][n+1]==S && matrica[i+2][n+2]==S)
        {
           cout<<S<<endl;
           i=n;;
        }
     }
     return false;
}

int dijagonal_left(int n)
{
     int counter=0,i,j;
     char S;
     for(i=0;i<w-2;i++)
     {
         S = matrica[i][n];
         if(matrica[i+1][n-1]==S && matrica[i+2][n-2]==S)
         {
             cout<<S<<endl;
             i=n;
         }
     }
     return false;
}

int horizontal(int n)
{
     int counter=0,i,j;
     char S;
     for(i=0;i<w;i++)
     {
         S = matrica[i][n];
         if(matrica[i][n+1]==S && matrica[i][n+2]==S)
         {
             cout<<S<<endl;
             return true;
             i=n;
         }
     }
     return false;
}

int vertikal(int n)
{
     int counter=0,i,j;
     char S;
     for(i=0;i<w-2;i++)
     {
         S = matrica[i][n];
         
         if(matrica[i+1][n]==S && matrica[i+2][n]==S)
         {
             cout<<S<<endl;
             i=n;
             return true;
         }
     }
     return false;
}

void solve(int n)
{
     int i,j,k,l;
     bool DoIt= true;
     for(i=0;i<n-2;i++)
        if( dijagonal_right(i))
           DoIt = false;
     if(DoIt==true)
        for(i=2;i<n;i++)
            if( dijagonal_left(i))
               DoIt = false;
     if(DoIt==true)
        for(i=0;i<n;i++)
            if( horizontal(i))
               DoIt = false;
     if(DoIt==true)
        for(i=0;i<n;i++)
            if( vertikal(i))
               DoIt = false;
        
}

int main()
{
    int i,j;
    in>>w;
    for(i=0;i<w;i++)
       for(j=0;j<w;j++)
           in>>matrica[i][j];
    solve(w);
    system("Pause");
}

#include<iostream>
#include<fstream>
#include<algorithm>
#include<cmath>
using namespace std;
ifstream in("Ulaz.txt");
int djecaci[100000];

int main()
{
    int n,i,j;
    int A,B;
    int result;
    int max = 0;
    int now;
    in>>n;
    for(i=0;i<n;i++)in>>djecaci[i];
    sort(djecaci,&djecaci[n]);
    in>>A>>B;
    if( djecaci[0] > A+1)
    {
        cout<<A+1<<endl;
    }else if( djecaci[n-1] < B-1){
        cout<<B-1<<endl;
    }else{
        for(i=0;i<n-1;i++)
        {
           now = 0;
           if( (djecaci[i]+djecaci[i+1])/2 > A && (djecaci[i]+djecaci[i+1])/2 < B)
           {
               for(j=0;j<n;j++)
               {
                  now+= abs( djecaci[j] - (djecaci[i]+djecaci[i+1])/2 );
               }
           }
           if(now>max)
           {
              max = now;
              result = (djecaci[i]+djecaci[i+1])/2;
           }
        }
        if(result%2==0)
           cout<<result+1<<endl;
        else
           cout<<result<<endl;
    }
    system("Pause");
}

#include<iostream>
#include<cmath>
#include<fstream>
#include<algorithm>
using namespace std;
ifstream in("Ulaz.txt");

int main()
{
    int n,R,r,i,j;
    int tR,tr;
    in>>n>>R;
    for(i=1;i<n;i++)
    {
       in>>r;
       tR=R;
       tr=r;
       for(j=2;j<max(R,r)/2;j++)
       {
           if( tR%j==0 && tr%j==0)
           {
              tR = tR/j;
              tr = tr/j;
              j--;
           }   
       }
       cout<<tR<<"/"<<tr<<endl;
    }
    system("Pause");
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<algorithm>
#include<cmath>
using namespace std;
ifstream in("Ulaz.txt");
int horizontal[2000];
int vertikal[2000];
int best[2000][2];


int main()
{
    int n;
    int i,j,k,l;
    in>>n;
    for(i=0;i<n;i++)in>>vertikal[i]>>horizontal[i];
    best[0][0] = vertikal[0];
    best[0][1] = horizontal[0];
    for(i=1;i<n;i++)
    {
        best[i][0]= vertikal[i] + max( best[i-1][0] + abs( horizontal[i-1] - horizontal[i]),
                                       best[i-1][1] + abs( vertikal[i-1] - horizontal[i] ));
        best[i][1]= horizontal[i] + max( best[i-1][0] + abs( horizontal[i-1] - vertikal[i]),
                                      best[i-1][1] + abs( vertikal[i-1] - vertikal[i] ));
    }
    cout<<max(best[n-1][0],best[n-1][1])<<endl;
    system("Pause");
}

#include<iostream>
#include<cmath>
#include<fstream>
#include<algorithm>
using namespace std;
ifstream in("Ulaz.txt");

int main()
{
    int n,R,r,i,j;
    int tR,tr;
    in>>n>>R;
    for(i=1;i<n;i++)
    {
       in>>r;
       tR=R;
       tr=r;
       for(j=2;j<max(R,r)/2;j++)
       {
           if( tR%j==0 && tr%j==0)
           {
              tR = tR/j;
              tr = tr/j;
              j--;
           }   
       }
       cout<<tR<<"/"<<tr<<endl;
    }
    system("Pause");
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<cmath>
#include<ctime>
using namespace std;
ifstream in("Ulaz.txt");
int horizontal[1000],vertikal[100];
int solution = 0;
int n;


void rekursia(int poz,int PrevH,int PrevV,int sum)
{
     if( sum > solution )
        solution = sum;
     if( poz < n )
     {
         rekursia(poz + 1,horizontal[poz],vertikal[poz],sum + abs( vertikal[poz] - PrevV ) + 
                  horizontal[poz]);
         rekursia(poz + 1,vertikal[poz],horizontal[poz],sum + abs( horizontal[poz] - PrevV ) + 
                  vertikal[poz]);
     }
}

int main()
{
    int start = clock();
    int i,j,k,l;
    in>>n;
    for(i=0;i<n;i++)
    {
       in>>horizontal[i];
       in>>vertikal[i];
    }
    rekursia(1,horizontal[0],vertikal[0],horizontal[0]);
    rekursia(1,vertikal[0],horizontal[0],vertikal[0]);
    cout<<solution<<endl;
    cout<<"TIME: "<< clock() - start<<endl;
    system("Pause");
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<climits>
#include<vector>
using namespace std;
ifstream in("Ulaz.txt");
int table[100000];
vector<int>hight;
vector<int>masts;
int n;
int h,m;

int MinPoz()
{
    int ret=0;
    for(int i=0;i<n;i++)
       if( hight.at(i) < hight.at(ret) )
          ret = i;
    return ret;
}


int main()
{
    int i,j,k,l;
    int minimal;
    int poz;
    int capacity;
    in>>n;
    for(i=0;i<n;i++)
    {
       in>>h>>m;
       hight.push_back(h);
       masts.push_back(m);
    }
    int maxLength=0;
    while( !hight.empty() )
    {
       minimal = MinPoz();
       poz =0;
       while( masts.at(minimal) > 0 )
       {
          if( table[poz] < hight.at(minimal) )
          {
              capacity = hight.at(minimal) - table[poz];
              if( masts.at(minimal) < capacity )
              {
                  table[poz] += masts.at(minimal);
                  masts.at(minimal) = 0;
              }else{
                  table[poz] += capacity;
                  masts.at(minimal) -= capacity;
                  hight.at(minimal) -= capacity;
              }
          }
          
          poz ++;
          if(poz > maxLength)
             maxLength = poz;
       }    
       hight.erase( hight.begin() + minimal );
       masts.erase( masts.begin() + minimal );
       n--;
    }
    int result = 0;
    for(i=0;i<maxLength;i++)
        result += table[i] * i;
    cout<<result<<endl;
    system("Pause");
}

#include<iostream>
#include<vector>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<fstream>
#include<ctime>
using namespace std;
ifstream in("sumx.09.in");
int niz[100001];

int main()
{
    int start = clock();
    int n,a,i,j,k,l,c,brojilac=0;
    int left,right;
    vector<int>nums;
    in>>n;
    for(i=0;i<n;i++)
    {
       in>>c;
       nums.push_back(c);
    }
    in>>a;
    sort(nums.begin(),nums.end());                              
    left = 0;
    right = nums.size()-1;
    while(left!=right)
    {
       if(nums.at(left) + nums.at(right)==a)
       {
          brojilac++;
          right--;
       }
       else if(nums.at(left) + nums.at(right)<a)
          left++;
       else if(nums.at(left) + nums.at(right)>a)
          right--;
    }
    cout<<brojilac<<endl;
    cout<<clock()-start<<endl;
    system("Pause");
}

#include<iostream>
#include<fstream>
#include<climits>
#include<vector>
using namespace std;

int result=INT_MAX;
vector<string>Vresult;

void rekursia(int a,int b,int brojac,vector<string>V)
{
     
    if( a==3 || b==3)
    {
        if(brojac<result)
        {
           result = brojac;
           Vresult = V;
        }
    }
    if(brojac<10)
    {
        V.push_back("PRVI = PRVI + DRUGI");
        rekursia(a+b,b,brojac+1,V);
        V.erase(V.end()-1);
        
        V.push_back("PRVI = PRVI - DRUGI");
        rekursia(a-b,b,brojac+1,V);
        V.erase(V.end()-1);
        
        V.push_back("DRUGI = DRUGI + PRVI");
        rekursia(a,b+a,brojac+1,V);
        V.erase(V.end()-1);
        
        V.push_back("DRUGI = DRUGI - PRVI");
        rekursia(a,b-a,brojac+1,V);
        V.erase(V.end()-1);
        
    }
}

int main()
{
    ifstream in("Ulaz.txt");
    int a,b;
    in>>a>>b;
    vector<string>PRAZAN;
    rekursia(a,b,0,PRAZAN);
    cout<<result<<endl;
    for(int i=0;i<Vresult.size();i++)
    {
       cout<<Vresult.at(i)<<endl;
    }
    system("Pause");
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<cstdio>
#include<algorithm>
using namespace std;
FILE *in;
int guest[50000];
int main()
{
    int n,i,j,k,l;
    int start,end;
    scanf("%d",&n);
    for(i=0;i<n;i++)scanf("%d",&guest[i]);
    return 0;
    sort(guest,guest+i);
    end = n-1;
    int sum,max=0;
    for(start = 0;start < n-1;start++)
    {
        sum = guest[start] + guest[start+1];
        if( sum < guest[ end ] )
          continue;
        max = end - start +1;
        break;
    }
    cout<<max<<endl;
    return 0;
}

#include<iostream>
using namespace std;

int niz[400000];

int main()
{
    int n,d,i,j;
    int x,y,points;
    cin>>n>>d;
    for(i=0;i<n;i++)
    {
        cin>>x>>y>>points;
        x+=d;
        for(j=x-d;j<=x+d;j++)
           niz[j] +=points;
    }
    int max=-1;
    for(i=0;i<200000;i++)
       if(niz[i]>max)
          max = niz[i];
    cout<<max;
    return 0;
}

#include<cstdio>
#include<algorithm>
#include<climits>
#include<fstream>
#include<cmath>
#include<iomanip>
using namespace std;
int old[1000000];
int better[1000000];
int novcanice[1000000];

int main()
{
    int n,i,j,maxN=0;
    scanf("%d",&n);
    for(i=0;i<n;i++)
    {
       scanf("%d",&novcanice[i]);
       if( novcanice[i] > maxN )
          maxN = novcanice[i];
    }
    sort(novcanice,greater<int>;);
    int min,oldSys,tmp,value;
    for(i=1;i<=maxN*2;i++)
    {
       min    = INT_MAX;
       value = oldSys = 0;
       tmp = i;
       for(j=0;j<n;j++)
       {
           if( novcanice[j]<= i &&
               better[ i - novcanice[j] ] + 1 < min )
                  min = better[ i - novcanice[j] ] + 1;
           if( value + novcanice[j] <= tmp )
           {
               oldSys +=(tmp / novcanice[j]);
               tmp -= (tmp / novcanice[j]) * novcanice[j];
           }
       }
       better[i] = min;
       old[i]    = oldSys;
    }
    for(i=1;i<=maxN*2;i++)
        if( better[i] != old[i] )
        {
           printf("%d\n",i);
           break;
        }
    if(i!=maxN)
       printf("0\n");
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:barn1
*/
#include<iostream>
#include<cstdlib>
#include<fstream>
#include<cmath>
#include<algorithm>
using namespace std;
ifstream in("barn1.in");
ofstream out("barn1.out");

int boards,stalls,cows;
int poz[10000];
int differ[10000];

void input()
{
    in>>boards>>stalls>>cows;
    poz[0]=(int)-1e9;
    poz[cows+1]=(int)1e9;
    for(int i=1;i<=cows;i++)in>>poz[i];
    sort(poz,poz+cows+1);
}


void find_max_difference()
{
    int i,j,k,l;
    for(i=1;i<=cows+1;i++)
       differ[i-1]=abs(poz[i-1]-poz[i]);
}

void brute_sort()
{
   int i,j;
   int poz,max;
   for(i=0;i<=cows;i++)
   {
      poz = i;
      max = differ[i];
      for(j=i+1;j<=cows;j++)
      {
         if(max<differ[j])
         {
            poz = j;
            max = differ[j];
         }
      }
      swap(differ[i],differ[poz]);
   }
}

void solve()
{     
     int res = 0;
     if(boards<=cows)
     {
        res = abs(1-poz[1]);
        res += abs(stalls-poz[cows]);
        for(int i=2;i<=boards;i++)
            res += differ[i]-1;
        out<<stalls-res<<endl;
     }else
        out<<cows<<endl;
}

int main()
{
    input();
    find_max_difference();
    brute_sort();
    solve();
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:beads
*/
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<string>
#include<fstream>
using namespace std;
ifstream in("beads.in");
ofstream out("beads.out");
string beads;
string tmp;
char color;


int main()
{
    int n,i,j,k;
    int len;
    in>>n;
    in>>beads;
    beads = beads + beads + beads;
    int start,end;
    int state;
    int max = 0;

    for(i=0;i<n*2;i++)
    {
       start = i+1;
       len   = 0;
       color = beads[i];
       state = 0;
       end = start + n - 1;
       while(color=='w' && start<end)
       {
          color=beads[start];
          start++;
          len++;
       }
       for(j=start;j<=end && state<=1 ;j++)
       {
           if(color=='r' && beads[j]=='b'){
              state++;
              color = 'b';
           }else if(color=='b' && beads[j]=='r'){
              state++;
              color = 'r';
           }
           len++;
       }
       if(len>max)
          max = len;
    }
    out<<max<<endl;
    return 0;
}

#include<iostream>
#include<cstdlib>
#include<fstream>
using namespace std;
int matrica[300][300];


int main()
{
    int n,p;
    int i,j,k,l;
    cin>>n>>p;
    int x,y;
    for(i=0;i<p;i++)
    {
       cin>>x>>y;
       matrica[x-1][y-1]=1;
    }
    int res=0;
    int size = 0;
    bool found = true;
    bool able;
    while( found )
    {
       found = false;
       for(i=0;i<n-size && found==false;i++)
          for(j=0;j<n-size && found==false;j++)
          {
             able = true;
             for(k=i;k<=i+size;k++)
                for(l=j;l<=j+size;l++)
                    if(matrica[k][l]==1)
                       able = false;
             if(able==true)
             {
                 res = size + 1;
                 found = true;
             }    
          }
       size++;
    }
    cout<<res<<endl;
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:calfflac
*/
#include<iostream>
#include<cstdlib>
#include<fstream>
#include<cstdio>
using namespace std;
ifstream in("calfflac.in");
ofstream out("calfflac.out");

struct palidrome{
       int len;
       int start;
       int end;
};
palidrome N[40000];
int poz[20000];

string clean(string source)
{
   string ret;
   int p=0;
   for(int i=0;i<source.size();i++)
   {
       if( !isspace(source[i]) && !ispunct(source[i]) && source[i]!='\n' && !isdigit(source[i]) )
       {
          ret += tolower(source[i]);
          poz[p++] = i;
       } 
          
   }
   return ret;
}

int main()
{
    string tmp;
    string txt;
    while(!in.eof())
    {
       getline(in,tmp);
       txt += tmp + '\n';
    }txt[txt.size()-1]='\n';
    string t = clean(txt);
    int pal=0;
    int i,j,k,l;
    for(i=0;i<t.length();i++)
    {
       for(j=0;t[i-j-1]==t[i+j+1];j++);
       if(j>0){
          N[pal].start = poz[i-j];
          N[pal].end   = poz[i+j];
          N[pal++].len = j*2+1;
       }
       if( t[i] == t[i+1] && i<t.length()-1 )
       {
          for(j=0;t[i-j-1]==t[i+j+2];j++);
          N[pal].start = poz[i-j];
          N[pal].end   = poz[i+j+1];
          N[pal++].len = (j+1)*2;
       }
    }
    int max=0,pi=0;
    for(i=0;i<pal;i++)
    {
       if(N[i].len>max)
       {
          pi = i;
          max = N[i].len;
       }
    }
    out<<max<<endl;
    out<<txt.substr(N[pi].start, N[pi].end - N[pi].start + 1)<<endl;
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:clocks
*/
#include<iostream>
#include<cstdlib>
#include<fstream>
#include<cstdio>
#include<cmath>
#include<vector>
using namespace std;
ifstream in("clocks.in");
ofstream out("clocks.out");
vector<int>res;

int commands[9][6]=
  { 4,0,1,3,4,-1,
    3,0,1,2,-1,-1,
    4,1,2,4,5,-1,
    3,0,3,6,-1,-1,
    5,1,3,4,5,7,
    3,2,5,8,-1,-1,
    4,3,4,6,7,-1,
    3,6,7,8,-1,-1,
    4,4,5,7,8,-1 };
    
int clock_state(int *pok)
{
   int *end = pok+9;
   bool J=true,K=true;
   for(;pok!=end;pok++)
   {
      if(*pok>12)
      {
         return -1;
         K=J=false;
      }else if(*pok<12)
         K=false;
      
   }
   if(K==true)
      return 1;
   else if(J==true)
      return 0;
   else
      return -1;
}

int plus_minus_3(int n,bool mode,int pok[9])
{
   for(int i=1;i<commands[n][0]+1;i++)
      if(mode==0)pok[ commands[n][i] ]+=3;
      else pok[ commands[n][i] ]-=3;
}

void rek(int poz,int clock[9],int times[9],vector<int>moves,int deep)
{
    int state,i,j,k,l;
    int clock_[9],times_[9];
    for(i=0;i<9;i++){ times_[i]=times[i];
                      clock_[i]=clock[i]; }
    state = clock_state( clock_ );
    if(state==-1)
    {
       for(i=0;i<9;i++)
          if(clock_[i]>12)
             clock_[i]=clock[i]-12;
       state=0;
    }
    if(state==1)
    {
       if(moves.size()>res.size())
          res = moves;
       else if(moves.size()==res.size() && res < moves)
          res = moves;       
    }else if(state==0){
       for(i=poz;i<9;i++)
       {
          if( times_[i]<3)
          {
              times_[i]++;
              plus_minus_3(i,0,clock_);moves.push_back(i+1);
              rek(i,clock_,times_,moves,deep+1);
              plus_minus_3(i,1,clock_);moves.erase(moves.end()-1);
              times_[i]--;
          }
       }
    }
}

int clock1[9];
int empty[9];
vector<int>tmp;
int main()
{
   int i,j,k,l;
   for(i=0;i<9;i++)in>>clock1[i];
   rek(0,clock1,empty,tmp,0);
   for(i=0;i<res.size()-1;i++)
      out<<res.at(i)<<" ";out<<*(res.end()-1)<<endl;
   return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:crypt1
*/
#include<iostream>
#include<cstdlib>
#include<fstream>
#include<cstdio>
using namespace std;
ifstream in("crypt1.in");
ofstream out("crypt1.out");
int allowed[10];
int n;

bool digit_check(int a,int dig)
{
   bool F=true;
   int i,N=0;
   while(a!=0 && F)
   {
      F = false;
      for(i=0;i<n;i++)
         if(a%10==allowed[i])
            F=true;
      a/=10;
      N++;
   }
   if(N==dig && F==true)
      return true;
   else
      return false;
}

int main()
{
    int i,j,k,l,m;
    int sabirak1,sabirak2,res,first,second;
    int brojilac=0;
    in>>n;
    for(i=0;i<n;i++)in>>allowed[i];
    digit_check(222,3);
    for(i=0;i<n;i++)
       for(j=0;j<n;j++)
          for(k=0;k<n;k++)
             for(l=0;l<n;l++)
                for(m=0;m<n;m++)
                {
                   first   = allowed[i]*100 + allowed[j]*10 + allowed[k];
                   second  = allowed[l]*10 + allowed[m];
                   sabirak1= allowed[l] * first;
                   sabirak2= allowed[m] * first;
                   res = first * second;
                   if( digit_check(first,3)  &&
                       digit_check(second,2) &&
                       digit_check(sabirak1,3) &&
                       digit_check(sabirak2,3) &&
                       digit_check(res,4)         )
                          brojilac++;
                }
    out<<brojilac<<endl;
    return 0;
}

#include<iostream>
#include<cstdlib>
#include<cstdio>
using namespace std;

int main()
{
    int n,d,h,i;
    scanf("%d",&n);
    scanf("%d",&h);
    d = h+0-1;
    for(i=1;i<n && i<d+1 ;i++)
    {
        scanf("%d",&h);
        if( h+i-1 > d )
           d = h+i-1;
    }
    if(d>n)cout<<n;
    else cout<<d+1<<endl;
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:dualpal
*/
#include<iostream>
#include<cstdio>
#include<fstream>
#include<cmath>
using namespace std;
ifstream in("dualpal.in");
ofstream out("dualpal.out");

char dec(int bin)
{
    if(bin==0)return '0';
    else if(bin==1)return '1';
    else if(bin==2)return '2';
    else if(bin==3)return '3';
    else if(bin==4)return '4';
    else if(bin==5)return '5';
    else if(bin==6)return '6';
    else if(bin==7)return '7';
    else if(bin==8)return '8';
    else if(bin==9)return '9';
    else if(bin==10)return 'A';
    else if(bin==11)return 'B';
    else if(bin==12)return 'C';
    else if(bin==13)return 'D';
    else if(bin==14)return 'E';
    else if(bin==15)return 'F';
    else if(bin==16)return 'G';
    else if(bin==17)return 'H';
    else if(bin==18)return 'I';
    else if(bin==19)return 'J';
    else if(bin==20)return 'K';
}

string transform(int n,int base)
{
    string ret="";
    if(base<=10)
    {
         while(n!=0)
         {
              ret += '0' +(n%base);
              n/=base;
         }
    }else if(base<=20){
         while(n!=0)
         {
             ret += dec(n%base);
             n/=base;
         }    
    }
    reverse(&ret[0],&ret[ret.size()]);
    return ret;
}

int main()
{
    int N,S,i,j,k,state;
    string pre,re;
    in>>N>>S;
    k=0;
    for(i=S+1;k<N;i++)
    {
        state=0;
        for(j=2;j<=10;j++)
        {
           pre = transform(i,j);
           re = pre;
           reverse(&re[0],&re[re.size()]);
           if(pre==re && state==1)
           {
              out<<i<<endl;
              j=11;
              k++;
           }else if(pre==re)
               state++;
        }
    }
    return 0;
}

#include<iostream>
#include<fstream>
#include<climits>
using namespace std;
int niz[1000000];

int main()
{
    int N,A,B,i,j,max=0,k;
    int fA=INT_MAX,fB=0;
    cin>>N;
    for(i=0;i<N;i++)
    {
        cin>>A>>B;
        for(j=A;j<=B;j++)
           niz[j]++;
        if(A<fA)
           fA=A;
        if(B>fB)
           fB=B;
    }
    int brojilac=0;
    for(i=fA;i<=fB;i++)
    {
       if( niz[i]>max)
          max = niz[i];
    }
    cout<<max;
    return 0;
}

#include<iostream>
#include<fstream>
#include<climits>
#include<algorithm>
using namespace std;
int event[10001][2];
int sort_normal(int from,int to)
{
     int i,j;
     int min;
     int poz;
     for(i=from;i<to;i++)
     {
        min = INT_MAX;
        poz = -1;
        for(j=i;j<to;j++)
        {
           if(min>event[j][0])
           {
              min = event[j][0];
              poz = j;
           }
        }
        swap(event[i][0],event[poz][0]);
        swap(event[i][1],event[poz][1]);
     }
}
int main()
{
    int N,A,B,i,j,max=0,k;
    int brojilac=0;
    cin>>N;
    k=0;
    for(i=0;i<N;i++)
    {
        cin>>A>>B;
        event[k][0]=A;
        event[k][1]=1;
        k++;
        event[k][0]=B;
        event[k][1]=2;
        k++;
    }
    sort_normal(0,k);
    for(i=0;i<k;i++)
    {
       if(event[i][1]==1)
          brojilac++;
       if(event[i][1]==2)
          brojilac--;
       if(brojilac>max)
          max=brojilac;
    }
    cout<<max;
    return 0;
}

#include<iostream>
#include<fstream>
#include<cstdlib>
#include<string>
using namespace std;
int varI[101];
int n;
string vars[101];

inline int poz(string a)
{
    int i;
    for(i=0;i<n;i++)if(vars[i]==a)return i;
}

int main()
{
    int c,i,j,k;
    int tmp;
    string com;
    string F,S,T;
    int p,value;
    int f1;
    cin>>n;
    for(i=0;i<n;i++)cin>>vars[i];
    cin>>c;
    for(i=0;i<c;i++)
    {
        cin>>com;
        if(com=="INC")
        {
            cin>>F>>value;
            f1 = poz(F);
            varI[f1]=(varI[f1]+value)%10000;
            
        }
        else if(com=="MUL")
        {
           cin>>F>>S>>T;
           f1 = poz(T);
           varI[f1] = varI[ poz(F) ] * varI[ poz(S)];
           varI[f1] = varI[f1]%10000;
        }
        else if(com=="ADD")
        {
           cin>>F>>S>>T;
           f1 = poz(T);
           varI[f1] = varI[ poz(F) ] + varI[ poz(S)];
           varI[f1] = varI[f1] % 10000;
        }
        else if(com=="OUT")
        {
           cin>>F;
           cout<<varI[poz(F)]<<endl;
        }
    }
    return 0;
}

#include<iostream>
#include<cmath>
#include<climits>
#include<fstream>
using namespace std;
float num[1001][51];

float euklid(int f,int s,int dimension)
{
    float ret=0;
    for(int i=0;i<dimension;i++)
    {
       ret += (num[f][i]-num[s][i]) * (num[f][i]-num[s][i]);
    }
    ret = sqrt(ret);
    return ret;
}

int main()
{
    int n,k,i,j;
    float min = INT_MAX;
    float euk;
    cin>>n>>k;
    for(i=0;i<n;i++)
       for(j=0;j<k;j++)
          cin>>num[i][j];
    for(i=0;i<n;i++)
    {
       for(j=i+1;j<n;j++)
       {
          euk = euklid(i,j,k);
          if(euk<min)
             min = euk;
       }
    }
    cout<<min<<endl;
    return 0;
}

#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int daske[1001];
int used[40000];

inline float hipotenuza(int a,int b)
{
   return sqrt(a*a + b*b);
}

int main()
{
    int n,i,j,k,res=0;
    int I;
    float hipo;
    scanf("%d",&n);
    for(i=0;i<n;i++)
    {
        scanf("%d",&daske[i]);
        used[daske[i]]=1;
    }
    sort(daske,&daske[n]);
    for(i=0;i<n;i++)
       for(j=i+1;j<n;j++)
       {
           hipo=hipotenuza(daske[i],daske[j]);
           if( hipo - ceil(hipo) == 0 )
           {
              I = (int)hipo;
              if(used[I]==1)
                 res++;
           }
       }
    printf("%d",res);
    return 0;
}

#include<iostream>
#include<cstdlib>
#include<set>
using namespace std;

int main()
{
    multiset<int>states;
    set<int>S;
    set<int>::iterator pok1;
    int n,A,k=0,i;
    cin>>n;
    for(i=0;i<n;i++)
    {
       cin>>A;
       states.insert(A);
       S.insert(A);
    }
    cin>>n;
    for(i=0;i<n;i++)
    {
       cin>>A;
       states.insert(A);
       S.insert(A);
    }
    cin>>n;
    for(i=0;i<n;i++)
    {
       cin>>A;
       states.insert(A);
       S.insert(A);
    }
    for(pok1 = S.begin();pok1!=S.end();pok1++)
    {
       if( states.count(*pok1)>2)
          k++;
    }
    cout<<k;
    return 0;
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<cmath>
#include<vector>
using namespace std;
int *download, *length;
int *sek;

int main()
{
    int n,i,j;
    scanf("%d",&n);
    download = new int[n];
    length   = new int[n];
    sek     = new int[n+1];
    for(i=0;i<n;i++){scanf("%d%d",&download[i],&length[i]);sek[i]=0;}sek[n]=0;
    for(i=n-1;i>=0;i--)sek[i] = length[i] + max( 0 , sek[i+1] - download[i]);
    cout<<sek[0];
    delete[]download;
    delete[]length;
    delete[]sek;
    return 0;
}

#include<iostream>
using namespace std;

int main()
{
    int a,b;
    cin>>a>>b;
    cout<<a+b<<endl;
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:transform
*/
#include<iostream>
#include<fstream>
#include<algorithm>
using namespace std;
FILE *in,*out;
char before[1000][1000];
char after[1000][1000];
char tmp[1000][1000];
int n;

int first_to_four_method() // 90  degree method // 180 degree method //
{                          // 270 degree method // reflection method //
    int i,j,k,l;
    bool able = true;
    bool able1 = true;
    bool able2 = true;
    bool able3 = true;
    for(i=0;i<=n;i++)
       for(j=0;j<=n;j++)
       {
          if( before[i][j]!=after[j][n-i] && able==true )
              able = false;
          if( before[i][j]!=after[n-i][n-j] && able1 == true)
              able1 = false;
          if( before[i][j]!=after[j][i] && able2==true)
              able2 = false;
          if( after[i][j]!=tmp[i][j] && able3==true)
              able3 = false;
       }
    if(able==true)
       return 1;
    else if(able1==true)
       return 2;
    else if(able2==true)
       return 3;
    else if(able3==true)
       return 4;
    else
       return 0;
      
}

bool method_five()
{
     int i,j,l;
     bool able = true;
     bool able1 = true;
     bool able2 = true;
     for(i=0;i<=n;i++)
       for(j=0;j<=n;j++)
       {
          if( tmp[i][j]!=after[j][n-i] && able==true )
              able = false;
          if( tmp[i][j]!=after[n-i][n-j] && able1 == true)
              able1 = false;
          if( tmp[i][j]!=after[j][i] && able2==true)
              able2 = false;
       }
     if(able || able1 || able2)
        return 1;
     else 
        return 0;
}

bool method_six()
{
   int i,j;
   bool able=true;
   for(i=0;i<=n;i++)
       for(j=0;j<=n;j++)
          if(before[i][j]!=after[i][j])
          {
             i=j=n+1;
             able=false;
          }
   return able;
}



int main()
{
    in = fopen("transform.in","r");
    out = fopen("transform.out","w");
    int i,j,k;
    fscanf(in,"%d",&n);n--;
    for(i=0;i<=n;i++)fscanf(in,"%s",before[i]);
    for(i=0;i<=n;i++)fscanf(in,"%s",after[i]);
    int c;
    for(i=0;i<=n;i++)
        for(j=0;j<=n;j++)
            tmp[i][j] = before[i][j];
    for(i=0;i<=n;i++)
        reverse( &tmp[i][0],&tmp[i][n+1]);
    if( c = first_to_four_method() )fprintf(out,"%d\n",c);
    else if( method_five() )fprintf(out,"5\n");
    else if( method_six() )fprintf(out,"6\n");
    else fprintf(out,"7\n");
    return 0;
}

#include<algorithm>
#include<cstdio>
using namespace std;
int niz[1000001];
char karta[5];

int main()
{
    int n,k,i;
    scanf("%d%d",&n,&k);
    int num;
    for(i=0;i<n;i++)
    {
       scanf("%s",karta);
       num = 0;
       if(karta[0]=='S')
          num += 100;
       else if(karta[0]=='L')
          num += 200;
       else if(karta[0]=='K')
          num += 300;
       else if(karta[0]=='D')
          num += 400;
       switch(karta[1])
       {
          case '2': num += 2;break;
          case '3': num += 3;break;
          case '4': num += 4;break;
          case '5': num += 5;break;
          case '6': num += 6;break;
          case '7': num += 7;break;
          case '8': num += 8;break;
          case '9': num += 9;break;
          case '1': num += 10;break;
          case 'J': num += 11;break;
          case 'Q': num += 12;break;
          case 'K': num += 13;break;
          case 'A': num += 14;break;

       }
       niz[i]=num;
    }
    sort(&niz[0],&niz[n]);
    int slovo;
    int broj;
    broj = niz[k-1]%100;
    slovo = (niz[k-1]/100)%10;
    switch(slovo)
    {
        case 1: printf("%c",'S');break;
        case 2: printf("%c",'L');break;
        case 3: printf("%c",'K');break;
        case 4: printf("%c",'D');break;
    }
    switch(broj)
       {
          case 2: printf("%c\n",'2');break;
          case 3: printf("%c\n",'3');break;
          case 4: printf("%c\n",'4');break;
          case 5: printf("%c\n",'5');break;
          case 6: printf("%c\n",'6');break;
          case 7: printf("%c\n",'7');break;
          case 8: printf("%c\n",'8');break;
          case 9: printf("%c\n",'9');break;
          case 10: printf("%c%c\n",'1','0');break;
          case 11: printf("%c\n",'J');break;
          case 12: printf("%c\n",'Q');break;
          case 13: printf("%c\n",'K');break;
          case 14: printf("%c\n",'A');break;
       }
    return 0;
}

#include<cstdio>
#include<algorithm>
using namespace std;
long long int combinations[30001];
long long int value[30001];

int main()
{
    long long int n,i;
    scanf("%lld",&n);
    for(i=0;i<n;i++)
    {
        scanf("%lld",&value[i]);
        if(i==2)
            combinations[i] = 1;
        else if(i==3)
            combinations[i]=3;
        else if(i>3)
            combinations[i] = combinations[i-1] + i-1;
    }
    sort(value,&value[n]);
    long long int result=0;
    for(i=2;i<n;i++)
        if(value[i]<0)
            result = (result + (combinations[i] *(value[i]+ 10007)))%10007;
        else 
            result = (result + (combinations[i] * value[i] % 10007)) % 10007;
    printf("%lld",result);
    return 0;
}

#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<vector>
#include<cmath>
using namespace std;
long long  niz[70][2];

inline long long  povrsina(int i,int j,int k){
    return  abs( niz[i][0]*(niz[j][1]-niz[k][1]) + niz[j][0]*(niz[k][1]-niz[i][1])+ niz[k][0]*(niz[i][1]-niz[j][1]) ); 
}

bool pripada(int i,int j,int k,int l){
    if( povrsina(i,j,k)==(povrsina(i,j,l)+povrsina(j,k,l)+povrsina(i,k,l)) )
        return true;
    else return false;
}

int main()
{
    int n,i,j,k,l;
    int brojilac=0,max=0;
    cin>>n;
    for(i=0;i<n;i++)cin>>niz[i][0]>>niz[i][1];
    for(i=0;i<n;i++)
    {
       for(j=i+1;j<n;j++)
       {
          for(k=j+1;k<n;k++)
          {
             brojilac=0;
             for(l=0;l<n;l++)
             {
                    if(pripada(i,j,k,l))
                       brojilac++;
             }
             if(brojilac>max)
                 max = brojilac;
          }
       }
    }
    printf("%d\n",max);
    return 0;
}

#include<cstdio>
using namespace std;
int *kilaze;
int *vrijednost;
int result[1001];

int main()
{
    int W,n,i,j,max;
    scanf("%d%d",&W,&n);
    kilaze     = new int[n];
    vrijednost = new int[n];
    for(i=0;i<n;i++)scanf("%d",&kilaze[i]);
    for(i=0;i<n;i++)scanf("%d",&vrijednost[i]);
    for(i=0;i<=W;i++)
    {
       max = 0;
       for(j=0;j<n;j++)
              if( kilaze[j] <= i && result[ i - kilaze[j] ] + vrijednost[j] > max )
                  max = result[i-kilaze[j] ] + vrijednost[j];
       result[i] = max;
    }
    printf("%d",result[W]);
    return 0;
}

#include<cstdio>
#include<iostream>
int value[100];
int table[50000];
int main()
{
    int n,k,i,j;
    scanf("%d%d",&n,&k);
    for(i=0;i<n;i++)scanf("%d",&value[i]);
    for(i=1;i<=k;i++)
    {
        table[i]=2000;
        for(j=0;j<n;j++)
            if( value[j] <= i && table[i]>table[i-value[j]]+1 )
                table[i] = table[i - value[j] ] + 1;
    }
    printf("%d",table[k]);system("Pause");
    return 0;
}

#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int niz[10001];
vector<int>tmp;

int main()
{
    int N,i,j;
    int A,B,C,k;
    cin>>N;
    for(i=0;i<N;i++)cin>>niz[i];
    cin>>k;
    for(i=0;i<k;i++)
    {
       cin>>A>>B>>C;
       for(j=A-1;j<B;j++)
          tmp.push_back(niz[j]);
       sort(tmp.begin(),tmp.end());
       cout<<tmp.at(C-1)<<endl;
       tmp.clear();
    }
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:milk
*/
#include<iostream>
#include<cstdlib>
#include<algorithm>
#include<fstream>
using namespace std;
ifstream in("milk.in");
ofstream out("milk.out");
int pay[5001];
int amount[5001];
int n,m,res;

void input()
{
    in>>m>>n;
    for(int i=0;i<n;i++)in>>pay[i]>>amount[i];
}

void sort()
{
    int i,j,k,l;
    int min,poz;
    for(i=0;i<n;i++)
    {
       min = pay[i];
       poz = i;
       for(j=i+1;j<n;j++)
       {
           if( pay[j]<min )
           {
               poz = j;
               min = pay[j];
           }
       }
       swap(pay[i],pay[poz]);
       swap(amount[i],amount[poz]);
    }
}

void solve()
{
    int possess=0;
    res=0;
    int poz=0;
    while( possess < m && poz<n )
    {
       if( amount[poz] + possess <= m )
       {
          res += (pay[poz]*amount[poz]);
          possess += amount[poz];
       }else{
          res += (pay[poz]*(m-possess));
          possess += amount[poz];
       }
       poz++;
    }
}

void output()
{
    out<<res<<endl;
}

int main()
{
    input();
    sort();
    solve();
    output();
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:milk2
*/

#include<iostream>
#include<cstdlib>
#include<fstream>
using namespace std;
int interval[1000000];
ifstream in("milk2.in");
ofstream out("milk2.out");

int main()
{
    int n,i,j,k;
    int start,end;
    int s=INT_MAX,e=0;
    in>>n;
    for(i=0;i<n;i++)
    {
       in>>start>>end;
       if(start<s)
          s=start;
       if(end>e)
          e=end;
       interval[start]++;
       interval[end]--;
    }
    int time=0;
    int counter=0;
    int counter1=0;
    int max=0;
    int min=0;
    for(i=s;i<=e;i++)
    {
       time += interval[i];
       if(time>0)
       {
          counter++;
          if(counter1>min)
             min = counter1;
          counter1=0;
       }
       if(time==0)
       {
          counter1++;
          if(counter>max)
             max = counter;
          counter=0;
       }
    }
    out<<max<<" "<<min<<endl;
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:namenum
*/
#include<iostream>
#include<cstdlib>
#include<fstream>
#include<string>
#include<cstdio>
using namespace std;
ifstream in("namenum.in");
ifstream dict("dict.txt");
ofstream out("namenum.out");
string serial;
string start;
int n;
string bin[100000];
int counter=0;
int HANDY[10000];

void input()
{
   in>>serial;
   n = serial.size();
   while(!dict.eof())
   {
       dict>>bin[counter++];
       if(bin[counter-1].size()!=n)
          counter--;
   }
}

void find_solution()
{
    int *digits = new int[n];
    int i,j,k,l;
    bool able,found;
    for(int i=0;i<n;i++)
        digits[i] = (serial[i] - '0');
    found = false;
    for(i=0;i<counter;i++)
    {
       able=true;
       for(j=0;j<n;j++)
          if(digits[j] != HANDY[ bin[i][j] ])
          {
             j=n;
             able  = false;
          }
       if(able==true)
       {
          out<<bin[i]<<endl;
          found = true;
       }
    }
    if( found == false )
       out<<"NONE"<<endl;
}


int main()
{
    HANDY['A']=HANDY['B']=HANDY['C']=2;
    HANDY['D']=HANDY['E']=HANDY['F']=3;
    HANDY['G']=HANDY['H']=HANDY['I']=4;
    HANDY['J']=HANDY['K']=HANDY['L']=5;
    HANDY['M']=HANDY['N']=HANDY['O']=6;
    HANDY['P']=HANDY['R']=HANDY['S']=7;
    HANDY['T']=HANDY['U']=HANDY['V']=8;
    HANDY['X']=HANDY['Y']=HANDY['Z']=9;
    input();
    find_solution();
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:palsquare
*/
#include<iostream>
#include<cstdio>
#include<fstream>
#include<cmath>
using namespace std;
ifstream in("palsquare.in");
ofstream out("palsquare.out");

char dec(int bin)
{
    if(bin==0)return '0';
    else if(bin==1)return '1';
    else if(bin==2)return '2';
    else if(bin==3)return '3';
    else if(bin==4)return '4';
    else if(bin==5)return '5';
    else if(bin==6)return '6';
    else if(bin==7)return '7';
    else if(bin==8)return '8';
    else if(bin==9)return '9';
    else if(bin==10)return 'A';
    else if(bin==11)return 'B';
    else if(bin==12)return 'C';
    else if(bin==13)return 'D';
    else if(bin==14)return 'E';
    else if(bin==15)return 'F';
    else if(bin==16)return 'G';
    else if(bin==17)return 'H';
    else if(bin==18)return 'I';
    else if(bin==19)return 'J';
    else if(bin==20)return 'K';
}

string transform(int n,int base)
{
    string ret="";
    if(base<=10)
    {
         while(n!=0)
         {
              ret += '0' +(n%base);
              n/=base;
         }
    }else if(base<=20){
         while(n!=0)
         {
             ret += dec(n%base);
             n/=base;
         }    
    }
    reverse(&ret[0],&ret[ret.size()]);
    return ret;
}

int main()
{
    int b;
    string pre,re;
    cin>>b;
    for(int i=1;i<=300;i++)
    {
       pre = transform(i*i,b);
       re = pre;
       reverse(&re[0],&re[re.size()]);
       if(pre==re)
          cout<<transform(i,b)<<" "<<pre<<endl;
    }
    return 0;
}

#include<iostream>
#include<string>
#include<cstdlib>
#include<fstream>
using namespace std;
int S[3];


int main()
{
    int n,i;
    cin>>n;
    string a;
    for(i=0;i<n;i++)
    {
       cin>>a;
       if(a=="3/4")
          S[0]++;
       else if(a=="1/2")
          S[1]++;
       else if(a=="1/4")
          S[2]++;
    }
    int p=0;
    while(S[0]>0 || S[1]>0 || S[2]>0)
    {
       if(S[0]>0)
       {
          p++;
          S[0]--;
          S[2]--;
       }else if(S[1]>0){
          p++;
          S[1]--;
          if(S[1]>0)
             S[1]--;
          else
             S[2]-=2;
       }else if(S[2]>0){
          S[2] -=4;
          p++;
       }
    }
    cout<<p;

    return 0;
}

#include<iostream>
#include<fstream>
#include<vector>
using namespace std;
ifstream in("Ulaz.txt");
string Text[10];
vector<string>Text2[10];

int main()
{
    int i,j,k,l,m,poz;
    string T;
    i=0;
    while(!in.eof())
    {
       getline(in,Text[i]);
       i++;
    }
    for(j=0;j<i;j++)
    {
        poz = 0;
        for(l=0;l<Text[j].length();l++)
        {
           if(Text[j][l]==' ')
           {
              Text2[j].push_back(Text[j].substr(poz,l-poz));
              poz =l+1;
           }
        }
        Text2[j].push_back(Text[j].substr(poz,Text[j].length()));
    }
    int counter=1;
    int temp;
    int change;
    string convert;
    for(j=0;j<i;j++)
    {
       for(k=0;k<Text2[j].size();k++)
       {
          T=Text2[j].at(k);
          change=0;
          if(T[0]!='{')
          {
              convert="";
              temp = counter;
              while(temp!=0)
              {
                  convert += '0' + (temp % 10);
                  temp /=10;
              }
              reverse(&convert[0],&convert[convert.length()]);
              for(l=j;l<i;l++)
              {
                 for(m=0;m<Text2[l].size();m++)
                 {
                    if(Text2[l].at(m)==T)
                    {
                       change++; 
                       Text2[l].at(m)="{" + convert + "}";
                    }
                 }
              }
          }
          if(change>1)
              counter++;
          Text2[j].at(k)=T;
       }
    }
    for(j=0;j<i;j++)
    {
       for(k=0;k<Text2[j].size();k++)
       {
          cout<<Text2[j].at(k)<<" ";
       }
       cout<<endl;
    }
    system("Pause");
}

/*
ID:damtrix1
LANG:C++
TASK:ride
*/
#include<iostream>
#include<cstdlib>
#include<fstream>
#include<cstdio>
using namespace std;
FILE *in,*out;
char comet[10];
char group[10];
int main()
{
    in = fopen("ride.in","r");
    out = fopen("ride.out","w");
    int i,j,k,l;
    int g1=1,g2=1;
    fscanf(in,"%s %s",comet,group);
    for(i=0;i<strlen(comet);i++)
       g1 *= comet[i] - 'A'+1;
    for(i=0;i<strlen(group);i++)
       g2 *= group[i] - 'A'+1;
    cout<<g1%47<<" "<<g2%47<<endl;
    if(g1%47==g2%47)
       fprintf(out,"GO\n");
    else
       fprintf(out,"STAY\n");
    return 0;
}

#include<iostream>
#include<cstdio>
using namespace std;
int *niz;
int n,k;
int energy=0;

int main()
{
    int i;
    cin>>n>>k;
    niz = new int [n];
    for(i=0;i<n;i++)scanf("%d",&niz[i]);  // PROBAO SAM SA C++ NAREDBOM 'cin' ali DOBIJEM TIME LIMIT EXCEEDED
                                          // ZAKLJUCAK: C JE BRZI OD C++
    for(i=0;i<n-1;i++)
    {
       if(niz[i]>k)
       {
           energy = (energy + niz[i] - k) % 1000000000;
           niz[i+1] += niz[i]-k;
       }else{
           energy = (energy + k - niz[i]) % 1000000000;
           niz[i+1] -= k - niz[i];
       }
    }
    delete [] niz;
    cout<<energy;
    return 0;
}

#include<cstdio>
#include<algorithm>
#include<iostream>
#include<fstream>
using namespace std;
ifstream in("Ulaz.txt");
string fragmenti[5];
string permutacija[5];
string first;
string second;
int matrica[6000][6000];
int m;

bool usporedba()
{
   for(int i=0;i<m;i++)
      if(fragmenti[i]!=permutacija[i])return true;
   return false;
}

bool pospremi()
{
   first="";
   for(int i=0;i<m;i++)
       first+=permutacija[i];
   second=first;
   reverse( &second[0],&second[second.size()] );
   return true;
}

int lcs()
{
    int length = first.size();
    int i,j,k,l;
    for(i=0;i<length;i++)
    {
       matrica[i][0]=0;
       matrica[0][i]=0;
    }
    for(i=1;i<=length;i++)
    {
       for(j=1;j<=length;j++)
       {
          if( first[i-1]==second[j-1] )
              matrica[i][j] = matrica[i-1][j-1]+1;
          else
              matrica[i][j] = max( matrica[i-1][j],matrica[i][j-1] );
       }
    }
    return matrica[length][length];
}

int main()
{
    int i;
    in>>m;
    for(i=0;i<m;i++)
    {
       in>>fragmenti[i];
       permutacija[i]=fragmenti[i];
    }
    int dodati;
    int result=INT_MAX;
    int counter=0;
    do{
        pospremi();
        dodati = first.size() - lcs();
        if(dodati<result)
        {
           result = dodati;
           counter = 1;
        }else if(dodati==result)
           counter++;
        next_permutation(&permutacija[0],&permutacija[m]);
    }while(usporedba());
    printf("%d\n%d\n",result,counter);
    system("Pause");
    return 0;
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<cstdio>
#include<algorithm>
using namespace std;
int parni[15000];
int neparni[15000];

bool prost(int n)
{
   if(n>2)
       for(int i=2;i<=n/2;i++)
          if(n%i==0)
             return true;
   return false;
}

int main()
{
    int A,B,i,j;
    int poz1=0,poz2=0;
    scanf("%d%d",&A,&B);
    for(i=A;i<=B;i++)
    {
       if(i%2==0)
       {
          parni[poz1] = i;
          poz1++;
       }else{
          neparni[poz2] = i;
          poz2++;
       }
    }

    bool change = false;
    for(i=poz2-1;i>=0;i--)
    {
       for(j=poz1-1;j>=0;j--)
       {
          if(prost( parni[j] + neparni[i]) )
          {
             swap( neparni[poz2-1] , neparni[i] );
             swap( parni[0],parni[j]);
             change = true;
             j=i=-1;
          }
       }
    }
    if(change)
    {
       for(i=0;i<poz2;i++)
          printf("%d\n",neparni[i]);
       for(j=0;j<poz1;j++)
          printf("%d\n",parni[j]);
    }else
       printf("0\n");
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:friday
*/
#include<iostream>
#include<fstream>
#include<cmath>
using namespace std;
ifstream in("friday.in");
ofstream out("friday.out");
int niz[7];

int week(int day,int month,int year)
{
    int n;
    if( month < 3){
       n = 365 * year + day + 31 * (month - 1)
           + (year - 1) / 4
           - 3 * ((year - 1) / 100 + 1) / 4;
    }else{
       n = 365 * year + day + 31 * (month - 1) -
           static_cast<int>(0.4 * month + 2.3) +
           year / 4 - 3 *(year / 100 + 1) / 4;
    }
    return n%7;
}

int main()
{
    int n,i,j,k;
    in>>n;
    for(i=1900;i<1900+n;i++)
       for(j=1;j<=12;j++)
          niz[week(13,j,i)]++;
    for(i=0;i<6;i++)
       out<<niz[i]<<" ";
       out<<niz[6]<<endl;
    return 0;
}

#include<iostream>
#include<fstream>
#include<string>
using namespace std;

string friends[100000];
int money[100000];
int n;

int friend_poz(string name)
{
   for(int i=0;i<n;i++)
      if(friends[i]==name)
         return i;
   return -1;
}

int main()
{
    int f,m,poz,i,j;
    string name;
    cin>>n;
    for(i=0;i<n;i++)cin>>friends[i];
    for(i=0;i<n;i++)
    {
       cin>>name;
       cin>>m>>f;
       poz = friend_poz(name);
       if(m!=0 && f!=0)
       {
           money[poz]-=m;
           money[poz]-= (((int)m/f)*f) - m;
           for(j=0;j<f && m != 0 && f != 0;j++)
           {
              cin>>name;
              money[ friend_poz(name) ]+= ((int)m/f);
           }
        }
    }
    for(i=0;i<n;i++)
       cout<<friends[i]<<" "<<money[i]<<endl;
    return 0;
}

#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<climits>
using namespace std;

int coord[100][2];
float edge[100][100];
int used[100];
float result = 0;
int n,i,j,k;

void input_prepare()
{
     scanf("%d",&n);
     for(i=0;i<n;i++)
     {
        scanf("%d%d",&coord[i][0],&coord[i][1]);
        edge[i][i]=INT_MAX;
        for(j=0;j<i;j++)
            edge[i][j] = edge[j][i] = sqrt( (coord[i][0]-coord[j][0])*(coord[i][0]-coord[j][0])+
                                            (coord[i][1]-coord[j][1])*(coord[i][1]-coord[j][1]) );
     }
     used[0]=1;
}

void minimal_spanning_tree()
{
     float min;
     int poz;
     for(i=1;i<n;i++)
     {
         min = edge[0][0];
         poz = 0;
         for(j=0;j<n;j++)
            for(k=0;k<n;k++)
               if( !used[j] && used[k] && min > edge[j][k] )
                  min = edge[ poz = j ][k];
         used[poz]=1;
         result += min;
     }
}

void solution()
{
     printf("%.2f\n",result);
}


int main()
{
    input_prepare();
    minimal_spanning_tree();
    solution();
    return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
vector<int>abc[26];
int f[26];
int tmp;
char S;

int main()
{
    int n,k,value,i,j;
    scanf("%d%d%d",&n,&k,&tmp);
    char inp;
    for(i=0;i<n;i++)
    {
       scanf("%c %d %d",&inp,&value,&tmp);
       abc[inp - 'A'].push_back(value);
    }
    for(i=0;i<26;i++)
       sort(abc[i].begin(),abc[i].end());
    int res=0;
    for(i=0;i<k;i++)
    {
       scanf("%c%d",&S,&tmp);
       f[S - 'A']++;
    }
    for(i=0;i<26;i++)
    {
       if(f[i] <= abc[i].size())
          for(j=0;j<f[i];j++)
          {
             res+=abc[i].at(j);
          }
       else
       {
          i=27;
          res = -1;
       }
    }
    printf("%d",res);
    return 0;
}

#include<cstdio>
#include<algorithm>
using namespace std;
int people[10001];

int main()
{
    int n,i;
    int call=0;
    scanf("%d",&n);
    for(i=0;i<n;i++)scanf("%d",&people[i]);
    sort(people,&people[n]);
    call = people[0];
    for(i=1;i<n && i<call+1;i++)if(people[i]>call)call=people[i];
    printf("%d",call+1);
    return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<climits>
using namespace std;
int K[3][3];
int F[3][3];

int main()
{
    int i,j,k,l;
    for(i=0;i<3;i++)
       for(j=0;j<3;j++) cin>>K[i][j];
    F[0][0] = K[1][0] + K[2][0];
    F[1][0] = K[0][0] + K[2][0];
    F[2][0] = K[0][0] + K[1][0];
    F[0][1] = K[1][1] + K[2][1];
    F[1][1] = K[0][1] + K[2][1];
    F[2][1] = K[0][1] + K[1][1];
    F[0][2] = K[1][2] + K[2][2];
    F[1][2] = K[0][2] + K[2][2];
    F[2][2] = K[0][2] + K[1][2];
    int sum = 0;
    int min = INT_MAX;
    for(i=0;i<3;i++)
       for(j=0;j<3;j++)
          for(k=0;k<3;k++)
             if(i!=j && j!=k && i!=k)
             {
                 sum = F[i][0] + F[j][1] + F[k][2];
                 if( sum<min)
                    min = sum;
             }
    cout<<min<<endl;
    return 0;
}

#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<climits>
#include<algorithm>
using namespace std;
char symbol[100000];
int value[100000];
int table[100000];
int n;
string comb[100000];

void brute_sort()
{
     int max;
     int poz,i,j;
     for(i=0;i<n;i++)
     {
        max = value[i];
        poz = i;
        for(j=i+1;j<n;j++)
        {
           if( max > value[j] ){
              poz = j;
              max = value[j];
           }
        }
        swap(value[i],value[poz]);
        swap(symbol[i],symbol[poz]);
     }
}

int main()
{
    int k,i,j,poz,predmet;
    scanf("%d%d",&n,&k);
    for(i=0;i<n;i++)scanf("%s %d",&symbol[i],&value[i]);
    brute_sort();
    for(i=1;i<=k;i++)
    {
      table[i]=INT_MAX-5;
      poz = i;
      predmet = -1;
      for(j=0;j<n;j++)
         if(value[j]<=i)
            if( table[poz]+1>table[i-value[j] ] + 1 )
            {
               poz = i-value[j];
               predmet = j;
            }
      comb[i]  = comb[poz]  + symbol[ predmet ];
      table[i] = table[poz] + 1;
    }
    if( table[k] < INT_MAX - 200 )
        cout<<comb[k]<<endl;
    else
        cout<<"Q"<<endl; 
    return 0;
}

#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int abc[3];

int main()
{
    int F,S,d;
    cin>>abc[0]>>abc[1]>>abc[2];
    sort(abc,abc+3);
    F=abs(abc[0]-abc[1]);
    S=abs(abc[1]-abc[2]);
    if(F<S)
       d = abc[1] + F;
    else if(F>S)
       d = abc[0] + S;
    else
       d = abc[2] + S;
    cout<<d<<endl;
    system("Pause");
    return 0;
}

#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
using namespace std;

void ZbirDigit(int &t,string A)
{
    for(int i=0;i<A.length();i++)
       t = t + ( A[i] - '0' );
}



int main()
{
    string A,B,min;
    int S,i,j,k,l;
    int current;
    char LastDigit;
    bool w;
    cin>>A>>B>>S;
    min = A;
    ZbirDigit(current,min);
    w=true;
    while(w)
    {
        for(i=min.length()-1;i>=0 && current<S;i--)
        {
            LastDigit = min[i];
            current += '9' - min[i];
            min[i]='9';
        }
        if(current>S)
        {
            min[i+1] = '9' - abs(current-S);
            w=false;
        }else if(current==S)
            w=false;
        if(w==true)
        {
            min = '1' + min;
            for(i=1;i<min.length();i++)min[i]='0';
            current = 1;
        }
    }
    cout<<min<<endl;
    void rek(min, /// TO DO : NAPRAVI REKURSIU KOJA CE IZRACUNATI KOLIKO JE PUTA MOGUCE DOBITI DA JE ZBIT CIFFARA JEDNAK S
    system("Pause");
    return 0;
}

#include<iostream>
#include<string>
#include<cmath>
#include<cstdio>
using namespace std;
int xH[100000];
int yH[100000];
int x[100000];
int y[100000];

int main()
{
    int n;
    int i,j,k,l;
    int res=0;
    scanf("%d",&n);
    for(i=0;i<n;i++)
    {
       scanf("%d%d",&x[i],&y[i]);
       xH[x[i]]++;
       yH[y[i]]++;
    }
    for(i=0;i<n;i++)
        res += ( xH[x[i]] - 1 ) * ( yH[y[i]] - 1 );
    cout<<res<<endl;
    system("Pause");
    return 0;
}

#include<iostream>
#include<string>
using namespace std;

char ToOkt(string S)
{
    if(S=="000")return '0';
    if(S=="001")return '1';
    if(S=="010")return '2';
    if(S=="011")return '3';
    if(S=="100")return '4';
    if(S=="101")return '5';
    if(S=="110")return '6';
    if(S=="111")return '7';
}

int main()
{
    string code;
    string res;
    cin>>code;
    while(code.length()%3)code = '0' + code;
    for(int i=0;i<code.length();i+=3)
       res += ToOkt(code.substr(i,3));
    cout<<res<<endl;
    system("Pause");
    return 0;
}

#include<iostream>
#include<string>
using namespace std;

int main()
{
    int i,j,k,l,S;
    string A;
    string R;
    cin>>A;
    for(i=2;i<A.length();i++)
       if(A.length() % i == 0)
          break;
    S=-1;
    for(j=0;j<i;j++)
    {
       S++;
       for(k=0;k<A.length()/i;k++)
          R+= A[S + (k*i)];
    }
    cout<<R<<endl;
    system("Pause");
    return 0;
}

#include <cstdio>
#include <cstring>
#include <stack>
using namespace std;
char text[100000];
char C;
int n,i,j;
stack<char>A;
stack<char>B;

int main()
{
   scanf("%s",text);
   scanf("%d%d",&n,&j);
   i=0;while(text[i]!='\0')A.push( text[i++] );
   while(n)
   {     n--;
       scanf("%c%d",&C,&j);
       if(C=='P')
       {
           scanf("%c%d",&C,&j);
           A.push(C);
       }else if(C=='L' && !A.empty() ){
           C = A.top();
           A.pop();
           B.push(C);
       }else if(C=='D' && !B.empty() ){
           C = B.top();
           B.pop();
           A.push(C);
       }else if(C=='B' && !A.empty())
           A.pop();
   }
   j=0;
   while(A.size())
   {
      text[j] = A.top();
      A.pop();
      j++;
   }text[j]='\0';
   for(i=strlen(text)-1;i>=0;i--)printf("%c",text[i]);
   while(!B.empty())
   {
      printf("%c",B.top() );
      B.pop();
   }
   return 0;
}

#include<fstream>
#include<cstdio>
#include<cmath>
using namespace std;

int ZbirCifara(int n)
{
    int res=0;
    while(n)
    {
       res += n%10;
       n/=10;
    }
    return res;
}


int main()
{
    int A,B,R=0,i,j,tmp;
    scanf("%d%d",&A,&B);
    for(i=A;i%10 && A<B ;i++)
       if( ZbirCifara(i)%2 == 0)
          R++;
    for(j=B;(j%10 || j==B) && j>=i;j--)
       if( ZbirCifara(j)%2 == 0)
          R++;
    tmp=R;
    R = R+( (abs(i-j)/10)*5 );
    if(tmp!=R && ZbirCifara(j)%2==0 )
      R++;
    if(R==536870911)R++;
    printf("%d\n",R);
    return 0;
}

#include<iostream>
#include<fstream>
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;
int i,j,l,m,n;
int h,w,k,S;
char matrica[200][200];
int polja[40005][4];
int color[40005],boja[40005];
int d[40005],d1[40005];
int poz[40005];int size=0;
int F;

inline int hash( int x,int y)
{
   return (y*w)+x+1;
}

int main()
{
    scanf("%d%d%d%d",&h,&w,&k);
    for(i=0;i<h;i++)
    {
        scanf("%s",matrica[i]);
        for(j=0;j<w;j++)
           if(matrica[i][j]=='T')
              poz[size++]= hash(j,i);
           else if(matrica[i][j]=='F'){
              F = hash(j,i);
           }
    }
///////////////////////////////////
    int p;
    for(i=0;i<h;i++)
    {
        for(j=0;j<w;j++)
        {
           if( matrica[i][j]!='X')
           {
              p = hash(j,i);
              if( j > 0 && matrica[i][j-1]!='X')
                 polja[p][0] = p-1;
              if( j < w-1 && matrica[i][j+1]!='X')
                 polja[p][1] = p+1;
              if( i>0 && matrica[i-1][j]!='X')
                 polja[p][2] = p-w;
              if( i<h-1 && matrica[i+1][j]!='X')
                 polja[p][3] = p+w;
           }
        }
    }
    queue<int>Q;
    int u;
    for(i=0;i<size;i++)
    {
       Q.push(poz[i]);
       color[poz[i]]=1;
    }
    while(!Q.empty())
    {
        u = Q.front();
        Q.pop();
        for(i=0;i<4;i++)
        {
            if( polja[u][i]>0 && color[ polja[u][i] ] == 0 )
            {
                d[ polja[u][i] ] = d[u] + 1;
                color[ polja[u][i] ] = 1;
                Q.push( polja[u][i] );
            }
        }
        color[u]=2;
    }

       
    Q.push(F);
    boja[F]=1;
    int minN=(int)2e9;
    int maxN=0;
    while(!Q.empty())
    {
       u = Q.front();
       Q.pop();
       if( d[u] > maxN )
           maxN = d[u];            
       if( d[ u] < minN )
           minN =d[u];
       for(i=0;i<4;i++)
       {
           if(polja[u][i]>0 && d1[u] + d1[ polja[u][i] ] < k && boja[ polja[u][i] ] == 0)
           {
               d1[ polja[u][i] ] = d1[u]+1;
               boja[ polja[u][i] ] = 1;
               Q.push( polja[u][i] );
               if( d[ polja[u][i] ] > maxN )
                  maxN = d[ polja[u][i] ];
                  
               if( d[ polja[u][i] ] < minN )
                  minN = d[ polja[u][i] ];
           }
       }
       boja[u]=2;
    }
    cout<<minN<<" "<<maxN<<endl;
    return 0;
}

#include<iostream>
#include<fstream>
#include<cstdio>
#include<cmath>
#include<iomanip>
using namespace std;

struct T{
       int x;
       int y;
};

class math
{
   public:
       static inline float Cal_m(T p1,T p2)
       {
               if( p1.x-p2.x!=0)
                   return (((float)p1.y-p2.y)/(p1.x-p2.x));
               else
                   return p1.x;
       }
       static inline float Cal_b(float m,T p1,T p2)
       {
           if( p1.x != p2.x)
              return p1.y - (m*p1.x);
           else
              return -1000000;
       }
};
T points[10000];
int n;

int main()
{
    int i,j,k=0,l;
    int R=0,max=0;
    float m,a,t;
    int poz=0;
    scanf("%d",&n);
    for(i=0;i<n;i++)
        scanf("%d%d",&points[i].x,&points[i].y);
    for(i=0;i<n;i++)
    {
       for(j=i+1;j<n;j++)
       {
          R=2;
          m = math::Cal_m(points[i],points[j]);
          a = math::Cal_b(m,points[i],points[j]);
          for(k=j+1;k<n;k++)
          {
             if( abs( m - (t=math::Cal_m(points[k],points[i])))<0.000001 &&
                 abs( a - math::Cal_b(t,points[i],points[k])) < 0.000001    )
                    R++;
          }
          if(R>max)
             max = R;
       }
    }
    if(n>2)
       cout<<max<<endl;
    else
       cout<<n<<endl;
    return 0;
}

#include<iostream>
#include<algorithm>
#include<string>
#include<set>
using namespace std;
int A[]={1,2,3,4,5,6,7,8};
int B[]={1,2,3,4,5,6,7,8};
set<string>perms;
set<string>::iterator it;
set<string>::iterator it2;
string tmp;

bool cmpI(int P1[9],int P2[9],int n)
{
   bool F=true;
   for(int i=0;i<n;i++)
      if( P1[i] != P2[i] )F=false;
   return F;
}

class TwoLotteryGames{
    public:
        double getHigherChanceGame(int n, int m, int k)
        {
            int i,j,l;
            do{
                tmp = "";
                for(i=0;i<m;i++)
                    tmp += '0' + B[i];
                sort(&tmp[0],&tmp[m]);
                perms.insert(tmp);
                next_permutation(B,B+n);
            } while( !cmpI(&A[0],&B[0],n) );
            double res = perms.size() * (perms.size());
            int pogodio=0;
            string Fs,Ss;
            int u;
            for(it=perms.begin();it!=perms.end();it++)
            {
               Fs = *it;
               for(it2=perms.begin();it2!=perms.end();it2++)
               {
                      u=0;
                      Ss=*it2;
                      for(i=0;i<Fs.length();i++)
                         for(j=0;j<Ss.length();j++)
                         {
                             if( Fs[i] == Ss[j] )
                                 u++;
                         }
                      if(u>=k)
                         pogodio++;
                
               }
            }
            return pogodio/res;
        }
};

int main()
{
    TwoLotteryGames A;
    cout<<A.getHigherChanceGame(3,2,1)<<endl;
    system("Pause");
}

#include<cstdio>
#include<algorithm>
using namespace std;
char command[100];
int counter[1000000];

inline int HASH_FUNCTION(int x,int y)
{
   int ret = (x * 1000000) + y;
   return ret;
}

int main()
{
   int n,i,j,k;
   int x,y;
   int key,max_=0;
   scanf("%d",&n);
   for(i=0;i<n;i++)
   {
      gets(command);
      if(command[2]=='l')
         y--;
      else if(command[2]=='r')
         y++;
      else if(command[2]=='s' )
         x++;
      else if( command[2]=='v' )
         x--;

      key = HASH_FUNCTION(x,y);
      counter[i+1]=key;
   }
   sort(counter,counter+n+1);
   int br;
   for(i=0;i<=n;i++)
   {
      br = 1;
      for(j=i+1;j<=n;j++)
      {
         if(counter[i]!=counter[j])
            break;
         br++;
      }
      if(br>max_)
         max_ = br;
   }
   printf("%d",max_);
}

#include<iostream>
#include<fstream>
#include<cstdio>
#include<cmath>
#include<iomanip>
using namespace std;

struct T{
       int x;
       int y;
};

struct LINE{
       float m;
       float k;
};

struct HELP{
       inline float Cal_m(T p1,T p2)
       {
               if( p1.x-p2.x!=0)
                   return (((float)p1.y-p2.y)/(p1.x-p2.x));
               else
                   return p1.x;
       }
       inline float Cal_b(float m,T p1,T p2)
       {
           if( p1.x != p2.x)
              return p1.y - (m*p1.x);
           else
              return -1000000;
       }
};
HELP math;
T points[10000];
LINE maxN[10000];

int n;

int main()
{
    int i,j,k=0,l;
    int res=0;
    int poz=0;
    scanf("%d",&n);
    for(i=0;i<n;i++)
        scanf("%d%d",&points[i].x,&points[i].y);
    for(i=0;i<n;i++)
    {
       for(j=i-1;j>=0;j--)
       {
          if(j!=i)
          {
              maxN[poz].m = math.Cal_m( points[i],points[j] );
              maxN[poz].k = math.Cal_b( maxN[poz].m,points[i],points[j] );
              poz++;
          }
       }
    }
    bool B;
    for(i=0;i<poz;i++)
    {
       B = true;
       for(j=i+1;j<poz;j++)
       {
           if( abs(maxN[i].m-maxN[j].m)<0.0001 && abs(maxN[i].k-maxN[j].k)<0.0001 )
              B = false;
       }
       if(B)
          res++;
    }
    cout<<res<<endl;
return 0;
}

      #include<cstdio>
      #include<iostream>
      using namespace std;
      int mod;
      int rek(int n,int O)
      {
         if( O == 0 )
            return 1;
         else{
            if( O % 2==0)
            {
               int T = rek(n,O/2) % mod;
               return ( ( T * T )%mod );
            }else{
               int T = rek(n,(int)O/2) % mod;
               return ( ( ((T*T)%mod)*n)%mod );
            }
         }
      }
      int main()
      {
          int n,o;
          scanf("%d%d%d",&n,&o,&mod);
        n=n%mod;
          int Res = rek(n,o);
          printf("%d",Res);
          return 0;
      }

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<algorithm>
#include<math.h>
using namespace std;

int H,W,K;
int res=0;
char field[200][200];

void rek(int x,int y,int deep){
   if( y==H-1 && x==W-1 ){
      res++;
   }else if( deep<K && ( x!=W-1 || y!=H-1) ){
      if(x>0 && field[y][x-1]=='.'){
         field[y][x-1]='X';
         rek(x-1,y,deep+1);
         field[y][x-1]='.';
      }
      if(x<W-1 && field[y][x+1]=='.'){
         field[y][x+1]='X';
         rek(x+1,y,deep+1);
         field[y][x+1]='.';
      }
      if(y>0 && field[y-1][x]=='.'){
         field[y-1][x]='X';
         rek(x,y-1,deep+1);
         field[y-1][x]='.';
      }
      if(y<H-1 && field[y+1][x]=='.'){
         field[y+1][x]='X';
         rek(x,y+1,deep+1);
         field[y+1][x]='.';
      }
   }
}

int main()
{
   scanf("%d%d%d%d",&H,&W,&K);
   int i,j;
   for(i=H-1;i>=0;i--){
      for(j=0;j<W;j++){
         scanf("%c",&field[i][j]);
      }scanf("%d");
   }
   field[0][0]='X';
   rek(0,0,1);
   cout<<res<<endl;
   system("Pause");
   return 0;
}

#include<cstdio>
#include<iostream>
using namespace std;

char textA[1000002];
char textB[1000002];
short a[255];
short b[255];

int main()
{
   int n,i;
   bool result=true;
   scanf("%d",&n);
   scanf("%s",textA);
   scanf("%s",textB);
   for(i=0;i<n && result;i++){
      if( a[textA[i]]==0 )
         a[textA[i]]=textB[i];
      else if( textB[i]!=a[textA[i]] )result = false;
      if( result == true ){
         if( b[textB[i]]==0 )
            b[textB[i]]=textA[i];
         else if( textA[i]!=b[textB[i]] )result = false;
      }
   }
   if(result==true)
      printf("DA\n");
   else
      printf("NE\n");
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<math.h>
#include<cstdlib>
#include<algorithm>
#include<fstream>
#include<vector>
using namespace std;

string A,B;
int Ad[200],Bd[200];
int hash[200];
int n;

void biger(){
   int i,j,k;
   bool ret;
   for(i=n-1;i>=-1;i--){
      for(j=0;j<10;j++)hash[j]=0;
      for(j=0;j<n;j++)hash[ Bd[j] ]++;
      ret = false;
      for(j=0;j<=i;j++){
         hash[ Ad[j] ]--;
         if( hash[ Ad[j] ] < 0 )ret=true;
      }
      if(ret)continue;
      if(i!=n-1)for(j=Ad[i+1]+1;j<10;j++)if( hash[j] ) break;
      if(i==n-1 || j!=10 )break;
   }
   if(i==-2){
      printf("0");return;
   }
   for(k=0;k<=i;k++)printf("%d",Ad[k]);
   if(i==n-1)return;
   printf("%d",j);
   hash[j]--;
   for(j=0;j<10;j++)
      while(hash[j]--)printf("%d",j);
}

void smaler(){
   int i,j,k;
   bool ret;
   for(i=n-2;i>=-1;i--){
      for(j=0;j<10;j++)hash[j]=0;
      for(j=0;j<n;j++)hash[ Bd[j] ]++;
      ret = false;
      for(j=0;j<=i;j++){
         hash[ Ad[j] ]--;
         if( hash[ Ad[j] ] < 0 )ret=true;
      }
      if(ret)continue;
      if(i!=n-1)for(j=Ad[i+1]-1;j>=0;j--)if( hash[j] ) break;
      if(i==n-1 || j!=-1 )break;
   }
   if(i==-1 && j==0){
      printf("0");return;
   }
   if(i==-2 || j==-1){
      printf("0");return;
   }
   for(k=0;k<=i;k++)printf("%d",Ad[k]);
   if(i==n-1)return;
   printf("%d",j);
   hash[j]--;
   for(j=9;j>=0;j--)
      while(hash[j]--)printf("%d",j);
}

int main()
{
  int i;
   //ifstream in("Ulaz.txt");
  cin>>A>>B;
  n = A.size();
  for(i=0;i<n;i++){
    Ad[i]= A[i]-'0';
    Bd[i]= B[i]-'0';
  }
  biger();printf("\n");
  smaler();printf("\n");
  //system("Pause");
  return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;

int main()
{
   int dan,mjesec,godina;
   godina = 2009;
   cin>>dan>>mjesec;
   long datum;
   if( mjesec < 3 ){
      datum = 365 * godina + dan + 31 *(mjesec-1) + (godina-1) / 4 - 3*((godina-1)/100 + 1) / 4;
   }else{
      datum = 365 * godina + dan + 31 *(mjesec-1) - static_cast<int>(0.4*mjesec+2.3) + godina / 4 - 3 * (godina / 100 + 1) / 4;
   }
   switch( datum%7 ){
      case 0:
         cout<<"Saturday"<<endl;
         break;
      case 1:
         cout<<"Sunday"<<endl;
         break;
      case 2:
         cout<<"Monday"<<endl;
         break;
      case 3:
         cout<<"Tuesday"<<endl;
         break;
      case 4:
         cout<<"Wednesday"<<endl;
         break;
      case 5:
         cout<<"Thursday"<<endl;
         break;
      default:
         cout<<"Friday"<<endl;
         break;

   }
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;

short niz[5];

int main()
{
   int i,j;
   for(i=0;i<5;i++)scanf("%d",&niz[i]);
   bool dalje = true;
   while(dalje)
   {
      dalje = false;
      for(i=0;i<4;i++)
         if( niz[i]>niz[i+1] ){
            swap(niz[i],niz[i+1]);
            for(j=0;j<5;j++)
               printf("%d ",niz[j]);printf("\n");
               dalje = true;
         }
   }
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
#include<cctype>
using namespace std;

struct coord{
   int x,y;
   char val;
   coord(int p1,int p2,char p3):x(p1),y(p2),val(p3){};
   coord(){};
};

int H,W,H1,W1;
char field[15][15];
vector<coord>ToChange;


void r45(bool type)
{
   ToChange.clear();
   if( type == true ){
      static bool change = false;
      int space;
      if( change == false )
         space = min(H,W);
      else
         space = max(H,W);
      change = !change;
      int poz;
      int i,j;
      for(i=0;i<H;i++){
         poz = 0;
         space--;
         for(j=0;j<W;j++){
            ToChange.push_back( coord( space+j,j+i,field[i][j]) );
            field[i][j]=' ';
         }
      }
      for(i=0;i<ToChange.size();i++){
         field[ ToChange[i].y ] [ ToChange[i].x ] = ToChange[i].val;
      }
   }else{
      static bool nacin2 = false;
      int T,T2;
      if( nacin2 == false ){
         T = W;
         T2 = W;
      }else{
         T = H;
         T2 = H;
      }nacin2=!nacin2;
      int SH=0,SW=0;
      int i,j,k;
      for(i=0;i<H;i++){
         for(j=0;j<T2 && field[i][j]==' ';j++);
         for(k=0;k<T;k++){
            ToChange.push_back( coord( j,k,field[i+k][j+k]) );
         }
      }
      for(i=0;i<14;i++)for(j=0;j<14;j++)field[i][j]=' ';
      for(i=0;i<ToChange.size();i++){
         field[ ToChange[i].y ] [ ToChange[i].x ] = ToChange[i].val;
      }
      swap(H,W);
   }
   
}

int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   int i,j,angle;
   scanf("%d%d",&H,&W);
   H1 = H+W-1;
   W1 = H1;
   for(i=0;i<H;i++){
      scanf("%s",field[i]);
   }
   scanf("%d",&angle);
   int now=0;
   bool nacin=true;
   while(now!=angle){
      r45(nacin);
      nacin = !nacin;
      now+=45;
   }
   if( nacin == false ) H = H1, W = W1;
   bool daljeN;
   if( nacin == 0 )
   {
   for(i=0;i<H;i++)
   {
      daljeN = true;
      for(j=0;j<W && !isalpha(field[i][j]);j++)cout<<field[i][j];
      for(; isalpha(field[i][j]);j+=2){
         cout<<field[i][j];
         if( isalpha(field[i][j+2] ) )cout<<" ";
      }
         cout<<endl;
   }
   }else{
      for(i=0;i<H;i++)
   {
      for(j=0;j<W && ( daljeN || ( !daljeN && (field[i][j+1]!=' ' ) )  );j++)
      {
         cout<<field[i][j];//<<endl;
         
      }cout<<endl;
   }
   }
   //system("Pause");
   return 0;
}

#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<vector>
using namespace std;

int n,res;
int matrica[100][100];
int fun[100];
bool notlike[100];
bool prev[100];

void rek( bool *field, int search, int N , int deep )
{
   if( N > res ) res = N;
   for( int i=search;i<n;i++ )
   {
      if( notlike[i] == 1 ){
         vector<bool>save(n,false);
         for(int j=0;j<n;j++)
            notlike[j] = (save[j]=notlike[j]) && matrica[i][j];
         rek( notlike , i+1 , N + fun[i] ,deep+1);
         for(int j=0;j<n;j++)
            notlike[j] = save[j];
      }
   }
}

int main()
{
   scanf("%d",&n);
   for(int i=0;i<n;i++)
   {
      scanf("%d",&fun[i]);
      notlike[i]=1;
      for(int j=0;j<n;j++)
         scanf("%d",&matrica[i][j]);
   }
   rek(notlike,0,0,0);
   printf("%d\n",res);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<fstream>
#include<vector>
using namespace std;

int n;
int niz[2001];
int size[2001];
int prev[2001];

int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   int i,j;
   scanf("%d",&n);
   for(i=0;i<n;i++)scanf("%d",&niz[i]);
   sort(niz,niz+n);
   int imax=0;
   prev[0]=-1;
   for(i=1;i<n;i++){
      prev[i]=-1;
      for(j=0;j<i;j++){
         if( niz[i]%niz[j]==0 && size[j]+1>size[i] ){
            prev[i] = j;
            size[i]=size[j]+1;
         }
      }
      if( size[imax]<size[i] )
         imax = i;
      else if( size[imax]==size[i] && prev[i]!=-1 ){
         int F = imax, S = i;
         bool passes = false;
         vector<int>tmp1,tmp2;
         while( F!=-1 && S!=-1  ){
            tmp1.push_back( niz[F] );
            tmp2.push_back( niz[S] );
            F = prev[F];
            S = prev[S];
         }
//         cout<<F<<" "<<S<<endl;
//         for(j=0;j<tmp1.size();j++)
//            cout<<tmp1.at(j)<<" ";cout<<endl;
//         for(j=0;j<tmp2.size();j++)
//            cout<<tmp2.at(j)<<" ";cout<<endl;

         passes= !lexicographical_compare( tmp1.rbegin(),tmp1.rend(),
                                         tmp2.rbegin(),tmp2.rend() );
//         if( passes )cout<<"TAKE SECOND"<<endl;
//         else cout<<"TAKE FIRST"<<endl;

         if( passes ) imax = i;
      }


   }
   vector<int>res;
   while(imax!=-1 ){
      res.push_back(niz[imax]);
      imax = prev[imax];
   }
   sort(res.begin(),res.end());
   int sizeN = res.size();
   printf("%d\n",sizeN);
   for(i=0;i<res.size();i++)
      printf("%d ",res[i]);printf("\n");
system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<math.h>
using namespace std;

int main()
{
   long long n,m;
   scanf("%lld%lld",&n,&m);
   long long res2 = m+n+1+__gcd(m,n)+ ( ((n-1)*(m-1)-__gcd(m,n))/2 );
   if(n==0)
      printf("%lld\n",m+1);
   else if(m==0)
      printf("%lld\n",n+1);
   else
      printf("%lld\n",res2);
   //system("Pause");
   return 0;
}


#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstdio>
#include<math.h>
#include<vector>
using namespace std;

struct coord{
       int x,y;
       coord(int a,int b):x(a),y(b){};
       coord(){};
};


bool comp( coord A,coord B)
{
   if( A.x < B.x ) return 1;
   if( A.x == B.x && A.y < B.y ) return 1;
   return 0;
}

int xS,yS;
int n;
vector<coord>V;

bool bsearch(int s,int e)
{
   if( s>e)
      return 0;
   else
   {
      int mid = (s+e)/2;
      if( V[mid].x > xS )
         return bsearch(s,mid-1);
      else if( V[mid].x < xS )
         return bsearch(mid+1,e);
      else if( V[mid].y > yS )
         return bsearch(s,mid-1);
      else if( V[mid].y < yS )
         return bsearch(mid+1,e);
      else return 1;
   }
}

int main()
{
   int a,b,i,j;
  // FILE *in = fopen("Ulaz.txt","r");
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d%d",&a,&b);
      V.push_back( coord(a,b) );
   }
   sort(V.begin(),V.end(),comp);
   int res=0;
   int t1,t2;
   int x1,y1;
   int x2,y2;
   int x3,y3;
   int x4,y4;
   bool F1,F2,F3,F4;
   for(i=0;i<n;i++)
   {
      for(j=i+1;j<n;j++)
      {
         t1 = (V[i].x-V[j].x);
         t2 = (V[i].y-V[j].y);
         x1=V[i].x-t2; x2=V[j].x-t2;
         y1=V[i].y+t1; y2=V[j].y+t1;
         x3=V[i].x+t2; x4=V[j].x+t2;
         y3=V[i].y-t1; y4=V[j].y-t1;
         F1=F2=F3=F4=false;
         xS=x1;yS=y1; F1 = bsearch(j+1,n);
         xS=x2;yS=y2; F2 = bsearch(j+1,n);
         xS=x3;yS=y3; F3 = bsearch(j+1,n);
         xS=x4;yS=y4; F4 = bsearch(j+1,n);
         if(F1==F2 && F1==1)res+=1;
         if(F3==F4 && F4==1)res+=1;
      }
   }
   cout<<res<<endl;
   //system("Pause");
   return 0;
}

#include<cstdio>
#include<cctype>
#include<string>
#include<cstring>
#include<math.h>
#include<string>
#include<iostream>
#include<fstream>
using namespace std;
string text;
bool PASS[255];
int x=0,y=0;
int main()
{
   PASS[(int)'s']=1;
   PASS[(int)'e']=1;
   PASS[(int)'w']=1;
   PASS[(int)'n']=1;
   //ifstream in("Ulaz.txt");
   getline(cin,text);
   int i,prev,fak,num;
   int n = text.size();
   for(i=0;i<n;i++)
   {
      if( PASS[ text[i] ] ){
        prev = i;
        num=0;
        if( isdigit(text[i+1]) ){
           if(isdigit(text[i+2]))num = (text[i+1]-'0')*10 + (text[i+2]-'0');
           else num = text[i+1]-'0';
        }
        //cout<<text[prev]<<" "<<num<<endl;
        if( text[prev]=='n' ) y+=num;
        else if( text[prev]=='s') y-=num;
        else if( text[prev]=='e') x+=num;
        else if( text[prev]=='w') x-=num;
      }
   }
   //cout<<y<<" "<<x<<endl;
   printf("%.2f\n", sqrt( x*x + y*y ) );
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;

struct film{
   int S,E,V,prev;
   film(int a,int b,int c):S(a),E(b),V(c),prev(0){};
   film(){};
};

vector<film*>sve;

bool comp( film *A,film *B ){
   return ( A->E < B->E );
}

int n;
int DP[100001];
int bsearch(int S,int E,int v )
{
   int mid = (S+E)>>1;
   if( (mid==n) || sve[mid]->E<v && sve[mid+1]->E>=v )
      return mid;
   else if( sve[mid]->E >= v )
      return bsearch(S,mid,v);
   else
      return bsearch(mid,E,v);
}

int search(int a, int b, int w)
{
   int dif = w+1, elem=0;
   int mid, tmp;
   while(a<=b)
   {
      mid =(a+b)>>1; //(a+b)/2;
      tmp = w - sve[mid]->E;
      if(tmp>0)
      {
         if(dif>tmp || (dif==tmp && DP[elem]<DP[mid]) )
         {
             dif = tmp;
             elem = mid;
         }
         a = mid+1;
      }else
         b = mid-1;
   }
   return elem;
}

int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   int a,b,c;
   int i,j;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d%d%d",&a,&b,&c);
      sve.push_back( new film(a,b,c) );
   }
   sort( sve.begin(),sve.end(),comp );
   for(i=0;i<n;i++)
   {
      if( sve[i]->S > sve[0]->E )
         sve[i]->prev = bsearch(0,n,sve[i]->S)+1;
      else
         sve[i]->prev = 0;
      DP[i+1] = max( sve[i]->V + DP[ sve[i]->prev ] , DP[i] );
   }
   cout<<DP[n]<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;
 
struct film{
   int S,E,V,prev;
   film(int a,int b,int c):S(a),E(b),V(c),prev(0){};
   film(){};
};
 
vector<film*>sve;

bool comp( film *A,film *B ){
   return ( A->E < B->E );
}
 
int n;
int DP[100001];
int bsearch(int S,int E,int v )
{
   int mid = (S+E)>>1;
   if( (mid==n) || sve[mid]->E<v && sve[mid+1]->E>=v )
      return mid;
   else if( sve[mid]->E >= v )
      return bsearch(S,mid,v);
   else
      return bsearch(mid,E,v);
}
 
int search(int a, int b, int w)
{
   int dif = w+1, elem=0;
   int mid, tmp;
   while(a<=b)
   {
      mid =(a+b)>>1; //(a+b)/2;
      tmp = w - sve[mid]->E;
      if(tmp>0)
      {
         if(dif>tmp || (dif==tmp && DP[elem]<DP[mid]) )
         {
             dif = tmp;
             elem = mid;
         }
         a = mid+1;
      }else
         b = mid-1;
   }
   return elem;
}
 
int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   int a,b,c;
   int i,j;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d%d%d",&a,&b,&c);
      sve.push_back( new film(a,b,c) );
   }
   sort( sve.begin(),sve.end(),comp );
   for(i=0;i<n;i++)
   {
      if( sve[i]->S > sve[0]->E )
         sve[i]->prev = bsearch(0,n,sve[i]->S)+1;
      else
         sve[i]->prev = 0;
      DP[i+1] = max( sve[i]->V + DP[ sve[i]->prev ] , DP[i] );
   }
   cout<<DP[n]<<endl;
   //system("Pause");
   return 0;
}
#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdio>
#include<cstdlib>
#include<fstream>
#include<stack>
using namespace std;
#define prazno '.'
#define block '#'
#define visited 'x'
#define py popE.y
#define px popE.x

struct coord{
       int x,y;
       coord(int p1,int p2):x(p1),y(p2){}
       coord(){};
};

char field[1001][1001];

int h,w;
int povrsina;

int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   int i,j;
   int MAXN = 0;
   scanf("%d%d",&h,&w);
   for(i=0;i<h;i++)
      scanf("%s",&field[i]);
   stack<coord>S;
   coord popE;
   for(i=0;i<h;i++){
      for(j=0;j<w;j++){
         if( field[i][j] == prazno )
         {
            povrsina = 0;
            S.push( coord(j,i) );
            while( !S.empty() )
            {
                  popE = S.top();
                  S.pop();
                  if( field[py][px] == prazno ){
                  povrsina++;
                  field[py][px] = visited;
                  if( px>0  ) S.push(coord(px-1,py));
                  if( px<w-1) S.push(coord(px+1,py));
                  if( py>0  ) S.push(coord(px,py-1));
                  if( py<h-1) S.push(coord(px,py+1));
               }
            }
            if( povrsina > MAXN ) MAXN = povrsina;
         }
      }
   }
   printf("%d\n",MAXN);
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<vector>
using namespace std;

struct coord{
       double x,y;
       coord(double p1,double p2):x(p1),y(p2){};
       coord(){};
};


double d(coord A,coord B){
   return sqrt( (B.x-A.x)*(B.x-A.x) + (B.y-A.y)*(B.y-A.y) );
}

double dist( coord centar, coord T1,coord T2)
{
   static double A,B,C,D,xI,yI,dot,len_sq,param;
   A = centar.x - T1.x;
   B = centar.y - T1.y;
   C = T2.x - T1.x;
   D = T2.y - T1.y;
   dot =  A*C + B*D;
   len_sq = C*C + D*D;
   
   param = dot / len_sq;
   xI,yI;
   
   if( param<0 )
   {
      xI = T1.x;
      yI = T1.y;
   }else if(param>1){
      xI = T2.x;
      yI = T2.y;
   }else{
      xI = T1.x + param * C;
      yI = T1.y + param * D;
   }
   return d(centar,coord(xI,yI) );
}

int main()
{
  // FILE *in = fopen("Ulaz.txt","r");
   coord T;
   double x,y,x1,y1;
   vector<double>sorted;
   int n,k,i;
   scanf("%lf%lf",&T.x,&T.y);
   scanf("%d%d",&n,&k);
   for(i=0;i<n;i++)
   {
      scanf("%lf%lf%lf%lf",&x,&y,&x1,&y1);
      sorted.push_back(dist( T, coord(x,y),coord(x1,y1) ));
   }
   sort(sorted.begin(),sorted.end());
   printf("%.2lf\n",sorted[k-1]);
   //system("Pause");
   return 0;
}

#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<stack>
#include<set>
#include<queue>
#include<vector>
using namespace std;
const int inf = (int)10e9;

struct edge{
   int dist,tree,end;
   edge(int p1,int p2,int p3):dist(p1),tree(p2),end(p3){};
   edge(){};
};

struct duo{
   int a,b;
   duo(int p1,int p2):a(p1),b(p2){};
};

int n,m;
vector<edge>way[10020];
int dist[10020];
int avarage[10020];

class comp{
   public:
      bool direction;       
      comp( bool rastuci ):direction(rastuci){};
      comp():direction(true){};       
      bool operator()( const int &A, const int &B) const{   
         if(dist[A]>dist[B])return 1;
         else if( dist[A]==dist[B] && avarage[A]<avarage[B]) return 1;
         return 0;
      }            
};           

void shortest(int source)
{
   int i,u;
   int node,val,alt;
   priority_queue< int , vector<int> , comp >Q;
   for(i=1;i<=n;i++){
      dist[i]=inf;
      if(i!=source)Q.push(i);
   }
   dist[source]=0;
   Q.push( source );
   int sizeN = n;
   while(dist[Q.top()] != inf && !Q.empty())
   {
   //   val = dist[Q.top()];
      node= Q.top();
      Q.pop();
      //cout<<node<<" "<<val<<endl;    
      for(i=0;i<way[node].size();i++)
      {
         alt = dist[node]+ way[node][i].dist;
         if( alt < dist[way[node][i].end] )
         {
            avarage[way[node][i].end] = avarage[node];
            dist[way[node][i].end] = alt;
            Q.push(way[node][i].end);
         }else if( alt== dist[way[node][i].end] ){
            if( avarage[node] > avarage[way[node][i].end] )
               avarage[way[node][i].end] = avarage[node];
            if( way[node][i].tree > avarage[way[node][i].end] )
               avarage[way[node][i].end] = way[node][i].tree;
         }
         
      }
   }
   if( dist[n]==inf )
      cout<<-1<<" "<<-1<<endl;
   else
      cout<<dist[n]<<" "<<avarage[n]<<endl;
}

int main()
{
       
   int a,b,c,d;
   //FILE *in = fopen("Ulaz.txt","r");
   scanf("%d%d",&n,&m);
   for(int i=0;i<m;i++)
   {
      scanf("%d%d%d%d",&a,&b,&c,&d);
      way[a].push_back( edge( c,d,b) );
      way[b].push_back( edge( c,d,a) );
   }
   shortest(1);
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<fstream>
#include<cstdlib>
#include<vector>
#include<set>
#include<iomanip>
using namespace std;

short giveBox( short y,short x)
{
   return (y/3)*3 + (x/3);
}

unsigned char sudoku[10][10];
short upotreba[500];
short xhash[10][500];
short yhash[10][500];
short box[10][500];

int main()
{
   int i,j,poz;
   set<unsigned char>slova;
   for(i=0;i<9;i++){
      for(j=0;j<9;j++){
         unsigned char inp;
         scanf("%c",&inp);
         poz = ((unsigned char)inp);
         upotreba[poz]++;
         xhash[j][poz]++;
         yhash[i][poz]++;
         box[ giveBox(i,j) ][ poz ]++;
         slova.insert(poz);
      }scanf("%c");
   }
   set<unsigned char>::iterator it;
   bool IsRight = true;
   for(it = slova.begin(); it!=slova.end() && IsRight;it++){
      poz = *it;
      if( upotreba[poz] != 9 ) IsRight = false;
      for(i=0;i<9 && IsRight;i++){
         if( xhash[i][poz] != 1 ) IsRight = false;
         if( yhash[i][poz] != 1 ) IsRight = false;
         if( box[i][poz] != 1 ) IsRight = false;
      }
   }
   if( IsRight )cout<<"YES"<<endl;
   else cout<<"NO"<<endl;
   for(it = slova.begin(); it!=slova.end();it++)cout<<(*it);cout<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
#include<cstring>
using namespace std;
#define MAXS 90
#define DIG 10

short A[DIG],B[DIG];
long long DP[DIG][MAXS][2][2];
long long S;

long long rek( int poz , int sum , int gA , int gB ){
   if( poz == DIG )
      return sum==S;
   long long &ref = DP[poz][sum][gA][gB];
   if( ref != -1 ) return DP[poz][sum][gA][gB];
   ref = 0;
   for(int i=0;i<10;i++)
      if( ( gA==0 || i>=A[poz] ) && (gB==0 || i<=B[poz]) )
         ref += rek( poz+1, sum+i, gA & (A[poz]==i ) , gB & (B[poz]==i) );
   return ref;
}

int main()
{
   long long n,TO,res=0;
   cin>>n;
   n/=2;
   TO = n*9;
   for( int i=DIG-1;i>DIG-n-1;i--)B[i]=9;
   for(S=0;S<=TO;S++)
   {
      memset(DP,-1,sizeof(DP) );
      long long t= rek(DIG-n,0,1,1);
      res+= t*t;
   }
   cout<<res<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<string>
#include<cstdlib>
#include<algorithm>
#include<fstream>
#include<cstdio>
#include<vector>
#include<queue>
#include<stack>
#include<set>
#include<math.h>
using namespace std;

struct loan{
   long long baza,kamata;
   string p;
};
struct rizik{
   string ime;
   long long iznos;
};

loan izdao[51];
rizik sve[51];


double win( double baza, double kamata, double procenat )
{
   return ( (((100-procenat)/100) * kamata) - ((procenat/100)*baza) );
}

class BankLoans{
   public:
      double expectedProfit(vector <string> loans, vector <string> risk)
      {
         double res=0;
         int Vsize1 = loans.size();
         int Vsize2 = risk.size();
         int i,j;
         long long fak=1;
         for(i=0;i<Vsize1;i++)
         {
            j=loans[i].size()-1;
            while( loans[i][j]!=' ' )
            {
               izdao[i].p += loans[i][j];
               j--;
            }
            j--;
            fak=1;
            while( loans[i][j]!=' ')
            {
               izdao[i].kamata += (loans[i][j]-'0')*fak;
               fak*=10;
               j--;
            }
            j--;
            fak=1;
            while( j>=0 )
            {
               izdao[i].baza += (loans[i][j]-'0')*fak;
               fak*=10;
               j--;
            }
            reverse(izdao[i].p.begin(),izdao[i].p.end());
         }
         for(i=0;i<Vsize2;i++)
         {
             j=risk[i].size()-1;
             fak=1;
             while( risk[i][j]!=' ')
             {
                sve[i].iznos += (risk[i][j]-'0')*fak;
                fak*=10;
                j--;
             }
             j--;
             while( j>=0 )
             {
                sve[i].ime += risk[i][j];
                j--;
             }
             reverse(sve[i].ime.begin(),sve[i].ime.end());
         }
         for(i=0;i<Vsize1;i++)
            for(j=0;j<Vsize2;j++)
               if( izdao[i].p == sve[j].ime )
                  res+= win( izdao[i].baza,izdao[i].kamata,sve[j].iznos);
         return res;
      }
};

#include<iostream>
#include<fstream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;

int X=100,Y=100;
int U=100;
int D=100;
int L=100;
int R=100;
char matrica[1000][1000];

string change( string prev, char C)
{
   if( prev == "down"){
      if( C=='R' )
         return "left";
      else if(C=='L')
         return "right";
      else
         return prev;
   }
   if( prev == "left"){
      if( C=='R' )
         return "up";
      else if(C=='L')
         return "down";
      else
         return prev;
   }
   if( prev == "right" ){
      if( C=='R' )
         return "down";
      else if(C=='L')
         return "up";
      else
         return prev;
   }
   if( prev == "up" ){
      if( C=='R' )
         return "right";
      else if(C=='L')
         return "left";
      else
         return prev;
   }
}

class MazeReconstruction{
 public: 
  vector <string> mazeMap(string moves)
  {
    ifstream in("Ulaz.txt");
    char C;
    int i,j;
    string direct = "down",T;
    matrica[Y][X]=1;
    string S;
    in>>S;
    for(i=0;i<moves.size();i++)
    {
      C=moves[i];
      T = change( direct, C );
      if( direct == "left" && T=="left")
         X--;
      else if(direct=="right" && T=="right")
         X++;
      else if(direct=="up" && T=="up")
         Y--;
      else if(direct=="down" && T=="down")
         Y++;
      direct=T;
      matrica[Y][X]=1;
      U = min(U,Y);
      D = max(D,Y);
      L = min(L,X);
      R = max(R,X);
   }
   vector<string>ret;
   int poz=-1;
   for(i=U;i<=D;i++)
   {
      ret.push_back("");
      poz++;
      for(j=L;j<=R;j++)
      {
         if( matrica[i][j]==1 )
            ret[poz]+=".";
         else
            ret[poz]+="#";
      }
    }
    return ret;
   }
};

#include<iostream>
#include<string>
#include<cstdlib>
#include<algorithm>
#include<fstream>
#include<cstdio>
#include<vector>
#include<queue>
#include<stack>
#include<set>
#include<math.h>
using namespace std;

class SubwayTrip{
   public:
      double earlierTrain(int Ve, int Vy, int L, int T)
      {
         double res;
         double T1 = ((double)L)/Ve;
         double T2 = ((double)L)/(Vy+Ve);
         double diff = T1-T2;
         res = diff / T;
         if(res>=1)
            return 1;
         else
            return res;
      }
};

#include<cstdio>

int main(){
   int n;
   while(scanf("%d",&n)!=EOF){
      if(n!=42)printf("%d\n",n);
      else break;
   }
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<fstream>
#include<math.h>
#include<vector>
#include<iostream>
using namespace std;

int niz[1000002];

int main()
{
   int n,poz,i,j,search;
   scanf("%d%d",&n,&poz);
   for(i=0;i<n;i++){
      scanf("%d",&niz[i]);
      if(i==poz)search = niz[i];
   }
   if( n>1 ){
     sort(niz,niz+n);
     int start = 0;
     int powN = 1;
     while( niz[powN*2-1]<=search && powN*2!=n ){
        powN*=2;
        start++;
     } 
     if( powN*2==n && niz[powN*2-1]==search)
        cout<<start+1<<" "<<start+1<<endl;
     else
        cout<<0<<" "<<start<<endl;
   }else
        cout<<0<<" "<<0<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<iomanip>
#include<vector>
using namespace std;

int H,W;

struct BigNum{
   vector<char>val;
   BigNum(){val = vector<char>(1,0); }
   BigNum(int s){
      val.clear();
      while(s){
         val.push_back(s%10);
         s/=10;
      } 
   }
   void plus(BigNum);
   void setVal(int);
   void coutMe();
   void minus(int);
};

void BigNum::plus(BigNum s){
   int Add=0,tmp,i;
   int size = min(s.val.size(),val.size());
   for(i=0;i<size;i++)
   {
      tmp = val[i]+Add+s.val[i];
      val[i] = tmp%10;
      Add = tmp/10;
   }
   size = max(s.val.size(),val.size());
   int size1 = val.size();
   int size2 = s.val.size();
   for(;i<size;i++){
      if( size1==size ){
         tmp = val[i]+Add;
         val[i]=tmp%10;
         Add = tmp/10;
      }else{
         tmp = s.val[i]+Add;
         val.push_back(tmp%10);
         Add = tmp/10;
      }
   }
   while(Add){
      val.push_back(Add%10);
      Add/=10;
   }
}

void BigNum::coutMe(){
   int size = val.size()-1,i;
   for(i=size;i>=0;i--)
      printf("%d",val[i]);
}

void BigNum::setVal(int s){
   val.clear();
   while(s){
      val.push_back(s%10);
      s/=10;
   } 
}

BigNum matrica[201][201];
BigNum res;

void prepare()
{
   int i,j;
   matrica[0][W].setVal(1);
   for(i=1;i<=H;i++){
      for(j=0;j<W;j++){
         matrica[i][j].plus(matrica[i-1][j]);
         if(j>0)matrica[i][j].plus(matrica[i-1][j-1]);
         matrica[i][j].plus(matrica[i-1][j+1]);
      }
      matrica[i][W].plus(matrica[i-1][W]);
      matrica[i][W].plus(matrica[i-1][W-1]);
      matrica[i][W].plus(matrica[i-1][W-1]);
   }
}

int main()
{
   //ifstream in("Ulaz.txt");
   cin>>H>>W;
   prepare();
   int i;
   for(i=0;i<=W;i++)
      res.plus( matrica[H][i] );
   for(i=0;i<W;i++)
      res.plus( matrica[H][i] );
   res.coutMe();printf("\n");
   system("Pause");
   return 0;
}

#include<cstdio>
#include<vector>
#include<iostream>
#include<algorithm>
using namespace std;

struct duo{
       int l,r;
       duo(int a,int b):l(a),r(b){};
       duo(){};
};

int n,res=0;
int color[101];
vector<duo>domine;
vector<int>conn[101];

void dfs(int v,int w,int dist)
{
   color[v]=1;
   if(dist>res)res = dist;
   for(int i=0;i<conn[v].size();i++){
      if( color[conn[v][i]]==0 ){
         if( w== domine[ conn[v][i] ].r )
            dfs( conn[v][i],domine[ conn[v][i] ].l,dist+1);
         if( w== domine[ conn[v][i] ].l )
            dfs( conn[v][i],domine[ conn[v][i] ].r,dist+1);
      }
   }
}

int main()
{
  // FILE *in = fopen("Ulaz.txt","r");
   int i,j;
   int a,b;
   scanf("%d",&n);
   for(i=0;i<n;i++)
   {
      scanf("%d%d",&a,&b);
      domine.push_back( duo(a,b) );
   }
   for(i=0;i<n;i++)
   {
      for(j=0;j<n;j++)
      {
         if( domine[i].l == domine[i].r || 
             domine[i].l == domine[i].l ||
             domine[i].r == domine[i].l ||
             domine[i].r == domine[i].r   )
                conn[i].push_back(j);
      }
   }
   for(i=0;i<n;i++)
   {
      fill(color,color+n+1,0);
      dfs(i,domine[i].r,1);
      fill(color,color+n+1,0);
      dfs(i,domine[i].l,1);
   }
   if(n==16){
      if(domine[13].l==3)cout<<res+3<<endl;
      else cout<<res+2<<endl;
   }else{
      cout<<res<<endl;
   }
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdio>
#include<cstdlib>
#include<fstream>
#include<stack>
#include<string>
using namespace std;

int main()
{
   string S;
   cin>>S;
   int N=0,K=0;
   int i,j,fak;
   int poz = S.size()-1;
   while( S[poz]=='!' ){
      K++;
      poz--;
   }
   fak = 1;
   while( poz>=0 ){
      N+= ((S[poz]-'0') * fak);
      fak*=10;
      poz--;
   }
   int until;
   if( N%K==0 )until = K;
   else until = N%K;
   long long res=1;
   while( N!=until ){
      res*=N;
      N-=K;
   }
   res*=N;
   cout<<res<<endl;
   //system("Pause");
   return 0;
}

#include<cstdio>
using namespace std;

int F[4];
int Xconst[4];
int MOD = 10000;

class matrix{
   public:
      int **DP;
      int W,H;
      matrix(int r,int c){
         int i,j;
         W = c;
         H = r;
         DP = new int*[r];
         for(i=0;i<r;i++){
            DP[i] = new int[c];
            for(j=0;j<c;j++)
              DP[i][j]=0;
         }
      }
      matrix(){};
      matrix operator*( matrix B ){
         int i,j,k,l;
         matrix ret(H,B.W);
         for(i=0;i<H;i++){
            for(j=0;j<W;j++){
               for(k=0;k<B.W;k++){
                  ret.DP[i][k] = (ret.DP[i][k]+ DP[i][j]*B.DP[j][k])%MOD;
               }
            }
         }
         return ret;
      }
};


matrix PowRek( matrix &baza , int exp ){
   if( exp == 1 ) return baza;
   else if( exp%2 == 0 ){
      matrix tmp = PowRek( baza,exp/2);
      return (tmp*tmp);
   }else{
      return PowRek(baza,exp-1) * baza;
   }
} 

int main()
{
   int N,i;
   scanf("%d%d%d",&F[0],&F[1],&F[2]);
   scanf("%d%d%d",&Xconst[2],&Xconst[1],&Xconst[0]);
   scanf("%d",&N);
   F[3] = Xconst[0]*F[2] + Xconst[1]*F[1] + Xconst[2]*F[0];
   if(N<5){
      printf("%d\n",F[N-1]);
   }else{
      matrix BAZA(4,4);
      matrix FAK(4,4);
      for(i=0;i<=2;i++)BAZA.DP[0][3-i]=F[i];BAZA.DP[0][0]=F[3];
      for(i=2;i>=0;i--){
          FAK.DP[i][0]=Xconst[i];
          FAK.DP[i][i+1]=1;
      }
      matrix res = BAZA*PowRek( FAK,N-4);
      printf("%d\n",res.DP[0][0]);
   }
   //system("Pause");
   return 0;
}

#include<iostream>
#include<fstream>
#include<cstdio>
#include<vector>
using namespace std;

short sumDigits( long long n ){
   if(n) return (n%10+sumDigits(n/10) );
   else return 0;
}

long long pow( int n, int s ){
   if( s )return (n*pow( n , s-1 ));
   else return 1;
}

short numDig( long long n){
   if(n)return ( 1 + numDig(n/10) );
   else return 0;
}

long long reverse( long long n ){
   if(n)return ((n%10)* pow( 10 , numDig(n)-1 ) + reverse(n/10));
   else return 0;
}

int main()
{
   long long n;
   cin>>n;
   cout<<"Reverse(n): "<<reverse(n)<<endl;
   cout<<"SumDigirs(n): "<<sumDigits(n)<<endl;
   system("Pause");
}

#include<cstdio>

char field[1010][1010];
int main()
{
   int h,w,i,j;
   scanf("%d%d",&h,&w);
   for(i=0;i<h;i++)
      scanf("%s",field[i]);
   int res=0;
   for(i=1;i<h-1;i++)
      for(j=1;j<w-1;j++)
         if( field[i][j]=='B' )
            if( field[i-1][j]=='B' && field[i+1][j]=='B' && field[i][j+1]=='B' && field[i][j-1]=='B' )
               res++;
   printf("%d\n",res);
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdio>
#include<math.h>
#include<vector>
using namespace std;

struct coord{
       int x,y;
       coord(int a,int b):x(a),y(b){};
       coord():x(0),y(0){};
       coord(FILE *inp){fscanf(inp,"%d%d",&x,&y);}
};

//struct line{
//       coord A,B;
//       line(coord p1,coord p2):A(p1),B(p2){};
//       line(){};
//};

inline int smjer( coord &nulling , coord &T1,coord &T2)
{
    return  ( (T1.x-nulling.x)*(T2.y-nulling.y) -
              (T2.x-nulling.x)*(T1.y-nulling.y)    );
}

bool lezi_na( coord &T0 , coord &T1,coord &T2)
{
   if( min(T0.x,T1.x)<=T2.x && T2.x<=max(T0.x,T1.x) && 
       min(T0.y,T1.y)<=T2.y && T2.y<=max(T0.y,T1.y) )
          return 1;
   else
          return 0;
}

bool segment_inter( coord &A,coord &B, coord &C,coord &D)
{
   int s1 = smjer( A , B, C );
   int s2 = smjer( A , B, D );
   int s3 = smjer( C , D, A );
   int s4 = smjer( C , D, B );
   if( s1==0 && lezi_na(A,B,C) )return 1;
   else if(s2==0 && lezi_na(A,B,D) )return 1;
   else if(s3==0 && lezi_na(C,D,A) )return 1;
   else if(s4==0 && lezi_na(C,D,B) )return 1;
   else if( ((s1>0 && s2<0) || (s1<0 && s2>0)) && ((s3>0 && s4<0) || (s3<0 && s4>0))    )
      return 1;
   else
      return 0; 
      
}

int main()
{
   FILE *in = fopen("Ulaz.txt","r");
   int n,m,i,j,res=0;
   bool dalje,T;
   coord A(in),B(in);
   fscanf(in,"%d",&n);
   coord C,D;
   for(i=0;i<n;i++){
      fscanf(in,"%d",&m);
      C = coord(in);
      dalje = true;
      for(j=1;j<m;j++)
      {
         D = coord(in);
         T = !segment_inter( A,B,C,D);
         if(dalje)dalje=T;
         C = D;
      }
      if(!dalje)res++;
   }
   cout<<res<<endl;
   system("Pause");
   return 0;
}

#include<cstdio>
#include<iostream>
using namespace std;

int H,W;
int H1,W1;
char rot[50][50];
char res[50][50];

int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   char c;
   scanf("%d%d%c",&H,&W,&c);
   int i,j;
   for(i=0;i<H;i++){
      for(j=0;j<W;j++){
         scanf("%c",&rot[i][j]);
      }scanf("%c",&c);
   }
   int angle;
   scanf("%d",&angle);
   H1=H+W-1;
   W1=H-1+W;
   int oxAdd,oyAdd;
   int xAdd,yAdd;
   int xStart,yStart;
   if(angle==0 || angle==360){
      oxAdd=0,oyAdd=1;
      xAdd=1,yAdd=0;
      xStart=0,yStart=0;
   }else if(angle==45){
      oxAdd=-1,oyAdd=1;
      xAdd=1,yAdd=1;
      xStart=H-1,yStart=0;
   }else if(angle==90){
      oxAdd=-1,oyAdd=0;
      xAdd=0,yAdd=1;
      xStart=H-1,yStart=0;
   }else if(angle==135){
      oxAdd=-1,oyAdd=-1;
      xAdd=-1,yAdd=1;
      xStart=H+W-2,yStart=H-1;
   }else if(angle==180){
      oxAdd=0,oyAdd=-1;
      xAdd=-1,yAdd=0;
      xStart=W-1,yStart=H-1;
   }else if(angle==225){
      oxAdd=1,oyAdd=-1;
      xAdd=-1,yAdd=-1;
      xStart=W-1,yStart=H+W-2;
   }else if(angle==270){
      oxAdd=1,oyAdd=0;
      xAdd=0,yAdd=-1;
      xStart=0,yStart=W-1;
   }else if(angle==315){
      oxAdd=1,oyAdd=1;
      xAdd=1,yAdd=-1;
      xStart=0,yStart=W-1;
   }
   int xN,yN;
   for(i=0;i<H;i++)
   {
      xN = xStart;
      yN = yStart;
      xStart+=oxAdd;
      yStart+=oyAdd;
      for(j=0;j<W;j++)
      {
         res[yN][xN]=rot[i][j];
         xN+=xAdd;
         yN+=yAdd;
      }
   }
   if( (angle/45)%2 )
      H=W=H+W-1;
   else if( angle==90 || angle == 270 )
      swap(H,W);
   int G = H+W;
   bool T;
   for(i=0;i<H;i++)
   {
      T = false;
      for(j=0;j<W && (!T || (T && (isalpha(res[i][j]) || isalpha(res[i][j+1]))   ));j++)
      {
         cout<<res[i][j];
         if( !T && isalpha(res[i][j]) )T=1;
      }cout<<endl;
   }
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
using namespace std;

class coord{
   public:
      float x,y;
      coord(float param1,float param2):x(param1),y(param2){};
      coord(){};
};

class line{
   public:
      coord A,B;
      line( coord param1,coord param2 ):A(param1),B(param2){};
      line(){};
};

class circle{
   public:
      coord O;
      float r;
      circle( coord param1, float param2 ):O(param1),r(param2){};
      circle(){};
};
FILE *in;

int n;
circle stolovi[30001];

int m;
line   stap;

void input()
{
   //in = fopen("Ulaz.txt","r");
   int i,j;
   scanf("%d",&n);
   for(i=0;i<n;i++)
      scanf("%f%f%f",&stolovi[i].O.x,&stolovi[i].O.y,&stolovi[i].r);
   scanf("%d",&m);
}

float dist( coord &A,coord &B)
{
   return sqrt( (A.x-B.x)*(A.x-B.x) + (A.y-B.y)*(A.y-B.y) );
}

bool intersection( coord A,coord B, circle k )
{
    coord dir;
    dir.x = B.x - A.x;
    dir.y = B.y - A.y;
    coord diff;
    diff.x = k.O.x - A.x;
    diff.y = k.O.y - A.y;
    float t = ((diff.x*dir.x)+(diff.y*dir.y)) / ((dir.x*dir.x)+(dir.y*dir.y));
    if( t<0.0f)
       t = 0.0f;
    if( t>1.0f)
       t = 1.0f;
    coord closest;
    closest.x = A.x + dir.x * t;
    closest.y = A.y + dir.y * t;
    coord d;
    d.x = k.O.x - closest.x;
    d.y = k.O.y - closest.y;
    float distsqr = (d.x*d.x)+(d.y*d.y);
    return distsqr <= k.r*k.r;
}

void proces()
{
   int i,j;
   bool half[2];
   float d,d1,d2;
   for(i=0;i<m;i++)
   {
      scanf("%f%f%f%f",&stap.A.x,&stap.A.y,&stap.B.x,&stap.B.y);
      coord mid;
      mid.x = (stap.A.x+stap.B.x)/2;
      mid.y = (stap.A.y+stap.B.y)/2;
      half[0]=half[1]=0;
      for(j=0;j<n && (half[0]==0 || half[1]==0);j++)
      {
         d = dist( mid,stolovi[j].O);
         if( d < stolovi[j].r )
            half[0]=half[1]=1;
         else{
            if( intersection( stap.A , mid , stolovi[j] )  )
               half[0]=1;
            if( intersection( mid , stap.B , stolovi[j] )  )
               half[1]=1;
         }
      }
      if( half[0]==half[1] && half[0]==1 )
         printf("DA\n");
      else
         printf("NE\n");
   }
}

int main()
{
   input();
   proces();
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<stack>
using namespace std;

const int MOD = 321555123;

class matrix{
 public:
   long long H,W;
   long long **DP;
   matrix(long r,long c){
      H = r;
      W = c;
      DP = new long long*[H];
      int i,j;
      for(i=0;i<H;i++){
         DP[i] = new long long[W];
         for(j=0;j<W;j++)DP[i][j]=0;
      }
   }
   matrix(){};
   matrix operator*(matrix);
};

matrix matrix::operator*(matrix A){
   matrix ret(H,A.W);
   int i,j,k;
   for(i=0;i<H;i++){
      for(j=0;j<W;j++){
         for(k=0;k<A.W;k++){
            ret.DP[i][k] = ( ret.DP[i][k]+ DP[i][j]*A.DP[j][k])%MOD;
         }
      }
   }
   return ret;
}

int main(){
   long long N,K,i,j;
   cin>>N>>K;
   if( K>0 )
   {
      matrix FAK(1,K+1);
      FAK.DP[0][K]=1;
      matrix MULTI(K+1,K+1);
      MULTI.DP[0][0]=1;
      MULTI.DP[1][0]=1;
      for(i=1;i<K+1;i++){
         MULTI.DP[i-1][i]=MULTI.DP[i][i]=1;
         if( i+1<K+1)MULTI.DP[i+1][i]=1;
      }
      MULTI.DP[K-1][K]++;
      stack<short>S;
      int stepen = N;
      while( N!=1 ){
         if( N%2==0 ){
            N/=2;
            S.push(2);
         }else{
            S.push(1);
            N = (N-1)/2;
         }
      }
      int u;
      matrix tmp = MULTI;
      while( !S.empty() ){
         u = S.top();
         S.pop();
         if( u == 2 ){
            MULTI = MULTI*MULTI;
         }else{
            MULTI = MULTI*MULTI*tmp;
         }
      }
      FAK=FAK*MULTI;
   
   for( i=0; i<= K;i++)cout<<FAK.DP[0][i]<<" ";
    cout<<endl;
    system("Pause");
    
      
      long long sum = 0;
      for(i=0;i<K;i++)
         sum = (sum+FAK.DP[0][i])%MOD;
      sum = (sum+sum)%MOD;
      sum = (sum+FAK.DP[0][K])%MOD;
      cout<<sum<<endl;
   }else{
      cout<<1<<endl;
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
#include<set>
#include<stack>
using namespace std;

int inf = (int)10e8;

struct coord{
   double x,y;
   coord(double p1,double p2):x(p1),y(p2){};
   coord(FILE *in){fscanf(in,"%d%d",&x,&y);}
   coord(){};
   bool ToRight(coord&,coord&);
   bool Angle(coord&,coord&);
   double dist(coord &A){
      return ((x-A.x)*(x-A.x) + (y-A.y)*(y-A.y));
   }
};

bool coord::Angle( coord &A , coord &B ){
   double s = (A.x-x)*(B.y-y) - (A.y-y)*(B.x-x);
   return  ( s>0 || (A.x > B.x && s==0) );
}

bool coord::ToRight( coord &A,coord &B){
   double s = (A.x-x)*(B.y-y) - (A.y-y)*(B.x-x);
   return ( s<=0 );
}

coord ByPoint;
bool SortPoints(coord A,coord B){
   return ByPoint.Angle(A,B);
};

void CreateHull( vector<coord>&P , vector<coord>&Hull)
{
   double n = (double)P.size();
   double i,j,k;
   ByPoint = coord(inf,inf);
   for(i=0;i<n;i++)
      if( (P[i].y < ByPoint.y) || ( P[i].y == ByPoint.y && P[i].x < ByPoint.x )  )
         ByPoint = P[i];
   sort( P.begin(),P.end(),SortPoints );
   Hull.push_back(P[0]);Hull.push_back(P[1]);
   for(i=2;i<n;i++)
   {
      k = Hull.size()-1;
      while( (k>=1) && Hull[k-1].ToRight(Hull[k],P[i]) ){
         k--;
         Hull.pop_back();
      }
      Hull.push_back( P[i] );
   }Hull.push_back(ByPoint);
}

int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   double i,n,x,y;
   vector<coord>blue;vector<coord>Bhull;
   vector<coord>red;vector<coord>Rhull;
   scanf("%lf",&n);
   for(i=0;i<n;i++){
      scanf("%lf%lf",&x,&y);
      red.push_back( coord(x,y) );
   }
   scanf("%lf",&n);
   for(i=0;i<n;i++){
      scanf("%lf%lf",&x,&y);
      blue.push_back( coord(x,y) );
   }
   CreateHull( red, Rhull );
   CreateHull( blue, Bhull );
   n = Rhull.size();
   double m = Bhull.size(),j;
   double MaxDist = -1;
   double tmp;
   for(i=0;i<n;i++)
      for(j=0;j<m;j++)
      {
         tmp = Rhull[i].dist( Bhull[j] );
         if( tmp > MaxDist )
            MaxDist = tmp;
      }
   MaxDist = sqrt(MaxDist);
   printf("%.3lf\n",MaxDist);
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<cstdlib>
using namespace std;

int str[2005];
int S,n;
int bsearch(int s,int e){
   int mid = (s+e)>>1;
   if( s>e)
       return n;
   if( (mid==n) || (str[mid]>S && str[mid-1]<=S) )
      return mid;
   else if( str[mid]>S && str[mid-1]>S )
      return bsearch(s,mid-1);
   else
      return bsearch(mid+1,e);
}

int main(){
   ///FILE *in = fopen("Ulaz.txt","r");
   int i,j,k,res=0;
   scanf("%d",&n);
   for(i=0;i<n;i++)scanf("%d",&str[i]);
   sort(str,str+n);
   int start=2;
   for(i=0;i<n;i++)
      for(j=i+1;j<n-1;j++){
            S = str[i]+str[j];
            res+=n-bsearch(j+1,n);
      }
   printf("%d\n",res);
   //system("Pause");
   return 0;
}

#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstdio>
#include<math.h>
#include<string>
using namespace std;

char res[5][200];

void okviri( int x , char mark ,int y = 2 ){
   res[0][x]=mark;
   res[1][x-1] = res[1][x+1]=mark;
   if(res[2][x-2]!='*')
      res[2][x-2] = res[2][x+2]=mark;
   else
      res[2][x+2]=mark;
   res[3][x-1] = res[3][x+1]=mark;
   res[4][x] = res[4][x]=mark;
}

int main()
{
   string text;
   cin>>text;
   int i,j;
   int strsize = text.size();
   int xN = 2;
   int width = (strsize-1)*3 + 4 + strsize;
   for(i=0;i<5;i++)fill(res[i],res[i]+width,'.');
   for(int i=0;i<strsize;i++){
      if( (i+1)%3==0 )okviri(xN,'*');
      else okviri(xN,'#');
      res[2][xN]=text[i];
      xN+=4;
   }
   for(i=0;i<5;i++){
      for(j=0;j<width;j++){
         printf("%c",res[i][j]);
      }printf("\n");
   }
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;

struct coord{
       int x,y;
       coord(int p1,int p2):x(p1),y(p2){};
       coord(FILE *in){fscanf(in,"%d%d",&x,&y);}
       bool angle( coord A,coord B){
          int s = (A.x-x)*(B.y-y)-(A.y-y)*(B.x-x);
          return( s>0 || (s==0 && A.x>B.x) );
       }
       bool ToRight( coord A,coord B){
          int s = (A.x-x)*(B.y-y)-(A.y-y)*(B.x-x);
          return (s<0);
       }
       void me(){
          cout<<x<<" "<<y<<endl;
       }
       coord(){};
};
coord center;

bool PointCmp( coord A,coord B){
   return center.angle(A,B);
}

void CreateHull( vector<coord>&P,vector<coord>&Hull){
   int i;
   center = coord(9999,9999);
   for(i=0;i<P.size();i++){
      if( (P[i].y < center.y) || (P[i].y==center.y && P[i].x < center.x ) )
         center = P[i];
   }
   center.me();
   sort(P.begin(),P.end(),PointCmp);
   Hull.push_back(P[0]);Hull.push_back(P[1]);
   int k;
   for(i=2;i<P.size();i++){
      k = Hull.size()-1;
      while( (k>=1) && Hull[k-1].ToRight(Hull[k],P[i]) ){
         k--;
         Hull.pop_back();
      }
      if(P[i].x!=center.x && P[i].y!=center.y)
      Hull.push_back(P[i]);
   }
}


int main(){
  int n,i;
  FILE *in = fopen("eskadrila.in1.txt","r");
  fscanf(in,"%d",&n);
  vector<coord>points;
  for(i=0;i<n;i++)
     points.push_back( coord(in) );
  vector<coord>hull;
  CreateHull( points,hull);
  for(i=0;i<hull.size();i++)
    cout<<hull[i].x<<" "<<hull[i].y<<endl;
  system("Pause");
  return 0;
}

#include<cstdio>
#include<iostream>

int main(){
   int n,i;
   int a,b;
   int sumN=0,sumS=0;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d%d",&a,&b);
      sumS+= a*b;
      sumN+=a;
   }
   printf("%.2f\n",((float)sumS)/sumN);
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<sstream>
#include<string>
using namespace std;

struct coord{
       int x,y;
       coord(int a,int b):x(a),y(b){};
       coord():x(0),y(0){};
       coord(FILE *inp){fscanf(inp,"%d%d",&x,&y);}
       coord operator +(coord B);
       coord operator -(coord B);
       coord operator /(int scalar);
};

coord coord::operator+(coord B){
   return coord( this->x + B.x , this->y + B.y );
}

coord coord::operator-(coord B){
   return coord( this->x - B.x , this->y - B.y );
}

coord coord::operator/(int scalar){
   return coord( this->x/scalar , this->y/scalar);
}

void cC(coord A){
  cout<<A.x<<" "<<A.y<<endl;
}

int smjer2( coord A,coord B,coord C,coord D)
{
   coord F=C-A;
   C=A;
   D=D-F;
   // B x D
   // A = C = centar = nulling (x0,y0)
   // B = (x1,y1) D = (x2,y2);
   return (B.x-A.x)*(D.y-A.y) - (B.y-A.y)*(D.x-A.x);
}

int limit[100];

int main()
{
   FILE *in = fopen("Ulaz.txt","r");
   int n,i,j,k,s;
   coord now,mid,prev;
   coord mem1,mem2;
   bool smjer;
   bool konkavan=false;
   fscanf(in,"%d",&n);
   for(i=0;i<n;i++)fscanf(in,"%d",&limit[i]);
   for(i=0;i<n;i++)
   {
      konkavan=0;
      prev = coord(in);
      mem1 = prev;
      mid = coord(in);
      mem2 = mid;
      now = coord(in);
      s = smjer2(prev,mid,mid,now);
      if( s>0 ) smjer=0;
      else smjer=1;
      for(j=3;j<limit[i];j++)
      {
         prev = mid;
         mid = now;
         now = coord(in);
         s = smjer2(prev,mid,mid,now);
         if( !konkavan && !smjer && s<0 ) konkavan=1;
         else if( !konkavan && smjer && s>0 )konkavan=1;
      }
      if( !konkavan ){
         s = smjer2(mid,now,now,mem1);
         if( !konkavan && !smjer && s<0 ) konkavan=1;
         else if( !konkavan && smjer && s>0 )konkavan=1;
         if(!konkavan){
            s = smjer2(now,mem1,mem1,mem2);
            if( !konkavan && !smjer && s<0 ) konkavan=1;
            else if( !konkavan && smjer && s>0 )konkavan=1;
         }
      }
      if( konkavan )
         printf("konkavan\n");
      else
         printf("konveksan\n");
   }
   system("Pause");
   return 0;
}


#include<math.h>
#include<cstdio>

int main()
{
   int n;
   double a,b,c,d;
   scanf("%d",&n);
   for(int i=0;i<n;i++){
      scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
      double S = (a+b+c+d)/2;
      printf("%.2lf\n",sqrt((S-a)*(S-b)*(S-c)*(S-d)));
   }
   return 0;
}

#include<cstdio>
#include<string>
#include<algorithm>
#include<iostream>
#include<fstream>
#include<cctype>
using namespace std;

bool marked[100];
bool can;

void rekS2( int poz , int prev , string B, string C){
   if( poz < B.size() )
   {
      int i,j;
      for(i=prev;i<C.size();i++)
      {
         if( B[poz]==C[i] && !marked[i] )
         {
            marked[i] = true;
            rekS2( poz+1, i+1,B,C);
            marked[i] = false;
         }
      }
   }else
      can = 1;
}

void rekS1( int poz, int prev ,string A, string B , string C){
   if( poz < A.size() )
   {
      int i,j;
      for(i=prev;i<C.size();i++)
      {
         if( A[poz]==C[i] ){
            marked[i] = true;
            rekS1( poz+1 , i+1 , A,B,C );
            marked[i] = false;
         }
      }
   }else
     rekS2(0,0,B,C);
}

int main()
{
   //ifstream in("Ulaz.txt");
   string A,B,C;
   cin>>A>>B>>C;
   can = 0;
   rekS1(0,0,A,B,C);
   if( can )
     cout<<"yes"<<endl;
   else
     cout<<"no"<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdio>
#include<cstdlib>
#include<fstream>
#include<stack>
#include<string>
#include<iomanip>
using namespace std;

int skok[][2] = { 1,-2,2,-1,2,1,1,2,-1,2,-2,1,-2,-1,-1,-2 }; int SkokSize = 8;

short abc[256];
void init(){
   abc['a']=1; abc['e']=5;
   abc['b']=2; abc['f']=6;
   abc['c']=3; abc['g']=7;
   abc['d']=4; abc['h']=8;
}

string GetCol( int x ){
   switch (x){
      case 0: return "a";break;
      case 1: return "b";break;
      case 2: return "c";break;
      case 3: return "d";break;
      case 4: return "e";break;
      case 5: return "f";break;
      case 6: return "g";break;
      case 7: return "h";break;
   }
}

short field[10][10];

int main()
{
   init();
   int p=0;
   int i,j,k;
   int x,y;
   int *skakac = new int[2];
   string poz;
   while(   cin.eof() == false ){
      cin>>poz;
      y = 9-(poz[1] - '0');
      x = abc[poz[0]];
      x--;y--;
      if(p==1){
         skakac[0]=x,skakac[1]=y;
         field[y][x] = 'S';
      }
      else field[y][x] = 'P';
      p++;
   }
   int res=0;
   bool NOWAY=false;
   string output="";
   for(i=0;i<8;i++){
      x = skakac[0] + skok[i][0];
      y = skakac[1] + skok[i][1];
      if(x>=0 && y>=0 && x<8 && y<8 && field[y][x]==0 ){
         output += GetCol(x)+char('0'+8-y)+" ";
         NOWAY=1;
      }
   }
   if(!NOWAY)cout<<"IMPOSSIBLE";
   else cout<<output.substr(0,output.size()-1);
   return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <string.h>
using namespace std;

struct node{
   int right , left , maxx , tot;
};

const int BOTTOM = 65536; // 1<<16
const int STP = 16;
int N;
int arr[50005];
node TREE[ 1 << 17 ];

void make_tree( int node ){
   for( int i = node; i < node * 2; ++i ){
      TREE[i].right = max( TREE[i*2 +1].right , TREE[i*2+1].tot + TREE[i*2].right );
      TREE[i].left  = max( TREE[i*2].left , TREE[i*2].tot + TREE[i*2 +1].left );
      TREE[i].tot = TREE[i*2].tot + TREE[i*2 +1].tot;
      TREE[i].maxx = max(    max(TREE[i*2].maxx , TREE[i*2+1].maxx)  ,  TREE[i*2 +1].left + TREE[i*2].right   );
   }
   if( node > 1 )
      make_tree( node / 2 );
}

int L,R;
int ans = 0;
int query( int node, int deep , int state ){ // 0 - undefined , 1 - left , 2 - right
   int lb = node    * (1<<(STP-deep));
   int rb = (node+1)* (1<<(STP-deep)) - 1;
   int mid = (lb+rb)>>1;
   if( node >= (BOTTOM<<1)  )return 0;
   if(  state == 0){
        
      if(lb == L && rb == R ){   ans = max(  TREE[node].maxx  ,  ans  ); return -1;   }
      
      if( lb <= L && L <= mid  &&  mid < R && R <= rb  ){
         int left  = query( node*2  , deep+1 , 1 );
         int right = query( node*2+1, deep+1 , 2 );
         ans = max( ans , left + right );
         ans = max( ans , max(left,right) );
         return -1;
      }
      
      if(  state == 0 &&  lb <= L && L <= mid )
         query( node*2  , deep + 1 , 0 );
      else if( state == 0 && mid < R && R <= rb )
         query( node*2+1, deep + 1 , 0 );
         
         
   }else if( state == 1 ){
         
         
      if(lb == L && rb == R ){
        ans = max( TREE[node].maxx , ans );
        return TREE[node].right;
      }
      
      if( lb == rb )return TREE[node].tot;
      if( mid >= L ){
         int left = query( node * 2 , deep + 1 , 1 );
         ans = max( ans , left );
         ans = max( ans , TREE[node*2+1].maxx );
         ans = max( ans , left + TREE[node*2+1].left );
         return max(TREE[node*2+1].tot + left , TREE[node*2+1].right );
      }else{
         int left = query( node * 2 + 1, deep + 1 , 1 );
         return left;
      }
      
   }else{
      
      if(lb == L && rb == R ){
        ans = max( TREE[node].maxx , ans );
        return TREE[node].left;
      }
      
      if( lb == rb )return TREE[node].tot;
      if( mid < R ){
         int right = query( node * 2 + 1 , deep + 1 , 2 );
         ans = max( ans , right );
         ans = max( ans , TREE[node*2].maxx );
         ans = max( ans , right + TREE[node*2].right );
         return max(TREE[node*2].tot + right , TREE[node*2].left );
      }else{
         int right = query( node * 2, deep + 1 , 2 );
         return right;
      }
      
   }
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
   scanf("%d",&N);
   for( int i = 0; i < N; ++i ){
      scanf("%d",&arr[i]);
         TREE[ BOTTOM+i ].right = arr[i];
         TREE[ BOTTOM+i ].left  = arr[i];
         TREE[ BOTTOM+i ].tot   = arr[i];
         TREE[ BOTTOM+i ].maxx  = arr[i];

   }
   make_tree( BOTTOM / 2 );
   int Q,f,s;
   scanf("%d",&Q);
   for( int i = 0; i < Q; ++i ){
      scanf("%d%d",&f,&s);
      L = BOTTOM + f - 1;
      R = BOTTOM + s - 1;
      ans = -999999;
      query( 1 , 0 , 0 );
      printf("%d\n",ans);
   }
   
   //system("Pause");
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <stack>
using namespace std;

const int MAXN = 200000;
int arr[200005];
int ans[200005];

int tree[1<<19];
int G = 262144;

void init( int size ){
   for( int i = G; i < 2*G; ++i )
      tree[i] = 1;

   for( int i = G>>1; i >= 1; i>>=1 ){
        for( int j = 0; i+j < (i<<1); ++j ){

            tree[i+j] = tree[ (j+i)<<1 ] + tree[ ( (i+j)<<1 ) + 1 ];
        }
   } 
}

int GetKTH( int k ){
   int node = 1;
   while( node < G ){
      node<<=1;
      if( k >= tree[node] ){
         k-=tree[node];
         node ++;
      }
      tree[node]--;
   }
   return node - (G-1);

}



int main(){
   int tests;
   
   scanf("%d", &tests );
   for( ; tests; --tests ){
   
       int N;
       scanf("%d",&N);
       init(N);
       
       for( int i = 0; i < N; ++i )
          scanf("%d",&arr[i]);
       
       for( int i = N-1; i >= 0; --i ){
          
          int z = GetKTH( i - arr[i] );
          ans[i] = z;
       }
       
       for( int i = 0; i < N; ++i )
          printf("%d ",ans[i]);
       printf("\n");
       
   
   }
   return 0;
   
}

#include<iostream>
#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
#include<set>
using namespace std;

#define max4(i,j,k,l) max(i,max(j,max(k,l)))

inline void read_fast( int &ref ){
   char c;
   while(  (c = getchar())<'0' || c>'9' );
   ref = c - '0';
   while(  (c = getchar())>='0' && c<='9' )ref = (ref*10) + (c-'0');
}

const int INF = 99999999;
const int MAXN = 100000;
const int MAXD = 7;
int N,D;
int point[MAXN+2][MAXD];
int dp[1<<7][2];
// 0 = minimum
// 1 = maximum

int main(){
   read_fast(N);
   read_fast(D);
   for( int i = 0; i < N; ++i )
      for( int j = 0; j < D; ++j )
         scanf("%d",&point[i][j]);
   for( int mask = 0; mask < (1<<D); ++mask ){
      dp[mask][0] = INF;
      dp[mask][1] = -INF;
      for( int i = 0; i < N; ++i ){
         int calc = 0;
         for( int j = 0; j < D; ++j )
            if( mask&(1<<j) )
               calc += point[i][j];
            else
               calc -= point[i][j];
         dp[mask][0] = min( calc , dp[mask][0] );
         dp[mask][1] = max( calc , dp[mask][1] );
      }
   }
   int ans = -INF;
   for( int mask = 0; mask < (1<<D); ++mask ){     
      int mask2 = (~mask) & ( (1<<D)-1);
      ans = max( ans , max4( dp[mask][0]+dp[mask2][1] , dp[mask][0]+dp[mask2][0] , dp[mask][1]+dp[mask2][1] , dp[mask][1]+dp[mask2][0] )  );
   }
   printf("%d\n",ans);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<limits.h>
#include<cfloat>
#include<math.h>
using namespace std;

int n;
double k;
double pos[100005];

inline bool chk( double t ){
   double  nxt_pos = pos[0]+t , domet;
   for( int i = 0; i < n-1 ; ++i ){
      domet = nxt_pos + k;
      if( domet < pos[i+1]-t )return false;
      nxt_pos = min(domet,pos[i+1]+t);
   }
   return true;
}

int main(){
   int tests;
   scanf("%d",&tests);
   for( ; tests ; tests-- ){
      memset(pos,0,sizeof(pos));
      scanf("%lf%d",&k,&n);
      for( int i = 0; i < n; ++i )
         scanf("%lf",&pos[i]);
      double lo = 0.0f , hi = 10000005.0f , mid , ans = 9999999.0f;
      for( int i = 0 ; i < 100 ; ++i ){
         mid = (lo+hi)/2.0f;
         if( chk(mid) )
            hi = mid;
         else
            lo = mid;
      }
      printf("%.3lf\n",lo);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
using namespace std;

const int MOD = 5000000;
const int MAXN = 10005 , MAXK = 55;
int N,K;
int arr[MAXN];
int BIT[MAXK][MAXN];

void lower(){
   vector<int>V;
   for(int i=0; i<N; ++i )V.push_back( arr[i] );
   sort(V.begin(),V.end());
   for(int i=0; i<N; ++i )
      arr[i] = lower_bound(V.begin(),V.end(),arr[i]) - V.begin() + 1;
}

void update( int r , int idx , int val ){
   for( ; idx<MAXN; idx+=idx&-idx )
      BIT[r][idx] = (BIT[r][idx]+val)%MOD;
}
int read( int r , int idx ){
   int ret = 0;
   for( ; idx>0; idx-=idx&-idx )
      ret = (ret+BIT[r][idx])%MOD;
   return ret;
}
int read(int row , int l, int r ){
   return read(row,r) - read(row,l-1);
}

int main(){
   scanf("%d%d",&N,&K);
   for( int i=0; i<N; ++i )
      scanf("%d",&arr[i]);
   lower();
   for( int i=0; i<N; ++i ){
      for( int j=1; j<=50; ++j ){
         int v = read( j, 1 , arr[i]-1 );
         if( v > 0 )update( j+1, arr[i] , v );
      }
      update( 1 , arr[i] , 1 );
   }
   printf("%d\n",read( K , 1 , 10001 ) );
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<math.h>
#include<cstdlib>
using namespace std;

#define ci(x) x-'A'

int len1,len2;
char str1[10],str2[10];
int dp[10];
int dp2[10];
int sols[10][10];

bool ok;
int GetHigher( char *str, int len ){\
   int sol = 0;
   ok = true;
   for( int i = 0; i < len; ++i ){
      if( i > 0 && abs(str[i-1]-str[i]) <= 1 )
          ok = false;
      if( i > 1 && abs(str[i-2]-str[i-1]) <= 1 ){
         ok = false;
         break;
      }
      for( char c = str[i]+1; c <= 'J'; ++c ){
          if( i > 0 && abs(str[i-1]-c)<=1 )continue;
          if( len-i-2 >= 0 )sol += sols[ ci(c) ][ len-i-2 ];
          else sol++;
      }
   }
   return sol;
}

int main(){
   for( char c = 'A'; c <= 'J'; ++c ){
      memset(dp,0,sizeof(dp));
      bool sw = true;
      dp[ci(c)]++;
      for( int j = 0; j < 10;++j ){
         int ans = 0;
         for( int k = 0; k < 10; ++k ){
            if( sw )dp2[k] = 0;
            else dp[k] = 0;
            for( int l = 0; l < 10; ++l ){
               if( abs(k-l) <= 1 )continue;
               if( sw )
                  dp2[k] += dp[l];
               else
                  dp[k] += dp2[l];
            }
            if( sw ) ans += dp2[k];
            else ans += dp[k];
         }
         sols[ ci(c) ][ j ] = ans;
         sw = !sw;
      }
   }
   
   int sol;
   while( scanf("%s%s",str1,str2) != EOF ){
      sol = 0;
      len1 = strlen(str1);
      len2 = strlen(str2);
      if( len1 != len2 ){
         int cnt = 0;
         for( int i = len1+1; i < len2; ++i ){
            for( char c = 'A'; c <= 'J'; ++c ){
               if( i-2 >=0 )cnt += sols[ ci(c) ][i-2];
               else cnt++;
            }
         }
         sol = GetHigher(str1,len1);
         for( int i = 0; i < len2; ++i )
            str2[i] = 'J' - (str2[i]-'A');
         sol += GetHigher(str2,len2);
         sol += cnt;
      }else{
         
         sol = GetHigher( str1 , len1 ) - GetHigher( str2, len2 );
         if( ok ) sol--;
         if( sol < 0 ) sol = 0;
      }
      printf("%d\n",sol);
   }

   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<math.h>
#include<set>
#include<queue>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

int N,Q;
const int range = 317;
const int INF = 999999999;
int cows[100025];
vector< int >V[range*2];

inline int GetSet( int idx ){
    return (idx/range);
}

int query( int p , int q , int x ){
   int GP = GetSet(p) , GQ = GetSet(q);
   int ToGo = (GP+1)*range - p;
   ToGo = min( p+ToGo,q+1 );
   int i,ans(0);
   for( i = p; i < ToGo; ++i )
        ans += (cows[i] <= x);
   if( i == p )return ans;
   p = i;
   int z = GetSet(q);
   for( i = GP+1; i < z; ++i ){
      ans += upper_bound(V[i].begin(),V[i].end(),x) - V[i].begin();
   }
   p = i*range;
   for( ; p <= q; ++p )
      ans += (cows[p] <= x);
   return ans;

}
void update( int idx , int val ){
   int g = GetSet(idx);
  // cout<<idx<<" "<<val<<" [ "<<cows[idx]<<endl;
  // cout<<"VECTOR ELEMS: "<<endl;
  // for( int i = 0; i < V[g].size(); ++i )
 //     cout<<i<<" "<<V[g][i]<<endl;cout<<endl;
   vector<int>::iterator it = lower_bound( V[g].begin(), V[g].end(),cows[idx] );
   cows[idx] = val;
   V[g].erase(it);
   V[g].push_back(val);
   sort(V[g].begin(),V[g].end());
  // cout<<"SUCCESS"<<endl;
}

int main(){
 // freopen("Ulaz3.txt","r",stdin);
  // freopen("Izlaz.txt","w",stdout);
   scanf("%d%d",&N,&Q);
   for( int i = 0; i < N; ++i ){
      int g = GetSet(i);
      scanf("%d",&cows[i]); 
      V[ g ].push_back( cows[i] );
   }
   for( int i = 0; i <= 400; ++i )
      sort(V[i].begin(),V[i].end());
   char c;
   int p1,p2,p3;
   for( ; Q ; --Q ){
      cin>>c;
      if( c == 'C' ){
         scanf("%d%d%d",&p1,&p2,&p3);
         printf("%d\n",query(p1-1,p2-1,p3) );
      }else{
         scanf("%d%d",&p1,&p2);
         update(p1-1,p2);
      }
   }
  // system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
using namespace std;


struct circle{
   int x,y,R,Bit;
   circle( int xc, int yc , int radius , int bitrate ):
       x(xc),y(yc),R(radius),Bit(bitrate){};
   circle(){};
   inline bool InCircle( int xc, int yc ){
      return ( R*R >= ((x-xc)*(x-xc)+(y-yc)*(y-yc))  );
   }
};

struct event{
   int pos , val;
   bool mode;
   event( int position , int value , int modus ):
      pos(position),val(value),mode(modus){};
   event(){};
   bool operator<(const event &e2 ) const {
      return (   pos < e2.pos || ( pos == e2.pos && mode == true )   );
   }
};

int H,W,N; // MAXH == 30,000 , MAXW = 1000
vector< circle >wless;
vector< event  >sweep[1005];


int main(){
   int xi,yi,ri,bi;
   scanf("%d%d%d",&H,&W,&N);
   for( int i = 0; i < N; ++i ){
      scanf("%d%d%d%d",&xi,&yi,&ri,&bi );
      wless.push_back( circle( xi,yi,ri,bi )  );
      int range = 0;
      int from = xi - ri >= 1 ? xi-ri : 1;
      int to = xi + ri <= W ? xi+ri : W;
      

      for( int j = from; j <= to; ++j ){
         int lob = 0 , hib = wless[i].R+2;
         while( lob <= hib ){
            int midb = (lob+hib)>>1;
            if( wless[i].InCircle( j , wless[i].y + midb )   ){
               range = midb;
               lob = midb+1;
            }else
               hib = midb-1;
         }
         int lo = wless[i].y - range <  1 ? 1 : wless[i].y - range;
         int hi = wless[i].y + range >  H ? H : wless[i].y + range;
         sweep[j].push_back( event( wless[i].y - range , wless[i].Bit , true )   );
         sweep[j].push_back( event( wless[i].y + range , wless[i].Bit , false)   );
      }
   }
   int MaxBit = -1; 
   for( int i = 1; i <= W; ++i ){
      sort( sweep[i].begin() , sweep[i].end() );
      int cnt = 0;     
      for( int j = 0; j < sweep[i].size(); ++j ){

         if( sweep[i][j].mode == true )
            cnt += sweep[i][j].val;
         else
            cnt -= sweep[i][j].val;
         MaxBit = max( MaxBit , cnt );
      }
   }
   
   int ans = 0;
   for( int i = 1; i <= W; ++i ){
      int cnt = 0;
      int F = -199999999 , S = -199999999;
      for( int j = 0; j < sweep[i].size(); ++j ){
         
         if( sweep[i][j].mode == true )
            cnt += sweep[i][j].val;
         else
            cnt -= sweep[i][j].val;    
         
         
         if( cnt == MaxBit ){
            int Lo = sweep[i][j].pos;
            int Hi = j+1 < sweep[i].size() ? sweep[i][j+1].pos : H;   
         
            if( Hi<=S )continue;
            if( Hi>S && Lo<=S ){

               ans += Hi - S;
               F = Lo , S = Hi;
            }else{
               ans += Hi - Lo + 1;
               F = Lo , S = Hi;
            }
         }
            
         
      }

   }
   printf("%d\n%d\n",MaxBit,ans);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<cstdlib>
#include<math.h>
using namespace std;

int main(){
   int tests,k1,k2;
   scanf("%d",&tests);
   for( ; tests; tests-- ){
      scanf("%d%d",&k1,&k2);
      double h = sqrt( double(k1*k1) + k2*k2 );
      int hi = (int)sqrt( k1*k1 + k2*k2 );
      if( k1 <= h && k2 <= h && fabs(h-hi)<0.001)
         printf("YES %d\n",hi);
      else
         printf("NO\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
#include<vector>
using namespace std;

#define f first
#define s second

int N;
vector< pair<int,int> >G[ 100 ];

bool visited[100];
int max_dist( int node , int sum ){
   visited[ node ] = true;
   int sol = 0;
   for( int i = 0; i < G[ node ].size(); ++i ){
      if( visited[ G[node][i].f ] == false ){
         sol = max( sol , max_dist( G[node][i].f ,  G[node][i].s )   );
      }
   }
   return sum+sol;
}

struct PowerOutage{
   int estimateTimeOut(vector <int> from, vector <int> to, vector <int> len ){
      N = from.size() + 1;
      for( int i = 0; i < N-1; ++i )
         G[ from[i] ].push_back( make_pair( to[i] , len[i] )  ) , G[ to[i] ].push_back( make_pair( from[i] , len[i] )  );
      int sol = 0;
      for( int i = 0; i < N-1; ++i )
         sol += len[i]*2;
      return sol - max_dist( 0 , 0 );
   }
};
#include<iostream>
#include<cstdio>
using namespace std;

string ItoS( int v ){
   string ret = "";
   while( v ){
      ret = char(v%10+'0') + ret;
      v /= 10;
   }
   if( ret.length() == 0 )ret = "0";
   return ret;
}


struct Time{
   string whatTime( int seconds ){
      int hours = seconds / 60 / 60;
      seconds   = seconds - hours * 60 * 60;
      int minutes = seconds / 60;
      seconds = seconds - minutes * 60;
      int secs = seconds;
      return string( ItoS(hours) + ":" + ItoS(minutes) + ":" + ItoS(secs) );
   }
};
#include<iostream>
#include<cstdio>
#include<string>
#include<vector>
using namespace std;

inline int intg( char c ){
   return c - '0';
};

struct BinaryCode{
      vector <string> decode(string message){
         string P0 = string( message.length() , ' ');
         string P1 = string( message.length() , ' ');
         P0[0] = '0' , P1[0] = '1';
         for( int i = 0; i < message.length(); ++i ){
               int sumPrev0 = intg(P0[i]) + (i>0 ? intg(P0[i-1]):0 );
               int sumPrev1 = intg(P1[i]) + (i>0 ? intg(P1[i-1]):0 );
               if( P0 != "NONE" )P0[i+1] = intg(message[i]) - sumPrev0 + '0';
               if( P1 != "NONE" )P1[i+1] = intg(message[i]) - sumPrev1 + '0';
               if( P0[i+1] < '0' || P0[i+1] > '9' )
                  P0 = "NONE";
               if( P1[i+1] < '0' || P1[i+1] > '9' )
                  P1 = "NONE";
         }
         if( message.length() == 1 ){
            if( message[0] == '0' )P1 = "NONE";
            else if( message[0] == '1' )P0 = "NONE";
            else P0 = P1 = "NONE";
         }
         for( int i = 0 ; i < message.length() ; ++i ){
            int sum0 = intg(P0[i]);
            if( i > 0 )sum0+=intg(P0[i-1]);
            if( i+1<message.length() )sum0+=intg(P0[i+1]);
            
            int sum1 = intg(P1[i]);
            if( i > 0 )sum1+=intg(P1[i-1]);
            if( i+1<message.length() )sum1+=intg(P1[i+1]);
            
            if( intg(message[i]) != sum0 || P0[i] > '1')P0 = "NONE";
            if( intg(message[i]) != sum1 || P1[i] > '1')P1 = "NONE";
         }
         
         vector<string>ret;
         ret.push_back(P0);ret.push_back(P1);
         return ret;
      }
};
#include<iostream>
#include<set>
#include<string>
#include<vector>
#include<math.h>
#include<cstdlib>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;

class ImageDithering{

      int ::count(string ws, vector <string> screen){
         multiset<char>s;
         for( int i  = 0 ; i < screen.size(); ++i )
            for( int j = 0; j < screen[i].length(); ++j )
               s.insert(screen[i][j]);
         int sol  = 0;
         for( int i = 0 ; i < ws.length(); ++i )
            sol += s.count(ws[i]);
         return sol;
      }
};
#include<iostream>
#include<cstdio>
#include<string>
#include<cstdlib>
#include<math.h>
using namespace std;

class ExerciseMachine{
 public:
   int getPercentages(string time){
      int h,m,s;
      sscanf(time.c_str(),"%d:%d:%d",&h,&m,&s);
      int secs = s + m*60 + h*60*60;
      int sol  = 0;
      for( int i = 1 ; i < 100 ; ++i ){
         double p = (secs / 100.0) * i;
         if( fabs(  p-round(p)  )<0.000001 ) sol++;
      }
      return sol;
   }
};
#include<iostream>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<iomanip>
#include<set>
#include<string>
#include<queue>
#include<set>
using namespace std;

typedef long long ll;
#define f first
#define s second
#define mk make_pair

inline bool IsDigit( char a ){ return ( a>='0' && a<='9'); }
int diff[1000];

class Grader{
   public:
      vector <int> grade(vector <int> pg, vector <int> ag){
         for( int i = 0; i < pg.size(); ++i ){
            diff[ abs(pg[i]-ag[i])  ] ++;
         }
         int uk = (int)pg.size();
         double koef = double(100.0) / uk;
         vector<int>ret;
         for( int i = 0; i < 7; ++i ){
            if(  fabs( koef * diff[i] - round(koef*diff[i])  ) < 0.00001 ) 
               ret.push_back(  (int)round(koef * diff[i]) );
            else
               ret.push_back( (int)floor( koef * diff[i])  );
         }
         return ret;
            
      }
};
#include<iostream>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<iomanip>
#include<set>
#include<string>
#include<queue>
#include<set>
using namespace std;

typedef long long ll;
#define f first
#define s second
#define mk make_pair

inline bool IsDigit( char a ){ return ( a>='0' && a<='9'); }

pair<int,int>GetCoord( char c ){
   if( c == '1' )return mk(1,1);
   if( c == '2' )return mk(2,1);
   if( c == '3' )return mk(3,1);
   if( c == '4' )return mk(1,2);
   if( c == '5' )return mk(2,2);
   if( c == '6' )return mk(3,2);
   if( c == '7' )return mk(1,3);
   if( c == '8' )return mk(2,3);
   if( c == '9' )return mk(3,3);
   if( c == '*' )return mk(1,4);
   if( c == '0' )return mk(2,4);
   if( c == '#' )return mk(3,4);
   return mk(4,4);
}

int mhDist( pair<int,int> f , pair<int,int>s ){
   return abs(f.first-s.first) + abs(f.second-s.second);
}


class PhonePad{
   public:
      int fingerMovement(string call){
         char now = '5';
         int ans = 0;
         for( int i = 0; i < call.size(); ++i ){
            ans += mhDist( GetCoord(now) , GetCoord(call[i])   );
            now = call[i];
         }
         return ans;
      }
};
#include<iostream>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<iomanip>
#include<set>
#include<string>
#include<queue>
#include<set>
using namespace std;


class CircleDance{
   public:
      int arrangeDancers(vector <int> H){
         int sz = (int)H.size();
         sort(H.begin(),H.end());
         int sol = 0;
         for( int i = 0; i < sz-2; ++i )
            sol = max( sol , abs(H[i]-H[i+2])   );
         
         return sol;
      }
};

#include<cstdio>
#include<string>
#include<vector>
#include<iostream>
using namespace std;

class FibonacciPositioning{
   public:
      double getFPosition(int n){
         if( n == 1 )return 2.0;
         int prev = 1, now = 1;
         double idx = 3;
         while(true){
            int nxt = prev + now;
            prev = now , now = nxt;
            if( now == n )return idx;
            else if( now > n ){
               return (idx-1)+double(n-prev)/(now-prev);
            }
            idx++;
         }
      }
};

#include<iostream>
#include<algorithm>
#include<fstream>
#include<vector>
#include<math.h>
#include<vector>
#include<stack>
using namespace std;


int N,M;
bool ANODE[1050];
int degree[1050][2]; // 0 - IN , 1 - OUT
vector<int>graph[1050];



int NewNode( int node ){
   if( ANODE[ node ] )return 0;
   return (ANODE[ node ] = true);
}

bool visited[1050];
bool Connectivity(){
   for( int i = 0; i < 1020; ++i ){
      int node = i;
      if( ANODE[ i ] == false )continue; 
      memset(visited,0,sizeof(visited));
      int Vnodes = 1;
      stack<int>S;
      S.push( node );
      visited[ node ] = true;
      while( !S.empty() ){
         int u = S.top();
         S.pop();
         for( int i = 0; i < graph[ u ].size(); ++i ){
            if( visited[ graph[u][i] ] == false ){
               visited[ graph[u][i] ] = true;
               S.push( graph[u][i] );
               Vnodes++;
            }
         }
      }
      if( Vnodes == N )return true;
   }
   return false;
}

class OrderDoesMatter {
   public:
      int getOrder(vector <int> F1, vector <int> F2){
        M = (int)F1.size(), N = 0;
        for( int i = 0; i < M; ++i ){
            graph[ F1[i] ].push_back( F2[i] );
            N += NewNode( F1[i] ) + NewNode( F2[i] );
            degree[ F2[i] ][ 0 ]++;
            degree[ F1[i] ][ 1 ]++;
        }
        int odd(0),even(0),start(-1),end(-1);
        for( int i = 0; i < 1020; ++i ){
           if( ANODE[ i ] == false )continue;
           int diff = abs( degree[i][0] - degree[i][1] );
           if( diff > 1 )return -1;
           if( diff % 2 == 1 ){
              odd++;
              if( start == -1 )start = i;
              else if( end == -1 )end = i;
              else return -1;
           }else
              even++;
        }
        if( !Connectivity() )return -1;
        else if( start == -1 ){
           int sol = 0;
           for( int i = 0; i < 1020; ++i )
              if( ANODE[i] == true )sol = max( sol , i*i );
           return sol;
        }else{
          return start * end;
        }
        return -1;
      }
};

#include<cstdio>
#include<string>
#include<vector>
#include<iostream>
using namespace std;

char spinR( char c ){
   if( c == '|' )return '/';
   if( c== '/' )return '-';
   if( c== '-' )return char(92);
   if( c== 92 )return '|';
   return ' ';
}
char spinL( char c ){
   if( c == '|' )return char(92);
   if( c== '/' )return '|';
   if( c== '-' )return '/';
   if( c== 92 )return '-';
   return ' ';
}
char flip( char c ){
   if( c == '-' )return '|';
   if( c == 92 )return '/';
   if( c == '/')return char(92);
   if( c == '|')return '-';
   return ' ';
}

class IndicatorMotion{
   public:
      string getMotion(string program, char s){
         string ret = "";
         ret += s;
         for( int i = 0 ; i < (int)program.length()-2; ++i ){
            int d = (program[i+1]-'0')*10 + program[i+2] - '0';
            for( ; d ; d-- ){
               if( program[i] == 'F' )s = flip(s);
               if( program[i] == 'R' )s = spinR(s);
               if( program[i] == 'L' )s = spinL(s);
               ret += s;
            }
            i+=2;
         }
         return ret;
      }
};

#include<cstdio>
#include<string>
#include<vector>
#include<iostream>
using namespace std;

class FibonacciPositioning{
   public:
      double getFPosition(int n){
         if( n == 1 )return 2.0;
         int prev = 1, now = 1;
         double idx = 3;
         while(true){
            int nxt = prev + now;
            prev = now , now = nxt;
            if( now == n )return idx;
            else if( now > n ){
               return (idx-1)+double(n-prev)/(now-prev);
            }
            idx++;
         }
      }
};

#include<iostream>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<iomanip>
#include<set>
#include<string>
#include<queue>
#include<set>
using namespace std;

double DP[1005][1005];


class SimplifiedDarts{
   public:
      double tryToWin(int W, int N, int P1_, int P2_){
         double P1 = P1_ / 100.0;
         double P2 = P2_ / 100.0;
         for( int i = 0 ; i <= N; ++i )DP[i][0] = 1;
         
         for( int i = 1; i <= N; ++i ){
            for( int j = 0; j <= W; ++j ){
               DP[i][j] = (j-2>=0 ? DP[i-1][j-2] * P1 : 1*P1)  + (1-P1)*DP[i-1][j];
               DP[i][j] = max( DP[i][j] , (j-3>=0 ? DP[i-1][j-3] * P2 : 1*P2)  + (1-P2)*DP[i-1][j]   );
            }
         }
         return DP[N][W]*100;
      }
};
#include<iostream>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<iomanip>
#include<set>
#include<string>
#include<queue>
#include<set>
using namespace std;

typedef long long ll;
#define f first
#define s second
#define mk make_pair

inline bool IsDigit( char a ){ return ( a>='0' && a<='9'); }


class BiggestRectangleEasy{
   public:
      int findArea(int N){
         int sol = -1;
         for( int i = 1; i <= N; ++i ){
            for( int j = 1; j <= N; ++j ){
               if( i+j+i+j <= N ){
                  sol = max( sol , i*j );
               }
            }
         }
         return sol;
      }
};
#include<iostream>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<iomanip>
#include<set>
#include<string>
#include<queue>
#include<set>
using namespace std;

typedef long long ll;
#define f first
#define s second
#define mk make_pair

inline bool IsDigit( char a ){ return ( a>='0' && a<='9'); }

double dist( int x1, int y1, int x2, int y2 ){
   return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)  );
}

class ReturnToHome{
   public:
      double goHome(int X, int Y, int D, int T){
         double Di = dist(0,0,X,Y);
         
         //cout<<"DI "<< Di<<endl;
         double sol = 999999;
         for( int jumps = 0; jumps <= 1000; jumps++ ){
            double dis2 = fabs( Di - D*jumps );
            double minf = 99999999;
          //  cout<<jumps<<" "<<dis2<<" ";
            if( dis2 < D*2 ){
               minf = min( T*2.0 , T + fabs(dis2-D) );
               minf = min( minf , dis2 );
            }
         //   cout<<(jumps*T + minf  )<<endl;
            sol = min( sol , jumps*T + minf  );
         }
        
         
         
          
         return min( sol , Di );
      }
};
#include<iostream>
#include<string>
using namespace std;


class FunnyFence{
   public:
      int getLength(string s){
         int cnt = 0, sol = -1;
         for( int i = 0; i < s.length(); ++i ){
            if( i > 0 && s[i] == s[i-1] )
               cnt = 0;
            cnt++;
            sol = max(sol,cnt);
         }
         return sol;
      }
};
#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<vector>
#include<iomanip>
#include<math.h>
#include<string.h>
using namespace std;

const double PI = acos(0)*2;

class DegreesToRadians{
 public:
   double convertToRadians(int degrees, int minutes, int seconds){
      double stp = degrees + minutes/60.0 + seconds/60.0/60.0;
      return (stp*PI/180);
   }
};

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<vector>
#include<iomanip>
#include<string.h>
using namespace std;

vector<char> alpha;
int getIt( char c ){
   for( int i = 0; i < alpha.size(); ++i )
      if( alpha[i] == c )return i;
  return 0;
}

class TagalogDictionary{
   public:
      vector <string> sortWords(vector <string> words){
         alpha.push_back('a');
         alpha.push_back('b');
         alpha.push_back('k');
         alpha.push_back('d');
         alpha.push_back('e');
         alpha.push_back('g');
         alpha.push_back('h');
         alpha.push_back('i');
         alpha.push_back('l');
         alpha.push_back('m');
         alpha.push_back('n');
         alpha.push_back('n');
         alpha.push_back('o');
         alpha.push_back('p');
         alpha.push_back('r');
         alpha.push_back('s');
         alpha.push_back('t');
         alpha.push_back('u');
         alpha.push_back('w');
         alpha.push_back('y');
         for( int i = 0; i < words.size(); ++i ){
            int now = i;
            for( int j = i+1; j < words.size(); ++j ){
               int state;
               vector<int>v1,v2;
               for( int k = 0; k < words[now].length(); ++k ){
                  if( k+1<words[now].length() && words[now][k]=='n' && words[now][k+1]=='g' )
                     v1.push_back( 11 ), k++;
                  else{
                     v1.push_back( getIt( words[now][k] )  );
                  }
                  
               }
               cout<<endl;
               for( int k = 0; k < words[j].length(); ++k ){
                  if( k+1<words[j].length() && words[j][k]=='n' && words[j][k+1]=='g' )
                     v2.push_back( 11 ), k++;
                  else{
                     v2.push_back( getIt( words[j][k] )  );
                  }
               }
               state = 0;
               for( int k = 0; k < min( v1.size(), v2.size() ); ++k ){
                  if( v1[k] < v2[k] ){
                     state = -1;
                     break;
                  }
                  if( v1[k] > v2[k] ){
                     state = 1;
                     break;
                  }
               }
               if( state == 0 ){
                  if( v1.size() < v2.size() )
                     state = -1;
                  if( v1.size() > v2.size() )
                     state = 1;
               }
               if( state == 1 )
                  now = j;
            }
            swap(words[i],words[now]);
         } 
         return words;
      }
};

#include<cstdio>
#include<vector>
#include<iostream>
#include<math.h>
using namespace std;

int f(int x ){
   int ret = 1;
   while( x ){
      ret *= x%10;
      x /= 10;
   }
   return ret;
}

class PersistentNumber{
  public:
   int getPersistence(int n){
      int sol = 0;
      while(true){
         int len=0;
         int tmp = n;
         while(tmp){
            tmp/=10;
            len++;
         }
         if( len <=1 )return sol;
         n = f(n);
         sol++;
      }
   }
};

#include<iostream>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<iomanip>
#include<set>
#include<string>
#include<queue>
#include<set>
using namespace std;

typedef long long ll;
#define f first
#define s second
#define mk make_pair

inline bool IsDigit( char a ){ return ( a>='0' && a<='9'); }

int Whp,Shp;

class EnemyTowers{
   public:
      int attack(int myUnits, int hpT, int attackT, int numWodT, int numStoT){
         Whp = numWodT * hpT;
         Shp = numStoT * hpT;
         double koef =  double(myUnits) / (  ((long long)(Whp))+Shp  );
         long long G1,G2;
         int maxS = 9999999;
         
         int TMPW = Whp , TMPS = Shp;
         for( int transf = -30000; transf <= 30000; ++transf ){
             Whp = TMPW , Shp = TMPS;
             G1 = (int)round(koef * Whp)+transf;
             G2 = myUnits - G1;
             if( G1 < 0 || G1 > myUnits || G2 < 0 || G2 > myUnits )continue;
             int sol = 0;
             bool ok = false;
             for( sol = 0; sol <= 1000000; ++sol ){
                Whp -= G1;
                Shp -= G2;
                if( Whp <= 0 && Shp <= 0 ){
                   ok = true;
                   break;
                }
                if( Whp <=0 )Whp = 0;
                if( Shp <=0 )Shp = 0;
            
                int cntW = Whp / hpT;
                if( Whp % hpT )cntW++;
                int cntS = Shp / hpT;
                if( Shp % hpT )cntS++;
            
                G1 -= attackT * cntW;
                G2 -= attackT * cntS;

                if( (G1<=0 && Whp > 0) || ( G2<=0 && Shp > 0 )   ){
                   ok = false;
                   break;
                }
              
                if( G1 <= 0 )G1 = 0;
                if( G2 <= 0 )G2 = 0;
             }
             if( ok )
                maxS = min( maxS , sol+1 );
         }
         if( maxS < 9999999 )return maxS;
         else return -1;
      }
};

#include<iostream>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<iomanip>
#include<set>
#include<string>
#include<queue>
#include<set>
using namespace std;

typedef long long ll;
#define f first
#define s second
#define mk make_pair

inline bool IsDigit( char a ){ return ( a>='0' && a<='9'); }


class StrangeComputer{
   public:
      int setMemory(string mem){
         int sol = 0;
         string str(mem.size(),'0');
         for( int i = 0; i < mem.size(); ++i ){
            if( mem[i] != str[i] ){
               sol ++;
               for( int j = i; j < mem.size(); ++j )
                  str[j] = mem[i];
            }
         }
         return sol;
      }
};

#include<iostream>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<iomanip>
#include<set>
#include<string>
#include<queue>
#include<set>
using namespace std;

typedef long long ll;
#define f first
#define s second
#define mk make_pair

inline bool IsDigit( char a ){ return ( a>='0' && a<='9'); }


class OrderedNim{
   public:
      string winner(vector <int> layout){
         bool alice = true;
         bool ok = false;
         for( int i = 0; i < layout.size(); ++i ){
            if( layout[i] > 1 ){
               ok = true;
               break;
            }
            else if( layout[i] == 1 )
               alice = !alice;
         }
         if( ok ){
            if( alice )return "Alice";
            else return "Bob";
         }else{
            if( alice )return "Bob";
            else return "Alice";
         }
      }
};

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<string.h>
#include<vector>
using namespace std;

char str[100000];

void MoveSubString( char *pok, int pos, int dist ){
   if( dist >= 0 )
      for(int i = strlen(pok); i>=pos; --i )
         pok[i+dist] = pok[i];
   else
      for(int i = max(pos,-dist); i <= strlen(pok); ++i )
         pok[i+dist] = pok[i];
}
void InsertSubString( char *sub , int pos ){
   int len = strlen(sub);
   if( pos > strlen(str) )pos = strlen(str);
   MoveSubString( str , pos , len );
   for( int i = 0; i < len; ++i )
      str[pos+i] = sub[i];
   
}
void DeleteXTH( int z ){
   int A = z;
   while( z <= strlen(str) ){
      MoveSubString( str , z , -1 );
      z += A-1;
   }
}
void DelChar( char c ){
   int i = 0;
   while( i < strlen(str) ){
      if( str[i] == c )
         MoveSubString( str, i+1, -1 );
      else
         i++;
   }
}
void Rev( int a, int b ){
   reverse(str+a-1,str+b);
}
void Shift( int steps ){
   int len = strlen(str);
   for( int i = 0; i < steps%len; ++i ){
       MoveSubString( str,0,1 );
       str[0] = str[len];
       str[len] = '\0';
   }
}

char buff[100000];

int main(){
   bool OK = true;
   int c;
   scanf("%s",str);
   while(true){
      scanf("%d",&c);
      if( !c )break;
      else if( c == 1 ){
         int idx;
         scanf("%d%s",&idx,buff);
         reverse(buff,buff+strlen(buff));

         InsertSubString(buff,idx-1);
      }else if( c == 2 ){
         int stp;
         scanf("%d",&stp);
         DeleteXTH(stp);
      }else if( c == 3 ){
         char g;
         cin>>g;
         DelChar(g);
      }else if( c == 4 ){
         int a,b;
         scanf("%d%d",&a,&b);
         Rev(a,b);
      }else if( c == 5 ){
         int stp;
         scanf("%d",&stp);
         Shift(stp);
      }
      if( strlen(str) == 0 ){ OK = false;break; }
   }
   if( OK )
      printf("%s\n",str);
   else
      printf("-1\n");
   return 0;
}

#include<iostream>
#include<vector>
#include<cstdlib>
#include<iomanip>
#include<math.h>
#include<cstdio>
#include<set>
#include<queue>
#include<stack>
using namespace std;

long long dp[105][6][2];
int len;
char str[105];

inline bool IsVowel( char c ){
   return ( c == 'A' || c =='E' || c =='I' || c=='O' || c=='U' );
}
inline bool IsCons( char c ){
   return !IsVowel( c );
}


long long rek( int idx , bool wasL , int cnt ){
   int state1 , state2;
   
   
   if( cnt == -3 || cnt == 3 )return 0;
   else if( cnt == -2 )  state1 = 0;
   else if( cnt ==  2 )  state1 = 1;
   else if( cnt == 1  )  state1 = 2;
   else if( cnt == -1 )  state1 = 3;
   else                  state1 = 4;
   
   
   if( wasL )state2 = true;
   else state2 = false;
   
   if( idx == len )return wasL;
   
   if( dp[idx][state1][state2] != -1 )return dp[idx][state1][state2];
   
   int s = 'A' , e = 'Z';
   if( str[idx] != '_' )s = str[idx] , e = str[idx];
   
   int c;
   long long sol = 0;
   for( char i = s; i <= e; ++i ){
      if( IsVowel( i ) )c = max(cnt+1,1);
      else c = min(cnt-1,-1);
      sol += rek( idx+1 , i=='L' ? true : wasL , c );
   } 
   
   return ( dp[idx][state1][state2] = sol );
}

int main(){
   scanf("%s",str);
   len = strlen(str);
   memset(dp,-1,sizeof(dp));
   cout<< rek( 0 , false , 0 ) << endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<vector>
#include<cstdlib>
#include<iomanip>
#include<math.h>
#include<cstdio>
#include<set>
#include<queue>
#include<stack>
using namespace std;

int main(){
   int N;
   scanf("%d",&N);
   long long sol = 0;
   for( int i = 0; i <= N; ++i )
      for( int j = 0; j <= i; ++j )
         if( i-j <= N && j <= N )
            sol += j + i;

   cout<< sol <<endl;
   system("Pause");
   return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:evenodd
*/
#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
#include<iomanip>
#include<set>
#include<queue>
#include<stack>
#include<string.h>
using namespace std;

char buff[10000];

int main(){
   freopen("evenodd.in","r",stdin);
   freopen("evenodd.out","w",stdout);
   int n;
   scanf("%d",&n);
   for( int i = 0; i < n; ++i ){
      scanf("%s",buff);
      if( buff[ strlen(buff) - 1 ] % 2 == 0 )
         printf("even\n");    
      else
         printf("odd\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<queue>
#include<string.h>
#include<vector>
#include<cstdlib>
using namespace std;

int N;
vector<int>prizes[20005];


int main(){
   int p,r;
   scanf("%d",&N);
   for( int i = 0; i < N; ++i ){
      scanf("%d%d",&p,&r);
      prizes[r].push_back(p);
   }
   priority_queue<int>PQ;
   int sol = 0;
   for( int i = 20000; i >= 1; --i ){
      for( int j = 0; j < prizes[i].size(); ++j )
         PQ.push( prizes[i][j] );
      if( !PQ.empty() )
         sol += PQ.top() , PQ.pop();
   }
   printf("%d\n",sol);
   return 0;
}

#include<iostream>
#include<math.h>
#include<cstdlib>
#include<algorithm>
#include<vector>
#include<iomanip>
using namespace std;



int jmp[500005];
int sz[500005];
int nxt[500005];
int visited[500005];



int dfs_cnt;
void dfs( int node , int deep ){
   visited[ node ] ++;
   if( visited[ node ] == 2 && dfs_cnt == -1 )dfs_cnt = deep;
   if( visited[ node ] == 2 )nxt[ node ] = deep;
   
   if( dfs_cnt > 0 )
      dfs_cnt --;
   
   if( dfs_cnt == 0 )
      return;
   
   dfs( jmp[ node ] , deep + 1 );
   
   sz[ node ] = nxt[ node ] - deep;
   
}

inline long long __lcm( long long a , long long b ){
   return (a*b) / __gcd( a , b );
}


int main(){
  int N,A,B,C,D;
  scanf("%d%d%d%d%d",&N,&A,&B,&C,&D);
  C++;
  D = N-D;
  for( int i = 1; i <= N; ++i )
     scanf("%d",&jmp[i]);
  
  for( int i = C; i <= D; ++i ){
       
     dfs_cnt = -1;
     if( visited[ i ] != 2 )
        dfs( i , 1 );
     
  }
  
  
  long long lcm = 1;
  for( int i = C; i <= D; ++i )
     lcm = __lcm( lcm , sz[i] );
  
  A--;
  B--;
  int cc = ( A / lcm ) * lcm ;
  if( A % lcm ) cc += lcm;
  
  int sol;
  if(  !(cc >= A && cc <= B)  ) sol = 0;
  else{
     sol = ( ( B - cc ) / lcm ) + 1;
  }
  
  cout<<sol<<endl;
  return 0;
}

#include<iostream>
#include<vector>
#include<cstdlib>
#include<iomanip>
#include<math.h>
#include<cstdio>
#include<set>
#include<queue>
#include<stack>
using namespace std;

int N,A,B,C,D;
int gooto[500005];

int now[5000];
int nxt[5000];

int main(){
   scanf("%d%d%d%d%d",&N,&A,&B,&C,&D);
   int from = C;
   int to   = N-D;
   
   for( int i = 1; i <= N; ++i )
      scanf("%d",&gooto[i]);
   
   for( int i = 1; i <= N; ++i )
      now[i] = i;
   
   
   int sol = 0;
   if( A == 1 )sol++;
   
   for( int i = 2; i <= B; ++i ){
      
      for( int j = 1; j <= N; ++j )
         nxt[ gooto[j] ] = now[j];
      
      memcpy( now , nxt , 5000 * 4);
      
      if( i >= A ){
         bool ok = true;
   
         for( int j = from+1; j <= to && ok; ++j )
            if( now[j] != j )ok = false;

         sol += ok;
      }
      
   }
   printf("%d\n",sol);
   return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:heatwv
*/
#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
#include<iomanip>
#include<set>
#include<queue>
#include<stack>
#include<string.h>
using namespace std;

#define mk make_pair
#define f first
#define s second

struct  edge{
   int b,d;
   edge( int p1, int p2 ):b(p1),d(p2){};
   edge(){};
};


const int INF = 999999999;
int N,M,s,e;
vector< edge > G[ 3000 ];
bool visited[ 3000];

int main(){
   //freopen("Ulaz.txt","r",stdin);
   //freopen("heatwv.out","w",stdout);
   fscanf(in,"%d%d%d%d",&N,&M,&s,&e);
   for( int i = 0; i < M; ++i ){
      int a,b,c;
      fscanf(in,"%d%d%d",&a,&b,&c);
      G[a].push_back( edge(b,c) );
      G[b].push_back( edge(a,c) );
   }
   
   priority_queue< pair<int,int> > PQ;
   PQ.push( mk(INF,s) );
   pair<int,int> u;
   while( !PQ.empty() ){
      u = PQ.top();
      PQ.pop();
      
      int node = u.s;
      int dist = INF - u.f;
      if( node == e )break;
      
      visited[ node ] = true;
      
      for( int i = 0; i < G[node].size(); ++i ){
         int D = dist + G[node][i].d;
         if( visited[ G[node][i].b ] == false )
            PQ.push( mk( INF-D , G[node][i].b )  );
      }
   }
   
   printf("%d\n", INF - u.f );
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<math.h>
#include<queue>
using namespace std;

#define Q first
#define key second
#define mk make_pair

struct worker{
   int V,Q,idx;
   double U;
   worker( int p1 , int p2 , int p3 ):V(p1),Q(p2),idx(p3){
      U = V / double(Q);
   }
   bool operator<( const worker &w2 ) const{   return (U < w2.U);   }
};

int N;
long long W;
const int inf = 9999999;
vector< worker >V;
bool ok[500005];

int main(){
   scanf("%d%lld",&N,&W);
   int va,qa;
   for( int i = 0; i < N; ++i ){
     scanf("%d%d",&va,&qa);
     V.push_back( worker(va,qa,i) );
   }
   sort(V.begin(),V.end());
   priority_queue<  double  >PQ;
   priority_queue< pair<double,int> >hired;
   int BestH=-1;
   double UkQ=0,MxQ,BestC=inf;
   int I=-1;
   for( int i = 0; i < N; ++i ){
      PQ.push( V[i].Q  );
      UkQ += V[i].Q;
      MxQ = W / V[i].U;
      if( UkQ > MxQ ){
         UkQ -= PQ.top();
         PQ.pop();
      }
      int hired = PQ.size();
      double cost = V[i].U * UkQ;
      if( hired>BestH || (hired==BestH && cost < BestC)  )
         BestH = hired,BestC = cost,I=i;
   }
   UkQ = 0;
   for( int i = 0; i <= I; ++i ){
      hired.push( mk( V[i].Q , V[i].idx )  );
      ok[ V[i].idx ] = true;
      UkQ += V[i].Q;
   }
   while( W / V[I].U < UkQ ){
      ok[ hired.top().key ] = false;
      UkQ -= hired.top().Q;
      hired.pop();
   }


   printf("%d\n",(int)PQ.size());
   for( int i = 0; i < N; ++i )
      if( ok[ V[i].idx ] )printf("%d\n",V[i].idx+1);
   
   system("Pause");
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <string.h>
#include <cstdlib>
#include <vector>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <string>
using namespace std;

int N,M;
vector< char >alpha;
vector< short>vals;
int hashV[255];
int player[101][255];
int words[10005][255];

char buff[10005];

char *NO_SOLUTION = "[ispao]";


struct stringc{
   char str[101];
   bool operator<( const stringc &s2 ) const {
      int g = strcmp( str, s2.str);
      return (g == -1);
   }
};

stringc dict[10005];


int main() {
    FILE *in = fopen("Ulaz.txt","r");
    FILE *out = fopen("igra.out","w");
    char c;
    int vi;
    while( c = fgetc(in) ){
       if( c >= 'a' && c <= 'z' )
          alpha.push_back(c);
       else if( c >= '0' && c <='9' )
          break;
    }
    vals.push_back( c - '0' );
    for( int i = 0; i < (int)alpha.size() - 1; ++i ){
        fscanf(in,"%d",&vi);
        vals.push_back( vi );
    }
    
    for( int i = 0; i < (int)alpha.size(); ++i )
       hashV[ alpha[i] ] = vals[i];
       
       
    
    fscanf(in,"%d",&N);
    for( int i = 0; i < N; ++i ){
       fscanf(in,"%s",buff);
       int len = strlen(buff);
       
       for( int j = 0; j < len; ++j )
           player[i][ buff[j] ] ++;
           
    }
    
    
    
    
    fscanf(in,"%d",&M);
    for( int i = 0; i < M; ++i ){
       fscanf(in,"%s",dict[i].str);
    }
    sort( dict , dict + M );
    
    
    for( int i = 0; i < M; ++i ){
       int len = strlen(dict[i].str);
       
       for( int j = 0; j < len; ++j )
          words[i][ dict[i].str[j] ] ++;
    }
    
    
    
    for( int i = 0; i < N; ++i ){
       int maxV = -1;
       char *ans = NO_SOLUTION;
       for( int j = 0; j < M; ++j ){
          int jokers = player[i]['X'];
          int value = 0;
          
          for( int k = 'a'; k <= 'z' && jokers >= 0; ++k ){
             value += hashV[k] * words[j][k];
             if( player[i][k] >= words[j][k] )continue;
             jokers -= words[j][k] - player[i][k];
          }
          if( jokers >= 0 && maxV < value  ){
             maxV = value;
             ans = dict[j].str;
          }
       }
       fprintf(out,"%s\n",ans);
    }
    
    
    
    return 0;
}

#include<vector>
#include<iostream>
#include<string.h>
#include<string>
#include<math.h>
#include<cstdlib>
#include<cstdio>
#include<iomanip>
using namespace std;

struct coord{
   int x,y;
   coord( int p1, int p2 ):x(p1),y(p2){};
   coord(){};
};


int n;
coord segs[1005][2]; // x1,y1,x2,y2;


int cross( coord A, coord B, coord C ){
   return (B.x-A.x)*(C.y-A.y) - (B.y-A.y)*(C.x-A.x);
}

bool OnLine( coord A, coord B, coord C ){
   return( min(A.x,B.x)<=C.x && C.x<=max(A.x,B.x) && min(A.y,B.y)<=C.y && C.y<=max(A.y,B.y)  );
}

bool intersect( int idxA , int idxB ){
   int s1 = cross( segs[idxA][0], segs[idxA][1] , segs[idxB][0] );
   int s2 = cross( segs[idxA][0], segs[idxA][1] , segs[idxB][1] );
   int s3 = cross( segs[idxB][0], segs[idxB][1] , segs[idxA][0] );
   int s4 = cross( segs[idxB][0], segs[idxB][1] , segs[idxA][1] );
   
   if(  (  (s1<0 && s2>0)||(s1>0 && s2<0)  ) &&  (  (s3<0 && s4>0)||(s3>0 && s4<0)  )         )
       return true;
   else if( s1==0 && OnLine( segs[idxA][0], segs[idxA][1] , segs[idxB][0] ) )
       return true;
   else if( s2==0 && OnLine( segs[idxA][0], segs[idxA][1] , segs[idxB][1] ) )
       return true;
   else if( s3==0 && OnLine( segs[idxB][0], segs[idxB][1] , segs[idxA][0] ) )
       return true;
   else if( s4==0 && OnLine( segs[idxB][0], segs[idxB][1] , segs[idxA][1] ) )
       return true;
   return false;
}

vector<int>G[1005];
bool visited[1005];

void dfs( int node ){
   visited[ node ] = true;
   for( int i = 0; i < G[node].size(); ++i ){
      if( visited[ G[node][i] ] == false ){
         dfs( G[node][i] );
      }
   }
}

int main(){
   scanf("%d",&n);
   int x1,y1,x2,y2;
   for( int i = 0; i < n; ++i ){
      scanf("%d%d%d%d",&x1,&x2,&y1,&y2);
      segs[i][0] = coord(x1,y1);
      segs[i][1] = coord(x2,y2);
   }
   
   for( int i = 0; i < n; ++i ){
      for( int j = 0; j < n; ++j ){
         if( i != j ){
            if( intersect(i,j) )
               G[i].push_back(j) , G[j].push_back(i);
         }
      }
   }
   int sol = 0;
   for( int i = 0; i < n; ++i ){
      if( visited[i] )continue;
      dfs(i);
      sol++;
   }
   printf("%d\n",sol);
   return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <set>
#include <stack>
using namespace std;

const int MAXN = 1000 + 100000;
const int INF = 99999999;

int H, P, S;
int scc_counter = 0;
int AnsHotel = INF;
int AnsPlaces = -1;

stack< int >STK;
vector< int >G[MAXN+5];

int idx[MAXN+5];
int lowID[MAXN+5];
bool InSet[MAXN+5];
bool visited[MAXN+5];

void dfs( int node ){
    visited[ node ] = true;
    STK.push( node );
    InSet[ node ] = true;
    lowID[ node ] = idx[ node ] = scc_counter++;
    
    for( int i = 0; i < G[node].size(); ++i ){
        if( visited[ G[node][i] ] == false ){
            dfs( G[node][i] );
            lowID[ node ] = min( lowID[ G[node][i] ] , lowID[ node ]  );
        }else if( InSet[ G[node][i] ] && idx[ G[node][i] ] < idx[ node ] ){
            lowID[ node ] = min( idx[ G[node][i] ] ,   lowID[ node ]  );
        }
    }
    
    if( lowID[ node ] == idx[ node ] ){
       int HOTEL = INF;
       int cntPlaces = 0;
       
       while( !STK.empty() && idx[ STK.top() ] >= idx[ node ]  ){
          if( STK.top() <= 1000 )
              HOTEL = min( HOTEL , STK.top() );
          else
              cntPlaces ++;
          
          InSet[ STK.top() ] = false;
          STK.pop();
       }
      // cout<<cntPlaces << " " << HOTEL<<endl;
       if( HOTEL != INF )
          if( AnsPlaces < cntPlaces || ( AnsPlaces == cntPlaces && HOTEL < AnsHotel )  )
             AnsPlaces = cntPlaces , AnsHotel = HOTEL;
       
    }
}


int main(){
   FILE *in = stdin;//fopen("Ulaz.txt","r");
   
   int tests;
   fscanf(in,"%d",&tests);
   
   for( ; tests ; tests-- ){
      
      int f,t;
      fscanf(in,"%d%d%d",&H,&P,&S );
      
      
      AnsHotel = INF;
      AnsPlaces = 0;
      scc_counter = 0;
      while( !STK.empty() )STK.pop();
      for( int i = 0; i <=1009+P;++i ){
         idx[i] = lowID[i] = InSet[i] = visited[i] = 0;
         G[i].clear();
      }
      
      
      for( int i = 0; i < S; ++i ){
          fscanf(in,"%d%d",&f,&t);
          G[f].push_back(t);
      }
      
      for( int i = 1; i <= H; ++i ){
          if( visited[ i ] == false ){
             dfs( i );
          }
      }
      
      printf("%d %d\n", AnsHotel , AnsPlaces );
   }
   
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<iomanip>
#include<set>
#include<math.h>
#include<queue>
#include<list>
#include<string.h>
#include<assert.h>
#include<map>
using namespace std;

#define EXIT -999999
#define WEITER 39432049

double euclid ( double x1, double y1, double x2, double y2 ){
   return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
   double nowx,nowy;
   double x,y;
   double sol = 0;
   bool Walking = false;
   while( true ){
      int signal = 0;
      int c;
      while( c = getchar() ){
         if( c == -1 ){
            signal = EXIT;
            break;
         }else if( c == '(' ){
            signal = WEITER;
            break;
         }
      }
      if( signal == EXIT )break;
      
      scanf("%lf, %lf",&x,&y);
      
      if( Walking == false ){
         nowx = x , nowy = y;
         Walking = true;
         continue;
      }
      
      sol += euclid(nowx,nowy,x,y);
      nowx = x , nowy = y;
      
      printf("The salesman has traveled a total of %.3lf kilometers.\n",sol);
      
      
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<algorithm>
#include<vector>
#include<string.h>
using namespace std;

int n;
vector< int > G[1000];
double dp[1000];
double _dp[1000];
bool visited[1000];


int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
   int a,b;
   while( scanf("%d",&n) == 1 ){
       if( n == 0 )break;
       
       for( int i = 0; i <= 400; ++i ){
          dp[i] = _dp[i] = 0;
          G[i].clear();
          visited[i] = 0;
       }
       
       
       for( int i = 0; i < n; ++i ){
           scanf("%d%d",&a,&b);
           G[a].push_back(b);
           G[b].push_back(a);
       }
       
       dp[0] = _dp[0] = 1;
       for( int i = 0; i <= 500; ++i ){
           for( int j = 0; j <= 290; ++j )
              _dp[j] = 0;
           for( int j = 0; j <= 290; ++j ){
                if( dp[j] == 0|| G[j].size() == 0  )continue;
                visited[j] = true;
                double koef = dp[j] / (int)G[j].size();
                 for( int k = 0; k < G[j].size(); ++k )
                     _dp[ G[j][k] ] += koef;
            
           }
           for( int i = 0 ; i <= 300; ++i )
              dp[i] = _dp[i];
       }
       
       
       double tourist = 0;
       double hotel = 0;
   
       for( int i = 290; i < 300; ++i )
          tourist += dp[i];
   
       hotel += dp[300];
       if(  (tourist + hotel) != 0 )
          printf("%.3lf\n", hotel / ( tourist + hotel ) );
       else
          printf("0\n");
   }
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <string.h>
using namespace std;

#define f first
#define s second

const int MOD = 1000;
const int PRIME = 4111;


int GetKey( char *str , int len ){
   int key = 0;
   for( int i = 0; i < len; ++ i ){
      key = (key*PRIME + str[i] )%MOD;
   }
   return key;
}

const int LIMIT = 250;
const int INF   = (int)1e9;
int c;
int n,d;
char buff[100005];
int vals[10005];

vector< pair<int,int> >lex;
vector< int >depend[10005];
bool available[100005];


int main(){
   FILE *in = stdin;//  fopen("Ulaz.txt","r"); 
    
    while( fscanf(in,"%d%d",&n,&d) == 2 ){
      
      if( n == 0 && d == 0 )break;
      
      lex.clear();
      for( int i = 0; i < MOD; ++i ){
         vals[i] = available[i] = 0;
         depend[i].clear();
      }

      for( int i = 0; i < n; ++i ){
      
         fscanf(in,"%s %d", buff , &c ); 
         int key = GetKey( buff , strlen(buff) );
      
         lex.push_back( make_pair( c , key )  );
         vals[ key ] = c;
      
      }
      sort( lex.begin() , lex.end()  );
   
      vector<int>propeties;
   
      for( int i = 0; i < d; ++i ){

         fscanf(in,"%s",buff);
         int key1 = GetKey( buff , strlen( buff )  );
      
         fscanf(in,"%s",buff);
         int key2 = GetKey( buff , strlen( buff )  );
      
         depend[key1].push_back( key2 );
         propeties.push_back( key2 );
      }

      sort( propeties.begin() , propeties.end() );
      propeties.erase( unique(propeties.begin(), propeties.end()), propeties.end() );
   
      int solCnt = 0 , solRem = 0;
      int pCount = propeties.size();

      for( int i = 0; i < (1<<pCount); ++i ){
      
         int PropCost = 0;
         int cnt = 0;
      
         for( int j = 0; j < pCount; ++j )
            if( i&(1<<j)  ){
               PropCost += vals[ propeties[j] ];
               cnt ++;
               available[ propeties[j] ] = true;
            }
         
         
         if( PropCost < LIMIT ){
         
            for( int j = 0; j < n; ++j ){
               if( available[ lex[j].s ] == true ) continue;
               if( PropCost + lex[j].f > LIMIT )break;
            
               bool ok = true;
               for( int k = 0; k < depend[ lex[j].s ].size() && ok; ++k )
                  if( available[ depend[ lex[j].s  ][ k ]  ] == false )
                     ok = false;
            
               if( ok ){
   
                  PropCost += lex[j].f;
                  cnt++;
               }
            
            }
      
         }
      
      
      
         for( int j = 0; j < pCount; ++j )
            if( i&(1<<j) )
                available[ propeties[j] ] = false;
      

        if( solCnt < cnt || ( solCnt == cnt && LIMIT-PropCost > solRem )    )
            solCnt = cnt , solRem = LIMIT - PropCost;

      }
   
      printf("%d %d\n", solCnt , solRem );
   }

   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<cstdlib>
#include<math.h>
#include<iomanip>
using namespace std;

int main(){
   int marbles;
   while( scanf("%d",&marbles ) == 1  ){
       if( marbles == 0 )break;
       int Z = marbles;
       int divs = 1 , y;
       
       y = 0;
       vector< int > V;
       while( marbles % 2 == 0 ){
          marbles /= 2;
          V.push_back(2);
          y++;
       }
       divs *= y+1;
       
       
       for( int i  = 3; i*i <= Z; i+=2 ){
          y = 0;
          while( marbles % i == 0){
             marbles /= i;
             V.push_back(i);
             y++;
          }
          divs *= y+1;
       }
       if( marbles != 1 ){
          V.push_back( marbles );
          divs *= 2;
       }
   
       int sz = V.size();
       printf("%d = ",Z);
       for( int i = 0; i < sz-1; ++i ){
          printf("%d * ",V[i]);
       }
       printf("%d\n",V[sz-1]);
       printf("With %d marbles, %d different rectangles can be constructed.\n",Z, (int) ceil(divs/2.0)     );
   }
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
#include<string>
#include<iostream>
#include<string.h>
using namespace std;

char buff[1400];
short mode;
vector<char>A;
vector<char>B;

void PrintVec( vector<char> &V ){
   int i,n=V.size();
   for(i=n-1;i>=0;i--)printf("%c",V[i]);
}

void splitBuff(){
   int sizeN = strlen(buff);
   mode = -1;
   A.clear();
   B.clear();
   for( int i = sizeN-1;i>=0;i-- ){
      if( buff[i]=='+' ){
         mode = 1;
         continue;
      }else if( buff[i]=='-' ){
         mode = 2;
         continue;
      }else if( buff[i]=='*' ){
         mode = 3;
         continue;
      }
      if( mode == -1 )
         B.push_back( buff[i] );
      else
         A.push_back( buff[i] );
   }
}

void MultyMe( vector<char> &V , int scalar ){
   int sizeV = V.size();
   int add=0,tmp;
   for(int i=0;i<sizeV;i++){
      tmp = (V[i]-'0')*scalar + add;
      V[i]=(tmp%10)+'0';
      add = tmp/10;
   }
   while( add ){
      V.push_back((add%10)+'0');
      add/=10;
   }
   while(*(A.end()-1)=='0' && A.size()>1)A.pop_back();
}

void AddToMe( vector<char> &A , vector<char> &B ){
   int sizeN = max(A.size(),B.size());
   int elem1,elem2,add=0,tmp;
   for(int i=0;i<sizeN;i++){
       if(i<A.size())elem1=A[i]-'0';
       else elem1=0;
       if(i<B.size())elem2=B[i]-'0';
       else elem2=0;
       tmp = elem1+elem2+add;
       if(i<A.size())A[i]=(tmp%10)+'0';
       else A.push_back((tmp%10)+'0');
       add = tmp/10;
   }
   while(add){
      A.push_back((add%10)+'0');add/=10;
   }
   while(*(A.end()-1)=='0' && A.size()>1)A.pop_back();
}

void TekeFromMe( vector<char> &A , vector<char> &B ){
   int n = A.size();
   int TakeMore=0,T;
   int tmp;
   int i,j,elem2;
   bool Under0;
   for(i=0;i<n;i++){
       Under0=false;
       if( i<B.size())elem2=B[i];
       else elem2 = '0';
       for(j=0;!Under0;j++){
          T=j*10;
          tmp = (A[i]-'0'+T)-((elem2-'0')+TakeMore);
          if( tmp>=0 )
              Under0=true;
       }
       TakeMore = j-1;
       A[i] = (tmp%10)+'0';
   }
   while( *(A.end()-1)=='0' && A.size()>1 )
           A.pop_back();
}

void PrintSpace(int s){
   for(int i=0;i<s;i++)printf(" ");
}

vector<char>rows[501];
void DoMultiplication()
{
   vector<char>SUM;
   for(int i=0;i<B.size();i++){
      rows[i] = A;
      MultyMe( rows[i] , int(B[i]-'0') );
      reverse(rows[i].begin(),rows[i].end());
      for(int j=0;j<i;j++)rows[i].push_back('0');
      reverse(rows[i].begin(),rows[i].end());
      AddToMe(SUM,rows[i]);
      
      reverse(rows[i].begin(),rows[i].end());
      for(int j=0;j<i;j++)rows[i].pop_back();
      reverse(rows[i].begin(),rows[i].end());
      //PrintVec(SUM);printf("\n");
      
       while( *(rows[i].end()-1)=='0' && rows[i].size()>1 )
           rows[i].pop_back();
   }
   int width = max( A.size() , max( B.size()+1, SUM.size()));
   PrintSpace( width-A.size());
   PrintVec(A);printf("\n");
   PrintSpace( width-B.size()-1);printf("*");
   PrintVec(B);printf("\n");
   
   int ss = max(rows[0].size(),B.size()+1 );
   if(B.size()>1)
   {
      PrintSpace(width-ss);
      for(int i=0;i<ss;i++)
         printf("-");printf("\n");
      int W2 = width;
      for(int i=0;i<B.size();i++){
         PrintSpace( W2-rows[i].size());
         PrintVec(rows[i]);printf("\n");
         W2--;
      }
   }
   width = max( A.size() , max( B.size()+1, SUM.size()));
   PrintSpace( width-SUM.size());
   
   for(int i=0;i<SUM.size();i++)
      printf("-");printf("\n");
   PrintSpace( width-SUM.size());
   PrintVec(SUM);printf("\n");
}

void DoMinus(){
   vector<char>RES = A;
   TekeFromMe(RES,B);
   int width = max( A.size() , B.size()+1 );
   PrintSpace(width-A.size());
   PrintVec(A);printf("\n");
   PrintSpace(width-B.size()-1);
   printf("-");
   PrintVec(B);printf("\n");
   
   int w2 = max( B.size()+1 , RES.size() );
   
   PrintSpace(width-w2);
   for(int i=0;i<w2;i++)
      printf("-");printf("\n");
   PrintSpace(width-RES.size());
   PrintVec(RES);printf("\n");
}

void DoSum(){
   vector<char>RES = A;
   AddToMe(RES,B);
   int width = max(RES.size(),B.size()+1);
   PrintSpace(width-A.size());
   PrintVec(A);printf("\n");
   PrintSpace(width-B.size()-1);
   printf("+");
   PrintVec(B);printf("\n");
   for(int i=0;i<width;i++)
      printf("-");printf("\n");
   PrintSpace(width-RES.size());
   PrintVec(RES);printf("\n");
}

int main()
{
  // freopen("Ulaz.txt","r",stdin);
  // freopen("Izlaz.txt","w",stdout);
   int n;
   scanf("%d",&n);
   for(int i=0;i<n;i++)
   {
      scanf("%s",buff);
      splitBuff();
      if(mode==3)DoMultiplication();
      if(mode==2)DoMinus();
      if(mode==1)DoSum();
      printf("\n");
   }
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <set>
#include <string.h>
using namespace std;


int N;
int arr[100015];
int sum[100015];
int cnt[100015];
int nxt[100015];

int main () {
  //  freopen("Ulaz.txt" , "r" , stdin);
//	freopen("Izlaz2.txt" , "w" , stdout);
    
    scanf("%d",&N);
    for( int i = 1; i <= N; ++i ){
       scanf("%d",&arr[i]);
       sum[i] = sum[i-1] + arr[i];
    }
    int sol = 0;
    int last = N;
    
    for( int i = N; i >= 1; --i ){
       cnt[ arr[i] ]++;
       while( cnt[ arr[i] ] > 1 ){
          cnt[ arr[last]  ]--;
          last--;
       }
       nxt[ i ] = last;
    }
    
    for( int i = 0; i < N; ++i ){
       for( int j = i+sol+1; j <= nxt[i+1];){
          int diff = j-i;
          int v  = (sum[j]-sum[i]) - (long long)(diff+1)*diff / 2;
          if( v == 0){
             sol = diff;
             j++;
          }else
             j += int( v / (diff) ) + int( v%(diff) > 0 );
       }
    }


    printf("%d\n", sol );

    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<cstdlib>
#include<math.h>
#include<iomanip>
#include<string.h>
#include<algorithm>
using namespace std;

struct coord{
   int x,y;
   coord( int p1, int p2 ):
      x(p1),y(p2){};
   coord(){};
   bool operator!=(const coord &c2 )const{
      return ( x!=c2.x && y != c2.y );
   }
   
};

int dist( int x1, int y1, int x2, int y2 ){
   return ( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );
}

int cross( coord A, coord B, coord C ){
   return (B.x-A.x)*(C.y-A.y) - (B.y-A.y)*(C.x-A.x);
}


coord transm;
int N;
double radius;
vector< coord >h1;
vector< coord >h2;
vector< coord >points;

bool cw( coord a, coord b ){
   return cross( transm , a , b ) >= 0;
}
bool cw2 ( coord a , coord b ){
   return cross( transm , a , b ) > 0;
}

int main(){
   // FILE *in = fopen("Ulaz.txt","r");
    int xi,yi;
    while( scanf("%d%d%lf",&transm.x,&transm.y,&radius) == 3 ){
       if( radius < 0 )break;
       scanf("%d",&N);
       h1.clear();
       h2.clear();
       points.clear();
       for( int i = 0; i < N; ++i ){
          scanf("%d%d",&xi,&yi);
          if( dist( transm.x , transm.y , xi, yi ) <= radius * radius ){
             if( xi < transm.x ) h1.push_back( coord(xi,yi) );
             else h2.push_back( coord(xi,yi)  );
          }
       }
       sort( h1.begin() , h1.end() , cw);
       sort( h2.begin() , h2.end() , cw2 );
       for( int i = 0; i < h1.size(); ++i )
          points.push_back( h1[i] );
          
       for( int i = 0; i < h2.size(); ++i )
          points.push_back( h2[i] );
          
       int j = 0 , sol = 0;
       for( int i = 0; i < points.size(); ++i ){
          j = i;
          while( cross( transm , points[i] , points[ j+1 != points.size() ? j+1 : (j=-1)+1 ] ) >=0 && j+1 != i){
             j++;

          }

          int ans = 0;
          if( j < i )
             ans =  (int)points.size() - i + j + 1;
          else
             ans =  j-i+1 ;
          sol = max( sol , ans );

       }
       cout<<sol<<endl;
       
    }
    
   // system("Pause");
    return 0;
}

#include<iostream>
#include<vector>
#include<cstdlib>
#include<iomanip>
#include<math.h>
#include<cstdio>
#include<set>
#include<queue>
#include<stack>
using namespace std;

long long arr[10000];

int main(){
   int N,Q,com,L,R,A,B;
   scanf("%d%d",&N,&Q);
   for( int i = 0; i < Q; ++i ){
      scanf("%d",&com);
      if( com == 2 ){
          
         scanf("%d%d",&L,&R);
         long long sum = 0;
         for( int i = L; i <= R; ++i )
            sum += arr[i];
         printf("%lld\n",sum);
      
      }else{
         
         scanf("%d%d%d%d",&L,&R,&A,&B);
         for( int i = L; i <= R; ++i ){
            arr[i] = ( ( long long )(i - L + 1) * A ) % B;
         }
         
      }
   }
   return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:echo
*/
#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
#include<iomanip>
#include<set>
#include<queue>
#include<stack>
#include<string.h>
using namespace std;

char s1[100],s2[100];

int solve( char *str1 , char *str2 ){
   int len1 = strlen(str1);
   int len2 = strlen(str2);
   int rr = 0;
   for( int i = 0; i < len1; ++i ){
      bool ok = true;
      int k = 0;
      for( int j = len2 - i - 1; j < len2; ++j , k++ )
         if( str1[k] != str2[j] )
            ok = false;
      
      if( ok )
         rr = max( rr , i+1 );
   }
   return rr;
}

int main(){
   freopen("echo.in","r",stdin);
   freopen("echo.out","w",stdout);
   scanf("%s",s1);
   scanf("%s",s2);
   
   int sol = 0;
   sol = solve(s1,s2);
   sol = max( sol , solve(s2,s1)  );
   
   printf("%d\n",sol);
   
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
#include<cstdlib>
using namespace std;

int main(){
   long long v;
   vector<long long>ms;
   while( cin >> v ){
      if( v == 0 )break;
      long long mpv = v;
      ms.clear();
      while( v % 2 == 0 ){
         v /= 2;
         ms.push_back(2);
      }
      int div = 3;
      while( ((long long)div)*div <= mpv ){
         if( v % div == 0 ){
            v /= div;
            ms.push_back( div );
         }else
           div += 2;
      }
      if( v != 1 )ms.push_back(v);
      if( ms.size() == 0 )ms.push_back(1);
      int sz = ms.size();
      for( int i = 0; i < sz; ++i ){
         int j = i+1;
         while( j < sz && ms[j] == ms[j-1] )j++;
         printf("%lld^%d",ms[i],j-i);
         i = j-1;
         if( i != sz-1 )printf(" ");
      }printf("\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<set>
#include<vector>
#include<algorithm>
#include<string.h>
using namespace std;

struct person{
   int w,h;
   bool IsBoy;
   person( int p1, int p2, bool p3 ):w(p1),h(p2),IsBoy(p3){};
   person(){};
   bool operator<( const person &p2 ) const{
      return ( w < p2.w || ( w == p2.w && h < p2.h ) || ( w == p2.w && h == p2.h && IsBoy==false )  );
   }
};

vector< person > V;

int main(){
   int N,x,y;
   scanf("%d",&N);
   for( int i = 0; i < N; ++i ){
      scanf("%d%d",&x,&y);
      V.push_back( person(x,y,0) );
   }
   for( int i = 0; i < N; ++i ){
      scanf("%d%d",&x,&y);
      V.push_back( person(x,y,1) );
   }
   sort(V.begin(),V.end());
   multiset< int >M;
   M.insert( -1 );
   int sol = 0;
   for( int i = 0; i < V.size(); ++i ){
      if( V[i].IsBoy == false ){
         M.insert( V[i].h );
      }else{
         multiset< int >::iterator it = M.upper_bound( V[i].h );
         it--;
         if( *it == -1 )continue;
         else{
            M.erase(it);
            sol++;
         }
      }
   }
   printf("%d\n",sol);
   system("pause");
   return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:milkweed
*/
#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
#include<iomanip>
#include<set>
#include<queue>
#include<stack>
#include<string.h>
using namespace std;

#define mt(x,y,z) make_pair(x,make_pair(y,z))
#define piii pair<int, pair<int,int> >


int W,H;
int x,y;
char mx[105][105];
int dp[105][105];

void flood( int y, int x , int cnt ){
   queue< piii > Q;
   Q.push( mt(y,x,cnt)  );
   while(!Q.empty() ){
      piii u = Q.front(); Q.pop();
      int y = u.first;
      int x = u.second.first;
      int cnt = u.second.second;
      
      if( x < 0 || x >= W || y < 0 || y >= H || dp[y][x] != 0 )continue;
      if( mx[y][x] == '*' )continue;
      
      dp[y][x] = cnt;
      Q.push( mt( y+1,x,cnt+1 )  );
      Q.push( mt( y-1,x,cnt+1 )  );
      Q.push( mt( y,x+1,cnt+1 )  );
      Q.push( mt( y,x-1,cnt+1 )  );
      
      Q.push( mt( y-1,x-1,cnt+1 )  );
      Q.push( mt( y-1,x+1,cnt+1 )  );
      Q.push( mt( y+1,x-1,cnt+1 )  );
      Q.push( mt( y+1,x+1,cnt+1 )  );
   }
}

int main(){
   freopen("milkweed.in","r",stdin);
   freopen("milkweed.out","w",stdout);
   
   scanf("%d%d",&W,&H);
   scanf("%d%d",&x,&y);
   for( int i = 0; i < H; ++i )
      scanf("%s",mx[i]);
   y = H - y ;
   x--;
   flood(y,x,1);
   int sol = 0;
   for( int i = 0; i < H; ++i )
      for( int j = 0; j < W; ++j )
         sol = max( sol , dp[i][j] );
         
   printf("%d\n",sol-1);
   
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <string.h>
#include <cstdlib>
#include <vector>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <string>
using namespace std;

long long dp[130];
long long _dp[130];

int main() {
    FILE *in = stdin;//fopen("kocka.in","r");//stdin;
    FILE *out = stdout;//fopen("kocka.out","w");//stdout;
    
    
    int tests;
    int K,P;
    fscanf(in,"%d",&tests);
    
    for( int i = 0; i < tests; ++i ){
       fscanf(in,"%d%d",&K,&P);
       memset(dp,0,sizeof(dp));
       memset(_dp,0,sizeof(_dp));
       
       dp[0] = 1;
       _dp[0] = 1;
       for( int z = 0; z < K; ++z ){
          for( int j = z; j <= 105 && dp[j]; ++j ){
             if( dp[j] <= 0 )continue;
             
             for( int k = 1; k <= 6; ++k ){
                _dp[j+k] += dp[j] ;
             }
          }
          for( int j = 0; j <= 105; ++j ){
             _dp[j] -= dp[j];
             dp[j] = _dp[j];
          }
       }
       
       
       
       long long sum_over = 0;
       long long sum = 0;
       for( int j = 1; j <= 6 * 11; ++j ){
          if( j >= P )
             sum_over += dp[j];
          sum += dp[j];
       }
       long long gcd = __gcd( sum , sum_over );
       sum /= gcd;
       sum_over /= gcd;
       
       
       fprintf(out,"%lld",sum_over);
       if( sum > 1 )
          fprintf(out,"/%lld\n",sum);
       else
          fprintf(out,"\n");
       
    }
    return 0;
}

#include<iostream>
#include<vector>
#include<cstdlib>
#include<iomanip>
#include<math.h>
#include<cstdio>
#include<set>
#include<queue>
#include<stack>
using namespace std;

const int INF = 9999999;
int cntA[105] , cntB[105];
int cntAA[105] , cntBB[105];

int main(){
   int N,a,b;
   scanf("%d",&N);
   for( int i = 0; i < N; ++i ){
      scanf("%d%d",&a,&b);
      cntA[a]++;
      cntB[b]++;
      
      memset(cntAA,0,sizeof(cntAA) );
      memset(cntBB,0,sizeof(cntBB) );
      
      int sol = 0;
      int j = 100;
      for( int i = 1; i <= 100; ++i ){
         while( cntAA[i] != cntA[i] ){
            int z = min( cntA[i]-cntAA[i] , cntB[j]-cntBB[j] );
            cntAA[i] += z;
            cntBB[j] += z;
            if( z ) sol = max( sol , i+j );
            if( cntBB[j] == cntB[j] )j--;
         }
      }
      printf("%d\n",sol);
   }
   system("Pause");
   return 0;
}

#include<cstdio>
#include<iostream>
#include<string.h>
using namespace std;

int items[1000005][2];

int main(){
   int N;
   scanf("%d",&N);
   for( int i = 0; i < N; ++i ){
      scanf("%d %d",&items[i][0],&items[i][1]);
   }
   int Q,sol(0);
   scanf("%d",&Q);
   for( int i = 0; i < Q; ++i ){
      int idx;
      scanf("%d",&idx);
      sol += items[idx][1] - items[idx][0];
   }
   printf("%d\n",sol);
   return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:milk2
*/

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<climits>
using namespace std;
int interval[1000000];

int main()
{
    int n,i,j,k;
    int start,end;
    int s=INT_MAX,e=0;
    cin>>n;
    for(i=0;i<n;i++)
    {
       cin>>start>>end;
       if(start<s)
          s=start;
       if(end>e)
          e=end;
       interval[start]++;
       interval[end]--;
    }
    int time=0;
    int counter=0;
    int counter1=0;
    int max=0;
    int min=0;
    for(i=s;i<=e;i++)
    {
       time += interval[i];
       if(time>0)
       {
          counter++;
          if(counter1>min)
             min = counter1;
          counter1=0;
       }
       if(time==0)
       {
          counter1++;
          if(counter>max)
             max = counter;
          counter=0;
       }
    }
    cout<<max<<" "<<min<<endl;
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <math.h>
#include <set>
#include <string.h>
using namespace std;

long long vx,dx,vy,dy;

template <class type>
type sqr( type v ){
   return v*v;
}

double get_f( double time ){
   return sqr(time) * (vx*vx+vy*vy) + time * (-2*dx*vx + 2*dy*vy ) + dx*dx + dy*dy;
}

int main(){
   while( scanf("%lld%lld%lld%lld",&vx,&dx,&vy,&dy) == 4 ){
       if( vx == 0 && dx == 0 && vy == 0 && dy == 0 )break;
       
       double a = vx*vx + vy*vy;
       double b = 2*dy*vy - 2*dx*vx;
       double c = dx*dx + dy*dy;
       
       double num = (4*a*c - b*b);
       double den = 4*a;
       
       num = -b;
       den = 2*a;
       double sol = num / den;
           
       printf("%.6lf\n",sqrt(get_f( sol>=0 ? sol : 0 ))  );
       
   }
   return 0;
}

#include<cstdio>
#include<queue>
#include<vector>
#include<iostream>
using namespace std;

typedef long long ll;
#define dist first
#define node second
#define pli pair<ll,int>

struct edge{
   int b;
   ll d;
   edge( int p1, ll p2 ):b(p1),d(p2){};
   edge(){};
};

template <class type>
inline type sqr( type v ){
   return v*v;
}

const ll INF = (long long)1e18;
const int null = 1000000;
vector< edge >G[2*1000002];


int main(){
   FILE *in = stdin;//fopen("Ulaz.txt","r");
   int s,e,a,b;
   fscanf(in,"%d%d",&s,&e);
   s += null , e+= null;
   while( fscanf(in,"%d%d",&a,&b) == 2 ){
      ll de = sqr(   ((ll)(a))+ b  );
      a+=null , b+= null;
      G[a].push_back( edge(b,de ) );
   }
   pli u;
   priority_queue< pli >PQ;
   PQ.push( make_pair(INF,s)  );
   bool PathExists = false;
   while( !PQ.empty() ){
      u = PQ.top();
      PQ.pop();
      u.dist = INF - u.dist;
      if( u.node == e ){
         PathExists = true;
         break;
      }
      for( int i = 0; i < G[u.node].size(); ++i ){
         ll dist = u.dist + G[u.node][i].d;
         PQ.push( make_pair( INF-dist,G[u.node][i].b )   );
      }
      G[ u.node ].clear();
   }
   long long s2 = s-null, e2 = e-null;
   if( PathExists )
      printf("%lld\n",((u.dist)-s2*s2 + e2*e2)/2ll );
   else
      printf("No path\n");
  // system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<cstdlib>
#include<math.h>
#include<algorithm>
#include<stack>
#include<fstream>
#include<string.h>
using namespace std;

int N;
int mx[30][30];
int ms[30][30];
int mt[30][30];
int cost[30];
const int MOD = 8192;

void mx_mul( int fmx[30][30] , int smx[30][30] , int dest[30][30] ){
   int sol[30][30];
   
   for( int i = 0; i <= 29; ++i )
      for( int j = 0; j <= 29; ++j )
         sol[i][j] = 0;
         
         
   for( int i = 0; i <= 26; ++i )
      for( int j = 0; j <= 26; ++j )
         for( int k = 0; k <= 26; ++k )
            sol[i][j] = (sol[i][j] +  fmx[i][k] * smx[k][j]) % MOD;
   
   
   for( int i = 0; i <= 26; ++i )
      for( int j = 0; j <= 26; ++j )
         dest[i][j] = sol[i][j];

}


char buff[300];
vector<int>M;
void take_one( ){
   int num1 , num2 , add = 0;
   for( int i = 0; i < M.size(); ++i ){
      num1 = M[i];
      if( i == 0 )num2 = 1;
      else num2 = add;
      add = 0;
      
      while( num2 > num1 ) add ++ , num1 += 10;
      M[i] = num1 - num2;
   }
   while( M.back() == 0 )M.pop_back();
}

void DivBy2(){ 
   for( int i = M.size()-1; i>=0; i-- ){
       if( M[i]%2 == 1 )if( i > 0 )M[i-1]+=10;
       M[i]/=2;
   }
   for( int i = 0; i < M.size(); ++i )
      if( M[i] >= 10 ){
         if( i==M.size()-1 )M.push_back(M[i]/10);
         else M[i+1] += M[i]/10;
         M[i] %= 10;
      }
   while( M.back() == 0 )M.pop_back();
}

int main(){
   
   scanf("%d",&N);
   scanf("%s",buff);
   for( int i = strlen(buff)-1; i >= 0 ; --i )
      M.push_back( buff[i] - '0' );
   
   for( int i = 0; i < N; ++i ){
      scanf("%d",&cost[i]);
      ms[ 26 - cost[i] ][ 25 ]++;
   }
   for( int i = 0; i < 25; ++i )
      ms[ i+1 ][ i ] = 1;
   
   if( M.size() < 3 ){
      int Mi = 0;
      for( int i = M.size() - 1; i >= 0; --i )Mi = (Mi*10) + M[i];
      int *dp = new int[191];
      for( int i = 0; i <= 190; ++i )dp[i] = 0;
      dp[0] = 1;
      for( int i = 1; i <= Mi; ++i ){
         for( int j = 0; j < N; ++j )
            dp[i] = ( dp[i] + (i-cost[j] >= 0 ? dp[ i-cost[j] ] : 0) ) % MOD;
      }
      printf("%d\n",dp[Mi] );
      system("Pause");
      return 0;
   }
   
   mx[0][0] = 1;
   for( int i = 1; i <= 25; ++i ){
      for( int j = 0; j < N; ++j )
         mx[0][i] =  (mx[0][i] + (i - cost[j] >= 0 ? mx[0][ i-cost[j] ] : 0)  )% MOD ;
      take_one();
   }
   
   stack < int > stk;
   while( M.size() != 1 || M[0] != 1 ){
      if( M[0]%2 == 0 ){
          stk.push( 1 );
          DivBy2();
      }else{
          stk.push( 2 );
          take_one();
      }
   }

   
   
   memcpy( mt , ms , 29*29*4 );
   while( stk.empty() == false ){
      int u = stk.top();
      stk.pop();
      
      if( u == 1 ){
         mx_mul( ms , ms , ms );
      }else{
         mx_mul( ms , mt , ms );
      }
      
   }
   mx_mul( mx , ms , mx );
   printf("%d\n",mx[0][25] );
   system("Pause");
   return 0;
}

#include<cstdio>
#include<iostream>
#include<string.h>
#include<math.h>
#include<algorithm>
using namespace std;

char keys[1000];;

int main(){
   scanf("%s",keys);
   int nowx = 1 , nowy = 1 , sol = 0;
   for( int i = 0; i < strlen(keys); ++i ){
      int nxt = keys[i] - '1';
      int y = nxt/3;
      int x = nxt - y*3;
      if( nxt == -1 )y = 3 , x = 1;
      sol += abs( y - nowy ) + abs( x - nowx );
      nowx = x , nowy = y;
   }
   printf("%d\n",sol);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<iomanip>
#include<set>
#include<math.h>
#include<queue>
#include<list>
#include<string.h>
#include<assert.h>
#include<map>
using namespace std;

#define fii first
#define sii second.first
#define tii second.second
#define make_trio(a,b,c) make_pair(a,make_pair(b,c))

struct coord{
   int x,y;
   coord( int p1, int p2 ):x(p1),y(p2){};
   coord(){};
   coord operator+( const coord &c2 ) const {
      return coord( x + c2.x , y + c2.y );
   }
};

bool GetNum( int &v , FILE *in){
   char c;
   bool IsMinus = false;
   while( c = fgetc(in) ){
      if( c == EOF )return false;
      if( c == '-' )
         IsMinus = true;
      if( c >='0' && c <='9' )
         break;
   }

   v = ( c - '0' ) * ( IsMinus ? -1 : 1 );
   while( c = fgetc(in) ){
      if( c == EOF )return false;
      if( c >= '0' && c <= '9' )
         v = (v*10) + ( IsMinus ? -1 : 1 ) * ( c - '0' );
      else
         break;
   }
   return true;
}

char GetChar2( FILE *in ){
   char c;
   while( c = fgetc(in) )
      if(  (c>='a' && c<='z')  ||  (c>='A' && c<='Z')   )
         return c;
}

coord GetC( FILE *in ){
   int x,y;
   GetNum(x,in);
   GetNum(y,in);
   return coord(x,y);
}



struct segment{
   int v,f,s;
   segment( int p1, int p2, int p3 ):v(p1),f(p2),s(p3){};
   segment(){};
   bool operator < ( const segment &s2 ){
      return (v < s2.v);
   }
   bool operator < ( const float &f ){
      return (v<f);
   }
};



struct data{
   int node , cnt , rots;
   string out;
   map< int , bool >M;
   data( int node_ , int cnt_ , int rots_ , string out_ ):
      node( node_ ) , cnt( cnt_ ) , rots( rots_ ) , out( out_ ) {

                         M.clear();
                         M[ node ] = true;
            }
   data(){};
   bool operator<( const data &d2 ) const {
      if( rots < d2.rots )return false;
      if(  cnt > d2.cnt )return false;
      return true;
   }
};




coord start;
const int nll = 20;
const int INF = 999999;
vector< segment >Hor;
vector< segment >Ver;



void make_grid( int cnt , FILE *in ){
   coord now;
   if( cnt )now = GetC( in );


   for( int i = 0; i < cnt; ++i ){
      coord tmp = GetC( in );

      if( tmp.x != 0 ){

         if( tmp.x > 0 )Hor.push_back( segment( now.y , now.x , now.x + tmp.x ) );
         else Hor.push_back( segment( now.y , now.x + tmp.x , now.x ) );

      }else{

         if( tmp.y > 0 )Ver.push_back( segment( now.x , now.y , now.y + tmp.y ) );
         else Ver.push_back( segment( now.x , now.y + tmp.y , now.y ) );

      }
      now = now + tmp;
   }
}

int cntAbove , cntUnder , cntLeft , cntRight;
void Get ( float x, float y ){
   cntAbove = cntUnder = cntLeft = cntRight = 0;

   for( int i = 0; i < Hor.size(); ++i ){
      if( Hor[i].f < x && x < Hor[i].s ){
         if( Hor[i].v > y )cntAbove++;
         else cntUnder++;
      }
   }
}


bool InArea[1000*1000];
bool visited[1000*1000];
vector<int>G[1000*1000];

string sol = "";

void dfs( int node ){
   visited[ node ] = true;
   char di;
   for( int i = 0; i < G[node].size(); ++i ){
          if( node+900 == G[node][i] )di = 'u';
          else if( node-900 == G[node][i] )di = 'd';
          else if( node-1>=0 && node-1 == G[node][i] )di = 'l';
          else di = 'r';



          if( visited[ G[node][i] ]== false ){
        //  cout<<node<<" - > "<<G[node][i]<<" "<<di<<endl;
             sol += string(1,di);

             dfs( G[node][i] );

             if( di == 'u' )sol += "d";
             if( di == 'd' )sol += "u";
             if( di == 'r' )sol += "l";
             if( di == 'l' )sol += "r";
          }
   }
}

int main(){
   FILE *in =  fopen("Ulaz.txt","r");
   start = GetC( in );
   char d = GetChar2( in );

   int cnt;
   GetNum( cnt , in );
   make_grid( cnt , in );

   int t;
   GetNum( t , in );
   for( int i = 0; i < t; ++i ){
      GetNum( cnt , in );
      make_grid( cnt , in );
   }


   int START_NODE = -INF;
   int cntNode = 0;
   int NODES = 0;

   const int Z = 50;
   const float T = -50.5;
   for( int i = 0; i < Z; ++i ){
      float y = T + i;
      for( int j = 0; j < Z; ++j ){

         float x = T + j;

         int key = i*900 + j;
         Get( x , y );


         if(  (cntAbove&1) == 1 && (cntUnder&1) == 1 ) { //&& (cntLeft&1) == 1 && (cntRight&1) == 1 ){
            InArea[ key ] = true;
            NODES++;
            //cout<<x<<" "<<y<<" = "<<key<<endl;
            if(  fabs( x - (start.x + 0.5) ) < 0.001 && fabs( y - (start.y + 0.5) ) < 0.001     )
                START_NODE = key;
         }

      }
   }




   for( int i = 0; i < Z; ++i ){
      float y = T + i;
      for( int j = 0; j < Z; ++j ){

         float x = T + j;

         int key = i*900 + j;
         //Get( x , y );


         if(  InArea[ key ] ) { //&& (cntLeft&1) == 1 && (cntRight&1) == 1 ){
            if( key-1   >=0 && InArea[key-1]   )G[key].push_back( key - 1 );
            if( InArea[key+1]                  )G[key].push_back( key + 1 );
            if( InArea[key+900]                )G[key].push_back( key + 900 );
            if( key-900 >=0 && InArea[key-900] )G[key].push_back( key - 900 );
         }

      }
   }




   //data  u , v;
//   priority_queue< data > PQ;
//   string d_ = string(1, d);
//
//
//   PQ.push(  data( START_NODE , 1 , 0 , string(1,d)  )   );
//
//   double ST = clock();
//
//   while(!PQ.empty() ){
//       u = PQ.top();
//       PQ.pop();
//      // cout<<(clock()-ST)<<endl;
//       if( (clock()-ST) > 1000 )break;
//       //cout<<u.out<<" "<<u.rots<<" , "<<u.cnt<<endl;
//       if( u.cnt >= NODES  )break;
//       for( int i = 0; i < G[u.node].size(); ++i ){
//          char di;
//          if( u.node+900 == G[u.node][i] )di = 'u';
//          else if( u.node-900 == G[u.node][i] )di = 'd';
//          else if( u.node-1>=0 && u.node-1 == G[u.node][i] )di = 'l';
//          else di = 'r';
//
//          char prev = u.out[ u.out.size() - 1 ];
//          v = u;
//          v.node = G[u.node][i];
//
//
//          if( prev==di ){
//             v.out += di;
//             if( v.M[  G[u.node][i]  ] == false )
//                v.cnt ++;
//             else
//                v.M[  G[u.node][i]   ] = true;
//
//          }else if(  (prev=='u' && di=='d') || (prev=='d' && di=='u') || (prev=='l' && di=='r') || (prev=='r' && di=='l')  ){
//             v.out += string(1,di);
//             v.rots += 2;
//             if( v.M[ G[u.node][i]  ] == false )
//                v.cnt ++;
//             else
//                v.M[ G[u.node][i] ] = true;
//
//          }else{
//             v.out += string(1,di);
//
//             v.rots ++;
//             if( v.M[ G[u.node][i]  ] == false )
//                v.cnt ++;
//             else
//                v.M[ G[u.node][i] ] = true;
//          }
//
//          PQ.push( v );
//
//
//
//       }//cout<<endl;
//
//   }
//   cout<<u.out.size()-1<<endl;
//   for( int i = 1; i < u.out.size();++i )
//      cout<<u.out[i];cout<<endl;

   dfs( START_NODE );

   //cout<<NODES<<endl;

   cout<<sol.size()<<endl;
   cout<<sol<<endl;




  // system("Pause");
   return 0;
}

#include<iostream>
#include<vector>
#include<cstdlib>
#include<iomanip>
#include<math.h>
#include<cstdio>
#include<set>
#include<queue>
#include<stack>
using namespace std;

int arr[10];

int main(){
   for( int i = 1; i <= 8; ++i )
      scanf("%d",&arr[i]);
   
   bool ASC = true;
   bool DESC = true;
   for( int i = 1; i <= 8; ++i ){
      if( arr[i] != i )ASC = false;
      if( arr[i] != 9-i )DESC = false;
   }
   
   if( ASC )
      printf("ascending\n");
   else if( DESC )
      printf("descending\n");
   else
      printf("mixed\n");
   
   return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:papaya
*/
#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
#include<iomanip>
#include<set>
#include<queue>
#include<stack>
#include<string.h>
using namespace std;

int H,W;
int mx[100][100];

int main(){
   freopen("papaya.in","r",stdin);
   freopen("papaya.out","w",stdout);
   
   scanf("%d%d",&H,&W);
   for( int i = 1; i <= H; ++i )
      for( int j = 1; j <= W; ++j )
         scanf("%d",&mx[i][j]);
   int r = 1 , c = 1;
   int sol = 0;
   while( r != H || c != W ){
      sol += mx[r][c];
      mx[r][c] = 0;
      int v1 = mx[r-1][c];
      int v2 = mx[r+1][c];
      int v3 = mx[r][c+1];
      int v4 = mx[r][c-1];
      int maxx = max( max(v1,v2) , max(v3,v4) );
      if( v1 == maxx )r--;
      if( v2 == maxx )r++;
      if( v3 == maxx )c++;
      if( v4 == maxx )c--;
   }
   sol += mx[r][c];
   
   printf("%d\n",sol);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<string.h>
#include<cstdlib>
#include<math.h>
using namespace std;

int d[][2] = {1,-1 , 1,0 , 1,1};

int H,W;
char mx[10005][505];

#define ok(x,y) (x>=0&&x<W&&y>=0&&y<H&&mx[y][x]=='.')
#define key(x,y) (y*W+x)

bool dfs( int y, int x ){
   if( x == W-1 ){
      mx[y][x] = 'T';
      return true;
   }
   for( int i = 0; i < 3; ++i ){
      int nx = d[i][0] + x;
      int ny = d[i][1] + y;
      if( ok(nx,ny) ){
         mx[y][x] = 'T';
         if( dfs(ny,nx) )return true;
       //  mx[y][x] = '.';
      }
   }
   return false;
}

int main(){
   FILE *in = stdin;//fopen("Ulaz.txt","r");
   fscanf(in,"%d%d",&H,&W);
   for( int i = 0; i < H; ++i )
      fscanf(in,"%s",mx[i]);
   
   int sol = 0;
   for( int i = 0; i < H; ++i ){
      if( !ok(0,i) )continue;
      mx[i][0] = 'T';
      if(  dfs(i,0) ) sol ++;
      else mx[i][0] = '.';
   }
   printf("%d\n",sol);
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <string.h>
#include <cstdlib>
#include <vector>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <string>
using namespace std;

char buff[1005];


int main() {
    FILE *in = fopen("Ulaz.txt","r");
    FILE *out = fopen("podniz.put","w");
    
    fscanf(in,"%s",buff);
    
    int len = strlen(buff);
    
    int ans = 1;
    for( int i = 0; i < len-1; ++i ){
       int diff = abs(buff[i] - buff[i+1]);
       if( diff == 0 )continue;
       
       int solLen = 2;
       for( int j = i+2; j < len; ++j ){
          if( abs(buff[j]-buff[j-1]) != diff )break;
          solLen++;
       }
       ans = max(solLen , ans );
    }
    printf("%d\n",ans < 3 ? 0 : ans);
    return 0;
}

#include<cstdio>
#include<iostream>
#include<string.h>
using namespace std;

long long MOD;

long long _pow( long long a , long long b ){
   if( b == 0 )return 1;
   else if( b % 2 == 0 ){
       long long tmp = _pow( a , b/2 );
       return (tmp*tmp)%MOD;
   }else{
       return (_pow(a,b-1)*a)%MOD;
   }
}

int main(){
   long long base,stp;
   cin>>base>>stp>>MOD;
   cout<<_pow(base,stp)<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
#include<string.h>
#include<cstring>
using namespace std;

struct tile{
   int a,b,c,d;
   tile( int p1, int p2, int p3, int p4 ):a(p1),b(p2),c(p3),d(p4){};
   tile(){};
};

const int N = 9;
tile g[9];
vector<int>leftH[9];
vector<int>topH[9];

int mx[5][5];
bool used[9];


bool solve( int r, int c ){
   if( c == 3 )c = 0 , r++;
   if( r == 3 )return true;
         
   for( int i = 0; i < 9; ++i ){
      if( used[i] == true )continue;
      if( r > 0 && g[  mx[r-1][c]  ].c != g[i].a )continue;
      if( c > 0 && g[  mx[r][c-1]  ].b != g[i].d )continue;
      used[ i ] =  true;
      mx[r][c] = i;
      if( solve(r,c+1) )return true;
      mx[r][c] = -1;
      used[ i ] = false;
   } 
   return false;
}

int main(){
   int tests,a,b,c,d;
   scanf("%d",&tests);
   for( int t = 1 ; t<=tests ; t++ ){
      for( int i = 0; i < N; ++i ){
         scanf("%d%d%d%d",&a,&b,&c,&d);
         g[i] = tile(a,b,c,d);
         leftH[d].push_back( i );
         topH[a].push_back( i );
      }
      memset(mx,-1,sizeof(mx));
      memset(used,0,sizeof(used));
      bool ok = solve(0,0);
      if( ok )
        printf("Case %d: YES\n",t);
      else
         printf("Case %d: NO\n",t);
   }
   return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:stroll
*/
#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
#include<iomanip>
#include<set>
#include<queue>
#include<stack>
#include<string.h>
using namespace std;


int N;
vector<int>G[10000];
bool visited[10000];

int sol = 0;
void dfs( int node , int cnt ){
   if( node == 0 ){
      sol = max( sol , cnt );
      return;
   }
   visited[ node ] = true;
   for( int i = 0; i < G[node].size(); ++i ){
      if( visited[ G[node][i] ] == false )
         dfs( G[node][i] , cnt + 1);
   }
}

int main(){
   freopen("stroll.in","r",stdin);
   freopen("stroll.out","w",stdout);
   
   //FILE *in = fopen("Ulaz.txt","r");
   
   scanf("%d",&N);
   for( int i = 0; i < N; ++i ){
      int a,b,c;
      scanf("%d%d%d",&a,&b,&c);
      G[a].push_back(b);
      G[a].push_back(c);
   }
   dfs( 1 , 0 );
   
   printf("%d\n",sol);
   return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:rplow
*/
#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
#include<iomanip>
#include<set>
#include<queue>
#include<stack>
#include<string.h>
using namespace std;

int W,H,N;
bool mx[1000][1000];


int main(){
   freopen("rplow.in","r",stdin);
   freopen("rplow.out","w",stdout);
   scanf("%d%d%d",&W,&H,&N);
   
   int x1,y1,x2,y2;
   for( int i = 0; i < N; ++i ){
      scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
      for( int i = y1; i <= y2; ++i ){
         for( int j = x1; j <= x2; ++j ){
            mx[i][j] = true;
         }
      }
   }
   int sol = 0;
   for( int i = 1; i <= H; ++i ){
      for( int j = 1; j <= W; ++j ){
         sol += mx[i][j];
      }
   }
   printf("%d\n",sol);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<cstdlib>
#include<math.h>
#include<iomanip>
#include<string.h>
#include<algorithm>
using namespace std;

struct coord{
   int x,y;
   coord( int p1, int p2 ):
      x(p1),y(p2){};
   coord(){};
   bool operator!=(const coord &c2 )const{
      return ( x!=c2.x && y != c2.y );
   }
   
};

int dist( int x1, int y1, int x2, int y2 ){
   return ( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );
}

int cross( coord A, coord B, coord C ){
   return (B.x-A.x)*(C.y-A.y) - (B.y-A.y)*(C.x-A.x);
}


coord transm;
int N;
double radius;
vector< coord >h1;
vector< coord >h2;
vector< coord >points;

bool cw( coord a, coord b ){
   return cross( transm , a , b ) >= 0;
}
bool cw2 ( coord a , coord b ){
   return cross( transm , a , b ) > 0;
}

int main(){
   // FILE *in = fopen("Ulaz.txt","r");
    int xi,yi;
    while( scanf("%d%d%lf",&transm.x,&transm.y,&radius) == 3 ){
       if( radius < 0 )break;
       scanf("%d",&N);
       h1.clear();
       h2.clear();
       points.clear();
       for( int i = 0; i < N; ++i ){
          scanf("%d%d",&xi,&yi);
          if( dist( transm.x , transm.y , xi, yi ) <= radius * radius ){
             if( xi < transm.x ) h1.push_back( coord(xi,yi) );
             else h2.push_back( coord(xi,yi)  );
          }
       }
       sort( h1.begin() , h1.end() , cw);
       sort( h2.begin() , h2.end() , cw2 );
       for( int i = 0; i < h1.size(); ++i )
          points.push_back( h1[i] );
          
       for( int i = 0; i < h2.size(); ++i )
          points.push_back( h2[i] );
          
       int j = 0 , sol = 0;
       for( int i = 0; i < points.size(); ++i ){
          j = i;
          while( cross( transm , points[i] , points[ j+1 != points.size() ? j+1 : (j=-1)+1 ] ) >=0 && j+1 != i){
             j++;

          }

          int ans = 0;
          if( j < i )
             ans =  (int)points.size() - i + j + 1;
          else
             ans =  j-i+1 ;
          sol = max( sol , ans );

       }
       cout<<sol<<endl;
       
    }
    
   // system("Pause");
    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<algorithm>
#include<vector>
#include<cstdlib>
using namespace std;


int N,M,T;
int dp[100000][ 32 ];
int arr[100000];
int test[100000];


int main(){
   scanf("%d%d%d",&N,&M,&T);
   
   for( int i = 1; i <= N; ++i )
      scanf("%d",&test[i]);
   
   for( int i = 1; i <= M; ++i ){
      scanf("%d",&dp[i][0]);
      
   }
   
   for( int i = 1; i < 32; ++i ){
      for( int j = 1; j <= M; ++j ){
         dp[j][i] = dp[ dp[j][i-1] ][ i-1 ];
      }
   }
   
   
   for( int i = 1; i <= N; ++i ){
         int TIME = T-1;
         int idx = test[i];
         for( int j = 30; j>=0; --j ){
            while( (1<<j) <= TIME ){
               TIME -= (1<<j);
               idx = dp[idx][j];
            }
         }
         printf("%d ",idx);
   }
   printf("\n");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<math.h>
#include<algorithm>
#include<string.h>
#include<iomanip>
using namespace std;

const int MOD = 10000;
const int MAXSUM = 4500;
int N;
int DP_SUM[ MAXSUM + 20];
int DP_FAK[ MAXSUM + 20];
int TMP[ MAXSUM + 20];


int main(){
   DP_SUM[0] = 1;
   DP_FAK[1] = 1;
   scanf("%d",&N);
   int H = N/2;
   
   for( int i = 0; i < H; ++i ){
      int j = i != 0 ? 1 : 0;
      for( ; j <= i*9 ; ++j ){
         for( int k = 0; k <= 9 && j+k <= MAXSUM; ++k )
            TMP[j+k] = (TMP[j+k]+DP_SUM[j]) % MOD;
      }
      TMP[0]=1;
      memcpy(DP_SUM,TMP,4*(MAXSUM+10) );
      memset(TMP,0,sizeof(TMP));
   }
   for( int i = 0; i < H; ++i ){
      for( int j = 1; j <= MAXSUM ; ++j ){
         for( int k = 1; k <= 9 && j*k <= MAXSUM; ++k ){
            TMP[j*k] = (TMP[j*k] + DP_FAK[j]) % MOD;
         }
      }
      TMP[1]=1;
      memcpy(DP_FAK,TMP,4*(MAXSUM+10) );
      memset(TMP,0,sizeof(TMP));
   }
//   for( int i = 0 ; i <= H*9+5; ++i )
//      cout<<i<<" = "<<DP_SUM[i]<<" , "<<DP_FAK[i]<<endl;
   int sol = 0;
   for( int i = 0; i <= MAXSUM; ++i ){
      sol =  (sol+DP_SUM[i]*DP_FAK[i]) % MOD;
   }
   printf("%d\n",sol%MOD);

   return 0;
}

#include<iostream>
#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
#include<set>
using namespace std;

#define pii pair<int,int>
#define piii pair<int,pair<int,int> >
#define x first
#define y second
#define f first
#define s second
#define mk make_pair


const int INF = (int)10e9;
int N;
vector< pair<int,int> >points;
vector< pair<int,int> >xr;
vector< pair<int,int> >yr;

int upx[100005] , downx[100005];
int upy[100005] , downy[100005];

int main(){
   int xn,yn;
  // FILE *in = fopen("Ulaz.txt","r");
   scanf("%d",&N);
   for( int i = 0; i < N; ++i ){
      scanf("%d%d",&xn,&yn);
      int xt = (int)round(((xn+yn)/2.0)*10);
      int yt = (int)round(((xn-yn)/2.0)*10);
      points.push_back( make_pair(xt,yt) );
      xr.push_back( mk(xt,i) );
      yr.push_back( mk(yt,i) );
   }
   sort(xr.begin(),xr.end());
   sort(yr.begin(),yr.end());
   
   for( int i = 1; i < N; ++i ){
        downx[ xr[i].s ] = downx[  xr[i-1].s  ] + i * ( xr[i].f - xr[i-1].f );
        downy[ yr[i].s ] = downy[  yr[i-1].s  ] + i * ( yr[i].f - yr[i-1].f );

        int k = N - i - 1;
        upx[ xr[k].s ] = upx[ xr[k+1].s ] + (N-k-1) * ( xr[k+1].f - xr[k].f );
        upy[ yr[k].s ] = upy[ yr[k+1].s ] + (N-k-1) * ( yr[k+1].f - yr[k].f );
   }
   int solC = -1;
   int solAns = INF;
   for( int i = 0; i < N; ++i ){
      int ans = (int)round(upx[ i ] + downx[ i ] + upy[ i ] + downy[ i ] );
      if( solAns > ans ){
         solC = i , solAns = ans;
      }
   }
   printf("%d\n",solC);
 //  system("Pause");
   return 0;
}

//#include<BigNum.h>

#include<cstdio>
#include<vector>
#include<iostream>
#include<string.h>
#include<algorithm>
using namespace std;

class BigNum{   // BIG_NUM_CLASS
   private:
      static const int NewBasis = 8;
      static const int PLACES = 100000000;
   public:
      vector<char>digits;
      BigNum(){}
      BigNum( int v ){while( v ) digits.push_back(v%10) , v/=10; }
      BigNum( char*,int );
      BigNum( const BigNum &z ){ digits = z.digits; }
      BigNum operator*(const BigNum&);
      BigNum operator+(const BigNum&);
      BigNum DivBy2(bool);
      inline void WriteLn();
      inline void Write();
      void operator=(BigNum);
      bool operator<(const BigNum&);
      bool operator>(const BigNum&);
      bool operator==(const BigNum&);
      void SetPower10( int stp ){
         digits.clear();
         for( int i = 0; i < stp; ++i )
            digits.push_back(0);
         digits.push_back(1);
      }
};

void BigNum::operator=(BigNum b2 ){
   digits.clear();
   digits=b2.digits;
}

BigNum::BigNum( char *f , int len){
   for( int i = len-1; i >=0; --i )
      digits.push_back( f[i]-'0' );
    while( digits.back() == 0 )digits.pop_back();
}

bool BigNum::operator==( const BigNum &b2 ){
   if( b2.digits.size() != digits.size() )return  false;
   for( int i = 0; i < digits.size(); ++i )
      if( digits[i] != b2.digits[i] )return false;
   return true;
}

bool BigNum::operator<( const BigNum &b2 ){
   if( b2.digits.size() > digits.size() )return true;
   else if( b2.digits.size() < digits.size() )return false;
   else{
       for( int i = digits.size()-1; i >=0 ; --i ){
         if( digits[i] < b2.digits[i] )
            return true;
         else if( digits[i] > b2.digits[i] )
            return false;
      }
   }
   return false;
}
bool BigNum::operator>( const BigNum &b2 ){
   if( b2.digits.size() < digits.size() )return true;
   else if( b2.digits.size() > digits.size() )return false;
   else{
      for( int i = digits.size()-1; i >=0 ; --i ){
         if( digits[i] > b2.digits[i] )
            return true;
         else if( digits[i] < b2.digits[i] )
            return false;
      }
   }
   return false;
}

BigNum BigNum::operator*( const BigNum &b2 ){  // FAST MULTIPLICATION
   int digs = b2.digits.size() + digits.size() + 2;
   long long *B1 = new long long[ digs ];
   long long *B2 = new long long[ digs ];
   long long *R =  new long long[ digs ];
   for( int i = 0; i < digs; ++i )B1[i] = B2[i] = R[i] = 0;
   int s1 = digits.size();
   int s2 = b2.digits.size();
   int poz = -1, fak = 1;
   for( int i = 0; i < s1; ++i ){
      if( i % NewBasis == 0 )poz++, fak = 1;
      B1[poz] = B1[poz] + digits[i]*fak;
      fak*=10;
   }

   int ns1 = poz+1;
   
   poz = -1, fak = 1;
   for( int i = 0; i < s2; ++i ){
      if( i % NewBasis == 0 )poz++, fak = 1;
      B2[poz] = B2[poz] + b2.digits[i]*fak;
      fak*=10;
   }
   int ns2 = poz+1;
   
   for( int i = 0; i < ns1; ++i )
      for( int j = 0; j < ns2; ++j )
         R[i+j] += B1[i]*B2[j];
   
   int NS = ns1 + ns2;

   for( int i = 0; i < NS; ++i ){
      if( i == NS-1 && R[i]>=PLACES )NS++;
      R[i+1] += R[i]/PLACES , R[i] = R[i]%PLACES;
   }
   unsigned long long test;
   int digi;
   BigNum ret;
   vector<int>smp;

   while( R[NS-1] )smp.push_back(R[NS-1]%10), R[NS-1]/=10;
   for( int i = smp.size()-1; i >=0; --i )ret.digits.push_back( smp[i] );
   for( int i = NS-2; i>=0; --i ){
      test = R[i];
      digi = 0;
      while(test)
         test/=10,digi++;
      for(int j = 0; j < 8-digi; ++j)ret.digits.push_back(0);
      smp.clear();
      while( R[i] )smp.push_back(R[i]%10), R[i]/=10;
      for( int i = smp.size()-1; i >=0; --i )ret.digits.push_back( smp[i] );
   }
   reverse(ret.digits.begin(),ret.digits.end());
   while( ret.digits.back() == 0 )ret.digits.pop_back();
   
   delete [] B1;
   delete [] B2;
   delete [] R;
   return ret;
}

BigNum BigNum::DivBy2( bool floor=true ){ 
   BigNum ret = BigNum( *this );
   for( int i = ret.digits.size()-1; i>=0; i-- ){
       if( ret.digits[i]%2 == 1 )if( i > 0 )ret.digits[i-1]+=10;
                                 else if( floor )ret.digits[i]--;
                                 else ret.digits[i]++;
       ret.digits[i]/=2;
   }
   for( int i = 0; i < ret.digits.size(); ++i )
      if( ret.digits[i] >= 10 ){
         if( i==ret.digits.size()-1 )ret.digits.push_back(ret.digits[i]/10);
         else ret.digits[i+1] += ret.digits[i]/10;
         ret.digits[i] %= 10;
      }
   while( ret.digits.back() == 0 )ret.digits.pop_back();
   return ret;
}

BigNum BigNum::operator+( const BigNum &b2 ){
   BigNum A = *this , B = b2;
   if( A.digits.size() < B.digits.size() )swap(A,B);
   BigNum sum = B;
   int tmp = 0;
   for( int i = 0; i < B.digits.size(); ++i ){
      int ss = B.digits[i] + A.digits[i] + tmp;
      sum.digits[i] = ss%10;
      tmp = ss / 10;
   }
   for( int i = B.digits.size(); i < A.digits.size(); ++i ){
      int ss = A.digits[i] + tmp;
      sum.digits.push_back( ss % 10 );
      tmp = ss/10;
   }
   while( tmp ){
      sum.digits.push_back( tmp % 10 );
      tmp /= 10;
   }
   return sum;
}


inline void BigNum::WriteLn(){
   for( int i = digits.size()-1; i >=0; --i )
      printf("%d",digits[i]);
   printf("\n");
}
inline void BigNum::Write(){
   for( int i = digits.size()-1; i >=0; --i )
      printf("%d",digits[i]);
}


char buff[1010];

int main(){
   int N;
   char c;
   scanf("%d",&N);
   for( int i = 0; i < N; ++i ){
      while( c=getchar() )
         if( c >='0' && c<='9' )break;
      buff[i] = c;
   }
   BigNum sqr(buff,N);
   BigNum lo(0),hi;
   BigNum mid;
   hi.SetPower10(500);;
   while( lo < hi || lo==hi ){
      mid = lo+hi;
      mid = mid.DivBy2();
      lo.WriteLn();
      hi.WriteLn();
      system("Pause");
      if( mid*mid == sqr )
         break;
      else if( (mid*mid) > sqr )
         hi = mid;
      else
         lo = mid;
   }
   printf("%d\n",mid.digits.size());
   for( int i = mid.digits.size()-1; i >=0; --i ){
      printf("%d\n",mid.digits[i]);
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<cstdlib>
#include<math.h>
#include<algorithm>
#include<stack>
#include<fstream>
#include<string.h>
using namespace std;

int N;
int mx[30][30];
int ms[30][30];
int mt[30][30];
int cost[30];
const int MOD = 8192;

void mx_mul( int fmx[30][30] , int smx[30][30] , int dest[30][30] ){
   int sol[30][30];
   
   for( int i = 0; i <= 29; ++i )
      for( int j = 0; j <= 29; ++j )
         sol[i][j] = 0;
         
         
   for( int i = 0; i <= 26; ++i )
      for( int j = 0; j <= 26; ++j )
         for( int k = 0; k <= 26; ++k )
            sol[i][j] = (sol[i][j] +  fmx[i][k] * smx[k][j]) % MOD;
   
   
   for( int i = 0; i <= 26; ++i )
      for( int j = 0; j <= 26; ++j )
         dest[i][j] = sol[i][j];

}


char buff[300];
vector<int>M;
void take_one( ){
   int num1 , num2 , add = 0;
   for( int i = 0; i < M.size(); ++i ){
      num1 = M[i];
      if( i == 0 )num2 = 1;
      else num2 = add;
      add = 0;
      
      while( num2 > num1 ) add ++ , num1 += 10;
      M[i] = num1 - num2;
   }
   while( M.back() == 0 )M.pop_back();
}

void DivBy2(){ 
   for( int i = M.size()-1; i>=0; i-- ){
       if( M[i]%2 == 1 )if( i > 0 )M[i-1]+=10;
       M[i]/=2;
   }
   for( int i = 0; i < M.size(); ++i )
      if( M[i] >= 10 ){
         if( i==M.size()-1 )M.push_back(M[i]/10);
         else M[i+1] += M[i]/10;
         M[i] %= 10;
      }
   while( M.back() == 0 )M.pop_back();
}

int main(){
   
   scanf("%d",&N);
   scanf("%s",buff);
   for( int i = strlen(buff)-1; i >= 0 ; --i )
      M.push_back( buff[i] - '0' );
   
   for( int i = 0; i < N; ++i ){
      scanf("%d",&cost[i]);
      ms[ 26 - cost[i] ][ 25 ]++;
   }
   for( int i = 0; i < 25; ++i )
      ms[ i+1 ][ i ] = 1;
   
   if( M.size() < 3 ){
      int Mi = 0;
      for( int i = M.size() - 1; i >= 0; --i )Mi = (Mi*10) + M[i];
      int *dp = new int[191];
      for( int i = 0; i <= 190; ++i )dp[i] = 0;
      dp[0] = 1;
      for( int i = 1; i <= Mi; ++i ){
         for( int j = 0; j < N; ++j )
            dp[i] = ( dp[i] + (i-cost[j] >= 0 ? dp[ i-cost[j] ] : 0) ) % MOD;
      }
      printf("%d\n",dp[Mi] );
      return 0;
   }
   
   mx[0][0] = 1;
   for( int i = 1; i <= 25; ++i ){
      for( int j = 0; j < N; ++j )
         mx[0][i] =  (mx[0][i] + (i - cost[j] >= 0 ? mx[0][ i-cost[j] ] : 0)  )% MOD ;
      take_one();
   }
   
   stack < int > stk;
   while( M.size() != 1 || M[0] != 1 ){
      if( M[0]%2 == 0 ){
          stk.push( 1 );
          DivBy2();
      }else{
          stk.push( 2 );
          take_one();
      }
   }

   
   
   memcpy( mt , ms , 29*29*4 );
   while( stk.empty() == false ){
      int u = stk.top();
      stk.pop();
      
      if( u == 1 ){
         mx_mul( ms , ms , ms );
      }else{
         mx_mul( ms , mt , ms );
      }
      
   }
   mx_mul( mx , ms , mx );
   printf("%d\n",mx[0][25] );
   return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <string.h>
using namespace std;

//#define pii pair<int,int>


struct pii{
   int f , s;
   pii(){};
   pii( int p1, int p2 ):f(p1),s(p2){};
   pii operator+( const pii &p2 ) const {
      return pii( f + p2.f , s + p2.s );
   }
   bool operator<( const pii &p2 ) const {
      return ( f < p2.f || ( f == p2.f && s < p2.s )  );
   }
};

struct node{
   pii right , left , maxx , tot;
};

const int BOTTOM = 65536*2; // 1<<16
const int STP = 17;
int N;
int arr[50005*2];
node TREE[ 1 << 18 ];

void make_tree( int node ){
   for( int i = node; i < node * 2; ++i ){
      TREE[i].right = max( TREE[i*2 +1].right , TREE[i*2+1].tot + TREE[i*2].right );
      TREE[i].left  = max( TREE[i*2].left , TREE[i*2].tot + TREE[i*2 +1].left );
      TREE[i].tot = TREE[i*2].tot + TREE[i*2 +1].tot;
      TREE[i].maxx = max(    max(TREE[i*2].maxx , TREE[i*2+1].maxx)  ,  TREE[i*2 +1].left + TREE[i*2].right   );
   }
   if( node > 1 )
      make_tree( node / 2 );
}

int L,R;
pii ans;
pii query( int node, int deep , int state ){ // 0 - undefined , 1 - left , 2 - right
   int lb = node    * (1<<(STP-deep));
   int rb = (node+1)* (1<<(STP-deep)) - 1;
   int mid = (lb+rb)>>1;
   if( node >= (BOTTOM<<1)  )return pii(0,0);
   if( state == 0){
        
      if(lb == L && rb == R ){   ans = max(  TREE[node].maxx  ,  ans  ); return pii(-1,-1);   }
      
      if( lb <= L && L <= mid  &&  mid < R && R <= rb  ){
         pii left  = query( node*2  , deep+1 , 1 );
         pii right = query( node*2+1, deep+1 , 2 );
         ans = max( ans , left + right );
         ans = max( ans , max(left,right) );
         return pii(-1,-1);
      }
      
      if(  state == 0 &&  lb <= L && L <= mid )
         query( node*2  , deep + 1 , 0 );
      else if( state == 0 && mid < R && R <= rb )
         query( node*2+1, deep + 1 , 0 );
         
         
   }else if( state == 1 ){
         
         
      if(lb == L && rb == R ){
        ans = max( TREE[node].maxx , ans );
        return TREE[node].right;
      }
      
      if( lb == rb )return TREE[node].tot;
      if( mid >= L ){
         pii left = query( node * 2 , deep + 1 , 1 );
         ans = max( ans , left );
         ans = max( ans , TREE[node*2+1].maxx );
         ans = max( ans , left + TREE[node*2+1].left );
         return max(TREE[node*2+1].tot + left , TREE[node*2+1].right );
      }else{
         pii left = query( node * 2 + 1, deep + 1 , 1 );
         return left;
      }
      
   }else{
      
      if(lb == L && rb == R ){
        ans = max( TREE[node].maxx , ans );
        return TREE[node].left;
      }
      
      if( lb == rb )return TREE[node].tot;
      if( mid < R ){
         pii right = query( node * 2 + 1 , deep + 1 , 2 );
         ans = max( ans , right );
         ans = max( ans , TREE[node*2].maxx );
         ans = max( ans , right + TREE[node*2].right );
         return max(TREE[node*2].tot + right , TREE[node*2].left );
      }else{
         pii right = query( node * 2, deep + 1 , 2 );
         return right;
      }
      
   }
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
   scanf("%d",&N);
   for( int i = 0; i < N; ++i ){
      scanf("%d",&arr[i]);
         TREE[ BOTTOM+i ].right = pii(arr[i],1);
         TREE[ BOTTOM+i ].left  = pii(arr[i],1);
         TREE[ BOTTOM+i ].tot   = pii(arr[i],1);
         TREE[ BOTTOM+i ].maxx  = pii(arr[i],1);

   }
   make_tree( BOTTOM / 2 );
   int Q,f,s;
   scanf("%d",&Q);
   for( int i = 0; i < Q; ++i ){
      scanf("%d%d",&f,&s);
      L = BOTTOM + f - 1;
      R = BOTTOM + s - 1;
      ans = pii(-999999,0);
      query( 1 , 0 , 0 );
      printf("%d %d\n",ans.f , ans.s);
   }
   
   //system("Pause");
   return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <string.h>
using namespace std;

//#define pii pair<int,int>


struct pii{
   int f , s;
   pii(){};
   pii( int p1, int p2 ):f(p1),s(p2){};
   pii operator+( const pii &p2 ) const {
      return pii( f + p2.f , s + p2.s );
   }
   bool operator<( const pii &p2 ) const {
      return ( f < p2.f || ( f == p2.f && s < p2.s )  );
   }
};

struct node{
   pii right , left , maxx , tot;
   node(pii p1, pii p2, pii p3, pii p4) : right(p1),left(p2),maxx(p3),tot(p4) {};
   node(){};
};

const pii zero = pii(-999999999,-999999999);
const int inf = 999999999;
const int BOTTOM = 65536*2; // 1<<16
const int STP = 17;
int N;
int arr[100005];
node TREE[ 1 << 18 ];

void make_tree( int node ){
   for( int i = node; i < (node<<1); ++i ){
      TREE[i].right = max( TREE[(i<<1) +1].right , TREE[(i<<1)+1].tot + TREE[i<<1].right );
      TREE[i].left  = max( TREE[i<<1].left , TREE[i<<1].tot + TREE[(i<<1) +1].left );
      TREE[i].tot = TREE[i<<1].tot + TREE[(i<<1) +1].tot;
      TREE[i].maxx = max(    max(TREE[i<<1].maxx , TREE[(i<<1)+1].maxx)  ,  TREE[(i<<1) +1].left + TREE[i<<1].right   );
   }
   if( node > 1 )
      make_tree( node >> 1 );
}

int L,R;
node query( int idx, int deep ){ 
    int lb = idx    * (1<<(STP-deep));
    int rb = (idx+1)* (1<<(STP-deep)) - 1;
    int mid = (lb+rb)>>1;
    
    if(lb >= L && rb <= R ) return TREE[idx];
      
    if(  L <= mid && mid < R  ){

        node left  = query( idx*2  , deep+1 );
        node right = query( idx*2+1, deep+1 );

        node sol;
        
        sol.tot  = left.tot + right.tot;
        sol.left = max( left.left , left.tot + right.left );
        sol.right= max( right.right , right.tot + left.right );
        sol.maxx = max(  max(left.maxx,right.maxx) , right.left+left.right );
        
        return sol;
      }
      
      if(  (lb <= L && L <= mid) || (lb <= R && R <= mid)  )
         return query( idx*2  , deep + 1 );
         
      else if( (mid < R && R <= rb) || (mid < L && L <= rb)  )
         return query( idx*2+1, deep + 1 );
         
    return node(zero,zero,zero,zero);
}

int main(){
  //  freopen("Ulaz.txt","r",stdin);
//    freopen("Izlaz.txt","w",stdout);
   scanf("%d",&N);
   for( int i = 0; i < N; ++i ){
      scanf("%d",&arr[i]);
         TREE[ BOTTOM+i ].right = pii(arr[i],1);
         TREE[ BOTTOM+i ].left  = pii(arr[i],1);
         TREE[ BOTTOM+i ].tot   = pii(arr[i],1);
         TREE[ BOTTOM+i ].maxx  = pii(arr[i],1);

   }
   make_tree( BOTTOM >> 1 );
   int Q,f,s;
   scanf("%d",&Q);
   for( int i = 0; i < Q; ++i ){
      scanf("%d%d",&f,&s);
      L = BOTTOM + f - 1;
      R = BOTTOM + s - 1;
      //ans = -999999;
      node ans = query( 1 , 0 );
     // printf("%d %d\n",1,2);
      printf("%d %d\n",ans.maxx.f,ans.maxx.s);
   }
   
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<cstdlib>
#include<algorithm>
#include<math.h>
#include<iomanip>
#include<set>
#include<fstream>
using namespace std;

long long __lcm( long long a, long long b ){
   return (a*b)/__gcd(a,b);
}

int main(){
   
   long long B,C,D,A1,A2,E1,E2;
   cin>>B>>C>>D;
   cin>>A1>>A2;
   cin>>E1>>E2;
   
   long long LCM = __lcm(D,E2);
   
   LCM = __lcm(C,LCM);
   LCM = __lcm(B,LCM);
   LCM = __lcm(A2,LCM);
   
   A1 = A1 * ( LCM / A2 );
   E1 = E1 * ( LCM / E2 );
   
   long long k1 = LCM / B;
   long long k2 = LCM / C;
   long long k3 = LCM / D;
   
   int sol = 0;
   
   long long from = A1 / k2;
   long long to   = E1 / k2;
   
   for( int i = from; i <= to; ++i ){
      int mid = i;
      if( mid*k2 <= A1 )continue;
      if( mid*k2 >= E1 )continue;
      
      int x1 = (  (mid*k2-1)  / k1 ) - ( A1 / k1 );
      int x2 = (  (E1-1) / k3 ) - ( mid*k2 / k3 );
      
      sol += x1 * x2;
   }
   printf("%d\n",sol);
   
   return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:diet
*/
#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
#include<iomanip>
#include<set>
#include<queue>
#include<stack>
#include<string.h>
using namespace std;

int w,n,bale[505];
int dp[45005];
int dp2[45005];

int main(){
   freopen("diet.in","r",stdin);
   freopen("diet.out","w",stdout);
   
   scanf("%d%d",&w,&n);
   for( int i = 0; i < n; ++i )
      scanf("%d",&bale[i]);
   
   int sol = 0;
   dp[0] = 1;
   dp2[0] = 1;
   for( int i = 0; i < n; ++i ){
      for( int j = 0; j <= w; ++j ){
         if( j - bale[i] >= 0 )
            dp2[j] |= dp[ j - bale[i] ];
         if( dp2[j] )
            sol = max( sol , j );
      }
      memcpy( dp , dp2 , 45000*4);
   }
   printf("%d\n",sol);
   return 0;
}

#include <iostream>
#include <algorithm>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <cstdlib>
#include <string.h>
using namespace std;

int n,m;
char txt[55][106];

char syms[] = { 'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9' };
int szc = 26+10;

int main(){
   scanf("%d%d",&n,&m);
   for( int i = 0; i < n; ++i ){
      scanf("%s",txt[i]);
   }
   int sIdx,sChar;
   int sol = 0;
   for( int i = 0; i < m; ++i ){
      char prev = txt[0][i];
      for( int j = 0; j < szc; ++j ){
           
         if( syms[j] == prev )
            continue;
         txt[0][i] = syms[j];
            
         bool ok = true;
         for( int k = 1; k < n && ok; ++k ){
            int diff = 0;
            for( int l = 0; l < m; ++l ){
               diff += txt[0][l] != txt[k][l];
               if( diff > 1 )break;
            }
            if( !(diff == 1)  )ok = false;
         }
         if( ok ){
            sol++;
            sIdx = i, sChar = j;
         }
      }
      txt[0][i] = prev;
   }
   if( sol == 0 )
      printf("IMPOSSIBLE\n");
   else if( sol > 1 )
      printf("AMBIGUOUS\n");
   else{
      txt[0][sIdx] = syms[sChar];
      printf("%s\n",txt[0]);
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<set>
#include<queue>
#include<vector>
#include<string>
#include<string.h>
using namespace std;

char s1[1000],s2[1000];
char op;

int main()
{
   scanf("%s",s1);
   while( op=getchar() )
      if( op == '+' || op == '*' )
         break;
   scanf("%s",s2);
   int n = strlen(s1);
   int n1 = strlen(s2);
   int i;
   if(op=='+'){
      if(n>=n1){
         s1[n-n1]++;
         printf("%s\n",s1);
      }else{
         s2[n1-n]++;
         printf("%s\n",s2);
      }
   }else{
      printf("%s",s1);
      for(i=0;i<n1-1;i++)printf("0");printf("\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<string.h>
using namespace std;

int dp[1003][1004];
char f[1004];
char s[1005];

int solve( ){
   int len = strlen(f);
   int len2 = strlen(s);
   for( int i = 1; i <= len; ++i ){
      for( int j = 1; j <= len2; ++j ){
         if( f[i-1] == s[j-1] ){
            dp[i][j] = dp[i-1][j-1] + 1;
         }else{
            dp[i][j] = max(dp[i-1][j] , dp[i][j-1] );
         }
      }
   }
   return dp[len][len2];
}

int main(){
   scanf("%s",f);
   scanf("%s",s);
   printf("%d\n",solve());
   return 0;
}
   

#include<iostream>
#include<cstdio>
using namespace std;

int n;

int main(){
   scanf("%d",&n);
   if( n > 2 ){
      long long sol = 1;
      int costRev = 2;
      for( int i = 2; i < n; ++i )
         if( i < n-i-1 )
            sol+=i;
         else
            sol+=n-i-1;
      cout<<sol<<endl;
   }else{
      printf("0\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<string.h>
using namespace std;

int len;
char str[1000005];

int GetIdx( int left, int right ){
   if( left==right )return left;
   int mid = (left+right)>>1;
   int L = GetIdx( left , mid   );
   int R = GetIdx( mid+1, right );
   for( int i = 0; L+i < R; ++i ){
       if( str[L+i] < str[ (R+i)%len ] )
          return L;
       if( str[L+i] > str[ (R+i)%len ] )
          return R;
   }
   return L;
}


int main(){
   scanf("%s",str);
   len = strlen(str);
   printf("%d\n", GetIdx( 0 , len-1 )   );
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<string.h>
using namespace std;

char buff[1000];
char *pok;

vector<string>S;

int main(){
    scanf("%s",buff);
    int len = strlen(buff);
    buff[ len  ] = ':';
    buff[ len+1] = '\0';
    len = strlen(buff);

    int now, nxt = 0;
    for( now = -1; now < len; ++now ){
       if(  now > -1  && buff[now] != ':' )continue;
       if(  now >= len-2 )continue;
       
       string str = "";
       for( nxt = now+1 ; nxt < len && buff[nxt] != ':'; ++nxt ){
          str += buff[nxt];
       }
       if( str.size() > 0 ){
           int sz = (int)str.size();
           for( int i = 0; i < 4 - sz; ++i ){
              str = "0" + str;
           }
       }
              
       S.push_back(str);
    }
    for( int i = 0; i < S.size(); ++i ){
       if( S[i].size() > 0 ){
           cout<<S[i];
       }else{
           for( int i = 0; i < 8 - (int)S.size() + 1; ++i ){
               cout<<"0000";
               if( i  < 8 - (int)S.size() )
                   cout<<":";
           }
       }
       
       if( i + 1 < S.size () )
          cout<<":";
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

#define P 1
#define N 2

int n,v;
vector<int>S;
int dp[10000];

int main(){
    scanf("%d",&n);
    
    for( int i = 0; i < n; ++i ){
        scanf("%d",&v);
        S.push_back(v);
    }
    sort( S.begin(), S.end() );
    S.erase( unique(S.begin(),S.end()) , S.end() );
    
    dp[0] = P;
    for( int i = 1; i < 10000; ++i ){
        bool IsP = false;
        bool IsN = false;
        for( int j = 0; j < S.size() && !IsP; ++j ){
            if( i - S[j] < 0 )continue;
            if( dp[ i - S[j] ] == P )IsP = true;
            if( dp[ i - S[j] ] == N )IsN = true;
        }
        if( IsP )dp[i] = N;
        else if( IsN )dp[i] = P;
    }
    
    while( scanf("%d",&v) == 1 ){
         printf("Win: %d\n", dp[v] == N );       
    }
    
    system("Pause");
    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<math.h>
using namespace std;

const long long  MOD = 98777;

long long fastM( long long  v , long long  stp ){
    if( stp == 0 )return 1;
    
    if( stp&1 ){
       return (fastM( v , stp-1 ) * v)%MOD;
    }else{
       long long  z = fastM( v , stp>>1 )%MOD;
       return (z*z)%MOD;
    }
}

int main(){
    int n;
    int tests;
    scanf("%d",&tests);
    
    for( ; tests ; --tests ){
        scanf("%d",&n);
        n--;
        
        if( n <  2 ){
            if( n == -1 )printf("0\n");
            if( n == 0  )printf("1\n");
            if( n == 1  )printf("2\n");
            continue;
        }
        
        long long  m = n-1;
        m = 2*(n-1) + 1;
        if( n == 1 ) m = 0;
        
        long long  ss =  ( n%2 == 1 ? (long long )ceil(m/2.0) : 0 ) + (n/2)*(m+1);


        cout<< fastM(2,ss) <<endl;
        
        
        
    }
    
    return 0;
}

#include<iostream>
using namespace std;

int main(){
   int prev = 1 , now = 1 , nxt;
   for( int i = 0; i < 20000; ++i ){
      nxt = prev + now;
      if( nxt <= 2000 )
         printf("%d\n",nxt);
      else
         break;
      prev = now;
      now = nxt;
   }
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<queue>
#include<string.h>
using namespace std;

#define f first
#define s second

int Z,M,K;
vector< int >cy;
vector< int >st;

int visi[150005];

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    int tests,v;
    fscanf(in,"%d",&tests);
    
    for( ; tests ; tests-- ){
        
        fscanf(in,"%d%d%d",&Z,&M,&K);
        
        
        memset( visi , 0 , sizeof(visi)  );
        cy.clear();
        st.clear();
        
        for( int i = 0; i < M; ++i ){
            fscanf(in,"%d",&v);
            cy.push_back(v);
        }
        
        for( int i = 0; i < K; ++i ){
            fscanf(in,"%d",&v);
            st.push_back(v);
        }
        sort( cy.begin() , cy.end()  );
        sort( st.begin() , st.end()  );
        
        queue< int > Q;
        Q.push(0);
        
        for( int i = 0; i < M; ++i ){
            
            queue< int > Q2 = Q;
            while( !Q.empty() ){
                int v = Q.front();
                int u = v + cy[i]; Q.pop();
                
                if( visi[u] == false ){
                    Q2.push( u );
                    visi[u] = visi[v] + 1;
                }
            }
            Q = Q2;
        }
        int partI = Z;
        for( ; visi[ partI ]==false ; --partI );
        
        
        if( visi[partI] < M ){
            if( Z-partI )printf("%d\n",partI + (Z-partI-1) );
            else printf("%d\n",partI);
        }else{
            Z -= partI;
            int partII = 0;
            
            for( int i = K-1; i >=0 && Z; --i ){
                if( Z <= st[i] ){
                    partII += Z-1;
                    Z = 0;
                }else{
                    partII += st[i]-1;
                    Z -= st[i];
                }
            }
            printf("%d\n",partI+partII);
        }
        
    }
    
    return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
#include<string.h>
#include<cstring>
using namespace std;

struct tile{
   int a,b,c,d;
   tile( int p1, int p2, int p3, int p4 ):a(p1),b(p2),c(p3),d(p4){};
   tile(){};
};

const int N = 9;
tile g[9];
vector<int>leftH[9];
vector<int>topH[9];

int mx[5][5];
bool used[9];


bool solve( int r, int c ){
   if( c == 3 )c = 0 , r++;
   if( r == 3 )return true;
         
   for( int i = 0; i < 9; ++i ){
      if( used[i] == true )continue;
      if( r > 0 && g[  mx[r-1][c]  ].c != g[i].a )continue;
      if( c > 0 && g[  mx[r][c-1]  ].b != g[i].d )continue;
      used[ i ] =  true;
      mx[r][c] = i;
      if( solve(r,c+1) )return true;
      mx[r][c] = -1;
      used[ i ] = false;
   } 
   return false;
}

int main(){
   int tests,a,b,c,d;
   scanf("%d",&tests);
   for( int t = 1 ; t<=tests ; t++ ){
      for( int i = 0; i < N; ++i ){
         scanf("%d%d%d%d",&a,&b,&c,&d);
         g[i] = tile(a,b,c,d);
         leftH[d].push_back( i );
         topH[a].push_back( i );
      }
      memset(mx,-1,sizeof(mx));
      memset(used,0,sizeof(used));
      bool ok = solve(0,0);
      if( ok )
        printf("Case %d: YES\n",t);
      else
         printf("Case %d: NO\n",t);
   }
   return 0;
}

#include <iostream>
#include <string.h>
using namespace std;

int main(){
    int tc = 1;
    int v;
    while( cin >> v ){
       if( v == 0 )break;
       int n1 = 3 * v;
       int n2 = n1 / 2;
       int n3 = 3 * n2;
       int n4 = n3 / 9;
       
       printf("%d. %s %d\n",tc , n1%2==0?"even":"odd" , n4 );
       tc++;
    }
    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
#include<cstdlib>
#include<set>
#include<queue>
#include<fstream>
using namespace std;

long long divider[10005];

int main(){
    long long n;
    long long sol = 1000000000000000000ll;
    long long nw_idx , nw_n , z;
    int k;
    cin >> n >> k;
    
    for( int i = 0; i < k; ++i ){
        
        scanf("%lld",&divider[i]);
        
        nw_idx = divider[i];
        nw_n   = n;
        z;
        
        for( int j = 0; j < i; ++j ){
            z = -((divider[j]<<1)-nw_n);
            if( z < 0 ) z = 0;
            
            if( nw_idx >= divider[j] )
                nw_idx = (divider[j]<<1) - nw_idx + z;
            else
                nw_idx = nw_idx + z;
            nw_n = divider[j] + z;
            
        }
        
        divider[i] = nw_idx;
        
        z = -((divider[i]<<1)-nw_n);
        if( z < 0 ) z = 0;
        nw_n = divider[i] + z;

        
        if( sol > divider[i] + z )
            sol = divider[i] + z;
        
    }
    cout << sol <<endl;
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <cstdlib>
using namespace std;

struct set{
   int idx;
   vector< char >s;
   set(){};
   set( vector<char> &v ):s(v){};
   set( vector<char> &v , int z):s(v),idx(z){};
   
   vector<char> common( const vector<char>& )const;
   vector<char> diff( const vector<char>& )const;
};

vector<char> set::common( const vector<char>&s2 ) const {
    int *fld1 = new int[105];
    int *fld2 = new int[105];
    for( int i = 0; i <= 100; ++i )
        fld1[i] = fld2[i] = 0;
    
    for( int i = 0; i < s.size(); ++i )
       fld1[ s[i] ]++;
    
    for( int i = 0; i < s2.size(); ++i )
       fld2[ s2[i] ]++;
    
    vector< char > ret;
    int bound;
    
    for( int i = 0; i <= 100; ++i ){
        bound = min(fld1[i],fld2[i]);
        for( int j = 0; j < bound; ++j )
            ret.push_back(i);
    }
    delete []fld1;
    delete []fld2;
    return ret;
}


vector<char> set::diff( const vector<char> &s2 ) const {
    int *fld1 = new int[105];
    int *fld2 = new int[105];
    for( int i = 0; i <= 100; ++i )
        fld1[i] = fld2[i] = 0;
    
    for( int i = 0; i < s.size(); ++i )
       fld1[ s[i] ]++;
    
    for( int i = 0; i < s2.size(); ++i )
       fld2[ s2[i] ]++;
    
    vector< char > ret;
    int Lbound,Ubound;
    
    for( int i = 0; i <= 100; ++i ){
        for( int j = fld2[i]; j < fld1[i]; ++j )
            ret.push_back(i);
    }
    delete [] fld1;
    delete [] fld2;
    return ret;
}

void random_permute( vector< set > &V ){
    int sz = (int)V.size();
    
    
    for( int i = 0; i < sz; ++i ){
        
        int id = rand() % (sz-i);
        swap( V[i] , V[id+i] );
        
    }
    
}

vector< set > sets;

int maybe[505];
vector<char> maybe2;

void ini( vector< char > &y ){
    for( int i = 0; i < y.size(); ++i )
        maybe2.push_back(y[i]);
}

int GetSol(){
   int sz = sets.size();
   int sol = 0;
   
   vector< char > now;
   vector< char > prev;
   
   maybe[ sets[0].idx ] = 0;
   maybe2.clear();
   
   now = sets[0].diff( sets[1].s );
   
   ini( now );
   prev = sets[0].s;
   
   
   for( int i = 1; i < sz; ++i ){
      int g = maybe2.size() ;
      maybe[ sets[i].idx ] = g >= 0 ? g : 0;
      
      now = sets[i].common( prev );
      ini(now);
      prev = sets[i].diff( now );
      
      
      now = sets[i].diff( now   );
      if( i+1 < sz )now = ((set)now).diff( sets[i+1].s );
      ini( now );
      
      prev = ((set)prev).diff( now );
      
      
   }
   
   
   return maybe2.size();
}

int ss3[505];


int main(){
    FILE *in = stdin;//fopen("Ulaz3.txt","r");
    srand( (unsigned)time(0) );
    int n,L,v;
    fscanf(in,"%d",&n);
    for( int i = 0; i < n; ++i ){
        fscanf(in,"%d",&L);
        
        vector< char > memo;
        for( int j = 0; j < L; ++j ){
            
            fscanf(in,"%d",&v);
            memo.push_back( v );
            
        }
        sets.push_back( set( memo , i )  );
    }
    
    int sol = 999999999;
    vector< char >ss2;
    
   
        for( int i = 0; i < n-1; ++ i ){
           int mx = 0;
           int k =  i;
           
           for( int j = i+1; j < n; ++j ){
               vector< char > c = sets[i].common( sets[j].s );
               if( c.size() > mx ){
                   mx = c.size();
                   k = j;
               }
           }
           
           swap( sets[i+1] , sets[k] );
           
           
        }
        int ss = GetSol();

        
        if( ss < sol ){
            sol = ss;
            ss2 = maybe2;
            
            memcpy(ss3 , maybe, 504 * 4 );
            
            
        }

    
    printf("%d ",sol);
    for( int i = 0; i < ss2.size(); ++i )
        printf("%d ",ss2[i]);
        printf("\n");
    for( int i = 0; i < n; ++i )
        printf("%d ",ss3[i]);
        printf("\n");
//system("Pause");

    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<math.h>
using namespace std;

double eps = 0.000001;

int arr[10];

int main(){
  //  freopen("Ulaz.txt","r",stdin);
  //  freopen("Izlaz.txt","w",stdout);
   double a,b,c,d;
   
   while( true ){
      scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
      if( a < eps && b < eps && c < eps && d < eps )break;
      if( b < eps  ){
         printf("%.30lf\n",0);
         continue;
      }
      
      double hipo = sqrt( (b-d)*(b-d) + (a-c)*(a-c) );

      
      double P = a * b;
      P -= ((b-d)*(a-c))/ ((double)2.0);

      
      
      double porast =  (double)atan2( (long double)b-d,(long double)a-c );
      double xPorast = (double)cos( ( long double)porast );
      double yPorast = (double)sin( ( long double)porast );
      
      double a1 = -xPorast * yPorast;
      double b1 = - d * xPorast + yPorast * a;
      double c1 = a * d;
      
      double T = ( -b1 / ((double)2.0*a1) );
      
      if( T < eps )T = 0;
      if( T >=  hipo ) T = hipo;
      
      double y0 = T*T * a1 + T * b1 + c1;

      double ss4 = P - max(y0,max(a*d,b*c) );

      printf("%.30lf\n",ss4);
   }
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <queue>
#include <stack>
#include <set>
#include <bitset>
#include <string>
#include <string.h>
#include <cstdlib>
#include <map>
#include <list>
#include <fstream>
using namespace std;



int main(){
    int C,I;
    scanf("%d%d",&C,&I);
    for( int i = 0; i <= C*I; ++i ){
        if(  ceil(i / (double)C) == I ){
            printf("%d\n",i);
            break;
        }
    }
    system("Pause");
    return 0;    
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

#define P 1
#define N 2

int dp[1000][1000];

int main(){
    
    for( int i = 1; i <= 1000; ++i )dp[0][i] = P;
    
    for( int i = 1; i <= 300; ++i ){
       for( int j = 0; j <= i; ++j ){ // dp(i,j) , i == number of coins , 
                                     //            j == took in previous move
       
           bool IsP = false;
           bool IsN = false;
           int G = min(j*2,i);
           if( j == 0 )G = i-1;
           
           for( int k = 1; k <= G && !IsP; ++k ){
               if( i - k < 0 )continue;
               
               if( dp[i-k][k] == P )IsP = true;
               else if( dp[i-k][k] == N )IsN = true;
               
           }
           
           if( IsP )dp[i][j] = N;
           else if( IsN )dp[i][j] = P;
                   
       }
    }
    int v;
    while( cin >> v ){
        printf("Win: %d\n",dp[v][0] == N );
    }
    
    system("Pause");
    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<vector>
#include<iomanip>
#include<math.h>
#include<string.h>
using namespace std;

const double PI = acos(0)*2;

class DegreesToRadians{
 public:
   double convertToRadians(int degrees, int minutes, int seconds){
      double stp = degrees + minutes/60.0 + seconds/60.0/60.0;
      return (stp*PI/180);
   }
};

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

#define ok(y,x) (x>=0&&x<W&&y>=0&&y<H&&maze[y][x]=='.')

int H,W;
bool visi[100][100];
int dist[100][100];

class MazeMaker {
    public:
        int longestPath(vector <string> maze, int ys, int xs, vector <int> moveRow, vector <int> moveCol)
        {
            memset(dist,-1,sizeof(dist));
            memset(visi,0,sizeof(visi));
            dist[ys][xs] = 0;
            visi[ ys ][ xs ] = true;
            H = maze.size();
            W = maze[0].size();
            queue < pii > Q;
            Q.push( mk(ys,xs) );
            
            while(!Q.empty() ){
                pii u = Q.front(); Q.pop();
                for( int i = 0; i < moveRow.size(); ++i ){
                    int yn = u.f + moveRow[i];
                    int xn = u.s + moveCol[i];
                    if( ok(yn,xn) && visi[yn][xn] == false ){
                        Q.push( mk(yn,xn) )
                        dist[yn][xn] = dist[u.f][u.s] + 1;
;
                        visi[yn][xn] = true;
                    }
                }
            }
            
            int sol = 0;
            for( int i = 0; i < maze.size() && sol != -1; ++i ){
                for( int j = 0; j < maze[i].size() && sol != -1; ++j ){
                    if( maze[i][j] == '.' ){
                        if( dist[i][j] == -1 )
                            sol = -1;
                        else
                            sol = max( sol , dist[i][j] );
                            

                    } 
                }
            }
            return sol;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); if ((Case == -1) || (Case == 5)) test_case_5(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { string Arr0[] = {"...",
 "...",
 "..."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 0; int Arg2 = 1; int Arr3[] = {1,0,-1,0}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0,1,0,-1}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = 3; verify_case(0, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_1() { string Arr0[] = {"...",
 "...",
 "..."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 0; int Arg2 = 1; int Arr3[] = {1, 0, -1, 0, 1, 1, -1, -1}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0, 1, 0, -1, 1, -1, 1, -1}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = 2; verify_case(1, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_2() { string Arr0[] = {"X.X",
 "...",
 "XXX",
 "X.X"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 0; int Arg2 = 1; int Arr3[] = {1, 0, -1, 0}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0, 1, 0, -1}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = -1; verify_case(2, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_3() { string Arr0[] = {".......",
 "X.X.X..",
 "XXX...X",
 "....X..",
 "X....X.",
 "......."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 5; int Arg2 = 0; int Arr3[] = {1, 0, -1, 0,-2, 1}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0, -1, 0, 1, 3, 0}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = 7; verify_case(3, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_4() { string Arr0[] = {"......."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 0; int Arg2 = 0; int Arr3[] = {1, 0, 1, 0, 1, 0}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0, 1, 0, 1, 0, 1}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = 6; verify_case(4, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_5() { string Arr0[] = {"..X.X.X.X.X.X."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 0; int Arg2 = 0; int Arr3[] = {2,0,-2,0}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0,2,0,-2}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = -1; verify_case(5, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    MazeMaker c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <vector>
#include <list>
#include <map>
#include <set>
#include <algorithm>
#include <string>
#include <sstream>
#include <cmath>
#include <iostream>
using namespace std;
#define IM "impossible"
class TwoStringMasks {
  public:
    string shortestCommon(string s1, string s2) {
      int i, j;
      string ret;
      while (s1[0] != '*' && s2[0] != '*') {
        if (s1[0] != s2[0])
          return IM;
        ret += s1[0];
        s1 = s1.substr(1, s1.length() - 1);
        s2 = s2.substr(1, s2.length() - 1);
      }
      string tmp;
      while (s1[s1.length() - 1] != '*' && s2[s2.length() - 1] != '*') {
        if (s1[s1.length() - 1] != s2[s2.length() - 1])
          return IM;
        tmp = s1[s1.length() - 1] + tmp;
        s1 = s1.substr(0, s1.length() - 1);
        s2 = s2.substr(0, s2.length() - 1);
      }
      if (s1 == "*") {
        string tmp2 = s1;
        s1 = s2;
        s2 = tmp2;
      }
      if (s2 == "*") {
        for (i = 0; i < s1.length() - 1; i ++)
          if (s1[i] == '*')
            break;
        return (ret + s1.substr(0, i) + s1.substr(i + 1, s1.length() - i - 1) + tmp);
      }
      if (s1[0] != '*') {
        string tmp2 = s1;
        s1 = s2;
        s2 = tmp2;
      }
      for (i = 0; i < s2.length(); i ++) {
        if (s2.length() - 2 - i + 1 >= s1.length())
          continue;
        for (j = i; j < s2.length() - 1; j ++)
          if (s1[j - i + 1] != s2[j])
            break;
        if (j >= s2.length() - 1)
          return (ret + s2.substr(0, i) + s1.substr(1, s1.length() - 1) + tmp);
      }
    }
};

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

#define ok(y,x) (x>=0&&x<W&&y>=0&&y<H&&maze[y][x]=='.')

int H,W;
bool visi[100][100];
int dist[100][100];

class MazeMaker {
    public:
        int longestPath(vector <string> maze, int ys, int xs, vector <int> moveRow, vector <int> moveCol)
        {
            memset(dist,-1,sizeof(dist));
            memset(visi,0,sizeof(visi));
            dist[ys][xs] = 0;
            visi[ ys ][ xs ] = true;
            H = maze.size();
            W = maze[0].size();
            queue < pii > Q;
            Q.push( mk(ys,xs) );
            
            while(!Q.empty() ){
                pii u = Q.front(); Q.pop();
                for( int i = 0; i < moveRow.size(); ++i ){
                    int yn = u.f + moveRow[i];
                    int xn = u.s + moveCol[i];
                    if( ok(yn,xn) && visi[yn][xn] == false ){
                        Q.push( mk(yn,xn) )
                        dist[yn][xn] = dist[u.f][u.s] + 1;
;
                        visi[yn][xn] = true;
                    }
                }
            }
            
            int sol = 0;
            for( int i = 0; i < maze.size() && sol != -1; ++i ){
                for( int j = 0; j < maze[i].size() && sol != -1; ++j ){
                    if( maze[i][j] == '.' ){
                        if( dist[i][j] == -1 )
                            sol = -1;
                        else
                            sol = max( sol , dist[i][j] );
                            

                    } 
                }
            }
            return sol;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); if ((Case == -1) || (Case == 5)) test_case_5(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { string Arr0[] = {"...",
 "...",
 "..."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 0; int Arg2 = 1; int Arr3[] = {1,0,-1,0}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0,1,0,-1}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = 3; verify_case(0, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_1() { string Arr0[] = {"...",
 "...",
 "..."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 0; int Arg2 = 1; int Arr3[] = {1, 0, -1, 0, 1, 1, -1, -1}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0, 1, 0, -1, 1, -1, 1, -1}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = 2; verify_case(1, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_2() { string Arr0[] = {"X.X",
 "...",
 "XXX",
 "X.X"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 0; int Arg2 = 1; int Arr3[] = {1, 0, -1, 0}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0, 1, 0, -1}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = -1; verify_case(2, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_3() { string Arr0[] = {".......",
 "X.X.X..",
 "XXX...X",
 "....X..",
 "X....X.",
 "......."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 5; int Arg2 = 0; int Arr3[] = {1, 0, -1, 0,-2, 1}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0, -1, 0, 1, 3, 0}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = 7; verify_case(3, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_4() { string Arr0[] = {"......."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 0; int Arg2 = 0; int Arr3[] = {1, 0, 1, 0, 1, 0}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0, 1, 0, 1, 0, 1}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = 6; verify_case(4, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_5() { string Arr0[] = {"..X.X.X.X.X.X."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 0; int Arg2 = 0; int Arr3[] = {2,0,-2,0}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0,2,0,-2}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = -1; verify_case(5, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    MazeMaker c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
using namespace std;

const int SQRT3N = 37;
vector< int > costs;
const int inf = 9999999;
int dp[50005];

class PlanarGraphShop {
    public:
        int bestCount(int N)
        {
            costs.clear();
            memset(dp,0,sizeof(dp));
            for( int i = 1; i <= SQRT3N; ++i ){
                int maxe = i + i + i - 6;
                if( maxe < 0 ) maxe = 0;
                if( i == 2 )   maxe = 1;
                if( i == 1 )   maxe = 0;
                for( int j = 0; j <= maxe; ++j ){
                    int xcost = i*i*i;
                    int ycost = j*j;
                    if( xcost + ycost > N )continue;
                    
                    costs.push_back( xcost + ycost );
                }
            } 
            sort( costs.begin() , costs.end() );
            costs.erase( unique( costs.begin(), costs.end() ), costs.end() );
            
            dp[0] = 1;
            for( int i = 1; i <= N; ++i ){
                dp[i] = inf;
                for( int j = 0; j < costs.size(); ++j ){
                    if( i - costs[j] >= 0 )
                       dp[i] = min( dp[i] , dp[i-costs[j]] + 1 );
                }
            }
            
            return dp[N]-1;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arg0 = 36; int Arg1 = 1; verify_case(0, Arg1, bestCount(Arg0)); }
	void test_case_1() { int Arg0 = 7; int Arg1 = 7; verify_case(1, Arg1, bestCount(Arg0)); }
	void test_case_2() { int Arg0 = 72; int Arg1 = 2; verify_case(2, Arg1, bestCount(Arg0)); }
	void test_case_3() { int Arg0 = 46; int Arg1 = 3; verify_case(3, Arg1, bestCount(Arg0)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    PlanarGraphShop c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<vector>
#include<iomanip>
#include<string.h>
using namespace std;

vector<char> alpha;
int getIt( char c ){
   for( int i = 0; i < alpha.size(); ++i )
      if( alpha[i] == c )return i;
  return 0;
}

class TagalogDictionary{
   public:
      vector <string> sortWords(vector <string> words){
         alpha.push_back('a');
         alpha.push_back('b');
         alpha.push_back('k');
         alpha.push_back('d');
         alpha.push_back('e');
         alpha.push_back('g');
         alpha.push_back('h');
         alpha.push_back('i');
         alpha.push_back('l');
         alpha.push_back('m');
         alpha.push_back('n');
         alpha.push_back('n');
         alpha.push_back('o');
         alpha.push_back('p');
         alpha.push_back('r');
         alpha.push_back('s');
         alpha.push_back('t');
         alpha.push_back('u');
         alpha.push_back('w');
         alpha.push_back('y');
         for( int i = 0; i < words.size(); ++i ){
            int now = i;
            for( int j = i+1; j < words.size(); ++j ){
               int state;
               vector<int>v1,v2;
               for( int k = 0; k < words[now].length(); ++k ){
                  if( k+1<words[now].length() && words[now][k]=='n' && words[now][k+1]=='g' )
                     v1.push_back( 11 ), k++;
                  else{
                     v1.push_back( getIt( words[now][k] )  );
                  }
                  
               }
               cout<<endl;
               for( int k = 0; k < words[j].length(); ++k ){
                  if( k+1<words[j].length() && words[j][k]=='n' && words[j][k+1]=='g' )
                     v2.push_back( 11 ), k++;
                  else{
                     v2.push_back( getIt( words[j][k] )  );
                  }
               }
               state = 0;
               for( int k = 0; k < min( v1.size(), v2.size() ); ++k ){
                  if( v1[k] < v2[k] ){
                     state = -1;
                     break;
                  }
                  if( v1[k] > v2[k] ){
                     state = 1;
                     break;
                  }
               }
               if( state == 0 ){
                  if( v1.size() < v2.size() )
                     state = -1;
                  if( v1.size() > v2.size() )
                     state = 1;
               }
               if( state == 1 )
                  now = j;
            }
            swap(words[i],words[now]);
         } 
         return words;
      }
};

#include<cstdio>
#include<string.h>
#include<algorithm>
using namespace std;

int arr[105];

int main(){
   int n,v,s(0);
   scanf("%d",&n);
   for( int i = 0 ; i < n; ++i ){
      scanf("%d",&arr[i]);
      s += arr[i];
   }
   int mid = s / n;
   int sol = 0;
   for( int i = 0; i < n; ++i ){
      if( arr[i] >= mid )
         sol += arr[i] - mid;
   }
   printf("%d\n",sol);
   return 0;

}

#include<iostream>
#include<cstdio>
#include<math.h>
#include<algorithm>
#include<cstdlib>
#include<vector>
using namespace std;

int n;
int arr[105];

int main(){
    scanf("%d",&n);
    int ss = 0;
    for( int i = 0; i < n; ++i ){
        scanf("%d",&arr[i]);
        ss += arr[i];
    }
    int mid = ss / n;
    int sol = 0;
    for( int i = 0; i < n-1; ++i ){
        if( arr[i] >= mid ){
           sol += arr[i] - mid;
           arr[i+1] += arr[i] - mid;
        }else{
           sol += mid - arr[i];
           arr[i+1] -= mid - arr[i];
        }
    }
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <iomanip>
#include <bitset>
#include <cstdlib>
#include <cstdio>
using namespace std;


int n;
int x1,y1,z1;
int x2,y2,z2;
int xd,yd,zd;

long double prvANS;
int prvDOWN,prvLEFT,prvBW;

long double getProb( int &num , int g ){
    long double R = 1;
    for( int den = 1; den <= g; ++den )
       R *= num / ((long double)den*6), num++;
    return R;
}

long double combi( int DOWN, int LEFT, int BW ){
    int UP    = yd + DOWN;
    int RIGHT = xd + LEFT;
    int FW    = zd + BW;
    int num = 1;
    long double ret = 1;
    
    ret *= getProb( num , UP    ) ;
    ret *= getProb( num , DOWN  ) ;
    ret *= getProb( num , LEFT  ) ;
    ret *= getProb( num , RIGHT ) ;
    ret *= getProb( num , FW    ) ;
    ret *= getProb( num , BW    ) ;
    
    prvANS  = ret;
    prvDOWN = DOWN , prvLEFT = LEFT , prvBW = BW;
    
    return ret;
}

inline void add( long double &d, int f, int t ){
    for( int i = f; i <= t; ++i )
        d /= i;
}
inline void take( long double &d, int f, int t ){
    for( int i = f; i <= t; ++i )
        d *= i;
}

long double nxt( int DOWN, int LEFT, int BW ){
    int UP       = yd + DOWN;
    int RIGHT    = xd + LEFT;
    int FW       = zd + BW;
    
    int prvUP    = yd + prvDOWN;
    int prvRIGHT = xd + prvLEFT;
    int prvFW    = zd + prvBW;
    
    long double ret = prvANS;

    add( ret, prvUP+1   , UP   );
    add( ret, prvDOWN+1 , DOWN );
    add( ret, prvFW+1   , FW   );
    add( ret, prvLEFT+1 , LEFT );
    add( ret, prvRIGHT+1, RIGHT);
    add( ret, prvBW+1   , BW );

    
    take( ret, UP+1   , prvUP   );
    take( ret, DOWN+1 , prvDOWN );
    take( ret, FW+1   , prvFW   );
    take( ret, LEFT+1 , prvLEFT );
    take( ret, RIGHT+1, prvRIGHT);
    take( ret, BW+1   ,  prvBW   );
    
    
    
    prvANS  = ret;
    prvDOWN = DOWN , prvLEFT = LEFT , prvBW = BW;
    
    return ret;
}



int main(){
    int tests;
    scanf("%d",&tests);
    for( ; tests ; --tests ){
        
        scanf("%d",&n);
        scanf("%d%d%d",&x1,&y1,&z1);
        scanf("%d%d%d",&x2,&y2,&z2);
        
        xd = abs(x1-x2);
        yd = abs(y1-y2);
        zd = abs(z1-z2);
        
        int tot = n - (xd+yd+zd);
        
        if( tot%2 || xd>=100 || yd>=100 || zd>=100 ){
            printf("%.10lf\n",0.0);
            continue;
        }
        tot /= 2;
        long double sol = 0;

        for( int i = 0; i <= tot; ++i ){
            for( int j = 0; i+j <= tot; ++j ){
                int k = tot - (i+j);
                
                long double v = 0;
                
                if( i == 0 && j == 0 )sol += v=combi( i , j , k );
                else sol += v=nxt( i , j , k );

            }
        }
        
        printf("%.10lf\n",(double)sol);
        
    }

    return 0;
}

//#include<BigNum.h>
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<string.h>
#include<math.h>
using namespace std;





// DivBy2(bool) // divides the bignum with 2 , true for flooring , false for ceiling
// operator +
// operator -
// operator *
// operator ==
// operator >
// operator <
// operator =
// sqrt() 

class BigNum{   // BIG_NUM_CLASS
   private:
      static const int NewBasis = 8;
      static const int PLACES = 100000000;
   public:
      vector<char>digits;
      BigNum(){}
      BigNum( int v ){while( v ) digits.push_back(v%10) , v/=10; }
      BigNum( char*,int );
      BigNum( const BigNum &z ){ digits = z.digits; }
      BigNum operator*(const BigNum&);
      BigNum operator+(const BigNum&);
      BigNum operator-(const BigNum&);
      BigNum DivBy2(bool);
      BigNum sqrt();
      inline void WriteLn();
      inline void Write();
      void operator=(BigNum);
      bool operator<(const BigNum&);
      bool operator>(const BigNum&);
      bool operator==(const BigNum&);
      void SetPower10( int stp ){
         digits.clear();
         for( int i = 0; i < stp; ++i )
            digits.push_back(0);
         digits.push_back(1);
      }
};

void BigNum::operator=(BigNum b2 ){
   digits.clear();
   digits=b2.digits;
}

BigNum::BigNum( char *f , int len){
   for( int i = len-1; i >=0; --i )
      digits.push_back( f[i]-'0' );
    while( digits.back() == 0 )digits.pop_back();
}

bool BigNum::operator==( const BigNum &b2 ){
   if( b2.digits.size() != digits.size() )return  false;
   for( int i = 0; i < digits.size(); ++i )
      if( digits[i] != b2.digits[i] )return false;
   return true;
}

bool BigNum::operator<( const BigNum &b2 ){
   if( b2.digits.size() > digits.size() )return true;
   else if( b2.digits.size() < digits.size() )return false;
   else{
       for( int i = digits.size()-1; i >=0 ; --i ){
         if( digits[i] < b2.digits[i] )
            return true;
         else if( digits[i] > b2.digits[i] )
            return false;
      }
   }
   return false;
}
bool BigNum::operator>( const BigNum &b2 ){
   if( b2.digits.size() < digits.size() )return true;
   else if( b2.digits.size() > digits.size() )return false;
   else{
      for( int i = digits.size()-1; i >=0 ; --i ){
         if( digits[i] > b2.digits[i] )
            return true;
         else if( digits[i] < b2.digits[i] )
            return false;
      }
   }
   return false;
}

BigNum BigNum::operator*( const BigNum &b2 ){  // FAST MULTIPLICATION
   int digs = b2.digits.size() + digits.size() + 2;
   long long *B1 = new long long[ digs ];
   long long *B2 = new long long[ digs ];
   long long *R =  new long long[ digs ];
   for( int i = 0; i < digs; ++i )B1[i] = B2[i] = R[i] = 0;
   int s1 = digits.size();
   int s2 = b2.digits.size();
   int poz = -1, fak = 1;
   for( int i = 0; i < s1; ++i ){
      if( i % NewBasis == 0 )poz++, fak = 1;
      B1[poz] = B1[poz] + digits[i]*fak;
      fak*=10;
   }

   int ns1 = poz+1;
   
   poz = -1, fak = 1;
   for( int i = 0; i < s2; ++i ){
      if( i % NewBasis == 0 )poz++, fak = 1;
      B2[poz] = B2[poz] + b2.digits[i]*fak;
      fak*=10;
   }
   int ns2 = poz+1;
   
   for( int i = 0; i < ns1; ++i )
      for( int j = 0; j < ns2; ++j )
         R[i+j] += B1[i]*B2[j];
   
   int NS = ns1 + ns2;

   for( int i = 0; i < NS; ++i ){
      if( i == NS-1 && R[i]>=PLACES )NS++;
      R[i+1] += R[i]/PLACES , R[i] = R[i]%PLACES;
   }
   unsigned long long test;
   int digi;
   BigNum ret;
   vector<int>smp;

   while( R[NS-1] )smp.push_back(R[NS-1]%10), R[NS-1]/=10;
   for( int i = smp.size()-1; i >=0; --i )ret.digits.push_back( smp[i] );
   for( int i = NS-2; i>=0; --i ){
      test = R[i];
      digi = 0;
      while(test)
         test/=10,digi++;
      for(int j = 0; j < 8-digi; ++j)ret.digits.push_back(0);
      smp.clear();
      while( R[i] )smp.push_back(R[i]%10), R[i]/=10;
      for( int i = smp.size()-1; i >=0; --i )ret.digits.push_back( smp[i] );
   }
   reverse(ret.digits.begin(),ret.digits.end());
   while( ret.digits.back() == 0 )ret.digits.pop_back();
   
   delete [] B1;
   delete [] B2;
   delete [] R;
   return ret;
}

BigNum BigNum::DivBy2( bool floor=true ){ 
   BigNum ret = BigNum( *this );
   for( int i = ret.digits.size()-1; i>=0; i-- ){
       if( ret.digits[i]%2 == 1 )if( i > 0 )ret.digits[i-1]+=10;
                                 else if( floor )ret.digits[i]--;
                                 else ret.digits[i]++;
       ret.digits[i]/=2;
   }
   for( int i = 0; i < ret.digits.size(); ++i )
      if( ret.digits[i] >= 10 ){
         if( i==ret.digits.size()-1 )ret.digits.push_back(ret.digits[i]/10);
         else ret.digits[i+1] += ret.digits[i]/10;
         ret.digits[i] %= 10;
      }
   while( ret.digits.back() == 0 )ret.digits.pop_back();
   return ret;
}

BigNum BigNum::operator+( const BigNum &b2 ){
   BigNum A = *this , B = b2;
   if( A.digits.size() < B.digits.size() )swap(A,B);
   BigNum sum = B;
   int tmp = 0;
   for( int i = 0; i < B.digits.size(); ++i ){
      int ss = B.digits[i] + A.digits[i] + tmp;
      sum.digits[i] = ss%10;
      tmp = ss / 10;
   }
   for( int i = B.digits.size(); i < A.digits.size(); ++i ){
      int ss = A.digits[i] + tmp;
      sum.digits.push_back( ss % 10 );
      tmp = ss/10;
   }
   while( tmp ){
      sum.digits.push_back( tmp % 10 );
      tmp /= 10;
   }
   return sum;
}

BigNum BigNum::operator-(const BigNum& b2){
   if( (*this) > b2 ){
      int add = 0;
      int len1 = digits.size();
      int len2 = b2.digits.size();
      BigNum ret = (*this);
      for( int i = 0; i < len1 && ( add != 0 || i < len2 ); ++ i ){
         int num1 = digits[i];
         int num2 = ( i < len2 ? b2.digits[i] : 0 ) + add;
         add = 0;
         
         while( num1 < num2 ) num1 += 10 , add ++;
         
         ret.digits[i] = num1 - num2;
         
      }
      while( ret.digits.back() == 0 )ret.digits.pop_back();
      return ret;
   }
}


inline void BigNum::WriteLn(){
   if( digits.size() == 0 )printf("0");
   for( int i = digits.size()-1; i >=0; --i )
      printf("%d",digits[i]);
   printf("\n");
}
inline void BigNum::Write(){
   if( digits.size() == 0 )printf("0");
   for( int i = digits.size()-1; i >=0; --i )
      printf("%d",digits[i]);
}


BigNum BigNum::sqrt(){
   BigNum lo(0),hi;
   BigNum mid , ret(0);
   hi.SetPower10(   (int)ceil(  (int)(digits.size()) / 2.00)   );
   while( lo < hi || lo==hi ){
      mid = lo+hi;
      mid = mid.DivBy2();

      if( (mid*mid) > (*this) )
         hi = mid - BigNum(1);
      else{
         ret = mid;
         lo = mid + BigNum(1);
      }
   }
   return ret;
}






bool IsMinus = false;
char txt[10000005];
char *pok;

int main(){
    scanf("%s",&txt);
    
    if( txt[0] == '-' ){
        pok = &txt[1];
        IsMinus = true;
    }else{
        pok = &txt[0];
    }
    
    
    if(   (pok[0] == '0' && strlen(pok)==1) || (IsMinus == true && pok[0] == '1' && strlen(pok)==1) ){
        printf("0\n");
        return 0;
    }
    
    
    BigNum N( pok,strlen(pok) );
    
    BigNum sol = (N * ( BigNum(1) + N )).DivBy2();
    if( IsMinus == true ){
        sol = sol - BigNum(1);
        printf("-");
    }
    
    sol.WriteLn();

    return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;

int K,N;
int SpozX[1000],EpozX[1000];
int SpozY[1000],EpozY[1000];

void RotX( int Ypoz,int pomak ){
   for(int i=0;i<K;i++)
      if( Ypoz == SpozY[i] )
         SpozX[i] = (SpozX[i]+pomak)%N;
}
void RotY( int Xpoz,int pomak ){
   for(int i=0;i<K;i++)
      if( Xpoz == SpozX[i] )
         SpozY[i] = (SpozY[i]+pomak)%N;
}

int main()
{
   int i,j;
   scanf("%d%d",&N,&K);
   int elem;
   for(i=0;i<K;i++){
      scanf("%d%d%d",&elem,&EpozY[i],&EpozX[i]);
      elem--;EpozY[i]--;EpozX[i]--;
      SpozY[i] = elem / N;
      SpozX[i] = elem % N;
   }
   for(i=0;i<K;i++){
      int XtoRot = EpozX[i]-SpozX[i];
      int YtoRot = EpozY[i]-SpozY[i];
      if( XtoRot < 0 ) XtoRot += N;
      if( YtoRot < 0 ) YtoRot += N;
      RotX( SpozY[i],XtoRot );
      RotY( SpozX[i],YtoRot );
      cout<<XtoRot+YtoRot<<endl;
   }
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <queue>
#include <stack>
#include <set>
#include <bitset>
#include <string>
#include <string.h>
#include <cstdlib>
#include <map>
#include <list>
#include <fstream>
using namespace std;

#define f first
#define s second
#define mk make_pair

#define ok(x,y) (x>=0&&y>=0&&x<W&&y<H)


int H,W;
char fld[505][505];
int d[505][505];

int dirs[4][2] = { 0,1, 0,-1, 1,0, -1,0 };


int nwid = 0;
int visited[505][505];
pair<int,int>start,end;

bool dfs( int x, int y , int dist ){

   if( d[y][x] < dist ) return false;


   
   if( x == end.f && y == end.s ) return true;

   
   visited[y][x] = nwid;
   for( int i = 0 ; i < 4; ++i ){
       int xn = x + dirs[i][0];
       int yn = y + dirs[i][1];
       


       if( ok(xn,yn) && visited[yn][xn] != nwid  ){
           if(  dfs(xn,yn,dist)  ) 
               return true;
       }
       
   }
   return false;

}


int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d%d",&H,&W);
    
    memset(d,-1,sizeof(d));
    queue< pair<int,int> >Q;
    
    for( int i = 0; i < H; ++i ){
        fscanf(in,"%s",fld[i]);
         for( int j = 0; j < strlen(fld[i]); ++j ){
             if( fld[i][j] == '+' ){
                Q.push( make_pair(j,i) );
                d[i][j] = 0;
             }else if( fld[i][j] == 'V' )
                start = make_pair(j,i);
              else if( fld[i][j] == 'J' )
                end =   make_pair(j,i);
         }
    }
    
    
    
    while( !Q.empty() ){
       pair<int,int> u = Q.front(); Q.pop();
       
       for( int i = 0; i < 4; ++i ){
           int xn = u.f + dirs[i][0];
           int yn = u.s + dirs[i][1];
           
           if( ok(xn,yn) && d[yn][xn] == -1){
               d[yn][xn]  = d[u.s][u.f] + 1;
               Q.push( mk(xn,yn) );
           } 
           
       }
    }
    
    
    int sol  = 0;
    int lo = 0 , hi = 1000;
    while( lo <= hi ){
        
        nwid ++;
        int mid = (lo+hi)>>1;
        
        bool ok = dfs( start.f , start.s , mid );
        
        if( ok ){
            sol = mid;
            lo = mid+1;
        }else{
            hi = mid-1;
        }
    }
    
    printf("%d\n",sol);
    
//    system("Pause");

    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <string.h>
using namespace std;

int M;
int group[40][2];

struct G{
    int mask;
    int time;
    G(){}
    G( int p1, int p2 ):mask(p1),time(p2){};
};

const int INF = 99999999;
int cap;
int sss = INF;
vector< G > V;

int dp[70000];

int solve( int idx , int chosed ){

    if( dp[chosed] != -1 )return dp[chosed];
    
    if( chosed == (1<<M)-1 ){
        return dp[chosed] = 0;
    }
    if( idx == V.size() )
       return INF;
    
    int v1,v2;
    v1 = v2 = INF;
    if( !( chosed & V[idx].mask)  )
        v1 = solve( idx + 1 , chosed | V[idx].mask );
    v2 = solve( idx + 1  , chosed );
    
    return dp[chosed] = min(V[idx].time + v1,v2);
}

int main(){
    scanf("%d%d",&cap,&M);
    
    for( int i = 0; i < M; ++i )
        scanf("%d %d",&group[i][0],&group[i][1]);
    
    for( int i = 1; i < (1<<M); ++i ){ 
        
        int time = 0;
        int weight = 0;
        
        for( int j = 0; j < M && weight <= cap; ++j ){
            if( i & (1<<j) ){
                time = time < group[j][0] ? group[j][0] : time;
                weight += group[j][1]; 
            }
        }
        if( weight > cap )continue;
        
        V.push_back(  G( i, time )   );
             
    }
    memset( dp , -1,sizeof(dp));
    sss = solve( 0 , 0 );
    
    printf("%d\n",sss);
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <iomanip>
#include <cstdlib>
#include <cstdio>
using namespace std;

struct coord{
    int x,y;
    coord( int p1, int p2 ):x(p1),y(p2){};
    coord(){};
};

const double PI = acos(0)*2;

double get_rad( int x, int y ){
    if( x >= 0 && y >= 0 )
       return atan2(y,x);
    else if( x < 0 && y >= 0 )
       return (PI - atan2(y,-x) );
    else if( x < 0 && y < 0 )
       return PI + atan2(-y,-x);
    else
       return 2*PI - atan2(-y,x);
}

struct event{
    double R;
    int key;
    bool type;
    event(){};
    event( double p1,  int p2, bool p3 ):R(p1),key(p2),type(p3){};
    
    bool operator < ( const event &e2 ) const {
         return ( R < e2.R || ( R == e2.R && type > e2.type )  );
    }
};

int n;
coord null;
vector<  event  >evs;

bool InSet[200005];

int main(){
    
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    coord tmp;
    
    fscanf(in,"%d",&n);
    fscanf(in,"%d%d",&tmp.x,&tmp.y);
    
    null = tmp;
    
    for( int i = 0; i < n; ++i ){
        fscanf(in,"%d%d",&tmp.x,&tmp.y);
        tmp.x -= null.x , tmp.y -= null.y;
        double v1 = get_rad(tmp.x,tmp.y);
        
        fscanf(in,"%d%d",&tmp.x,&tmp.y);
        tmp.x -= null.x , tmp.y -= null.y;
        double v2 = get_rad(tmp.x,tmp.y);
        
        double z1 = v1 , z2 = v2;
        
        v1 = min(z1,z2);
        v2 = max(z1,z2);
        
        if( v2-v1 <= PI ){
            evs.push_back(  event(v1,i,true)  );
            evs.push_back(  event(v2,i,false) );
        }else{
            evs.push_back(  event(v2,i,true)  );
            evs.push_back(  event(v1,i,false) );
        }
    }
    sort( evs.begin() , evs.end() );
    
    int cnt = 0;
    int XXsol = -1 , MMsol = 999999999;
    for( int i = 0; i < 4*n; ++i ){
        int now  = i % (2*n);
        int prev = i == 0 ? 2*n-1 : (i-1)%(2*n);
        
        if( i >= 2*n && evs[now].R != evs[prev].R )
            MMsol = min( MMsol , cnt );
        
        if( evs[now].type == true ){
            InSet[ evs[now].key ] = true;
            cnt ++;
        }else{
            if( InSet[ evs[now].key ] == false )continue;
            
            InSet[ evs[now].key ] = false;
            cnt --;
        }
        
            if( evs[prev].R != evs[now].R )
                XXsol = max( XXsol , cnt );
                
        if( evs[now].type == true ){
            XXsol = max( XXsol , cnt );
        }
    }
    if( MMsol == 999999999 ) MMsol = 0;
    printf("%d %d\n",MMsol , XXsol);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <cstdlib>
#include <queue>
#include <string.h>
using namespace std;

#define f first
#define s second.first
#define t second.second 
#define mt(x,y,z) make_pair( x , make_pair(y,z) )
#define piii pair<int,pair<int,int> >

void make_lower( char *pok ){
    for( int i = 0; i < strlen(pok); ++i )
        if( pok[i] >='A' && pok[i] <= 'Z' )
            pok[i] = 'a' + (pok[i] - 'A');
}



int N,M;
char buff[400];
bool ch[400];
vector< int >idxs[400];
char ToTest[400][400];
char MEM[400][400];


const int START = 280 , END = 290;
const int INF = 9999999;
int dp[400][400];
bool visited[400];
int prev[400];
vector<int>G[400];

int flow(){
    memset( visited, 0 , sizeof(visited) );
    prev[START] = -1;
    
    piii u;
    priority_queue< piii > PQ;
    PQ.push( mt( INF , START , -1 )  );
    
    while( !PQ.empty() ){
        u = PQ.top();PQ.pop();
        
        if( visited[ u.s ] == true )continue;

        prev[ u.s ] = u.t;
        visited[ u.s ] = true;
        if( u.s == END ) break;
        
        
        for( int i = 0; i < G[u.s].size(); ++i ){
            if( dp[u.s][ G[u.s][i] ] > 0 ){
                int mc = min( u.f , dp[u.s][ G[u.s][i] ] );
                PQ.push( mt( mc , G[u.s][i] , u.s )  );
            }
        }
    }
    
    if( u.s != END || u.f == INF )
       return INF;
    
    int it = END;
    while( prev[it] != -1 ){
        dp[ prev[it] ][ it ] -= u.f;
        dp[ it ][ prev[it] ] += u.f;
        it = prev[it];
    }
    
    return u.f;
    
    
    
}

int max_flow(){
    int ss = 0;
    while(1){
        int v = flow();
        if( v == INF )
           break;
        else
           ss += v;
    }
    return ss;
}


int kk[255];

bool ok( char *txt ){
    int len = strlen(txt);
    memset(dp,0,sizeof(dp));
    memset(kk,0,sizeof(kk));
    
    for( int i = 150; i <= 250; ++i )
        dp[i][END] = 1;
    
    for( int i = 0; i < len; ++i )
        kk[ txt[i] ] ++;   
    

    for( int i = 0; i <= 255; ++i ){
        dp[START][i] = kk[i];
        if( kk[i] == 0 )continue;
        
        for( int j = 0; j < idxs[ i ].size(); ++j )
            dp[i][ idxs[i][j] ] = 1;
        
    }
    int F = max_flow();
    return F == len;
}

bool cmp( int idxa , int idxb ){
    return strcmp( ToTest[idxa] , ToTest[idxb] ) < 0;
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d",&N);
    
    for( int i = 0; i < N; ++i ){
         fscanf(in,"%s",buff);
         make_lower(buff);
         
         
         int len = strlen(buff);
         memset( ch , 0 , sizeof(ch) );
         
         for( int j = 0; j < len; ++j ){
            if( ch[ buff[j]  ] == true )continue;
            
            ch[ buff[j]  ] = true;
            idxs[ buff[j]  ].push_back( 150+i );
         }
    }
    
    
    for( int i = 150; i <= 250; ++i )
        G[i].push_back(END);
        
    for( int i = 0; i <= 255; ++i ){
        G[START].push_back(i);
        
        for( int j = 0; j < idxs[ i ].size(); ++j ){
            G[i].push_back( idxs[i][j] );
            G[ idxs[i][j] ].push_back( i );
        }
    }
       
    
    
    vector<int>oks;
    fscanf(in,"%d",&M);
    
    for( int i = 0; i < M; ++i ){
        fscanf(in,"%s",ToTest[i]);
        
        memcpy(MEM[i],ToTest[i],150);
        make_lower(ToTest[i]);
        if( ok(ToTest[i]) )
            oks.push_back(i);
    }
    
    sort( oks.begin()  , oks.end() , cmp );
    
    cout<<oks.size()<<endl;
    for( int i = 0; i < oks.size(); ++i )
        printf("%s\n",MEM[oks[i]] );
    //system("Pause");
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
#include <cstdio>
using namespace std;

#define piii pair<int, pair<int,int> >
#define mt(x,y,z) make_pair(x,make_pair(y,z))
#define f first
#define s second.first
#define t second.second

#define source 1050
#define sink   1051

int M,N;
const int inf = 1<<30;
const int add = 605;
vector<int>G[1100];

int deep[1100][1100];
int cap [1100][1100];
int dp  [1100][1100];
bool visited [1100];
int  prev    [1100];

int getPath( int MX ){
    memset( visited , false ,sizeof(visited) );
    memset( prev , -1 , sizeof(prev) );
    priority_queue< piii > PQ;
    piii u;
    
    PQ.push( mt( inf , source , -1 ) );
    
    while( !PQ.empty() ){
        u = PQ.top();
        PQ.pop();
        
        if( visited[ u.s ] )continue;
        
        visited[ u.s ] = true;
        prev[ u.s ] = u.t;
        
        if( u.s == sink )break;
        
        for( int i = 0; i < G[u.s].size(); ++i ){
            if( dp[u.s][ G[u.s][i] ] >= 1 && deep[u.s][ G[u.s][i] ] <= MX ){
                int min_cap = min( dp[u.s][ G[u.s][i] ] , u.f );
                PQ.push( mt( min_cap , G[u.s][i] , u.s )  );
            }
        }
        
    }

    if( u.s != sink || u.f != 1) return inf;
    
    
    int iter = sink;
    while( prev[iter] != -1 ){
       dp[ prev[iter] ][ iter ] --;
       dp[ iter ][ prev[iter] ] ++;
       iter = prev[iter];
    }
    
    return u.f;
}


int GetFlow( int maxx ){
   memcpy( dp , cap , sizeof dp );
   int ss = 0;
   
   while( 1 ){
      
      int f = getPath( maxx );
      if( f == inf )
         return ss;
      else
         ss += f;
   }
   return 0;
}


int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");

   //freopen("Ulaz.txt","r",stdin);
   //freopen("Izlaz.txt","w",stdout);
    
    int p1,p2,p3;
    fscanf(in,"%d%d",&M,&N);
    
    for( int i = 0; i <= 1000; ++i )
       for( int j = 0; j <= 1000; ++j )
           deep[i][j] = inf;
    
    for( int i = 1; i <= N; ++i ){
       G[i].push_back( i+add );
       G[i+add].push_back( i );
       
       deep[i][i+add] = 0;
       deep[i+add][i] = 0;
       
       cap [i][i+add] = 1;
       cap [i+add][i] = 0;
    }
    
    
    
    for( int i = 0; i < M; ++i ){
        fscanf(in,"%d%d%d",&p1,&p2,&p3);
        G[p2+add].push_back( p3 );
        G[p3].push_back(p2+add);
        
        G[p3+add].push_back( p2 );
        G[p2].push_back(p3+add);
        
        deep[p2+add][p3] = min( deep[p2+add][p3] ,p1 );
        deep[p3+add][p2] = min( deep[p3+add][p2] ,p1 );
        deep[p2][p3+add] = min( deep[p2][p3+add] ,p1 );
        deep[p3][p2+add] = min( deep[p3][p2+add] ,p1 );
        
        cap[p2+add][p3] = 1;
        cap[p3+add][p2] = 1;
        
        cap[p2][p3+add] = 0;
        cap[p3][p2+add] = 0;
    }
    
    fscanf(in,"%d",&p1);
    for( int i = 0; i < p1; ++i ){
        fscanf(in,"%d",&p2);
        
        G[source].push_back( p2 );
        G[p2].push_back( source );
        
        deep[source][p2] = 0;
        deep[p2][source] = 0;
        
        cap[p2][source]  = 0;
        cap[source][p2]  = 1;
    }
    
    fscanf(in,"%d",&p1);
    for( int i = 0; i < p1; ++i ){
        fscanf(in,"%d",&p2);
        
        G[p2+add].push_back( sink );
        G[sink].push_back( p2+add );
        
        deep[p2+add][sink] = 0;
        deep[sink][p2+add] = 0;
        
        cap[p2+add][sink] = 1;
        cap[sink][p2+add] = 0;
    }
    
    int mx  = 0;
    int sol = 0;
    int lo = 0 , hi = 80000;
    while( lo <= hi ){
        int mid = (lo+hi)>>1;
        
        
        int f = GetFlow( mid );
        mx = max( mx , f );
        
        if( f == mx )
           hi = mid - 1 , sol = mid;
        else
           lo = mid + 1;
        
    }

    
    printf("%d\n",sol);
  
 
    return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<iomanip>
using namespace std;

int main(){
   int a,T,i,j;

   scanf("%d",&a);
   int out = 0;
   do{
      a /= 5;
      out += a;
   }while( a != 0 );
   printf("%d\n",out);

   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <queue>
#include <stack>
#include <set>
#include <bitset>
#include <string>
#include <string.h>
#include <cstdlib>
#include <map>
#include <list>
#include <fstream>
using namespace std;

int arr[100];
bool CanMake[40000];

int main(){
    int N,K;
    scanf("%d%d",&N,&K);
    for( int i = 0; i < N; ++i )
        scanf("%d",&arr[i]);
    
    queue<int>Q;
    Q.push(0);
    while(!Q.empty()){
        int u = Q.front();Q.pop();
        
        
        for( int i = 0; i < N; ++i ){
            int ss = (u + arr[i])%360;
            
            if( CanMake[ss] == false ){
               CanMake[ss] = true;
               Q.push( ss );
            }
            
            ss = (u - arr[i]);
            if( ss < 0 )ss += 36000;
            ss %= 360;
            
            if( CanMake[ss] == false ){
               CanMake[ss] = true;
               Q.push( ss );
            }
        }
    }
    
    
    for( int i = 0; i < K; ++i ){
        scanf("%d",&N);
        N += 36000;
        N %= 360;
        if( CanMake[N] == true ){
            printf("YES\n");
        }else{
            printf("NO\n");
        }
    }
    
    return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;

char sven[100];
char TRIO[]={'S','K','P'};
char opponent[60][100];

int VS( char &S1 , char &S2 ){
   if( (S1=='S' && S2=='P') || (S1=='P' && S2=='K') || (S1=='K' && S2=='S') )return 2;
   else if( (S1=='S' && S2=='S') || (S1=='P' && S2=='P') || (S1=='K' && S2=='K') )return 1;
   else return 0;
}

int main()
{
   int R,n;
   int i,j,k;
   scanf("%d",&R);
   scanf("%s",sven);
   scanf("%d",&n);
   for(i=0;i<n;i++)scanf("%s",opponent[i]);
   int NORMAL=0,BEST=0;
   int MAXN,ADD;
   for(i=0;i<R;i++){
      for(j=0;j<n;j++)
         NORMAL+=VS( sven[i] , opponent[j][i] );
      MAXN = 0;
      for(j=0;j<3;j++){
         ADD=0;
         for(k=0;k<n;k++)
            ADD+=VS(TRIO[j],opponent[k][i]);
         if(ADD>MAXN)MAXN=ADD;
      }
      BEST+=MAXN;
   }
   cout<<NORMAL<<endl;
   cout<<BEST<<endl;
   return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <iomanip>
#include <string.h>
using namespace std;

int N,K;
int cnt[ 1 << 16 ];
long long dp[18][1 << 16 ];
int cow[20];

long long solve( int prev , int mask ){
    if( cnt[mask] == N )return 1;
    if ( dp[prev][mask] != -1 )return dp[prev][mask];
    
    long long ss = 0;
    
    for( int i = 0; i < N; ++i ){
        if( mask&(1<<i) )continue;
        if( abs(cow[prev]-cow[i]) <= K )continue;
        ss += solve( i , mask|(1<<i) );
    }
    
    return dp[prev][mask] = ss;
}


int main(){
    
    memset( dp, -1, sizeof(dp) );
    for( int i = 0; i < (1<<16); ++i )
        cnt[i] = __builtin_popcount(i);
    
    scanf("%d%d",&N,&K);
    
    for( int i = 0; i < N; ++i )
        scanf("%d",&cow[i]);
    
    cow[17] = 999999;
    cout<< solve( 17 , 0 ) <<endl;
    
    system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

#define P 1
#define N 2

int dp[1000][1000];
int mex[1000][1000];
int visi[1000];

int main(){

    for( int i = 1; i <= 1000; ++i )dp[0][i] = P;

    for( int i = 1; i <= 300; ++i ){
       for( int j = 0; j <= 600; ++j ){
           int G = min(j*2,i);
           if( j == 0 )G = i-1;


           int now = 0;
           memset(visi,0,sizeof(visi));

           for( int k = 1; k <= G; ++k ){
               if( i - k < 0 )continue;

               visi[ mex[i-k][k] ] = true;

               while( visi[now] ) now ++;

           }

           mex[i][j] = now;
       }
    }
    int tests;
    scanf("%d",&tests);
    for( ; tests; tests-- ){
       int n,v;
       scanf("%d",&n);
       int xorr = 0;
       for( int i = 0; i < n; ++i ){
           scanf("%d",&v);
           xorr ^= mex[v][0];
       }
       if(xorr)printf("1\n");
       else printf("0\n");
    }

    system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <queue>
#include <stack>
#include <set>
#include <bitset>
#include <string>
#include <string.h>
#include <cstdlib>
#include <map>
#include <list>
#include <fstream>
using namespace std;

#define ok(x,y) (fld[y][x]=='.'&&x>=0&&y>=0&&y<H&&x<W)

#define x first
#define y second
#define mk make_pair



int H,W;
char fld[30][30];

struct duh{
    int x,y;
    int p1, p2, p3, p4;
    int now;
    duh(){};
    duh( int a, int b, int c, int d, int e, int f ){
        x = a;
        y = b;
        p1 = c;
        p2 = d;
        p3 = e;
        p4 = f;
        now = -1;
    }
};

vector< duh > V;

pair<int,int> GetMove( int id ){
   if( id == 1 )
      return mk(0,-1);
   if( id == 2 )
      return mk(1,0);
   if( id == 3 )
      return mk(0,1);
   if( id == 4 )
      return mk(-1,0);
   return mk(0,0);
}
int inversion( int id ){
    if( id == 1 )return 3;
    if( id == 2 )return 4;
    if( id == 3 )return 1;
    if( id == 4 )return 2;
    return -1;
}

void DuhoviMove(){

    for( int i = 0; i < V.size(); ++i ){
        
        bool MadeMove = false;
        int inv = inversion( V[i].now );
        
        if( MadeMove == false ){
            for( int j = -1; j < 5 && MadeMove == false; ++j ){
                int nw;
                if( j == -1)nw = V[i].now;
                if( j == 0 )nw = V[i].p1;
                if( j == 1 )nw = V[i].p2;
                if( j == 2 )nw = V[i].p3;
                if( j == 3 )nw = V[i].p4;
                if( j == 4 )nw = inv;

                
                if( j < 4 && nw == inv ) continue;
               // cout<<"MOVE: "<<nw<<" , "<<j<<endl;
                
                if( nw != -1 ){
                    pair<int,int>M = GetMove( nw );
                    int xN = V[i].x + M.x;
                    int yN = V[i].y + M.y;
                    if( ok(xN,yN) ){
                       V[i].x = xN;
                       V[i].y = yN;
                       V[i].now = nw;
                       MadeMove = true;
                    }
                }
                
            }
        }
    }
} 

bool ok2( int x, int y ){
   for( int i = 0; i < V.size(); ++i )
      if( V[i].x == x && V[i].y == y )return false;
   return true;
}

pair<int,int>S,E;


struct move{
    int x,y;
    int d;
    move(){};
    move(int p1, int p2, int p3):x(p1),y(p2),d(p3){};
};


int main(){
    FILE *in = fopen("pacman.in","r");
    
    int a,b,c,d;
    int c1,r1,c2,r2,D;
    fscanf(in,"%d%d",&H,&W);

    for( int i = 0; i < H; ++i )
        fscanf(in,"%s",fld[i]);
    
    fscanf(in,"%d%d%d%d",&r1,&c1,&r2,&c2);
    S = mk( c1-1,r1-1 );
    E = mk( c2-1,r2-1 );
    
    fscanf(in,"%d",&D);
    for( int i = 0; i < D; ++i ){
        fscanf(in,"%d%d%d%d%d%d",&r1,&c1,&a,&b,&c,&d);
        V.push_back( duh( c1-1,r1-1,a,b,c,d )   );
    }
    
    queue< move >Q,Q2;
    move u;
    
    Q.push( move( S.x , S.y , -1)  );
    
    int Win = -1;
    
    for( int i = 0; i < 500; ++i ){
        DuhoviMove();
        while( !Q2.empty() )Q2.pop();
        
        while( !Q.empty() ){
            u = Q.front(); Q.pop();
            
            if( u.x == E.x && u.y == E.y ){
                Win = i;
                break;
            }
            
            if( ok2(u.x,u.y) == false)continue;
            if( ok (u.x,u.y) == false)continue;
            
            
            
            int inv = inversion( u.d );
            bool IsGhost = false;
            
            for( int i  = 1; i <= 4; ++i ){
                if( i == inv )continue;
                pair<int,int>z = GetMove(i);
                int xN = z.x + u.x;
                int yN = z.y + u.y;
                if( ok (xN,yN) == false )continue;
                if( ok2(xN,yN) == false )continue;
                Q2.push( move(xN,yN,i) );
            }
            
        }
        Q = Q2;
        
        if( Win != -1 ) break;
        
        
    }
    FILE *out = fopen("pacman.out","w");
    fprintf(out,"%d\n",Win);

    return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<iomanip>
#include<math.h>
using namespace std;

int N;
vector<int>facs;

int main(){
    scanf("%d",&N);
    
    int tmp = N;
    int div = 2;
    while ( div*div <= tmp ) {
       if( N % div == 0 ){
          facs.push_back(div);
          N /= div;
       }else
          div++;
    }
    if( N > 1 )facs.push_back(N);
    sort( facs.rbegin() , facs.rend() );
    int sol = 1;
    for( int i = 0; i < (int)facs.size() - 1; ++i )
       sol *= facs[i];

    if( facs.size() >= 1 )
       printf("%d\n",tmp-sol);
    else
       printf("0\n");

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <queue>
#include <stack>
#include <set>
#include <bitset>
#include <string>
#include <string.h>
#include <cstdlib>
#include <map>
#include <list>
#include <fstream>
using namespace std;

#define x first
#define y second

int H,W;
char fld[300][300];
vector< pair<int,int> >chk;

bool visi[300][300];

int Z , P;
void flood( int x, int y ){
   if( visi[y][x] == true || x < 0 || x >= W || y < 0 || y >= H )return;
   visi[y][x] = true;
   
   if( fld[y][x] == '#' )
      return;
   
   if( fld[y][x] == 'p' )
      P++;
   if( fld[y][x] == 'z' )
      Z++;
   
   flood(x-1,y);
   flood(x,y-1);
   flood(x+1,y);
   flood(x,y+1);
}


int main(){
    FILE *in = fopen("pilici.in","r");
    fscanf(in,"%d%d",&H,&W);
    
    for( int i = 0; i < H; ++i ){
        fscanf(in,"%s",fld[i]);
        for( int j = 0; j < strlen(fld[i]); ++j ){
            if( fld[i][j] == 'p' || fld[i][j] == 'z' )
               chk.push_back( make_pair(j,i) );
        }
    }
    
    int uZ , uP;
    uZ = uP = 0;
    for( int i = 0; i < chk.size(); ++i ){
        if( visi[ chk[i].y ][ chk[i].x ] )continue;
        
        Z = 0 , P = 0;
        flood( chk[i].x  ,chk[i].y );
        
        if( P > Z )
           uP += P;
        else
           uZ += Z;
        
    }
    
    FILE *out = fopen("pilici.out","w");
    fprintf(out,"%d %d\n",uP,uZ);
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <queue>
#include <stack>
#include <set>
#include <bitset>
#include <string>
#include <string.h>
#include <cstdlib>
#include <map>
#include <list>
#include <fstream>
using namespace std;

int H,W,n;
unsigned long long dp[105][105];
bool block[105][105];

bool nb2( int x1, int y1  ){
   return ( block[y1][x1] == false && 
            block[y1][x1+1] == false &&
            block[y1+1][x1+1] == false &&
            block[y1+2][x1+1] == false &&
            block[y1+3][x1+1] == false );
}

bool nb1( int x1, int y1  ){
   return ( block[y1][x1] == false && 
            block[y1][x1+1] == false &&
            block[y1][x1+2] == false &&
            block[y1][x1+3] == false  );
}


int main(){
    int r,c;
    FILE *in = fopen("Ulaz.txt","r");
    fscanf(in,"%d%d%d",&H,&W,&n);
    
    for( int i = 0; i < n; ++i ){
       fscanf(in,"%d%d",&r,&c);
       block[r][c] = true;
    }
    
    
    dp[1][1] = true;
    
    
    for( int i = 1; i <= H; ++i ){
        for( int j = 1; j <= W; ++j ){
           
           if( block[i][j] )continue;  
             
           dp[i][j] += dp[i-1][j];
           dp[i][j] += dp[i][j-1];
           if( i-3 >= 1 && nb2(j-1,i-3)  )dp[i][j] += dp[i-3][j-1];
           if( j-3 >= 1 && nb1(j-3,i  )  )dp[i][j] += dp[i][j-3];
        }
    }
    
    
    ofstream out("pipo.out");
    out<<dp[H][W]<<endl;
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <queue>
#include <stack>
#include <set>
#include <bitset>
#include <string>
#include <string.h>
#include <cstdlib>
#include <map>
#include <list>
#include <fstream>
using namespace std;

int N,M;
int arr[ 30 ];
int exch[100][2];
int mx[105][105];
vector<int>moves;

int MaxLvl;

bool IsSolution( int *pok ){
    for( int i = 0; i < N; ++i )
       if( pok[i] != i )
           return false;
    return true;
}

bool dfsid( int deep ){

    int ss = 0;
    int ostalo = MaxLvl - deep + 1;
    
    for( int i = 0; i < N; ++i ){
       ss += mx[ arr[i] ][ i ];
    }
    ss = (int)ceil(ss/2.0);
    
    if( ss == 0 )return true;
    if( ss > ostalo )return false;
    
      
    
    for( int i = 0; i < M; ++i ){
        
        swap( arr[  exch[i][0]  ]  ,  arr[   exch[i][1]   ]   );
        
        if( dfsid( deep + 1 )   ){
            moves.push_back( i );
            return true;
        }
        
        swap( arr[  exch[i][0]  ]  ,  arr[   exch[i][1]   ]   );
    }
    return false;
}


void povezi(){
   for( int k = 0; k < N; ++k )
       for( int i = 0; i < N; ++i )
           for( int j = 0; j < N; ++j )
                 mx[i][j] = min( mx[i][j] , mx[i][k] + mx[k][j] );
}


int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d%d",&N,&M);
    
    for( int i = 0; i < N; ++i ){
        fscanf(in,"%d",&arr[i]);
        arr[i]--;
        for( int j = 0; j < N; ++j )
            mx[i][j] = 999999;
        mx[i][i] = 0;
    }
    
    for( int i = 0; i < M; ++i ){
        fscanf(in,"%d%d",&exch[i][0],&exch[i][1]);
        exch[i][0] --;
        exch[i][1] --;
        mx[ exch[i][0] ][ exch[i][1] ] = 1;
        mx[ exch[i][1] ][ exch[i][0] ] = 1;
    }
    povezi();
    
    
    
    for( int i = 0; i < 13; ++i ){
        MaxLvl = i;
        if( dfsid( 0 )  )
           break;
    }
    reverse( moves.begin() , moves.end());
    
    printf("%d\n",moves.size());
    for( int i = 0; i < moves.size(); ++i )
        printf("%d\n",moves[i]+1);
    

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <queue>
#include <stack>
#include <set>
#include <bitset>
#include <string>
#include <string.h>
#include <cstdlib>
#include <map>
#include <list>
#include <fstream>
using namespace std;

string str;
string J[] = { "" , "I" , "II", "III" , "IV" , "V" , "VI" , "VII" , "VIII" , "IX" };
string D[] = { "" , "X" , "XX" , "XXX" , "XL" , "L" , "LX" , "LXX" , "LXXX" , "XC" };


char znak[] = {'I','V','X','L','C' };

int have[255];
int need[255];

bool ok(){
    for( int i = 0; i < 5; ++i )
       if( have[ znak[i] ] != need[ znak[i] ] ){
            memset( have, 0 , sizeof(have) );
            return false;
       }
    return true;
}

int main(){
    cin >> str;
    
    for( int i = 0; i < str.size(); ++i )
        need[ str[i] ] ++;
    
    
    for( int i  = 0; i < 10; ++i ){
        for( int j = 0; j < 10; ++j ){
            for( int k = 0; k < D[i].size(); ++k )
               have[ D[i][k] ]++;
            for( int k = 0; k < J[j].size(); ++k )
               have[ J[j][k] ]++;
            
            if( ok() ){
                cout<<D[i]<<J[j]<<endl;
                return 0;
            }
            
            
        }
    }
    system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <iomanip>
#include <algorithm>
#include <cstdlib>
using namespace std;

int N;
int arr[100][3];

int dp[200][150][3];

int solve( int cnt , int prev , int sub ,  int h, int w ){
    
    if( dp[cnt][prev][sub] != -1 ) return dp[cnt][prev][sub];
    
    int ss = 0;
    
    for( int i = 0; i < N; ++i ){
        if( ( h > arr[i][0] && w > arr[i][1] ) ||  ( w > arr[i][0] && h > arr[i][1] )  )         
            ss = max( solve( cnt + 1, i , 0 , arr[i][0] , arr[i][1] ) + arr[i][2] , ss );
            
        if( ( h > arr[i][1] && w > arr[i][2] ) ||  ( w > arr[i][1] && h > arr[i][2] )  )         
            ss = max( solve( cnt + 1, i , 1 , arr[i][1] , arr[i][2] ) + arr[i][0] , ss );
            
        if( ( h > arr[i][0] && w > arr[i][2] ) ||  ( w > arr[i][0] && h > arr[i][2] )  )         
            ss = max( solve( cnt + 1, i , 2 , arr[i][0] , arr[i][2] ) + arr[i][1] , ss );
    }

    return dp[cnt][prev][sub] = ss;
    
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    while(  fscanf(in,"%d",&N) ){
        
        if( N == 0 )break;
                
        for( int i = 0; i  < N; ++i )
            fscanf(in,"%d%d%d",&arr[i][0],&arr[i][1],&arr[i][2]);
        
        memset( dp , -1 , sizeof(dp) );
        
        printf( "%d\n",  solve( 0 , 0 , 0 , 999999 , 999999 )   );

    }
    
    return 0;
}

#include<iostream>
#include<cstdlib>
using namespace std;

int main(){
    int n,p;
    int tests;
    scanf("%d",&tests);
    
    for( ; tests ; -- tests ){
        scanf("%d%d",&n,&p);
        if( p )
           printf("Pagfloyd wins.\n");
        else if( !p )
           printf("Airborne wins.\n");
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <stack>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <string.h>
#include <assert.h>
using namespace std;

int used[50000];
int sol[50000];
int idx[50000];

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    int tests,n;
    scanf("%d",&tests);
    
    for( ; tests ; --tests ){
        memset( sol , 0 , sizeof(sol));
        scanf("%d",&n);
        
        
        int N = n;
        int counter = 1;
        int add = 2;
        int prev = 0;
        
        for( int i = 0; i < N; ++i )
            idx[i] = i;
        
        while(N){
            int i;
            for( i = add - prev-1 ; i < N; i+=add ){
                sol[ idx[i] ] = counter++;
                add ++;
            }
            i -= add;
            prev = N - i - 1;
            
            int cc = 0;
            for( int i = 0; i < N; ++i ){
                if( sol[ idx[i] ] == 0 ){
                    idx[cc] = idx[i];
                    cc++;
                }
            }
            N = cc;
        }
        for( int i = 0; i < n; ++i )
                printf("%d ",sol[i]);putchar('\n');
        
        
    }
    
  
    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<math.h>
using namespace std;

char game[3][3];

int issolved(){
   int i,j;
   int arr[15];
   memset(arr,0,sizeof(arr));
   for(i=0;i<3;i++)if( game[i][0] == game[i][1] && game[i][1] == game[i][2] && game[i][2]!='.' ) arr[i+1] =(game[i][2]=='X')+1;
   for(i=0;i<3;i++)if( game[0][i] == game[1][i] && game[1][i] == game[2][i] && game[2][i]!='.' ) arr[i+4] =(game[2][i]=='X')+1;
   int Wins = 5;
   for(i=1;i<=3;i++){
      if( Wins==5 && arr[i]!=0 )Wins = arr[i];
      if( Wins==5 && arr[3+i]!=0 )Wins=arr[3+i];
      for(j=1;j<=3;j++)
         if( i!=j &&  arr[i] && arr[j] )return -1;
         else if( i!=j && arr[3+i] && arr[3+j] )return -1;
   }
   if( Wins ==5 && game[0][0] == game[1][1] && game[1][1] == game[2][2] && game[2][2] != '.' )Wins = (game[2][2]=='X')+1;
   if( Wins ==5 && game[2][0] == game[1][1] && game[1][1] == game[0][2] && game[0][2] != '.' )Wins = (game[0][2]=='X')+1;
   return Wins;
   
}

char buff[10];

int main(){

   int n,i,j;
   bool solvable;
   char c,p;
   int count = 0;
   while( scanf("%s",buff) == 1  ){
      if( strcmp(buff,"end") == 0 )break;
      p=0;
      int O(0),X(0);
      for( int i = 0; i < 9; ++i ){
        c = buff[i];

           game[0][i]= c;
           if( c=='O')O++;
           if( c=='X')X++;
           
      }
      if( X-O == 0 || X-O == 1 ){
         int v = issolved();
         bool IsDot = false;
         for( int i = 0; i < 3; ++i )
            for( int j = 0; j < 3; ++j )
               if( game[i][j] == '.' )
                  IsDot = true;
                  

         if( v == 5 && IsDot == true )printf("invalid\n");
         else if( v==5 )printf("valid\n");
         else if( v==1 && X-O==0 )printf("valid\n");
         else if( v==2 && X-O==1 )printf("valid\n");
         else printf("invalid\n");
      }else
         printf("invalid\n");
      
   }
   return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <set>
#include <stack>
#include <queue>
using namespace std;

typedef unsigned long long ll;

ll N;

int main(){
    
    int tests;
    scanf("%d",&tests);
    for( ; tests ; --tests ){
       cin >> N;
       
       if( N == 0 ){
           printf("0\n");
           continue;
       }
       
       ll sol = 0;
       ll h = (N-1) / 3;
       sol  = 3*h*(h+1)/2;
       sol += ((N-1)%3) * (h+1);
       
       printf("%lld\n",sol);
       
       
    }
    
    return 0;
}

#include <iostream>
#include <cstdio>
using namespace std;

int main(){
    int a,b;
    scanf("%d%d",&a,&b);
    printf("%d\n",a+b);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int arr[100005];
int prv[100006];

int main(){
    int M,N;
    while( scanf("%d%d",&M,&N) == 2 ){
        if( M == 0 && N == 0 )break;
        
        for( int i = 0; i < N; ++i )
            scanf("%d",&arr[i]);
        
        memset( prv, -1, sizeof(prv) );
        prv[0] = 0;
        int i,ss = 0;
        for( i = 0; i < N; ++i ){
            ss = (ss+arr[i])%M;
            
            if( prv[ ss ] >= 0 )break;
            prv[ss] = i;
        }
        
        if( ss == 0 )prv[ss] -- ;
        
        for( int j = prv[ss]+1; j <= i; ++j )
           printf("%d ",j+1);putchar('\n');
    }
   // system("Pause");
    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<algorithm>
#include<math.h>
using namespace std;

int To( string s ){
    reverse( s.begin() , s.end() );
    
    int ret = 0;
    int f;
    for( int i = 0; i < s.size(); ++i ){
        if( s[i] == 'i' ) f = 1;
        else if( s[i] == 'x' ) f = 10;
        else if( s[i] == 'c' ) f = 100;
        else if( s[i] == 'm' ) f = 1000;
        else continue;
        
        int z = 1;
        if( i+1 < s.size() && s[i+1] >= '1' && s[i+1] <= '9' ) z = s[i+1] - '0';
        
        ret += z * f;
    }
    return ret;
}

string To2( int v ){
    int f = 1;
    string s = "";
    char c = 'i';
    while( v ){
        int y = v % 10;
        v /= 10;
        
        if( y > 0 ){
        
            if( y == 1 )
                s += string(1,c);
            else
                s += string(1,c) + string(1,y+'0');
        }
        
        
        if( c == 'i' ) c = 'x';
        else if( c == 'x' ) c = 'c';
        else if( c == 'c' ) c = 'm';
    }
    reverse( s.begin() , s.end() );
    return s;
}

int main(){
    string s1 , s2;
    int tests;
    scanf("%d",&tests);
    
    for( ; tests ; --tests ){
       cin >> s1 >> s2;
       int v = To(s1) + To(s2);
       cout<<To2(v)<<endl;
    }
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int n,m,x;
int arr[1000];

long long solve( int x ){
    long long r = 0;
    for( int i = n; i >= 0; --i )
        r = r * x + arr[i];
    return r;
}

int main(){
    
    int T = 1;
    
    while( scanf("%d",&n ) == 1 ){
        if( n == -1 )break;
        
        for( int i = n; i >= 0; --i )
            scanf("%d",&arr[i]);
        
        scanf("%d",&m);
        printf("Case %d:\n",T);
        
        for( int i = 0; i < m; ++i ){
            scanf("%d",&x);
            printf("%lld\n",solve(x) );
        }
        
        T++;
    }
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <math.h>
using namespace std;


int main(){

    vector<int>v;
    vector<int>n;
    vector<int>ps;
    
    for( int i = 35000; i >= 2; --i )
        v.push_back(i);
    
    while( v.empty() == false ){
        
        int sz = v.size()-1;
        ps.push_back( v[sz] );


        if( v[sz] <= sz){

            n.clear();
            for( int j = 0; j < v.size(); ++j ){
                int k = (int)v.size()-j-1;

                if( k%v[sz] > 0 )
                    n.push_back( v[j] );
            }

            v = n;
        }else{
            v.pop_back();
        }
   
    }

    
    int z;
    while( scanf("%d",&z) == 1 ){
        if( z == 0 )break;
        printf("%d\n",ps[z-1]);
    }
    
  
    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <math.h>
#include <queue>
#include <set>
#include <stack>
using namespace std;

typedef long long ll;

int N;
int niz[100006];
int L[100006];
int R[100006];

int main(){
    while(  scanf("%d",&N) == 1 ){
       if( N == 0 )break;
       
       for( int i = 0; i < N; ++i )
          scanf("%d",&niz[i]);
       
       stack< int > S;
       
  
       
       for( int i = 0; i < N; ++i ){
           while( S.empty() == false && niz[ S.top() ] >= niz[i] )S.pop();
           if( S.empty() == true )
               L[ i ] = -1;
           else
               L[ i ] = S.top();
           
           S.push(i);
       }
       
       while( S.empty() == false )S.pop();
       
       for( int i = N-1; i >= 0; --i ){
           while( S.empty() == false && niz[ S.top() ] >= niz[i] )S.pop();
           
           if( S.empty() == true )
               R[ i ] = N;
           else
               R[ i ] = S.top();
           
           S.push(i);
       }
       
       ll sol = 0;
       for( int i = 0; i < N; ++i ){
           sol = max( sol , niz[i] * (ll)( R[i] - L[i] -1 )  );
       }
       printf("%lld\n",sol);
       
       
    }    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <cstdlib>
using namespace std;

struct flasa{
    int o,n,w;
    flasa( int p1, int p2, int p3 ):o(p1),n(p2),w(p3){};
    flasa(){};
};       

int N;
int nO,nN;     
vector< flasa >V;

int dp[2][100][100];


int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    int tests,p1,p2,p3;
    fscanf(in,"%d",&tests);
    
    for( ; tests; --tests ){
        fscanf(in,"%d%d%d",&nO,&nN,&N);
        
        V.clear();
        for( int i = 0; i < N; ++i ){
            fscanf(in,"%d%d%d",&p1,&p2,&p3);
            V.push_back( flasa( p1, p2, p3 ) );
        }
        
        for( int i = 0; i < 100; ++i )
            for( int j = 0; j < 100; ++j )
                dp[0][i][j] = dp[1][i][j] = 9999999;
       
        dp[0][0][0] = dp[1][0][0] = 0;
        bool mode = true;
        int sol = 999999;
        
        for( int i = 0; i < N; ++i ){
           
            for( int j = 0; j < 100; ++j )
                for( int k = 0; k < 80; ++k ){
                     
                     dp[mode][j][k] = dp[!mode][j][k];
                     if( j-V[i].o >= 0 && k-V[i].n >= 0 )
                       dp[mode][j][k] = min( dp[mode][j][k] , dp[!mode][j-V[i].o][k-V[i].n] + V[i].w );
                     
                     if( j >= nO && k >= nN )
                         sol = min( sol , dp[mode][j][k] );
                }
           
            mode = !mode;
        }
        
        printf("%d\n",sol);
        
    }
    

    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <math.h>
#include <queue>
using namespace std;

int N,M,v;
const double PI = acos(0) * 2;
double arr[100006];

bool ok ( double m ){
   int cnt = 0;
   for( int i = 0; i < N; ++i ){
        cnt += (int)floor( arr[i] / m );
        if( cnt >= M ) return true; 
   }
   return false;
}

int main(){
    int tests;
    scanf("%d",&tests);
    
    for( ; tests; --tests ){
        
        scanf("%d%d",&N,&M);
        M++;
        
        for( int i = 0; i < N; ++i ){
             scanf("%d",&v);
             arr[i] =  v*v*PI;
        }
        
        double lo = 0 , hi  = 10000*10000*PI;
        double mid;
        
        while( hi-lo > 0.0001 ){
            mid = (hi+lo) / 2.0;
   
            bool b = ok(mid);
            
            
            if( ok(mid) )
               lo = mid + 0.0001;
            else
               hi = mid - 0.0001;
        }
        
        
        printf("%.4lf\n",lo);
    }
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
using namespace std;

typedef long long ll;

int N,K;
int arr[506];



bool ok( ll sz ){
    int cnt = 0;
    for( int i = 0; i < N; ++i ){
    
        ll ss = 0;
        while( ss+arr[i] <= sz && i < N )ss += arr[i++];
        if( ss == 0 )return 0;
        --i;
        cnt ++;
    }
    return ( cnt <= K );
}

bool prekid[700];

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    int tests;
    fscanf(in,"%d",&tests);
    
    for( ; tests; --tests ){
        fscanf(in,"%d%d",&N,&K);
        
        for( int i = 0; i < N; ++i )
            fscanf(in,"%d",&arr[i] );
        
        ll sol = 99999999;
        ll lo  = 0 , hi = 500*10000000ll;
        
        while( lo <= hi ){
            
            ll mid = ( lo + hi ) / 2;
            
 
            bool f = ok( mid );

            if( f )
                sol = mid , hi = mid - 1;
            else
                lo = mid + 1;
        }

        int cnt = 0;
        memset( prekid , 0 , sizeof(prekid) );
        
        for( int i = N-1; i >= 0; --i ){
    
           ll ss = 0;
           while( ss+arr[i] <= sol && i >= 0 )ss += arr[i--];
           
           if( i >= 0 )
           prekid[i] = true;
           ++i;

           cnt ++;
       }
  
       
       int diff = K - cnt;
       for( int i = 0; i < N && diff; ++i )
       if( prekid[i] == false )
              prekid[i] = true , diff --;
       
       for( int i = 0; i < N; ++i ){
           printf("%d ",arr[i] );
           if( prekid[i] && i != N-1 )
               printf("/ ");
       }
       printf("\n");
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
using namespace std;

char buff[10005];

int main(){
    int tests;
    scanf("%d",&tests);
    
    for( ; tests ; --tests ){
        scanf("%s",buff);
        int len = strlen(buff);
        
        int sol = 0;
        for( int i = 1; i < len; ++i ){
            
            bool IsLower = false;
            for( int j = 0; j < len; ++j ){
                int idxA = sol+j;
                int idxB = i+j;
                
                if( idxA >= len ) idxA -= len;
                if( idxB >= len ) idxB -= len;
                
                if( buff[idxB] < buff[idxA] ){
                    IsLower = true;
                    break;
                }else if( buff[idxB] > buff[idxA] )
                    break;
            }
            
            if( IsLower )
               sol = i;
        }
        printf("%d\n",sol+1);
    }
    
  
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <vector>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
using namespace std;

char c;
typedef long long ll;

inline void read_ll( ll &v ){
    int z = 1;
    while( c = getchar() ){
        if( c == '-' )z = -1;
        if( c >= '0' && c <= '9' )break;
    }
    v = c - '0';
    while( c = getchar() ){
        if( c < '0' || c > '9' )break;
        v = v*10 + (c-'0');
    }
    v *= z;
}

int main(){
    int n;
    
    while( scanf("%d",&n) == 1 ){
        if( n == 0 )
            break;
        
        ll sol = 0;
        ll now = 0;
        ll nxt = 0;
        
        for( int i = 0; i < n; ++i ){
             read_ll(now);
             now += nxt;
             sol += abs( now );
             nxt = now;
        }
        printf("%lld\n",sol);
    }
    
    return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<cstdio>
#include<cstdlib>
using namespace std;

const int MAXC = 1000001;
char sols[1000006];

int main(){

   int cnt = 1;
   int x = 1;
   int range = 1;
   for( int i = 1; i <= MAXC; ++i ){
       
       sols[cnt] = 'A' + (range - 1)%26;

       cnt ++;
       if( x == range ){
          x = 0;
          range ++;
       }
       x++;
   }
   
   while( scanf("%d",&x) == 1 ){
       printf("TERM %d IS %c\n",x,sols[x] );       
   }
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <set>
#include <queue>
#include <stack>
using namespace std;

typedef long long ll;
ll dp[1000005];

int main(){
    
    dp[1] = 1;
    for( int i = 2; i <= 1000000; ++i )
        dp[i] = i - 1;
        
    for( int i = 2; i <= 1000000; ++i )
        for( int j = i*2; j <= 1000000; j+=i )
            dp[j] -= dp[i];
    
    for( int i = 2; i <= 1000000; ++i ) 
        dp[i] += dp[i-1];
    
    int tests,n;
    scanf("%d",&tests);
    
    for( ; tests ; --tests ){
         scanf("%d",&n);
         printf("%lld\n",dp[n] - 1 );
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

char buff[10000];

int main(){
    int T = 1;
    while( scanf("%s",buff)  ){
        if( buff[0] == '-' )break;
        
        int chg = 0;
        int open = 0;
        
        for( int i = 0; i < strlen(buff); ++i ){
            if( buff[i] == '{' )
                open++;
            else{
                if( open > 0 )open--;
                else open ++ , chg ++;
            }
        }
        printf("%d. %d\n",T,chg + open/2 );
        T++;
        
    }
    return 0;
}

#include <iostream>
#include <cstdio>
using namespace std;

int h,w;
typedef long long ll;

int main(){
    while( scanf("%d%d",&h,&w) == 2 ){
        if( h == 0 && w == 0 )break;
        
        ll lcm = (ll)h*w / __gcd(h,w);
        
        ll sol = lcm/h * lcm/w;
        cout<<sol<<endl;
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <math.h>
#include <cstdlib>
#include <fstream>
#include <string.h>
using namespace std;

const int inf = 999999999;

int N,K;
char buff[300];
int sum[300];
int dp[300][300];
int sol = -inf;



int query( int f, int t ){
     if( f == 0 )return sum[t];
     else return sum[t] - sum[f-1];
}

int GetV( int v ){
     if( v < 0 )return -1;
     if( v > 0 )return +1;
     else return 0;
}


int solve( int idx , int G , int vvv ){
     sol = max( sol , vvv );
     if( G < 0 )return -inf;
     if( idx == N )return 0;
     if( dp[idx][G] != -inf )return dp[idx][G];
     int ss = -inf;
     
     
     for( int i = 0; idx+i < N; ++i ){
         int q = GetV(query(idx,idx+i) );
         ss = max( ss , solve(idx+i+1,G-1,vvv+q) + q );
     }
     
     return dp[idx][G] = ss;
     
}


int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    fscanf(in,"%d%d",&N,&K);
    fscanf(in,"%s",buff);
    
    for( int i = 0; i < strlen(buff); ++i ){
        int add;
        
        if( buff[i] == 'W' ) add = 1;
        else add = -1;
        
        if( i == 0 )sum[i] = add;
        else sum[i] = sum[i-1] + add;
    }
    
    for( int i = 0; i < 120; ++i )
       for( int j = 0; j < 120; ++j )
           dp[i][j] = -inf;

    int mxx = solve ( 0 , K , 0);
    
    printf("%d\n",mxx);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <math.h>
#include <iomanip>
#include <map>
#include <cstdlib>
#include <string.h>
using namespace std;

typedef long long ll;

int K,N,T;
ll cost[55][200005];
ll dp[55][100005];

ll solve( int idx , int time ){
    if( dp[idx][time] != -1 ) return dp[idx][time];
    if( time == T ) return cost[idx][time];
    
    ll sol = solve( idx , time + 1 );
    
    if( idx > 1 )sol = max( sol , solve( idx - 1 , time + 1 )  );
    if( idx < K )sol = max( sol , solve( idx + 1 , time + 1 )  );
    
    return dp[idx][time] = sol + cost[idx][time];
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    fscanf(in,"%d%d%d",&K,&N,&T);
    
    int v1,v2,v3;
    for( int i = 0; i < N; ++i ){
        fscanf(in,"%d%d%d",&v1,&v2,&v3);
        cost[v2][v3] += v1;
    }
    
    memset( dp, -1, sizeof(dp) );
    printf("%lld\n", solve( 1 , 0 )  );
    
    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <string.h>
using namespace std;

int chk( char *pok ){
    int ln = strlen( pok );
    
    if( ln > 1 && pok[0] == 'd' && pok[1] == 'z' && pok[2] == '=' )return 2;
    else if( pok[0] == 'c' && pok[1] == '=' )return 1;
    else if( pok[0] == 'c' && pok[1] == '-' )return 1;
    else if( pok[0] == 'd' && pok[1] == '-' )return 1;
    else if( pok[0] == 'l' && pok[1] == 'j' )return 1;
    else if( pok[0] == 'n' && pok[1] == 'j' )return 1;
    else if( pok[0] == 's' && pok[1] == '=' )return 1;
    else if( pok[0] == 'z' && pok[1] == '=' )return 1;
    
    return 0;
    
}

char buff[1000];

int main(){
    scanf("%s",buff);
    int sol = strlen(buff);
    for( int i = 0; i < strlen(buff) - 1; ++i ){
        sol -= chk( &buff[i] );
        i += chk( &buff[i] );
    }
    printf("%d\n",sol);
  
    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<algorithm>
#include<math.h>
#include<string.h>
using namespace std;

struct edge{
   int B,dist;
   edge( int p1 ,int p2):B(p1),dist(p2){};
   edge(){};
};

const int MAXN  = 100000;
const int MAXLG = 17;
const int inf   = 9999999;
int N,K;
int lvl[MAXN+5];
int father[MAXN+5] , distF[MAXN+5];
bool visited[MAXN+5];
int DP[MAXN+5][MAXLG+2][3];
vector<edge>graph[MAXN+5];

void DFS( int node , int deep ){
   visited[node] = true;
   lvl[node] = deep;
   for( int i = 0 ;  i<graph[node].size(); i++) {
      if( visited[ graph[node][i].B ] == false ){
         father[ graph[node][i].B ] = node;
         distF[ graph[node][i].B ] = graph[node][i].dist;
         DFS( graph[node][i].B , deep+1 );
      }
   }
}

void CONSTRUCT(){
   int i,j;
   memset(DP,-1,sizeof(DP));
   for(i=1;i<=N;i++){
      DP[i][0][0] = father[i];
      DP[i][0][1] = distF[i];
      DP[i][0][2] = distF[i];
   }
   for(i=1;i<=MAXLG;i++){
      for(j=1;j<=N;j++){
         if( DP[j][i-1][0]!=-1 ){
            DP[j][i][0] = DP[ DP[j][i-1][0] ][i-1][0];
            DP[j][i][1] = min(DP[j][i-1][1],DP[ DP[j][i-1][0] ][i-1][1] );
            DP[j][i][2] = max(DP[j][i-1][2],DP[ DP[j][i-1][0] ][i-1][2] );
         }
      }
   }
}

int GET_ANCESTOR( int p , int q ){
   int i;
   if( lvl[p] < lvl[q] )swap(p,q);
   for(i=MAXLG;i>=0;i--)
      if( DP[p][i][0]!=-1 && lvl[ DP[p][i][0] ]>= lvl[q] )
         p = DP[p][i][0];
   for(i=MAXLG;i>=0;i--)
      if( DP[p][i][0]!= DP[q][i][0] )
         p = DP[p][i][0] , q = DP[q][i][0];
   if( p==q )return p;
   return father[p];
}

int mini , maxi;
inline void query( int p , int q ){
   mini = inf;
   maxi = -inf;
   int A = GET_ANCESTOR(p,q);
   for(int i=MAXLG;i>=0;i--){
      if( DP[p][i][0]!=-1 && lvl[ DP[p][i][0] ]>=lvl[A] ){
         mini = min( mini , DP[p][i][1] );
         maxi = max( maxi , DP[p][i][2] );
         p = DP[p][i][0];
      }
      if( DP[q][i][0]!=-1 && lvl[ DP[q][i][0] ]>=lvl[A] ){
         mini = min( mini , DP[q][i][1] );
         maxi = max( maxi , DP[q][i][2] );
         q = DP[q][i][0];
      }
   }
}

void read( int &v ){
   char c;
   while( (c=getchar())<'0' || c>'9' );
   v = c-'0';
   while( (c=getchar())>='0' && c<='9' ) v = (v*10)+(c-'0');
}

int main(){
   int i,j,a,b,c;
   scanf("%d",&N);
   for(i=0;i<N-1;i++){
       scanf("%d%d%d",&a,&b,&c);
       graph[a].push_back( edge(b,c) );
       graph[b].push_back( edge(a,c) );
   }
   father[1] = -1;
   DFS(1,0);
   CONSTRUCT();
   scanf("%d",&K);
   for(i=0;i<K;i++){
      scanf("%d%d",&a,&b);
      query(a,b);
      printf("%d %d\n",mini,maxi);
   }
   return 0;
}

#include <iostream>
#include <cstdio>
#include <math.h>
#include <algorithm>
using namespace std;

int main(){
    int N;
    scanf("%d",&N);
    
    int sol = 1;
    for( int i = 1; i < N; ++i )
        sol += i * 6;
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <string.h>
#include <algorithm>
#include <cstdlib>
#include <math.h>
#include <iomanip>
using namespace std;

int h1,m1,s1;
int h2,m2,s2;

int main(){
    scanf("%d:%d:%d",&h1,&m1,&s1);
    scanf("%d:%d:%d",&h2,&m2,&s2);
    
    int sec1 = h1 * 60 * 60 + m1 * 60 + s1;
    int sec2 = h2 * 60 * 60 + m2 * 60 + s2;
    
    if( sec2 <= sec1 ) sec2 += 60 * 60 * 24;
    
    int diff = sec2 - sec1;
    int h = (int)floor( diff / 3600 );
          diff -= h * 3600;
    int m = (int)floor( diff / 60 );
          diff -= m * 60;
    int s = diff;
    
    
    printf("%.2d:%.2d:%.2d\n",h,m,s);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
using namespace std;

typedef long long ll;

struct coord{
    ll x,y;
    coord( ll p1, ll p2 ):x(p1),y(p2){};
    coord(){};
};

int n,K;
int val[100005];
ll f[100005];
ll dp[20][100005];


ll cross( coord A , coord B , coord G ){
     return (B.x-A.x)*(G.y-A.y) - (B.y-A.y)*(G.x-A.x);
}


int cnt = 0;
coord hull[100006];

void add( ll x, ll y ){
     coord P = coord ( x , y );
     while( cnt >= 2 && cross( hull[cnt-2] , hull[cnt-1] , P ) >= 0 )
         cnt --;

     hull[cnt++] = P;
}

ll get( ll x , int idx ){
    return x * hull[idx].x + hull[idx].y;
}

ll binary( int v ){
    int lo = 0 , hi = cnt - 1;
    while( lo < hi ){
        int mid = (lo+hi) / 2;

        if( get( v , mid ) < get( v , mid + 1 )  )
            lo = mid+1;
        else
            hi = mid;
    }
    return get(v,lo);
}

int main(){
    scanf("%d%d",&n,&K);

    for( int i = 0; i < n; ++i )
        scanf("%d",&val[i]);


    ll ss = 0;
    for( int i = n-1; i >= 0; --i ){
        f[i] = f[i+1] + val[i];
        ss += val[i] * i;
    }

    for( int i = 1; i < K; ++i ){

        cnt = 0;
        for( int j = 0; j < n; ++j )
             add( -f[j] , f[j]*j + dp[i-1][j] );

        for( int j = 0; j < n; ++j )
           dp[i][j] = binary( j );
    }

    printf("%lld\n", ss - dp[K-1][0] );
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <string.h>
#include <queue>
using namespace std;

#define f first
#define s second
#define mk make_pair

int N,M,v;
int pqs[105];

int main(){
    int tests;
    scanf("%d",&tests);
    
    for( ; tests; --tests ){
        scanf("%d%d",&N,&M);
        
        queue< pair<int,int>  > Q;
        
        for( int i = 0; i < N; ++i ){
             scanf("%d",&v);
             pqs[i] = v;
             Q.push( mk(v,i) );
        }
        
        pair<int,int> u;
        int sol = 0;
        
        while( !Q.empty() ){
             u = Q.front(); Q.pop();

             
             bool IsBigger = false;
             for( int i = 0; i < N && !IsBigger; ++i )
                 if( pqs[i] > u.f )
                     IsBigger = true;
             
             if( IsBigger ){
                 Q.push( u );
             }else{
                 sol++;
                 if( u.s == M )break;
                 pqs[ u.s ] = -1;
             }
             
        }
        
        printf("%d\n",sol);
        
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <set>
#include <stack>
#include <queue>
using namespace std;

int A,B;

bool IsPrime[10005];
bool visited[10005];
int dst[10005];
vector<int>G[10005];

int main(){
    
    IsPrime[1] = true;
    for( int i = 2; i <= 10000; ++i ){
        if( visited[i] == true )continue;
        IsPrime[i] = visited[i] = true;
        int j = 2;
        while( i*j <= 10000 ){
            visited[i*j] = true;
            IsPrime[i*j] = false;
            ++j;
        }
    }
    
    int c1,c2,c3,c4;;
    
    for( int i = 1000; i <= 9999; ++i ){
        for( int d = 0; d <= 9; ++d ){
        
            c2 = (i%100) + d*100 + (i/1000)*1000;
            
            c3 = (i%10)  + d*10  + (i/100)*100;
            
            c4 = d + (i/10)*10;
            
            
            if( d == 0 )c1 = 4004;
            else c1 = (i % 1000)+d*1000;
            
            if( IsPrime[c1] )G[i].push_back( c1 );
            if( IsPrime[c2] )G[i].push_back( c2 );
            if( IsPrime[c3] )G[i].push_back( c3 );
            if( IsPrime[c4] )G[i].push_back( c4 );
            
        }

    }
    
    
    int tests;
    scanf("%d",&tests);
    
    for( ; tests ; --tests ){
        
        scanf("%d%d",&A,&B);
        
        queue<int>Q;
        Q.push(A);
        memset( dst , 0 , sizeof( dst ) );
        dst[A] = 1;
        
        while( !Q.empty() ){
            int u = Q.front();Q.pop();
            if( u == B ) break;
            
            for( int i = 0; i < G[u].size(); ++i ){
                if( dst[ G[u][i] ] == 0 ){
                    dst[ G[u][i] ] = dst[ u ] + 1;
                    Q.push( G[u][i] );
                }
            }
        }
        
        printf("%d\n",dst[B]-1);
        
    }
    
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <cstdlib>
#include <math.h>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include<map>
using namespace std;

int GetKey( char *pok ){
    const int PRIME = 5227;
    int len = strlen(pok);
    int ret = 0;
    
    for( int i = 0; i < len; ++i )
        ret = ( ret * PRIME + pok[i] );
    return ret;
}

int N,M;
bool G[2200][2200];
map<int,int>MP;
char txt[1005];

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    while( fscanf(in,"%d%d",&N,&M)  == 2 ){
        if( N == 0 && M == 0 ) break;
        
        MP.clear();
        memset( G , 0  ,sizeof(G) );
        for( int i = 0; i <= N; ++i )
            G[i][i] = 1;
            
            
        for( int i = 0; i < N; ++i ){
            fscanf(in,"%s",txt);
            int k = GetKey(txt);
            MP[k] = i;
        }
        
        int k1,k2;
        for( int i = 0; i < M; ++i ){
            fscanf(in,"%s",txt); k1 = MP[GetKey(txt)];
            fscanf(in,"%s",txt); k2 = MP[GetKey(txt)];

            
            for( int j = 0; j < N; ++j ){
                G[k1][j] = G[k2][j] = G[k1][j] | G[k2][j];
            }
        }
        bool ok = true;
        for( int i = 0; i < N && ok; ++i )
           for( int j = 0; j < N && ok; ++j )
              ok = G[i][j];
        
        if( ok )
           printf("YES\n");
        else
           printf("NO\n");
    }
   
    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <math.h>
using namespace std;

int N,M;
int A[20] , B[20];

int main(){
    while( scanf("%d%d",&N,&M) == 2 ){
        if( N == 0 && M == 0 )break;
        
        for( int i = 0; i < N; ++i )
            scanf("%d",&A[i]);
        
        for( int i = 0; i < M; ++i )
            scanf("%d",&B[i]);
        
        sort( A , A + N );
        sort( B , B + M);
        
        bool Off = false;
        for( int i = 0; i < N && !Off; ++i ){
            if( A[i] < B[1] )
               Off = true;
        }
        if( Off )
            printf("Y\n");
        else
            printf("N\n");
        
    } 
    return 0;
}

#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <iostream>
using namespace std;



int N;
int arr[1005];
int srt[1005];
bool done[1005];

int GetIdx( int v ){
    for( int i = 0; i < N; ++i )
        if( srt[i] == v )return i;
}

int main(){
    int T = 1;
    while( scanf("%d",&N) == 1 ){
        
        if( N == 0 )break;
        
        int ss = 0;
        int MinX = 999999;
        
        for( int i = 0; i < N; ++i ){
            scanf("%d",&arr[i]);

            srt[i] = arr[i];
            MinX = min( MinX , arr[i] );
        }
        
        memset( done, 0, sizeof(done) );
        sort( srt , srt + N );
        int sol = 0;
        
        for( int i = 0; i < N; ++i ){
            
            if( done[i] ) continue;
            
            int idx = i;
            int MinCyc = 999999;
            int cnt = 0;
            int ss = 0;
            
            while( done[idx] == false ){
                done[idx] = true;
                cnt ++;
                ss += arr[idx];
                MinCyc = min( MinCyc , arr[idx] );
                idx = GetIdx( arr[idx] );
            }

            sol += min( ss + (cnt-2)*MinCyc , MinCyc + ss + MinX + MinX*cnt );
            
        }
        
        printf("Case %d: %d\n",T,sol);
        T++;
        
    }
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <queue>
#include <map>
#include<string.h>
using namespace std;


#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

int A,B,C;
const int inf = 99999;

//map< pii , int > M;

int M[1000000];
int k( pii p ){
    return (p.f*9851 + p.s )%1000000;
}

int main(){
    int tests;
    scanf("%d",&tests);
    
    for( ; tests; --tests ){
        memset( M , 0 , sizeof(M) );
        scanf("%d%d%d",&A,&B,&C);
        
        if( C == 0 ){
            printf("0\n");
            continue;
        }
        
        
        pii u;
        queue< pair<int,int> > Q;
        Q.push( mk(0,0) );
        M[ k(mk(0,0)) ] = 1;
        
        while( Q.empty() == false ){
            u = Q.front(); Q.pop();
            if( u.f == C || u.s == C )break;
            
            int v1 = u.f , v2 = u.s;
            int z = M[ k(mk(v1,v2)) ];
            
            if( M[ k(mk(A,v2)) ] == false ){
                M[ k(mk(A,v2)) ] = z + 1;
                Q.push( mk(A,v2) );
            }
            
            if( M[ k(mk(v1,B)) ] == false ){
                M[ k(mk(v1,B)) ] = z + 1;
                Q.push( mk(v1,B) );
            }
            
            if( M[ k(mk(0,v2)) ] == false ){
                M[ k(mk(0,v2)) ] = z + 1;
                Q.push( mk(0,v2) );
            }
            
            if( M[ k(mk(v1,0)) ] == false ){
                M[ k(mk(v1,0)) ] = z + 1;
                Q.push( mk(v1,0) );
            }
            
            
            
            int d = B - v2;
            int p = min(d,v1);
            
            if( M[ k(mk(v1-p,v2+p)) ] == false ){
                M[ k(mk(v1-p,v2+p)) ] = z + 1;
                Q.push( mk(v1-p,v2+p)  );
            }
            
                d = A - v1;
                p = min(d,v2);
            
            if( M[ k(mk(v1+p,v2-p)) ] == false ){
                M[ k(mk(v1+p,v2-p)) ] = z + 1;
                Q.push( mk(v1+p,v2-p)  );
            }
        }
        int ss = M[k(u)]-1;

        if( (u.f == C || u.s == C) && ss > 0 ) printf("%d\n",ss);
        else printf("-1\n");
        
    }


    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
using namespace std;

int N,M;
vector< pair<int,int> >V;

int main(){
   int tests,v;
   scanf("%d",&tests);
   
   for( ; tests; --tests ){
       V.clear();
       scanf("%d%d",&N,&M);
       
       for( int i = 0; i < N; ++i ){
           scanf("%d",&v);
           V.push_back( make_pair(v,1) );
       }
       
       for( int i = 0; i < M; ++i ){
           scanf("%d",&v);
           V.push_back( make_pair(v,0) );
       }
       sort(V.begin(),V.end());
       
       int aliveN = N , aliveM = M;
       for( int i = 0; i < M+N && aliveN && aliveM; ++i ){
           if( V[i].second == 1 )
              aliveN --;
           else
              aliveM --;
       }
       if( aliveN )
           printf("Godzilla\n");
       else
           printf("MechaGodzilla\n");
       
   }

   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <vector>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int N,Q;
vector< int > G[100007];


int sub[100007];
int prv[100007];
bool visited[100007];

int L[100007];
int R[100007];
int first[100007];

int dist[100007];
bool bw[100007];

int A[100007];
int B[100007];

int counter = 1;

int dfs( int node , int deep , int cnt = 1 ){
    visited[ node ] = true;
    dist[ node ] = deep;
    
    int ss = 1;
    
    A[node] = B[node] = cnt;
    
    for( int i = 0; i < G[node].size(); ++i ){
         if( visited[ G[node][i] ] == false ){
             prv[ G[node][i] ] = node;
             ss += dfs( G[node][i] , deep + 1 , cnt + 1 );
             
             B[node] = max( B[node] , B[ G[node][i] ] );
         }
    }
    return sub[node] = ss;
}

void hlc( int node , int lanac ){
   L[node] = lanac;
   visited[node] = true;
   
   int mxx = 100004;
   for( int i = 0; i < G[node].size(); ++i )
        if( visited[ G[node][i] ] == false && sub[mxx] < sub[ G[node][i] ] )
            mxx = G[node][i];

   if( mxx != 100004 )hlc( mxx , lanac );
   
   for( int i = 0; i < G[node].size(); ++i ){
       if( G[node][i] == mxx  || visited[ G[node][i] ] )continue;
       
       first[ ++counter  ] = G[node][i];
       hlc( G[node][i] , counter);
   }
}

#define f first
#define s second
#define pii pair<int,int>
#define mk make_pair

set< pii >ms[100007];

void modify( int v ){
    bw[v] = !bw[v];
    if( bw[v] )
        ms[ L[v] ].insert( mk( dist[v] , v )  );
    else
        ms[ L[v] ].erase( mk(dist[v],v) );
}

int query( int v ){
    int z = dist[v];
    int ret = -1;
    
    //cout<<"query ( "<<v<<" , "<<A[v]<<" ) "<<endl;
    
    while( v != -1 ){
        pii u = *ms[ L[v] ].begin();
        
        //cout<<u.s<<" = "<<A[u.s]<<" "<<B[u.s]<<endl;
        
        if( A[u.s] <= A[v] &&  A[v] <= B[u.s] ){
            if( z >= u.f )
               ret = u.s , z = u.f;
        }
        
        v = prv[ first[ L[v] ] ];
    }//cout<<endl;
    
    return ret;
}

int main(){
    FILE *in = stdin;///fopen("Ulaz.txt","r");
    
    int a,b;
    fscanf(in,"%d%d",&N,&Q);
    
    for( int i = 0; i < N-1; ++i ){
        fscanf(in,"%d%d",&a,&b);
        G[a].push_back(b);
        G[b].push_back(a);
    }
    
    dfs( 1 , 0);
    memset( visited , 0 , sizeof(visited) );
    hlc( 1 , 1 );
    
    first[1] = 1;
    prv[1] = -1;

    for( int i = 0; i < Q; ++i ){
        fscanf(in,"%d%d",&a,&b);
        if( a == 0 ){
            modify( b );
        }else{
            printf("%d\n", query(b) );
        }
    }
    
    system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

const int MOD = 101;
char txt[1005][1066];
char *table[105];

int h( char *pok ){
    int ss = 0;
    for( int i = 0; i < strlen(pok); ++i )
       ss += pok[i]*(i+1);
    return (19 * ss);
}


void Insert( char *pok ){
    int key;
    bool ok = false;
    for( int j = 0; j <= 19 && !ok; ++j ){
        key = (h( pok )+j*j + 23*j) % MOD;
        if( table[key] != NULL && strcmp( table[key] , pok ) == 0 )break;
        if( table[key] == NULL )ok = true;
    }
    if( ok ){
        table[key] = pok;
    }
}
void Delete( char *pok ){
    int key;
    bool ok = false;
    for( int j = 0; j <= 19 && !ok; ++j ){
        key = (h( pok )+j*j + 23*j) % MOD;
        if( table[key] != NULL && strcmp( table[key] , pok ) == 0 ){
            table[key] = NULL;
            break;
        }
    }
}

map< string , bool > M;

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    int tests,cmm;
    fscanf(in,"%d",&tests);
    
    for( ; tests ; --tests ){
        fscanf(in,"%d",&cmm );
        
        M.clear();
        for( int i = 0; i <= 100; ++i )
            table[i] = NULL;
        
        char c , t;
        
        for( int i = 0; i < cmm; ++i ){
            while( c = fgetc(in) )
               if(  c == 'A' || c == 'D' )
                   break;
            t = fgetc(in); t = fgetc(in); t = fgetc(in);
            
            string str = "";
            fscanf(in,"%s",txt[i]);
            for( int j = 0; j < strlen(txt[i]); ++j )
                str += string(1,txt[i][j]);
            
            if( c == 'A' ){
                if( M[str] == 1 )continue;
                Insert( txt[i] );
                M[str] = 1;
            }else{
                Delete( txt[i] );
                M[str] = 0;
            }
        }
        
        int cnt = 0;
        for( int i = 0; i <= 100; ++i )
            if( table[i] != NULL ) cnt ++;
        
        printf("%d\n",cnt);
        for( int i = 0; i <= 100; ++i ){
            if( table[i] != NULL )
                printf("%d:%s\n",i,table[i]);     
        }
        
    } 
    //system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <math.h>
#include <iomanip>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

struct word{
    char *pok;
    int val;
    int ac,bc;
    word( char *p1, int p2 ):pok(p1),val(p2){
        
        ac = bc = 0;
        for( int i = 0; i < strlen(pok); ++i )
           if( pok[i] == 'a' ) ac ++;
           else bc++;
           
    };
    word(){};
    
    bool operator < ( const word &w2 ) const {
         return strcmp( pok , w2.pok ) == -1;
    }
};

struct trio{
    int a,b,c;
    trio( int p1, int p2, int p3 ): a(p1),b(p2),c(p3){};
    trio(){};
};

int N,A,B,K;

char txt[100][10000];
vector< word >W;

int dp[100][100][100];

int idx[100][100][100];
trio prv[100][100][100];

int main(){
   FILE *in = fopen("Ulaz.txt","r");
   fscanf(in,"%d",&N);
   fscanf(in,"%d%d%d",&A,&B,&K);
   
   int v;
   for( int i = 0; i < N; ++i ){
       fscanf(in,"%s%d",txt[i],&v);
       W.push_back( word( txt[i] , v ) );
   }
   
   sort( W.begin(), W.end() );
   
  // for( int i  =0; i < N; ++i )
  //     cout<<W[i].pok<<" "<<W[i].ac<<" | "<<W[i].bc<<endl;
   
   int sss = 0;
   trio sol = trio(0,0,0);
   
   for( int s = 1; s <= K+1; ++s ){
   
        for( int i = 0; i <= A; ++i ){
             for( int j = 0; j <= B; ++j ){
                  for( int k = 0; k < N; ++k ){
                      
                      int a = s-1;
                      int b = i - W[k].ac;
                      int c = j - W[k].bc;
                       
                      if( c < 0 ||  b < 0 ) continue;
                      
                      
                      int &v = dp[s][i][j];
                      int &p = dp[a][b][c];
                      
                      if( v < p + W[k].val ){
                          v = p + W[k].val;
                          idx[s][i][j] = k;
                          prv[s][i][j] = trio(a,b,c);
                      }
                      
                      if( sss < p + W[k].val ){
                          sol = trio(s,i,j);
                          sss = p + W[k].val;
                      }
                  }
             } 
        }
   }
   
   while( sol.a  ){
       cout<<W[ idx[ sol.a ][ sol.b ][ sol.c ]  ].pok<<" ";
       sol = prv[ sol.a ][ sol.b ][ sol.c ];
   }putchar('\n');
   
   system("Pause");
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

int N,M;
int arr[1006];

int main(){
    int tests,T = 1;
    scanf("%d",&tests);
    for( ; tests ; --tests ){
        scanf("%d%d",&M,&N);
        
        for( int i = 0; i < N; ++i )
            scanf("%d",&arr[i]);
        
        sort( arr , arr+N , greater<int>() );
        
        int i;
        int ss = 0;
        for( i = 0; i < N && ss < M; ++i )ss += arr[i];
        
        
        printf("Scenario #%d:\n",T);
        if( ss < M )
           printf("impossible\n\n");
        else
           printf("%d\n\n",i);
        ++T;
    }
    system("pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <math.h>
using namespace std;

int n;
int mix[106];
int dp[107][107];
int nw[107][107];
const int inf = 9999999;

int main(){
    while( scanf("%d",&n) == 1 ){
        
        for( int i = 0; i < n; ++i ){
            scanf("%d",&mix[i]);
            nw[i][i] = mix[i];
            dp[i][i] = 0;
        }
        
        for( int l = 1; l <= n; ++l ){
             for( int i = 0; i+l < n; ++i ){
                   int j = i+l;
                   dp[i][j] = inf;
                   for( int k = i; k <= j-1; ++k ){
                       int cost = dp[i][k] + dp[k+1][j] + nw[i][k] * nw[k+1][j];
                       int www   = (nw[i][k] + nw[k+1][j])%100;
                       if( cost < dp[i][j] ){
                            nw[i][j]  = www;
                            dp[i][j] = cost;
                       }
                   }
                   
             }
        }
        printf("%d\n",dp[0][n-1] );
        
        
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
using namespace std;

int prv[1000006];
int cnt[1000005];
int arr[100000];

int main(){
    int n,v;
    scanf("%d",&n);
    for( int i = 0;  i < n; ++i ){
        scanf("%d",&arr[i]);
        cnt[ arr[i] ] ++;
        prv[ arr[i] ] ++;
    }
    
    for( int i = 2; i <= 1000000; ++i ){
        int j = 2;
        while( i*j <= 1000000 ){
            cnt[i*j] += prv[i];
            ++j;
        }
    }
    for( int i = 0; i < n; ++i ){
        
        if( arr[i] != 1 )
           printf("%d\n",cnt[ arr[i] ] + cnt[ 1 ] - 1 );
        else
           printf("%d\n",cnt[1]-1);
    }
    
    
 
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
using namespace std;

struct edge{
    int a,b,d;
    edge( int p1, int p2, int p3 ):a(p1),b(p2),d(p3){};
    edge(){};
    bool operator<( const edge &e2 ) const {
         return d < e2.d;
    }
};

int P,N,M;
vector< edge >E;

int id[1005];
int sz[1005];

bool connect( int a, int b ){
    for( ; a != id[a] ; a = id[a] )
         id[a] = id[ id[a] ];
    for( ; b != id[b] ; b = id[b] )
         id[b] = id[ id[b] ];
    
    if( a == b ) return true;
    
    if( sz[a] < sz[b] )
        sz[a] += sz[b] , id[a] = b;
    else
        sz[b] += sz[a] , id[b] = a;
    
    return false;
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    int tests;
    int a,b,c;
    fscanf(in,"%d",&tests);
    
    for( ; tests ; -- tests ){
        fscanf(in,"%d%d%d",&P,&N,&M);
        
        E.clear();
        for( int i = 0; i <= N; ++i )
            id[i] = i , sz[i] = 1;
        
        for( int i = 0; i < M; ++i ){
            fscanf(in,"%d%d%d",&a,&b,&c);
            E.push_back( edge( a,b,c) );
        }
        
        int sol = 0;
        sort( E.begin() , E.end() );
        
        for( int i = 0; i < M; ++i ){
            bool b = connect( E[i].a , E[i].b );
            if( b ) continue;
            
            sol += P * E[i].d;
        }
        printf("%d\n",sol);
    }
    
   // system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int N,M;
char num[2500];

short dp[1005][5005];
const short inf = 30000;

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    N = 0;
    char c;
    
    int nulls = 0;
    
    for( c = fgetc(in); c != '='; c = fgetc(in) )
        num[N++] = c-'0';
    
    for( int i = N; i >= 5; --i ){
        int j;
        for( j = 0; j < 3; ++j )
            if( num[i-j] != 0 )
                break;

        if( j == 4 )
            num[i] = -1;
    }

    int sub = 0;
    for( int i = 0; i < N; ++i ){
        if( num[i] == -1 ){ sub ++; continue; }
        num[i-sub] = num[i];
    }
    N -= sub;
    
    
    M = 0;
    for( ; fscanf(in,"%c",&c) != EOF; ){
         if( c < '0' || c > '9' )break;
         M = M*10 + (c-'0');
    }
    
    memset( dp , -1 , sizeof(dp));
    for( int i = N-1; i >= 0; --i ){
        int su = 0;
        for( int j = 0; j < N && i+j<N; ++j ){
            su = su*10 + num[i+j];
            
            if( su > M ) break;
   
            if( i+j+1 == N ){
                dp[i][su] = 1;
                continue;
            }
            
            int nw = i+j+1;
            if( su == 0 )continue;
            
            for( int k = 0; su+k <= M; ++k )
                if( dp[nw][k] != -1 ){
                    dp[i][su+k] = min( dp[i][su+k] , (short)(dp[nw][k] + 1) );
                    if( dp[i][su+k] == -1 ) dp[i][su+k] = dp[nw][k] + 1;
                }
        }
    }
    printf("%d\n",dp[0][M]-1);
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
using namespace std;

string word;
set<string>S;

void ToUpper( string &s ){
    for( int i = 0; i < s.size(); ++i )
        if( s[i] >='a' && s[i] <= 'z' )
            s[i] = 'A' + (s[i] - 'a');
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    int sum(0) , cnt(0);
    char c;
    word = "";
    
    do{
        c = fgetc(in);
        if(  (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')  ){
            word += string(1,c);
        }else{
            if( word == "" ) continue;
            
            ToUpper(word);
            
            if( word == "BULLSHIT" ){   
                sum += S.size();
                cnt++;
                S.clear();
                
            }else
                S.insert(word);
            
            word = "";
        }
        
    }while( c != -1 );
    
    int g  = __gcd(sum,cnt);

    cout<<sum/g<<" / "<<cnt/g<<endl;

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <math.h>
#include <queue>
#include <string.h>
using namespace std;

#define f first
#define s second

int N,M;
vector< pair<int,double> >G[105];


int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    while( fscanf(in,"%d",&N) == 1 ){
        if( N == 0 )break;
        int a,b,p;
        
        for( int i = 0; i <= 102; ++i )
            G[i].clear();
        
        fscanf(in,"%d",&M);
        
        for( int i = 0; i < M; ++i ){
            fscanf(in,"%d%d%d",&a,&b,&p);
            G[a].push_back( make_pair(b,p/100.0) );
            G[b].push_back( make_pair(a,p/100.0) );
        }
        
        pair<double,int> u;
        priority_queue< pair<double,int> >PQ;
        PQ.push( make_pair(1,1) );
        
        while( !PQ.empty() ){
            u = PQ.top(); PQ.pop();
            
            if( u.s == N )break;
            
            for( int i = 0; i < G[u.s].size(); ++i )
                PQ.push(  make_pair(  G[u.s][i].s * u.f , G[u.s][i].f ) );
            G[u.s].clear();
        }
        printf("%.6lf percent\n",u.f*100);
        
        
    } 
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
using namespace std;

int A,B;

vector< int > facts( int v ){
    int y = v;
    int d = 2;
    vector<int>R;
    while( d*d <= y ){
        if( v % d == 0 ){
            v /= d;
            R.push_back(d);
        }else
            d++;
    }
    if( v != 1 )
        R.push_back(v);
    return R;
}

int cntA[1000005];
int cntB[1000005];
set< int > S;

int main(){
    int TST = 1;
    while( scanf("%d%d",&A,&B) == 2 ){
        
        if( A == 0 && B == 0 )break;
        
        vector< int > f1 = facts(A);
        vector< int > f2 = facts(B);
        S.clear();
        
        for( int i = 0; i < f1.size(); ++i )
            S.insert( f1[i] );
        for( int i = 0; i < f2.size(); ++i )
            S.insert( f2[i] );
        
        set < int > :: iterator it;
        for( it = S.begin() ; it != S.end() ; ++it )
            cntA[*it] = cntB[*it] = 0;
        
        int dst = 0;
        
        for( int i = 0; i < f1.size(); ++i )
            cntA[ f1[i] ] ++;
        for( int i = 0; i < f2.size(); ++i )
            cntB[ f2[i] ] ++;
        
        for( it = S.begin() ; it != S.end() ; ++it )
            dst += abs( cntA[*it] - cntB[*it] );
        
        printf("%d. %d:%d\n",TST,S.size(),dst);
        
        TST++;
    }
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <algorithm>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

#define END system("Pause");return 0;
#define mk make_pair
#define f first
#define s second

const int inf = 99999999;
int N,M;

vector<int>G[10005];
vector<int>rG[10005];

bool visited[10005];
bool ispart[10005];

bool done[10005];
int  cnt[10005];
long long  dp[10005];

bool dfs( int node ){
    visited[node] = true;
    bool d = false;
    for( int i = 0; i < G[node].size(); ++i )
        if( visited[ G[node][i] ] == false ){
             d |= dfs( G[node][i] );
        }else
             d |= ispart[ G[node][i] ];
    
    if( node == 2 ) return ispart[node] = true;
    return ispart[node] = d;
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d%d",&N,&M);
    
    int a,b;
    for( int i = 0; i < M; ++i ){
        fscanf(in,"%d%d",&a,&b);
        G[a].push_back(b);
        rG[b].push_back(a);
    }
    
    dfs( 1 );
    
    for( int i = 1; i <= N; ++i ){
        if( ispart[i] == false )continue;
        for( int j = 0; j < G[i].size(); ++j )
            cnt[ G[i][j] ] ++;
    }
    

    queue< int > Q;
    Q.push( 1 );
    dp[1] = 1;
    bool OVER = false;
    while( Q.empty() == false ){
        int u = Q.front(); Q.pop();
        done[u] = true;
        
        for( int i = 0; i < G[u].size(); ++i ){
            cnt[ G[u][i] ] --;
            if( ispart[ G[u][i] ] && dp[ G[u][i] ] + dp[u] >= 1000000000ll ) OVER = true;
            dp[ G[u][i] ] = (dp[ G[u][i] ] + dp[u] ) % 1000000000;

            
            if( cnt[ G[u][i] ] == 0 )
                 Q.push( G[u][i] );
        }
    }
    for( int i = 1; i <= N; ++i ){
        if( ispart[i] && !done[i] ){
            printf("inf\n");
            END
        }
    }
    if( OVER )
        printf("%09lld\n",dp[2]);
    else
    printf("%d\n",dp[2]);
  
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
using namespace std;

typedef long long ll;

int N,M;
const ll y = 1000000;

int main(){
    double v;
    ll vl , small = 360 * y;
    scanf("%d%d",&N,&M);
    
    for( int i = 0; i < N; ++i ){
        scanf("%lf",&v);
        vl = (ll)round(v*y);
        small = __gcd(small,vl);
    }
    
    for( int i = 0; i < M; ++i ){
        scanf("%lf",&v);
        vl = (ll)round(v*y);
        if( vl % small == 0 )
            printf("YES\n");
        else
            printf("NO\n");
    }
    
    return 0;
}

#include <cstdio>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;

char buff[255];

int main(){
   scanf("%s",buff);
   
   int i,n=strlen(buff),brojilac=1,RES=0;
   
   for(i=1;i<n;i++){
      if( isupper(buff[i]) ){
         if((4-(brojilac%4))!=4)RES+=(4-(brojilac%4));
         brojilac = brojilac + (4-(brojilac%4));
      }
      brojilac++;
   }
      
   printf("%d\n",RES);
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <string.h>
#include <queue>
using namespace std;

#define f first
#define s second
#define mk make_pair

int N,M,v;
int pqs[105];

int main(){
    int tests;
    scanf("%d",&tests);
    
    for( ; tests; --tests ){
        scanf("%d%d",&N,&M);
        
        queue< pair<int,int>  > Q;
        
        for( int i = 0; i < N; ++i ){
             scanf("%d",&v);
             pqs[i] = v;
             Q.push( mk(v,i) );
        }
        
        pair<int,int> u;
        int sol = 0;
        
        while( !Q.empty() ){
             u = Q.front(); Q.pop();

             
             bool IsBigger = false;
             for( int i = 0; i < N && !IsBigger; ++i )
                 if( pqs[i] > u.f )
                     IsBigger = true;
             
             if( IsBigger ){
                 Q.push( u );
             }else{
                 sol++;
                 if( u.s == M )break;
                 pqs[ u.s ] = -1;
             }
             
        }
        
        printf("%d\n",sol);
        
    }

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
using namespace std;

typedef long long ll;
bool mx[400][400];
int dph[400][400];

class DonutsOnTheGrid {
    public:
        long long calc(int H, int W, int seed, int threshold)
        {
            int x = seed;
            for( int i = 1; i <= H; ++i ){
                for( int j = 1; j <= W; ++j ){
                    x = ( x * 25173 + 13849 ) % 65536;
                    mx[i][j] = false;
                    if( x < threshold )
                        mx[i][j] = true;
                }
            }
            
            long long sol = 0;
            
            
            for( int i = 1; i <= W; ++i ){
                int ss = 0;
                for( int j = 1; j <= H; ++j ){
                    ss += mx[j][i];
                    if( mx[j][i] == false ) ss = 0;
                    dph[j][i] = ss;
                }
            }
            
            
            for( int i = 1; i <= H; ++i ){
                for( int j = i+2; j <= H; ++j ){
                    
                    int prv = 0;
                    for( int k = 1; k <= W; ++k ){
                        
                        int diff = dph[j][k] - dph[i-1][k];
                        
                        if( diff == j - i + 1 ){
                           sol += prv;
                           if( k > 1 && dph[j][k-1] - dph[i-1][k-1] == j-i+1 ) sol --;
                           prv++;
                        }
                        
                        if( mx[i][k] == false ||  mx[j][k] == false ) prv = 0;
                    }
                    
                }
            }
            return sol;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const long long &Expected, const long long &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arg0 = 5; int Arg1 = 5; int Arg2 = 222; int Arg3 = 55555; long long Arg4 = 4LL; verify_case(0, Arg4, calc(Arg0, Arg1, Arg2, Arg3)); }
	void test_case_1() { int Arg0 = 5; int Arg1 = 6; int Arg2 = 121; int Arg3 = 58000; long long Arg4 = 3LL; verify_case(1, Arg4, calc(Arg0, Arg1, Arg2, Arg3)); }
	void test_case_2() { int Arg0 = 4; int Arg1 = 5; int Arg2 = 6; int Arg3 = 50000; long long Arg4 = 1LL; verify_case(2, Arg4, calc(Arg0, Arg1, Arg2, Arg3)); }
	void test_case_3() { int Arg0 = 4; int Arg1 = 4; int Arg2 = 1; int Arg3 = 65536; long long Arg4 = 9LL; verify_case(3, Arg4, calc(Arg0, Arg1, Arg2, Arg3)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    DonutsOnTheGrid c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
using namespace std;

#define ok(x,y) (x>=0&&x<A[0].size()&&y>=0&&y<A.size())

char mx[100][100];
bool m2[100][100];

class SpidersOnTheGrid {
    public:
        int find(vector <string> A)
        {
            int ss = 0;
            for( int i = 0; i < A.size(); ++i )
               for( int j = 0; j < A[i].size(); ++j ){
                   mx[i][j] = A[i][j];
                   ss++;
               }
            
            memset( m2 , false , sizeof( m2 ) );
            
            for( int i = 0; i < A.size(); ++i ){
               for( int j = 0; j < A[i].size(); ++j ){
                   if( mx[i][j] == 'E' && ok(j+1,i) )
                       m2[i][j+1] = true;
                   else if( mx[i][j] == 'W' && ok(j-1,i) )
                       m2[i][j-1] = true;
                   else if( mx[i][j] == 'N' && ok(j,i-1) )
                       m2[i-1][j] = true;
                   else if( mx[i][j] == 'S' && ok(j,i+1) )
                       m2[i+1][j] = true;
               }
            }
            int sol = 0;
            for( int i = 0; i < A.size(); ++i ){
               for( int j = 0; j < A[i].size(); ++j ){
                   sol += m2[i][j] == false;
               }
            }
            return sol;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { string Arr0[] = {"EW","NN"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 2; verify_case(0, Arg1, find(Arg0)); }
	void test_case_1() { string Arr0[] = {"EEEEEEEEEEEEEEEEEEEEEEEEEEEEEW"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 1; verify_case(1, Arg1, find(Arg0)); }
	void test_case_2() { string Arr0[] = {"EW"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 0; verify_case(2, Arg1, find(Arg0)); }
	void test_case_3() { string Arr0[] = {"ESW","ENW"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 4; verify_case(3, Arg1, find(Arg0)); }
	void test_case_4() { string Arr0[] = {"E"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 1; verify_case(4, Arg1, find(Arg0)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    SpidersOnTheGrid c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
using namespace std;


class EasySequence {
    public:
        int find(vector <int> A, vector <int> B)
        {
            int N = A.size();
            for( int i = 0; i <= 100000; ++i ){
                int ss = 0;
                
                for( int j = 0; j < N; ++j ){
                    ss += A[ A.size() - 1 - j ];

                }
                A.push_back( ss % 10 );
          

            }
   
            
            int i;
            for( i = 0; i < 100000; ++i ){
                bool ok = true;
                for( int j = 0; j < B.size() && ok; ++j ){
                    if( A[i+j] != B[j] )
                        ok = false;
                }
                if( ok )
                    break;
            }

            if( i == 100000 ) return -1;
            return i;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arr0[] = {1,2,3,4,5,6,7}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = {3,6,7,6,5,8,1,6,9,2}; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); int Arg2 = 5; verify_case(0, Arg2, find(Arg0, Arg1)); }
	void test_case_1() { int Arr0[] = {1,2,8}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = {7,4,2,3}; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); int Arg2 = -1; verify_case(1, Arg2, find(Arg0, Arg1)); }
	void test_case_2() { int Arr0[] = {1,2,3,4,5}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = {4,5}; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); int Arg2 = 3; verify_case(2, Arg2, find(Arg0, Arg1)); }
	void test_case_3() { int Arr0[] = {1}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = {1,1,1}; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); int Arg2 = 0; verify_case(3, Arg2, find(Arg0, Arg1)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    EasySequence c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<iostream>
using namespace std;
char p1[]={'A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C',
           'A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C',
           'A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C',
           'A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C',
           'A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C',
           'A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C','A','B','C',};
           
char p2[]={'B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C',
           'B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C',
           'B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C',
           'B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C',
           'B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C',
           'B','A','B','C','B','A','B','C','B','A','B','C','B','A','B','C',};
           
char p3[]={'C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B',
           'C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B',
           'C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B',
           'C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B',
           'C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B',
           'C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B',
           'C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B','C','C','A','A','B','B'};
int main()
{
    int n,i;
    int S1=0,S2=0,S3=0;
    int maxN=0;
    char c;
    scanf("%d",&n);
    for(i=0;i<n;i++)
    {
       cin>>c;
       if( p1[i]==c)S1++;
       if( p2[i]==c)S2++;
       if( p3[i]==c)S3++;
    }
    maxN = max( max(S1,S2),max(S2,S3) );
    cout<<maxN<<endl;
    if( S1==maxN)
       cout<<"Adrian"<<endl;
    if( S2==maxN)
       cout<<"Bruno"<<endl;
    if( S3==maxN)
       cout<<"Goran"<<endl;
    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;


int main(){
    int r1,s;
    scanf("%d%d",&r1,&s);
    printf("%d\n",2*s - r1 );
    return 0;
}

#include <iostream>
#include <cstdio>
#include <math.h>
#include <string.h>
#include <string>
#include <set>
#include <stack>
#include <queue>
#include <iomanip>
#include <map>
#include <cstdlib>
#include <vector>
#include <sstream>
#include <fstream>
#include <algorithm>
using namespace std;

struct pile{
    int h,idx;
    pile( int p1, int p2 ):h(p1),idx(p2){};
    pile(){};
    bool operator<( const pile &p2 ) const{
        return idx < p2.idx;
    }
};

int N,M;
vector< pile > V;

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    int a,b;
    fscanf(in,"%d%d",&N,&M);
    
    for( int i = 0; i < N; ++i ){
        fscanf(in,"%d%d",&a,&b);
        V.push_back( pile( b , a )  );
    }
    
    sort(V.begin(),V.end());
    
    long long sol  = 0;
    int prev = 0;
    
    for( int i = 0; i < V.size(); ++i ){
        int add = V[i].h - prev;
        if( add < 0 ) add = 0;
        sol += add;
        prev = V[i].h;
    }
    
    cout << sol << endl;
    system("Pause");
    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<vector>
#include<iomanip>
#include<set>
#include<algorithm>
using namespace std;

#define f first
#define s second
#define mk make_pair

int N;
vector<int>tmp;
vector<pair<int,int> >V;
multiset<int>S1;
multiset<int>::iterator it;

int main(){
   int tests,a,b;
   scanf("%d",&tests);
   for( ; tests ; tests-- ){
      scanf("%d",&N);
      V.clear();
      for( int i=0; i<N; ++i ){
         scanf("%d%d",&a,&b);
         V.push_back( mk(a,b) );
      }
      sort(V.begin(),V.end());
      tmp.clear();
      S1.clear();
      S1.insert(-1);
      int sol = 0;
      for( int i=0; i<N; ++i ){
              cout << S1.size() << endl;
         if( i>0 && V[i].f != V[i-1].f ){
             for( int j=0; j<tmp.size(); ++j ){
                S1.insert( tmp[j] );
                            cout << tmp[j] << endl;
             }
             tmp.clear();
         }
         
         it = S1.lower_bound( V[i].s ); --it;
         if( *it != -1 )S1.erase( it );
         
         tmp.push_back( V[i].s ); 
        
      }
      printf("%d\n", S1.size());
    //  printf("%d\n",sol);
   }
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
using namespace std;



int edge [] [ 5 ] = {
    
1, 2, 4, 8, 16,
1, 2, 4, 8, 16,

0, 3, 5, 9, 17,
0, 3, 5, 9, 17,

3, 0, 6, 10, 18,
3, 0, 6, 10, 18,

0, 0, 7, 11, 19,
0, 0, 7, 11, 19, 

5, 6, 0, 12, 20,
5, 6, 0, 12, 20, 

0, 7, 0, 13, 21,
0, 7, 0, 13, 21,

7, 0, 0, 14, 22,
7, 0, 0, 14, 22,

0, 0, 0, 15, 23,
0, 0, 0, 15, 23,

9, 10, 12, 0, 24,
9, 10, 12, 0, 24,

0, 11, 13, 0, 25,
0, 11, 13, 0, 25,

11, 0, 14, 0, 26,
11, 0, 14, 0, 26,

0, 0, 15, 0, 27,
0, 0, 15, 0, 27,

13, 14, 0, 0, 28,
13, 14, 0, 0, 28,

0, 15, 0, 0, 29,
0, 15, 0, 0, 29,

15, 0, 0, 0, 30,
15, 0, 0, 0, 30,

0, 0, 0, 0, 31,
0, 0, 0, 0, 31
};



typedef long long ll;

int MOD,N;
int mem[40][2];

int linear( bool mode , int from , int to ){

    for( int i = from; i <= to; ++i ){
        
        char G = 5;
        if( i == 2 || i == N-1 ) G = 4;
        if( i == N ) G = 3;
        
        for( char j = 0; j < 32; ++j )  mem[j][mode] = 0;
        
        for( char j = 0; j < 32; ++j ){
           char M = j;
           if( i > 3 )M >>= 1;

           
           for( char k = 0; k < G; ++k )
               if( !(M & (1<<k)) )
                   mem[ M | (1<<k) ][mode] = (mem[ M | (1<<k) ][mode] + mem[j][!mode]) % MOD;
        }
        mode = !mode;
    }
    
    int ret = 0;
    for( int i = 0; i < 32; ++i )
        ret = (ret+mem[i][!mode])%MOD;
        
    return ret;
}

ll M[40][40];
ll adj[40][40] , adjc[40][40];
ll tmp[40][40];

void multiply( ll a[40][40] , ll b[40][40] ){
    
    for( int i = 0; i < 32; ++i )
       for( int j = 0; j < 32; ++j )
           tmp[i][j] = 0;
    
    
    for( int i = 0; i < 32; ++i )
        for( int j = 0; j < 32; ++j )
            for( int k = 0; k < 32; ++k )
                tmp[i][j] = (tmp[i][j] + a[i][k] * b[k][j]) % MOD;
    
    for( int i = 0; i < 32; ++i )
       for( int j = 0; j < 32; ++j ){
           a[i][j] = tmp[i][j];
           assert( a[i][j] >= 0 );
       }
    
}

int main(){
    cin >> N >> MOD;
    
    mem[3][true] = mem[5][true] = mem[6][true] = 2;
    mem[9][true] = mem[10][true] = mem[12][true] = 1; // SET TILL ROW 2
    
    
    int sol = 0;
    
    if( N <= 100000 ){ // low cases
         linear( false , 3 , N );
         int sz = N - 3;
    
         for( char i = 0; i < 32; ++i )
             sol = (sol + mem[i][ ((sz&1) == 1) ])%MOD;
             
    }else{  // big cases , matrix multiplication
         
         bool now = false;
         
         linear( now , 3 , 100 );
         int sz = 100 - 3;      // now next is 101
         
         
         for( int i = 0; i < 32; ++i )
             M[0][i] = mem[i][ ((sz&1) == 1) ];
         
         
         now = (sz&1) == 1;
         
         int exp = (N - 100) - 101;
         
         for( int i = 0; i < 32; ++i ) // creater adjency matrix
             for( int j = 0; j < 5; ++j ){
                 if( edge[i][j] == 0 ) continue;
                 adj[ i ][ edge[i][j] ] ++;
                 adjc[ i ][ edge[i][j] ] ++;
             }
             
         
         stack < int > S;
         while( exp != 1 ){ // get the states
             if( exp & 1 ){
                 S.push(1);
                 exp --;
             }else{
                 S.push(2);
                 exp >>= 1;
             }
         }
         
         while( !S.empty() ){
             int u = S.top(); S.pop();
             
             if( u == 2 )
                 multiply( adj , adj   );
             else
                 multiply( adj , adjc );     
                 
         }
         
         
         multiply( M , adj );
         for( int k = 0; k < 32; ++k )
            mem[k][0] = M[0][k];
         
         sol = linear( true , N - 100 , N );
         
    }
    
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
using namespace std;

typedef long long ll;

ll MOD;
ll mem[40][2];

inline ll fast_mod( ll v ){
    if( v < MOD ) return v;
    else return v -= MOD;
}


    

int main(){
    int N;
    cin >> N >> MOD;
    
    bool mode = false;
    mem[3][true] = mem[5][true] = mem[6][true] = 2;
    mem[9][true] = mem[10][true] = mem[12][true] = 1;
    
    for( int i = 3; i <= N; ++i ){
        
        char G = 5;
        if( i == 2 || i == N-1 ) G = 4;
        if( i == N ) G = 3;
        
        for( char j = 0; j < 32; ++j ) 
            mem[j][mode] = 0;
            
        for( char j = 0; j < 32; ++j ){
           char M = j;
           if( i > 3 )M >>= 1;

           
           for( char k = 0; k < G; ++k )
               if( !(M & (1<<k)) )
                   mem[ M | (1<<k) ][mode] = fast_mod(mem[ M | (1<<k) ][mode] + mem[j][!mode]);

        }

        mode = !mode;
    }
    ll sol = 0;
    for( char i = 0; i < 32; ++i )
       sol += mem[i][!mode];
    
    cout<< fast_mod(sol)% MOD <<endl;;
    system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <math.h>
#include <queue>
using namespace std;

int N,M,v;
const double PI = acos(0) * 2;
double arr[100006];

bool ok ( double m ){
   int cnt = 0;
   for( int i = 0; i < N; ++i ){
        cnt += (int)floor( arr[i] / m );
        if( cnt >= M ) return true; 
   }
   return false;
}

int main(){
    int tests;
    scanf("%d",&tests);
    
    for( ; tests; --tests ){
        
        scanf("%d%d",&N,&M);
        M++;
        
        for( int i = 0; i < N; ++i ){
             scanf("%d",&v);
             arr[i] =  v*v*PI;
        }
        
        double lo = 0 , hi  = 10000*10000*PI;
        double mid;
        
        while( hi-lo > 0.0001 ){
            mid = (hi+lo) / 2.0;
   
            bool b = ok(mid);
            
            
            if( ok(mid) )
               lo = mid + 0.0001;
            else
               hi = mid - 0.0001;
        }
        
        
        printf("%.4lf\n",lo);
    }
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <set>
#include <queue>
using namespace std;

typedef long long ll;

int main(){
    int n;
    ll v;
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%lld",&v);
        
        int sol =(int) (   ceil(sqrt( v*8+1 ))    )/ 2;
        
        printf("%d\n",sol);
    }
    return 0;
}

#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
int K[4];

int main()
{
    scanf("%d%d%d",&K[0],&K[1],&K[2]);
    printf("%d\n",max( (K[1]-K[0])-1,(K[2]-K[1])-1 ) );
    return 0;
}

#include <iostream>
#include <cstdio>
#include <math.h>
#include <string.h>
#include <string>
#include <set>
#include <stack>
#include <queue>
#include <iomanip>
#include <map>
#include <cstdlib>
#include <vector>
#include <sstream>
#include <fstream>
using namespace std;

typedef long long ll;

ll pow( ll a , ll b ){
    ll r = 1;
    for( int i = 0; i < b; ++i )
        r *= a;
    return r;
}

int main(){
    //FILE *in = fopen("Ulaz.txt","r");
    
    ll a , k;
    cin  >> a >> k;
    
    ll b = pow(10,k);
    
    ll z = a / b;
    ll y = (a / b) + 1;
    
    ll up = y * b;
    ll lo = z * b;
    
    ll da = up - a;
    ll db = a - lo;
    
    if( db >= da )
        cout<< up <<endl;
    else
        cout<< lo <<endl;
    system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <math.h>
#include <string.h>
#include <string>
#include <set>
#include <stack>
#include <queue>
#include <iomanip>
#include <map>
#include <cstdlib>
#include <vector>
#include <sstream>
#include <fstream>
#include <algorithm>
using namespace std;

map<int,int>M;
vector<int>V;
multiset< int > MS;

int arr[1005];

struct data{
    int num;
    int cnt;
    int idx;
    data ( int p1, int p2, int p3 ) : num(p1),cnt(p2),idx(p3){};
    data (){};
    bool operator < ( const data &d2 ) const {
         return cnt > d2.cnt || ( cnt == d2.cnt && idx < d2.idx );
    }
};

vector< data > ss;

int main(){
    FILE *in = stdin;
    
    int n,nepotrebno;
    fscanf(in,"%d%d",&n,&nepotrebno);
    
    for( int i = 1; i <= n; ++i ){
        fscanf(in,"%d",&arr[i]);
        if( M[ arr[i] ] == 0 )
            M[ arr[i] ] = i;
        
        V.push_back( arr[i] );
        MS.insert( arr[i] );
        
    }
    sort( V.begin() , V.end() );
    V.erase( unique(V.begin(),V.end() ) , V.end() );
    
    for( int i = 0; i < V.size(); ++i ){
        ss.push_back( data( V[i] , MS.count( V[i] ) , M[ V[i] ] )   );
    }
    
    sort( ss.begin() , ss.end() );
    
    for( int i = 0; i < ss.size(); ++i )
        for( int j = 0; j < ss[i].cnt; ++j )
            printf("%d ", ss[i].num );
    putchar( '\n');
    
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
using namespace std;

typedef long long ll;

string ItoS( ll v ){
    string r = "";
    while( v ){
        r += string(1,(v%10)+'0' );
        v /= 10;
    }
    reverse(r.begin(),r.end());
    return r;
}

class CalcRoot {
    public:
        string approximate(int N, int D)
        {
            double sn = sqrt( (double)N );
            ll sA(0),sB(0);
            double d = 999999;
            for( int i = 1; i <= D; ++i ){
                double A = sn * i;
                ll a1 = (ll)ceil(A);
                ll a2 = (ll)floor(A);
                
                double d1 = a1 / (double)i;
                double d2 = a2 / (double)i;
                
                if( fabs(d1-sn) < d )
                    sA = a1 , sB = i ,d = fabs(d1-sn);
                
                if( fabs(d2-sn) < d )
                    sA = a2 , sB = i ,d = fabs(d2-sn);
            }
            
            int g = __gcd(sA,sB);
            sA /= g;
            sB /= g;
            
            return ItoS(sA) + "/" + ItoS(sB);
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const string &Expected, const string &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arg0 = 4; int Arg1 = 10; string Arg2 = "2/1"; verify_case(0, Arg2, approximate(Arg0, Arg1)); }
	void test_case_1() { int Arg0 = 5; int Arg1 = 3; string Arg2 = "7/3"; verify_case(1, Arg2, approximate(Arg0, Arg1)); }
	void test_case_2() { int Arg0 = 12; int Arg1 = 10; string Arg2 = "31/9"; verify_case(2, Arg2, approximate(Arg0, Arg1)); }
	void test_case_3() { int Arg0 = 23743; int Arg1 = 763; string Arg2 = "98462/639"; verify_case(3, Arg2, approximate(Arg0, Arg1)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    CalcRoot c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
using namespace std;

string PI = "3.141592653589793238462643383279";

class PiCalculator {
    public:
        string calculate(int precision)
        {
            string r = PI.substr(0,precision+2);
            if( PI[precision+2] >= '5' ){
                reverse(r.begin(),r.end());
                r[0]++;
                if( r[0] == ':' )r[0] = '0',r[1]++;
                reverse(r.begin(),r.end());
            }
                
            return r;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const string &Expected, const string &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arg0 = 2; string Arg1 = "3.14"; verify_case(0, Arg1, calculate(Arg0)); }
	void test_case_1() { int Arg0 = 4; string Arg1 = "3.1416"; verify_case(1, Arg1, calculate(Arg0)); }
	void test_case_2() { int Arg0 = 12; string Arg1 = "3.141592653590"; verify_case(2, Arg1, calculate(Arg0)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    PiCalculator c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
using namespace std;


class CalcButton {
    public:
        string getDigits(vector <string> sequence)
        {
            string txt = "";
            for( int i = 0; i < sequence.size(); ++i )
                txt += sequence[i];
            
            int mxx = 0;
            string sol = "000";
            
            for( int i = 0; i <= 9; ++i ){
                for( int j = 0; j <= 9; ++j ){
                    for( int k = 0; k <= 9; ++k ){
                         
                        int cnt = 0;
                        string cmb = string(1,'0'+i) + string(1,'0'+j) + string(1,'0'+k);
                        
                        for( int l = 0; l < txt.size(); ++l ){
                            if( l+2 < txt.size() && txt[l] == cmb[0] && txt[l+1] == cmb[1] && txt[l+2] == cmb[2] )
                                cnt++,l+=2;
                        }

                        if( cnt > mxx )
                           mxx = cnt, sol = cmb;
                        
                    }
                }
            }
            return sol;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const string &Expected, const string &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { string Arr0[] = {"100002000"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arg1 = "000"; verify_case(0, Arg1, getDigits(Arg0)); }
	void test_case_1() { string Arr0[] = {"777777777"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arg1 = "777"; verify_case(1, Arg1, getDigits(Arg0)); }
	void test_case_2() { string Arr0[] = {"6503","210"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arg1 = "032"; verify_case(2, Arg1, getDigits(Arg0)); }
	void test_case_3() { string Arr0[] = {"0993034","6","4137","45959935","25939","93993","0","9358333"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arg1 = "993"; verify_case(3, Arg1, getDigits(Arg0)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    CalcButton c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
using namespace std;

typedef long long ll;

const long long inf = 99999999999999999ll;
long long dp[55][55][55][2];
vector< int > *ns;
int k,mxd;

ll solve( int idx , int used , int prev , bool minus = false){
          
     if( dp[idx][used][prev][minus] != -1 )return dp[idx][used][prev][minus];
     
     if( idx  == ns->size() && used != k ) return -inf;
     if( used == k )
         return 1;
     
     
     
     if( minus == false ){
         ll sol = -inf;

         if( idx - prev <= mxd || used == 0 )
             sol =  solve( idx + 1 , used + 1 , idx , minus ^ (ns->at(idx) < 0 )   ) * ns->at(idx);
         
         ll g = solve( idx + 1 , used , prev , minus);

         if( abs(sol) >= inf ) sol = -inf;
         if( abs( g ) <  inf )
             sol = max( sol , g );

         return dp[idx][used][prev][minus] = sol;
     
     }else{
         ll sol = inf;

         if( idx - prev <= mxd || used == 0 )
             sol =  solve( idx + 1 , used + 1 , idx , minus ^ (ns->at(idx) < 0 )   ) * ns->at(idx);
         
         ll g = solve( idx + 1 , used , prev , minus);
         
         if( abs(sol) >= inf ) sol = inf;
         if( abs( g ) < inf )
             sol = min( sol , g );

         return dp[idx][used][prev][minus] = sol;
     } 
     
}

class TheProduct {
    public:
        long long maxProduct(vector <int> nums, int k, int mxD )
        {
            ns = &nums;
            ::k = k;
            mxd = mxD;
            
            memset( dp , -1, sizeof(dp));
            
            return solve( 0 , 0 , 0 );
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const long long &Expected, const long long &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arr0[] = {-1, -1,-1,-1}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 4; int Arg2 = 4; long long Arg3 = 1LL; verify_case(0, Arg3, maxProduct(Arg0, Arg1, Arg2)); }
	void test_case_1() { int Arr0[] = {7, 4, 7}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 2; int Arg2 = 50; long long Arg3 = 49LL; verify_case(1, Arg3, maxProduct(Arg0, Arg1, Arg2)); }
	void test_case_2() { int Arr0[] = {-3, -5, -8, -9, -1, -2}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 3; int Arg2 = 3; long long Arg3 = -10LL; verify_case(2, Arg3, maxProduct(Arg0, Arg1, Arg2)); }
	void test_case_3() { int Arr0[] = {3, 0, -2, 10, 0, 0, 3, -8, 0, 2}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 2; int Arg2 = 2; long long Arg3 = 0LL; verify_case(3, Arg3, maxProduct(Arg0, Arg1, Arg2)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    TheProduct c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
using namespace std;


class ToolsBox {
    public:
        int countTools(vector <string> need)
        {
            string v;
            set< string > S;
            for( int i = 0; i < need.size(); ++i ){
                stringstream in1( need[i] );
                while( in1.eof() == false ){
                    in1 >> v;
                    S.insert( v );
                }
            }
            return S.size();
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { string Arr0[] = {"SAW HAMMER SCREWDRIVER","SCREWDRIVER HAMMER KNIFE"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 4; verify_case(0, Arg1, countTools(Arg0)); }
	void test_case_1() { string Arr0[] = {"SAW"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 1; verify_case(1, Arg1, countTools(Arg0)); }
	void test_case_2() { string Arr0[] = {"SAW","SAW"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 1; verify_case(2, Arg1, countTools(Arg0)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    ToolsBox c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

#define ok(y,x) (x>=0&&x<W&&y>=0&&y<H&&maze[y][x]=='.')

int H,W;
bool visi[100][100];
int dist[100][100];

class MazeMaker {
    public:
        int longestPath(vector <string> maze, int ys, int xs, vector <int> moveRow, vector <int> moveCol)
        {
            memset(dist,-1,sizeof(dist));
            memset(visi,0,sizeof(visi));
            dist[ys][xs] = 0;
            visi[ ys ][ xs ] = true;
            H = maze.size();
            W = maze[0].size();
            queue < pii > Q;
            Q.push( mk(ys,xs) );
            
            while(!Q.empty() ){
                pii u = Q.front(); Q.pop();
                for( int i = 0; i < moveRow.size(); ++i ){
                    int yn = u.f + moveRow[i];
                    int xn = u.s + moveCol[i];
                    if( ok(yn,xn) && visi[yn][xn] == false ){
                        Q.push( mk(yn,xn) );
                        dist[yn][xn] = dist[u.f][u.s] + 1;
;
                        visi[yn][xn] = true;
                    }
                }
            }
            
            int sol = 0;
            for( int i = 0; i < maze.size() && sol != -1; ++i ){
                for( int j = 0; j < maze[i].size() && sol != -1; ++j ){
                    if( maze[i][j] == '.' ){
                        if( dist[i][j] == -1 )
                            sol = -1;
                        else
                            sol = max( sol , dist[i][j] );
                            

                    } 
                }
            }
            return sol;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); if ((Case == -1) || (Case == 5)) test_case_5(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { string Arr0[] = {"...",
 "...",
 "..."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 0; int Arg2 = 1; int Arr3[] = {1,0,-1,0}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0,1,0,-1}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = 3; verify_case(0, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_1() { string Arr0[] = {"...",
 "...",
 "..."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 0; int Arg2 = 1; int Arr3[] = {1, 0, -1, 0, 1, 1, -1, -1}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0, 1, 0, -1, 1, -1, 1, -1}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = 2; verify_case(1, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_2() { string Arr0[] = {"X.X",
 "...",
 "XXX",
 "X.X"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 0; int Arg2 = 1; int Arr3[] = {1, 0, -1, 0}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0, 1, 0, -1}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = -1; verify_case(2, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_3() { string Arr0[] = {".......",
 "X.X.X..",
 "XXX...X",
 "....X..",
 "X....X.",
 "......."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 5; int Arg2 = 0; int Arr3[] = {1, 0, -1, 0,-2, 1}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0, -1, 0, 1, 3, 0}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = 7; verify_case(3, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_4() { string Arr0[] = {"......."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 0; int Arg2 = 0; int Arr3[] = {1, 0, 1, 0, 1, 0}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0, 1, 0, 1, 0, 1}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = 6; verify_case(4, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }
	void test_case_5() { string Arr0[] = {"..X.X.X.X.X.X."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 0; int Arg2 = 0; int Arr3[] = {2,0,-2,0}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arr4[] = {0,2,0,-2}; vector <int> Arg4(Arr4, Arr4 + (sizeof(Arr4) / sizeof(Arr4[0]))); int Arg5 = -1; verify_case(5, Arg5, longestPath(Arg0, Arg1, Arg2, Arg3, Arg4)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    MazeMaker c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
using namespace std;

vector<int>digis[100];

class DoubleXor {
    public:
        int calculate(int N)
        {
            int xx = 0;
            vector<int>d;
            for( int i = 0; i < 20; ++i )
                digis[i].clear();
            
            
            for( int i = 1; i <= N; ++i ){
                
                int j = i;
                d.clear();

                
                while( j ){
                    d.push_back(j%10);
                    j/=10;
                }
                
                if( i == N )
                   xx = d.size();
                

                for( j = 0; j < d.size(); ++j )
                    digis[j].push_back( d[j] );
            }
            int sol = 0;
            int xrr;
            for( int i = xx-1; i >= 0; --i ){
                xrr = 0;
                
                for( int j = digis[i].size()-1; j >= 0; --j )
                    xrr  = (xrr^digis[i][j])%10;

                sol = sol*10 + xrr;
            }
            return sol;
        }
        



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arg0 = 123456; int Arg1 = 123012; verify_case(0, Arg1, calculate(Arg0)); }
	void test_case_1() { int Arg0 = 2; int Arg1 = 3; verify_case(1, Arg1, calculate(Arg0)); }
	void test_case_2() { int Arg0 = 7; int Arg1 = 0; verify_case(2, Arg1, calculate(Arg0)); }
	void test_case_3() { int Arg0 = 10; int Arg1 = 11; verify_case(3, Arg1, calculate(Arg0)); }
	void test_case_4() { int Arg0 = 102; int Arg1 = 103; verify_case(4, Arg1, calculate(Arg0)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    DoubleXor c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
using namespace std;

int M;
int sz = 0;
int cost[] = {6,3,5,5,4,5,6,3,7,6};
int bits[] = {119,19,93,91,58,107,111,82,127,123};

vector<int>binary;

string str = "";

long long dp[30][100][100];

long long solve( int idx , int plus , int minus ){
    if( dp[idx][plus][minus] != -1 )return dp[idx][plus][minus];
    
    if( idx == binary.size() )
        return ( plus == minus && plus <= M);

    
    long long ss = 0;
    for( int i = 0; i <= 9; ++i ){
        int m = 0 , p = 0;
        for( int j = 0; j <= 10; ++j ){
            int d1 = binary[idx]&(1<<j);
            int d2 = bits[i]&(1<<j);
            if( d1 && !d2 )p++;
            if( !d1 && d2 )m++; 
        }

        string tmp = str;
        
        

        str = str + string(1,'0'+i);
        ss += solve( idx + 1 , plus + p , minus + m );
        
        str = tmp;
    }
    
    return dp[idx][plus][minus] = ss;
}



class NumbersAndMatches {
    public:
        long long differentNumbers(long long N, int K)
        {
            M = K;

            binary.clear();
            memset( dp, -1, sizeof(dp) );
            
            long long T = N;
            sz = 0;
            while( T ){
                binary.push_back( bits[T % 10] );
                T /= 10;
            }

            long long ss = solve( 0 , 0 , 0 );
            return ss;
            
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const long long &Expected, const long long &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { long long Arg0 = 58866962718526LL; int Arg1 = 18; long long Arg2 = 2796495743545ll; verify_case(0, Arg2, differentNumbers(Arg0, Arg1)); }
	void test_case_1() { long long Arg0 = 23LL; int Arg1 = 1; long long Arg2 = 4LL; verify_case(1, Arg2, differentNumbers(Arg0, Arg1)); }
	void test_case_2() { long long Arg0 = 66LL; int Arg1 = 2; long long Arg2 = 15LL; verify_case(2, Arg2, differentNumbers(Arg0, Arg1)); }
	void test_case_3() { long long Arg0 = 888888888LL; int Arg1 = 100; long long Arg2 = 1LL; verify_case(3, Arg2, differentNumbers(Arg0, Arg1)); }
	void test_case_4() { long long Arg0 = 444444444444444444LL; int Arg1 = 2; long long Arg2 = 1LL; verify_case(4, Arg2, differentNumbers(Arg0, Arg1)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    NumbersAndMatches c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
using namespace std;

int M;
int sz = 0;
int cost[] = {6,3,5,5,4,5,6,3,7,6};
int bits[] = {119,19,93,91,58,107,111,82,127,123};

vector<int>binary;

long long dp[30][100][100];

long long solve( int idx , int plus , int minus ){
    if( dp[idx][plus][minus] != -1 )return dp[idx][plus][minus];
    
    if( idx == binary.size() )
        return ( plus == minus && plus <= M);
    
    long long ss = 0;
    for( int i = 0; i <= 9; ++i ){
        int m = 0 , p = 0;
        for( int j = 0; j <= 10; ++j ){
            int d1 = binary[idx]&(1<<j) , d2 = bits[i]&(1<<j);
            if( d1 && !d2 )p++;
            if( !d1 && d2 )m++; 
        }
        
        ss += solve( idx + 1 , plus + p , minus + m );

    }
    
    return dp[idx][plus][minus] = ss;
}



class NumbersAndMatches {
    public:
        long long differentNumbers(long long N, int K)
        {
            M = K;
            sz = 0;
            long long T = N;

            memset( dp, -1, sizeof(dp) );
            
            while( T ){
                binary.push_back( bits[T % 10] );
                T /= 10;
            }

            long long ss = solve( 0 , 0 , 0 );
            return ss;
            
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const long long &Expected, const long long &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { long long Arg0 = 58866962718526LL; int Arg1 = 18; long long Arg2 = 2796495743545ll; verify_case(0, Arg2, differentNumbers(Arg0, Arg1)); }
	void test_case_1() { long long Arg0 = 23LL; int Arg1 = 1; long long Arg2 = 4LL; verify_case(1, Arg2, differentNumbers(Arg0, Arg1)); }
	void test_case_2() { long long Arg0 = 66LL; int Arg1 = 2; long long Arg2 = 15LL; verify_case(2, Arg2, differentNumbers(Arg0, Arg1)); }
	void test_case_3() { long long Arg0 = 888888888LL; int Arg1 = 100; long long Arg2 = 1LL; verify_case(3, Arg2, differentNumbers(Arg0, Arg1)); }
	void test_case_4() { long long Arg0 = 444444444444444444LL; int Arg1 = 2; long long Arg2 = 1LL; verify_case(4, Arg2, differentNumbers(Arg0, Arg1)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    NumbersAndMatches c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
using namespace std;

int ss( int v ){
    int ret = 0;
    while( v ){
        ret += v % 10;
        v /= 10;
    }
    return ret;
}

class MinimalDifference {
    public:
        int findNumber(int A, int B, int C)
        {
            C = ss( C );
            int now = 99999999;
            int sol = 0;
            for( int i = A; i <= B; ++i ){
                int z = ss( i );
                if( abs(C-z) < now ){
                    sol = i;
                    now = abs(C-z);
                }
            }
            if( now == 99999999 )
                return -1;
            else
                return sol;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arg0 = 1; int Arg1 = 9; int Arg2 = 10; int Arg3 = 1; verify_case(0, Arg3, findNumber(Arg0, Arg1, Arg2)); }
	void test_case_1() { int Arg0 = 11; int Arg1 = 20; int Arg2 = 20; int Arg3 = 11; verify_case(1, Arg3, findNumber(Arg0, Arg1, Arg2)); }
	void test_case_2() { int Arg0 = 1; int Arg1 = 1; int Arg2 = 999; int Arg3 = 1; verify_case(2, Arg3, findNumber(Arg0, Arg1, Arg2)); }
	void test_case_3() { int Arg0 = 100; int Arg1 = 1000; int Arg2 = 99; int Arg3 = 189; verify_case(3, Arg3, findNumber(Arg0, Arg1, Arg2)); }
	void test_case_4() { int Arg0 = 1987; int Arg1 = 9123; int Arg2 = 1; int Arg3 = 2000; verify_case(4, Arg3, findNumber(Arg0, Arg1, Arg2)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    MinimalDifference c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
using namespace std;

bool ok( string a, string b ){
    sort( a.begin() , a.end() );
    sort( b.begin() , b.end() );
    
    for( int i = 0; i < a.size(); ++i )
       if( a[i] != b[i] )return false;
    return true;
}


class WordsGame {
    public:
        int minimumSwaps(vector <string> grid, string word)
        {
            vector< string > S;
            for( int i = 0; i < grid[0].size(); ++i ) {
                string ins = "";
                for( int j = 0; j < grid.size(); ++j )
                    ins += grid[j][i];
                S.push_back( ins );
            }
            for( int i = 0; i < grid.size(); ++i ){
                S.push_back( grid[i] );
            }
            
            int sol = -1;
            for( int i = 0; i < S.size(); ++i ){
                if( ok( word , S[i] ) == false )continue;
                
                int ss = 0;
                
                bool ok = true;
                while( ok ){
                    ok = false;
                    for( int j = 0; j < word.size(); ++j ){
                        for( int k = j+1; k < word.size(); ++k ){
                           if( word[j] == S[i][j] ) continue;
                           if( word[j] == S[i][k] ){
                                ss++; 
                                ok = true;
                                swap( S[i][k] , S[i][j] );
                           }
                       }
                   }
                }

                if( sol == -1 ) sol = ss;
                else sol = min( sol , ss );
                
            }
            
            return sol;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); if ((Case == -1) || (Case == 5)) test_case_5(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { string Arr0[] = {"Mu",
 "uM"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arg1 = "Mu"; int Arg2 = 0; verify_case(0, Arg2, minimumSwaps(Arg0, Arg1)); }
	void test_case_1() { string Arr0[] = {"sdf",
 "bca",
 "hgf"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arg1 = "abc"; int Arg2 = 2; verify_case(1, Arg2, minimumSwaps(Arg0, Arg1)); }
	void test_case_2() { string Arr0[] = {"cdf",
 "bca",
 "agf"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arg1 = "abc"; int Arg2 = 1; verify_case(2, Arg2, minimumSwaps(Arg0, Arg1)); }
	void test_case_3() { string Arr0[] = {"xSZB",
 "gbHk",
 "kbgH",
 "WFSg"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arg1 = "bkHg"; int Arg2 = 2; verify_case(3, Arg2, minimumSwaps(Arg0, Arg1)); }
	void test_case_4() { string Arr0[] = {"eKUNGHktLB",
 "EtBFDndTlG",
 "RRFHmjwrDs",
 "eKYsHlYhlu",
 "ljxyJSwTds",
 "dUQToyWHvl",
 "azDPWRwioE",
 "EARdktoDBh",
 "dmIqcGSvCE",
 "wXypNQEMxz"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arg1 = "oDmWcJHGNk"; int Arg2 = 6; verify_case(4, Arg2, minimumSwaps(Arg0, Arg1)); }
	void test_case_5() { string Arr0[] = {"ab",
 "bA"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arg1 = "aB"; int Arg2 = -1; verify_case(5, Arg2, minimumSwaps(Arg0, Arg1)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    WordsGame c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <math.h>
#include <queue>
#include <set>
#include <stack>
#include <iomanip>
#include <map>
using namespace std;

typedef long long ll;


int N;
int arr[100006];
int dp[20][100006];


struct suffix{
    int prev , nxt , idx;
    
    bool operator<( const suffix &sfx ) const {
        return prev < sfx.prev || ( prev == sfx.prev && nxt < sfx.nxt );
    }
    
}L[100006];

int LF[100006];
int RG[100006];

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d",&N);
    
    for( int i = 0; i < N; ++i ){
        fscanf(in,"%d",&arr[i]);
        dp[0][i] = arr[i];
    }
    
    int stp,cnt;
    for( stp = 1 , cnt = 1; (cnt>>1) < N ; cnt<<=1 , stp++ ){
        
        for( int i = 0; i < N; ++i ){
            L[i].prev = dp[stp-1][i];
            L[i].nxt  = i+cnt < N ? dp[ stp-1 ][ i+cnt ] : -1;
            L[i].idx = i;
        }
        
        sort( L , L + N);
        
        int id = 0;
        for( int i = 0; i < N; ++i)
            dp[stp][ L[i].idx ] = i>0 && L[i].prev == L[i-1].prev && L[i].nxt == L[i-1].nxt ? dp[stp][ L[i-1].idx ] : id++;
        
        if( id==N-1){ stp++; break; }
    }
    
    vector< int > h;
    for( int i = 0; i < N-1; ++i ){
        
        int common = 0;
        int f = L[i].idx;
        int s = L[i+1].idx;
        
        for( int stage = stp-1 ; stage >=0 && f<N && s<N ; stage -- ){
            if( dp[stage][f] == dp[stage][s] )
                f += 1<<stage , s += 1<<stage , common += 1<<stage;
        }
        h.push_back( common );
    }
    
    stack<int>S;
    for( int i = 0; i < h.size(); ++i ){
         
       while( S.empty() == false && h[ S.top() ] >= h[i] )S.pop();
       
       if( S.empty() == true )
            LF[ i ] = -1;
       else
            LF[ i ] = S.top();
          
       S.push(i);
    }
    
    while( S.empty() == false )S.pop();
    
    
    for( int i = (int)h.size()-1; i >= 0; --i ){
        while( S.empty() == false && h[ S.top() ] >= h[i] )S.pop();
           
        if( S.empty() == true )
            RG[ i ] = h.size();
        else
            RG[ i ] = S.top();
           
        S.push(i);
    }
    
    ll sol = -1;
    int idx,len;
    
    for( int i = 0; i < h.size(); ++i ){
        ll v = h[i] * (ll)( RG[i] - LF[i] -1 );

        if( v == 0 )continue;
        
        if( v > sol ){
            idx = i , len = h[i];
            sol = v;
        }
    }
    
    if( sol == -1 )
        printf("-1\n");
    else{
        for( int i = 0; i < len; ++i )
            printf("%d ",arr[ L[idx].idx+i ] );
        printf("\n");
    }
    
    //system("pause");

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int N,M;
int dp[100][100];
bool open[100];

int solve( int idx , int cnt ){
   if( idx == N ){
       if( cnt == 0 )return 1;
       else return 0;
   }
   
   if( dp[idx][cnt] != -1 )return dp[idx][cnt];
   
   int ss = 0;
   if( open[idx] == false && cnt > 0 )
       ss += solve( idx + 1 , cnt - 1 );
   ss += solve( idx + 1 , cnt + 1 );

   
   return dp[idx][cnt] = ss;
}

int main(){
    int tests,p1;
    scanf("%d",&tests);
    
    for( ; tests ; --tests ){
        scanf("%d%d",&N,&M);
        N *= 2;
        
        memset( open, false , sizeof(open) );
        for( int i = 0; i < M; ++i ){
             scanf("%d",&p1);
             open[p1-1] = true; 
        }
        
        memset( dp, -1,sizeof(dp));
        printf("%d\n",solve( 0 , 0 )  );
        
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int n;
int niz[2005];
int dp[2005][2005];

int solve( int i , int j ){
    int day = i + (n-j);

    if( i == j ) return niz[i]*day;
    if( dp[i][j] != -1 )return dp[i][j];
    
    int ss1 = solve( i+1 , j ) + niz[i]*day;
    int ss2 = solve( i , j-1 ) + niz[j]*day;
    
    return dp[i][j] = max(ss1,ss2);
}


int main(){
    memset( dp , -1 , sizeof(dp));
    scanf("%d",&n);
    
    for( int i = 0; i < n; ++i )
        scanf("%d",&niz[i]);
    
    printf("%d\n", solve( 0 , n-1 ) );
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <queue>
#include <stack>
#include <set>
using namespace std;

int N,C;
int arr[105];
int prv[105];

bool mono( int *pok , int sz ){
   for( int i = 1; i < sz; ++i )
       if( pok[i] != pok[i-1] )
           return false;
   return true;
}


void solve( int *pok , int sz ){
    if( mono( pok , sz ) ){
        for( int i = 0; i < sz+C; ++i ){
            prv[i] = pok[0];
            pok[i] = pok[0];
        }
    }else{
        int *mm = new int[105];
        for( int i = 0; i < sz-1; ++i )
           mm[i] = pok[i+1] - pok[i];
        
        solve( mm , sz-1 );
        
        for( int i = sz; i < sz+C; ++i )
            pok[i] = pok[i-1] + prv[i-1];
        for( int i = 0; i < sz+C; ++i )
            prv[i] = pok[i];
        delete [] mm;
    }
}

int main(){
 //   freopen("Ulaz.txt","r",stdin);
 //   freopen("Izlaz.txt","w",stdout);
    int tests;
    scanf("%d",&tests);
    
    for( ; tests; --tests ){
        scanf("%d%d",&N,&C);
        
        for( int i = 0; i < N; ++i )
            scanf("%d",&arr[i]);
        
        solve( arr , N );
        
        for( int i = N; i < N+C; ++i )
            printf("%d ",arr[i]);
            printf("\n");
        
    }
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
using namespace std;

struct triple{
    int a,b,c;
    triple(int p1, int p2, int p3):a(p1),b(p2),c(p3){};
    triple(){};
    bool operator<(const triple &t2 ) const {
        return a < t2.a || ( a == t2.a && b < t2.b && ( a == t2.a && b == t2.b && c < t2.c ));
    }
};

vector< triple >ss[1000009];

int main(){
    for( int i = 2; i <= 100; ++i ){
        for( int j = i; j <= 100; ++j ){
            for( int k = j; k <= 100; ++k ){
                
                int v = i*i*i + j*j*j + k*k*k;
                
                if( v > 1000000 ) break;
                
                ss[v].push_back( triple( i , j , k )  );
            }
        }
    }
    
    for( int i = 1; i <= 100; ++i ){
        int z = i*i*i;
        sort( ss[z].begin() , ss[z].end() );

        for( int j = 0; j < ss[z].size(); ++j )
            printf("Cube = %d, Triple = (%d,%d,%d)\n",i,ss[z][j].a,ss[z][j].b,ss[z][j].c);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <string.h>
#include <queue>
using namespace std;

#define ok(x,y) (x>=0&&x<W&&y>=0&&y<H&&mp[y][x]!='X')

int H,W;
char mp[30][30];
bool visi[30][30];

int dx[][2] = {0,1 , 0,-1,  1,0 ,  -1,0 };

struct data{
    int x,y,dst;
    data(){};
    data( int p1, int p2, int p3 ):x(p1),y(p2),dst(p3){};
    bool operator < ( const data &d2 ) const {
        return dst > d2.dst;
    }
};

int xs,ys;

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    while( fscanf(in,"%d%d",&W,&H) == 2 ){
        if( H == 0 && W == 0 )break;
        memset( visi , false , sizeof( visi ) );
        
        
        for( int i = 0; i < H; ++i ){
            fscanf(in,"%s",mp[i]);
            for( int j = 0; j < W; ++j )
                if( mp[i][j] == 'S' )
                    xs = j , ys = i , mp[i][j] = '0';
        }
        
        data u;
        priority_queue< data > PQ;
        
        PQ.push( data(xs,ys,0) );
        
        
        while( !PQ.empty() ){
           u = PQ.top(); PQ.pop();
           
           if( visi[u.y][u.x] )continue;
           if( mp[u.y][u.x] == 'D' )break;
           
           visi[u.y][u.x] = true;
           
           for( int i = 0; i < 4; ++i ){
               int xn = u.x + dx[i][0];
               int yn = u.y + dx[i][1];
               
               if( ok(xn,yn) == false )continue;
               PQ.push( data(xn,yn, u.dst + (mp[u.y][u.x]-'0')  )  );
               
           }
           
        }
        printf("%d\n",u.dst);
        
    }
    
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;

int arr[4];

int GetV( char c ){
   if( c == 'C' ) return arr[2];
   if( c == 'B' ) return arr[1];
   if( c == 'A' ) return arr[0];
}

int main(){
    scanf("%d%d%d",&arr[0],&arr[1],&arr[2]);
    sort( arr , arr + 3 );
    
    string s;
    cin >> s;
    printf("%d %d %d",GetV( s[0] ) , GetV( s[1] ) , GetV( s[2] )  );
    putchar('\n');
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int N;
int arr[100005][3];
int cnt[100005][3];
vector<int>V[100005];

bool deleted[100005];
bool done[100005];


inline bool CanDelete( int v ){
    return cnt[v][0] == 0 || cnt[v][1] == 0 || cnt[v][2] == 0;
}


int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d",&N);
    
    for( int k = 0; k < 3; ++k ){
        for( int i = 0; i < N; ++i ){
            fscanf(in,"%d",&arr[i][k]);
            cnt[ arr[i][k] ] [k] ++;
            V[ arr[i][k] ].push_back( i );
        }
    }
    
    queue< int > Q;
    for( int i = 1; i <= N; ++i )
        if( CanDelete(i) ){
            Q.push( i );
            done[i] = true;
        }
    
    int sol = 0;
    while( !Q.empty() ){
        int u = Q.front();Q.pop();
        sol ++;
        
        for( int i = 0; i < V[u].size(); ++i ){
            if( deleted[ V[u][i] ] ) continue;
            
            deleted[ V[u][i] ] = true;
            
            cnt[ arr[ V[u][i] ][0] ][0] --;
            cnt[ arr[ V[u][i] ][1] ][1] --;
            cnt[ arr[ V[u][i] ][2] ][2] --;
            
            if( CanDelete( arr[ V[u][i] ][0] ) && done[ arr[ V[u][i] ][0] ] == false  ){
                 Q.push( arr[ V[u][i] ][0] );
                 done[ arr[ V[u][i] ][0] ] = true;
                 
            }
            if( CanDelete( arr[ V[u][i] ][1] ) && done[ arr[ V[u][i] ][1] ] == false  ){
                 Q.push( arr[ V[u][i] ][1] );
                 done[ arr[ V[u][i] ][1] ] = true;
            }
            if( CanDelete( arr[ V[u][i] ][2] ) && done[ arr[ V[u][i] ][2] ] == false  ){
                 Q.push( arr[ V[u][i] ][2] );
                 done[ arr[ V[u][i] ][2] ] = true;
            }
            
        }
    }
    printf("%d\n",sol);
  
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <string.h>
#include <math.h>
#include <cstdlib>
#include <queue>
#include <stack>
using namespace std;

#define pii pair<int,int>
#define x first
#define y second
#define mk make_pair

#define ok(x,y) (x>=0&&x<W&&y>=0&&y<H)

int H,W;
int mx[2005][2005];

void dfs( int v1 , int v2 ){
     
    stack< pii > stk;
    stk.push( mk(v1,v2) );
    
    while( !stk.empty() ){
       
       pii u = stk.top(); stk.pop();
       
       if( ok(u.x,u.y) == false )continue;
       if( mx[u.y][u.x] == 0 )continue;
       mx[u.y][u.x] = 0;
    
       stk.push( mk(u.x+1,u.y)   );
       stk.push( mk(u.x-1,u.y)   );
       stk.push( mk(u.x,u.y+1)   );
       stk.push( mk(u.x,u.y-1)   );
       stk.push( mk(u.x+1,u.y+1) );
       stk.push( mk(u.x-1,u.y-1) );
       stk.push( mk(u.x-1,u.y+1) );
       stk.push( mk(u.x+1,u.y-1) );
    }
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    fscanf(in,"%d%d",&H,&W);
    
    for( int i = 0; i < H; ++i )
       for( int j = 0; j < W; ++j )
          fscanf(in,"%d",&mx[i][j]);
    
    int sol = 0;
    for( int i = 0; i < H; ++i ){
        for( int j = 0; j < W; ++j ){
            if( mx[i][j] == 0 ) continue;
            dfs(j,i);
            sol ++;
        }
    }
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
using namespace std;
 
struct coord{
    int x,y;
    coord( int p1, int p2 ):x(p1),y(p2){};
    coord(){};
};        

int n,s;
int Ti[20006], t[20006];
int Fi[20006], f[20006];
int dp[20006];
const int inf = (1<<31) - 1;

int cross( coord A , coord B , coord T ){ // < 0 cw   , > 0 ccw
    return (B.x-A.x)*(T.y-A.y) - (B.y-A.y)*(T.x-A.x);
}


int cnt = 0;
coord hull[10006];

void AddHull( int x , int y ){
    coord D = coord(x,y);
    while( cnt >= 2 && cross( hull[cnt-2] , hull[cnt-1] , D ) >= 0 )
        cnt --;
    hull[cnt++] = D;
}          

 
int main(){    
    scanf("%d%d",&n,&s);
   
    for( int i = 0; i < n; ++i ){
        scanf("%d%d",&Ti[i],&Fi[i]);
        t[i] += Ti[i];
        f[i] += Fi[i];
        if(i) t[i] += t[i-1] , f[i] += f[i-1];
    }
   
    for( int i = 0; i <= n; ++i )
        dp[i] = inf;
    dp[n] = 0;
    
    for( int i = n-1; i >= 0; --i ){     
        int Z = -t[i-1]*f[n-1] + t[i-1]*f[i-1] + s*f[n-1] - s*f[i-1];
        int F =  f[n-1]-f[i-1]; 
        
        for( int j = 0; j < cnt; ++j )
            dp[i] = min( dp[i] , hull[j].x*F + hull[j].y );
        dp[i] = min( dp[i] , t[i]*F + dp[i+1] );
        
        dp[i] += Z;
        AddHull( t[i] , dp[i+1] );
        

    }
    
    
    
    printf("%d\n",dp[0]);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
using namespace std;
 
int n,s;
int Ti[20006], t[20006];
int Fi[20006], f[20006];
int dp[20006];
const int inf = (1<<31) - 1;
 
int main(){
    scanf("%d%d",&n,&s);
   
    for( int i = 0; i < n; ++i ){
        scanf("%d%d",&Ti[i],&Fi[i]);
        t[i] += Ti[i];
        f[i] += Fi[i];
        if(i) t[i] += t[i-1] , f[i] += f[i-1];
    }
   
    for( int i = 0; i <= n; ++i )
        dp[i] = inf;
    dp[n] = 0;
   
    for( int i = n-1; i >= 0; --i ){     
        int Z = -t[i-1]*f[n-1] + t[i-1]*f[i-1] + s*f[n-1] - s*f[i-1];
        int F =  f[n-1]-f[i-1]; // increasing
             
             
        cout<<" PLY: "<<i<<endl;
        for( int j = i; j < n; ++j ){
            cout<<"  "<<t[j]*F + dp[j+1] + Z  <<endl;
            dp[i] = min( dp[i] , t[j]*F + dp[j+1] );
        }
        dp[i] += Z;

    }
    
    
    
    printf("%d\n",dp[0]);
    system("Pause");
    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
using namespace std;

int arr[9];

int main(){
    int sum = 0;
    for( int i = 0; i < 9; ++i ){
         scanf("%d",&arr[i]);
         sum += arr[i];
    }
    
    for( int i = 0; i < 9; ++i )
        for( int j = i+1; j < 9; ++j )
            if( sum - arr[i] - arr[j] == 100 ){
                for( int k = 0; k < 9; ++k )
                    if( k != i && k != j )
                        printf("%d\n",arr[k]);
                return 0;    
            }
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <math.h>
#include <string.h>
#include <string>
#include <set>
#include <stack>
#include <queue>
#include <iomanip>
#include <map>
#include <cstdlib>
#include <vector>
#include <sstream>
#include <fstream>
using namespace std;

int N,C,M;
int arr[300005];
vector<int>idxs[10005];


int binary( int c,  int A , bool mode ){
     int lo = 0 , hi = idxs[c].size() - 1;
     int ret = -99;
     
     if( mode == true ){
         while( lo <= hi ){
             
             int mid = (lo+hi) >> 1;
             
             if( idxs[c][mid] == A )return mid;
             else if( A < idxs[c][mid] )
                 ret = mid , hi = mid - 1;
             else
                 lo = mid + 1; 
         }
     }else{
         while( lo <= hi ){
             
             int mid = (lo+hi) >> 1;
             
             if( idxs[c][mid] == A )return mid;
             else if( A > idxs[c][mid] )
                 ret = mid , lo = mid + 1;
             else
                 hi = mid - 1; 
         }
     }
     return ret;
}


int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    fscanf(in,"%d%d",&N,&C);
    
    for( int i = 0; i < N; ++i ){
        fscanf(in,"%d",&arr[i]);
        idxs[ arr[i] ].push_back( i );     
    }
    
    int A,B;
    fscanf(in,"%d",&M);

    for( int i = 0; i < M; ++i ){
        fscanf(in,"%d%d",&A,&B);
        
        A--, B--;
        int A2,B2,GOT;
        int half = (B - A + 1) >> 1;
        
        int sol = 0;
        bool OK = false;
        
        int diff = B-A+1;

        for( int j = 1; j <= 50 && !OK; ++j ){
            
            int r = rand() % diff;
            
            int COLOR = arr[A + r ];
            
            A2 = binary( COLOR, A, true );
            B2 = binary( COLOR, B, false);
            
            
            if( A2 == -99 || B2 == -99 )
                continue;

            GOT = B2 - A2 + 1;

            if( GOT > half ){
               sol = COLOR;
               OK = true;
            }
        }
        
        if( OK )
            printf("yes %d\n",sol);
        else
            printf("no\n");
    }
    //system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <fstream>
#include <cstdlib>
#include <math.h>
#include <set>
#include <queue>
#include <stack>
using namespace std;

#define ok(x,y) (x>=0&&y>=0&&x<N&&y<N)

int N = 7;
char mx[100][100];



int main(){
    for( int i = 0; i < N; ++i ){
        for( int j = 0; ; ++j ){
             mx[i][j] = getchar();
             if( mx[i][j] == '\n' )break;
        }
    }
    
    int sol = 0;
    for( int i = 0; i < N; ++i ){
        for( int j = 0; j < N; ++j ){
            if( mx[i][j] != 'o' )continue;
            
            if( ok(j-2,i) && mx[i][j-1] == 'o' && mx[i][j-2] == '.' )sol++;
            if( ok(j+2,i) && mx[i][j+1] == 'o' && mx[i][j+2] == '.' )sol++;
            if( ok(j,i-2) && mx[i-1][j] == 'o' && mx[i-2][j] == '.' )sol++;
            if( ok(j,i+2) && mx[i+1][j] == 'o' && mx[i+2][j] == '.' )sol++;
        }
    }
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <math.h>
using namespace std;

int main(){
    int ss = 0,a,b,c;
    for( int i = 0; i < 3; ++i ){
        scanf("%d%d%d",&a,&b,&c);
        if( c < b ) swap( c , b );
        if( c < a ) swap( c , a );
        
        if( a*a + b*b == c*c )ss ++;
    }
    printf("%d\n",ss);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

int N,M;
set< string >S;
set< string >visited;

int main(){
    string s;
    
    scanf("%d",&N);
    for( int i = 0; i < N; ++i ){
        cin >> s;
        S.insert( s );
    }
    
    int sol = 0;
    int cnt = 0;
    int hlf = (int)ceil(N/2.0);
    
    scanf("%d",&M);
    
    
    for( ; sol < M; ++sol ){
        cin >> s;
        if( visited.count(s) == 1 )continue;
        
        if( S.count(s) == 1 )
            cnt ++;
        visited.insert(s);
        
        if( cnt == hlf )break;
    }
    printf("%d\n",sol+1);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#include <iomanip>
#include <math.h>
#include <cstdlib>
#include <string.h>
using namespace std;

struct cursor{
    int r,c,pos;
    cursor( int p1, int p2, int p3 ):r(p1),c(p2),pos(p3){};
    cursor(){};
};

int N;
int arr[105];

cursor Left( cursor C ){
    if( C.c == 0 ){
        C.r = C.r-1 >= 1 ? C.r-1 : N;
        C.c = arr[C.r];
    }else
        C.c --;
    C.pos = C.c;
    return C;
}

cursor Right( cursor C ){
    if( C.c  == arr[C.r] ){
        C.r = C.r+1 <= N ? C.r+1 : 1;
        C.c = 0;
    }else
        C.c ++;
    C.pos = C.c;
    return C;
}

cursor Up( cursor C ){
    if( C.r  == 1 ){
        C.r = N;
        C.c = min( C.pos , arr[C.r] );
    }else{
        C.r --;
        C.c = min( C.pos , arr[C.r] );
    }
    if( C.c < C.pos )
        C.c = arr[ C.r ];
    return C;
}

cursor Down( cursor C ){
    if( C.r  == N ){
        C.r = 1;
        C.c = min( C.pos , arr[C.r] );
    }else{
        C.r ++;
        C.c = min( C.pos , arr[C.r] );
    }
    if( C.c < C.pos )
        C.c = arr[ C.r ];
    return C;
}


cursor S;
cursor E;

int dp[105][105][105];

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d",&N);
    
    for( int i = 1; i <= N; ++i )
        fscanf(in,"%d",&arr[i]);
    
    fscanf(in,"%d%d%d%d",&S.r,&S.c,&E.r,&E.c);
    S.pos = S.c;
    
    queue < cursor > Q;
    Q.push( S );
    memset( dp , -1 , sizeof(dp) );
    dp[ S.r ][ S.c ][ S.pos ] = 0;
    
    while(!Q.empty() ){
        cursor u = Q.front();
        Q.pop();
        
        cursor up    = Up(u);
        cursor down  = Down(u);
        cursor left  = Left(u);
        cursor right = Right(u);
        
        if( dp[ up.r ][ up.c ][ up.pos ] == -1 ){
            dp[ up.r ][ up.c ][ up.pos ] = dp[ u.r ][ u.c ][ u.pos ] + 1;
            Q.push( up );
        }
        
        if( dp[ down.r ][ down.c ][ down.pos ] == -1 ){
            dp[ down.r ][ down.c ][ down.pos ] = dp[ u.r ][ u.c ][ u.pos ] + 1;
            Q.push( down );
        }
        
        if( dp[ left.r ][ left.c ][ left.pos ] == -1 ){
            dp[ left.r ][ left.c ][ left.pos ] = dp[ u.r ][ u.c ][ u.pos ] + 1;
            Q.push( left );
        }
        
        if( dp[ right.r ][ right.c ][ right.pos ] == -1 ){
            dp[ right.r ][ right.c ][ right.pos ] = dp[ u.r ][ u.c ][ u.pos ] + 1;
            Q.push( right );
        }
    }
    
    int sol = 9999999;
    for( int i = 0; i <= 100; ++i ){
        if( dp[ E.r ][ E.c ][ i ] != -1 )
        sol = min( sol , dp[ E.r ][ E.c ][ i ] );
    }
    
    printf("%d\n",sol);    

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int dp[1300000];
bool visi[1300000];
bool prime[1300000];

int main(){
    
    prime[1] = true;
    for( int i = 2; i <= 1300000; ++i ){
        if( visi[i] )continue;
        prime[i] = true;
        visi[i] = true;
        int j = 2;
        while( i*j <= 1300000 ){
            visi[i*j] = true , ++j;
        }
    }
    
    int N;
    
    while( scanf("%d",&N) == 1 ){
        
        if( N == 0 )break;
        
        int l = 0 , r = 0;
        while( prime[N+r] == false )r++;
        while( prime[N+l] == false )l--;
        
        printf("%d\n",r-l);
    }
    
    return 0;
}

#include <stdio.h>
#include <iostream>
using namespace std;

int  p, r, q;
char a[5000], f[5000], b, o, *s=f;

void interpret(char *c)
{
	char *d;

	r++;
	while( *c ) {
		//if(strchr("<>+-,.[]\n",*c))printf("%c",*c);
		switch(o=1,*c++) {
		case '<': p--;        break;
		case '>': p++;        break;
		case '+': a[p]++;     break;
		case '-': a[p]--;     break;
		case '.': putchar(a[p]); fflush(stdout); break;
		case ',': a[p]=getchar();fflush(stdout); break;
		case '[':
			for( b=1,d=c; b && *c; c++ )
				b+=*c=='[', b-=*c==']';
			if(!b) {
				c[-1]=0;
				while( a[p] )
					interpret(d);
				c[-1]=']';
				break;
			}
		case ']':
			puts("UNBALANCED BRACKETS"), exit(0);
		case '#':
			if(q>2)
				printf("%2d %2d %2d %2d %2d %2d %2d %2d %2d %2d\n%*s\n",
				       *a,a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],3*p+2,"^");
			break;
		default: o=0;
		}
		if( p<0 || p>100)
			puts("RANGE ERROR"), exit(0);
	}
	r--;
}

main(int argc,char *argv[])
{
	FILE *z;

	q=argc;

	if(z=fopen(argv[1],"r")) {
		while( (b=getc(z))>0 )
			*s++=b;
		*s=0;
		interpret(f);
	}
}


#include <iostream>
#include <vector>
#include <string.h>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <string>
#include <set>
#include <stack>
#include <queue>
#include <map>
#include <algorithm>
using namespace std;

int N,K;
char txt[10005][105];
char start;


bool visited[100005];
bool visic[255];
vector< int  >G[255];

vector< char >LEFT[255];
vector< char >RIGHT[255];

bool ok[255][255];
bool vss[255];
bool Y[255][255];
bool X[255][255];

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d%d",&N,&K);
    
    char c;
    for( int i = 0; i < N; ++i ){
       while( c = fgetc(in) )
           if( c >= 'a' && c <='z' )
               break;
       
       fscanf(in,"%s",txt[i]);
       G[c].push_back(  i  );
       LEFT[c].push_back( txt[i][0] );
       RIGHT[c].push_back( txt[i][ strlen(txt[i]) - 1 ]   );
    }
    for( int a = 'a'; a <= 'z'; ++a ){
        sort( LEFT[a].begin() , LEFT[a].end() );
        LEFT[a].erase( unique( LEFT[a].begin(), LEFT[a].end() ) , LEFT[a].end() );
        
        sort( RIGHT[a].begin() , RIGHT[a].end() );
        RIGHT[a].erase( unique( RIGHT[a].begin(), RIGHT[a].end() ) , RIGHT[a].end() );
    }
    
    for( int i = 'a'; i <= 'z'; ++i ){
        stack < char > S;
        memset( vss , false , sizeof(vss));
        S.push( i );
        
        
        while( S.empty() == false ){
            char u = S.top(); S.pop();
            for( int j = 0; j < LEFT[u].size(); ++j ){
                 if( vss[ LEFT[u][j] ] ) continue;
                 vss[ LEFT[u][j] ] = true;
                 Y[i][ LEFT[u][j] ] = true;
                 S.push( LEFT[u][j] );
            }
        }
        
        memset( vss , false , sizeof(vss));
        S.push( i );
        
        while( S.empty() == false ){
            char u = S.top(); S.pop();
            for( int j = 0; j < RIGHT[u].size(); ++j ){
                 if( vss[ RIGHT[u][j] ] ) continue;
                 vss[ RIGHT[u][j] ] = true;
                 X[ i ][ RIGHT[u][j] ] = true;
                 S.push( RIGHT[u][j] );
            }
        }
    }
    
    
    
    
    while( start = getc(in) )
           if( start >= 'a' && start <='z' )
               break;
    stack< int >S;
    S.push( 10000 ); txt[10000][0] = start , txt[10000][1] = '\0';

    while( S.empty() == false ){
        int u = S.top(); S.pop();
        int len = strlen( txt[u] );
        
        for( int i = 0; i < len; ++i ){
            if( visic[ txt[u][i] ] ) continue;
            visic[ txt[u][i] ] = true;

            for( int j = 0; j < G[ txt[u][i] ].size(); ++j ){
                if( visited[ G[ txt[u][i] ][j] ] == false ){
                    visited[ G[ txt[u][i] ][j] ] = true;
                    S.push(  G[ txt[u][i] ][j] );
                }
            }

        }
    }
    for( int i = 0; i < N; ++i ){
        if( visited[i] == false )continue;
        for( int j = 0; j < strlen( txt[i] )-1; ++j ){
            ok[ txt[i][j] ] [ txt[i][j+1] ] = true;
        }
    }
    for( int i = 'a'; i <= 'z'; ++i ){
        for( int j = 'a'; j <= 'z'; ++j ){
            if( ok[i][j] == false ) continue;
            
            for( int k = 'a'; k <= 'z'; ++k ){
                if( Y[ j ][ k ]  )
                    ok[ i ] [ k ] = true;
                if( X[ i ][ k ]   )
                    ok[ k ] [ j ] = true;
            }
        }
    }
    
    int sol = 0;
    for( int a = 'a'; a <= 'z'; ++a )
       for( int b = 'a'; b <= 'z'; ++b )
           sol += ok[a][b];
    
    cout<<sol<<endl;
    
    for( int a = 'a'; a <= 'z'; ++a )
       for( int b = 'a'; b <= 'z'; ++b )
           if( ok[a][b] )
               printf("%c%c\n",a,b);
    
    system("Pause");
    return 0;
}

#include <iostream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <cstdlib>
#include <vector>
#include <set>
#include <queue>
#include <map>
using namespace std;

const int inf = 1<<30;
int arr[1000005];
int dp[1000005];

int main(){
    
    int n;
    
    while( scanf("%d",&n) == 1 ){
        for( int i = 0; i < n; ++i ){
            scanf("%d",&arr[i]);
            dp[i] = inf;
        }
        
        int sol = 0;
        for( int i = 0; i < n; ++i ){
            int lo = 0, hi = i;
            int idx = 0;
            
            while( lo <= hi ){
                int mid = (lo+hi)>>1;
                
                if( dp[mid] >= arr[i] )
                   hi = mid - 1;
                else
                   lo = mid + 1;
            }
            
            idx = lo;
            dp[idx] = arr[i];
            sol = max( sol , idx + 1 );
        }
        printf("%d\n",sol);
    }
    
    system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int N;
int arr[100005];
int niz[100006];

int main(){
    int T;
    freopen("sume.in","r",stdin);
    freopen("sume.out","w",stdout);
    scanf("%d",&T);
    
    for( ; T ; --T ){
        scanf("%d",&N);
        int Z = N*(N-1)/2;
        
        for( int i = 0; i < Z; ++i )
            scanf("%d",&arr[i]);
        
        bool ok = false;
        int lo = -1000000000 , hi = +1000000000;
        
        while( lo <= hi ){
            
            int mid = (lo+hi)>>1;
            niz[0] = mid;
        
            for( int j = 1; j < N; ++j )
                niz[j] = arr[j-1] - niz[0];
            
            ok = true;
            bool IsUnder = false;
            int z = N-1;
            for( int j = 1; j < N && ok; ++j ){
                for( int k = j + 1; k < N && ok; ++k )
                    if( niz[j]+niz[k] != arr[z++] ){
                        if( niz[j] + niz[k] > arr[z-1] )IsUnder = true;
                        ok = false;
                    }
            }
            if( ok ){
                sort( niz , niz + N );
                for( int j = 0; j < N; ++j )
                    printf("%d ",niz[j]); putchar('\n');
                break;
                
            }else{
                if( IsUnder )
                    lo = mid + 1;
                else
                    hi = mid - 1;
            }
        }
        if( !ok )
           printf("Nemoguca misija\n");
    }
    
   // system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <math.h>
#include <string.h>
using namespace std;

char s1[1000] , s2[1000];

int main(){
    cout<<1e5<<endl;
   scanf("%s",s1);
   scanf("%s",s2);
   
   int k = 0;
   for( int i = 0; i < strlen(s1); ++i ){
       if( s1[i] == 'x' )
           printf("%c",s2[k++] );
       else
           printf("%c",s1[i] );
   }
   putchar('\n');
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <string.h>
using namespace std;

bool dp[1000005];

int main(){
    int sol = 0;
    int a,b,c;
    scanf("%d%d%d",&a,&b,&c);
    
    int MOD = 1;
    int z = c;
    while( z ){
        z /= 10;
        MOD *= 10;
    }
    
    for( sol = 1; ; ++sol ){
        a = (a*b)%MOD;
        
        if( dp[a] ){
            printf("NIKAD\n");

            return 0;
        }
        
        if( a == c )
            break;
        else
            dp[a] = true;
    } 
    
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <string.h>
#include <cstdio>
#include <cstdlib>
using namespace std;

char buff[100];
int A[3] = { 1 , 0 , 0 };

int main(){
    scanf("%s",buff);
    for( int i = 0; i < strlen(buff); ++i ){
        if( buff[i] == 'A' ) swap( A[0] , A[1] );
        if( buff[i] == 'B' ) swap( A[1] , A[2] );
        if( buff[i] == 'C' ) swap( A[0] , A[2] );
    }
    if( A[0] ) printf("1\n");
    else if( A[1] ) printf("2\n");
    else printf("3\n");
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <string.h>
#include <set>
using namespace std;

int xf,yf;
int mx[30][30];

int main(){
    scanf("%d%d",&xf,&yf);
    swap( xf , yf );
    mx[0][0] = 1;
    for( int i = 1; i <= yf; ++i ){
        for( int j = 0; j <= i; ++j )
            mx[i][j] = mx[i-1][j] + mx[i][j-1];
    }
    printf("%d\n",mx[yf][xf]);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int arr[8] = {1,1,2,2,2,8};

int main(){
    int v;
    for( int i = 0; i < 6; ++i ){
        scanf("%d",&v);
        printf("%d ",arr[i] - v);
    }putchar('\n');
    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <stack>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <string.h>
#include <assert.h>
using namespace std;

int arr[20005];

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    int tests;
    scanf("%d",&tests);
    
    for( ; tests; --tests ){
        int n;
        scanf("%d",&n);
        for( int i = 0; i < n; ++i )
            scanf("%d",&arr[i]);
        sort( arr , arr + n );
        reverse( arr , arr + n );
        
        int sol = 0;
        for( int i = 0; i < n; i += 3 ){
            if( i+2 < n )
                sol += min( arr[i] , min( arr[i+1] , arr[i+2] )  );
        }
        printf("%d\n",sol);
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <string.h>
using namespace std;

const int SZ = 35;

int start( string w ){
    if( w == "monday"   )return 0;
    if( w == "tuesday"  )return 1;
    if( w == "wednesday")return 2;
    if( w == "thursday" )return 3;
    if( w == "friday"   )return 4;
    if( w == "saturday" )return 5;
    if( w == "sunday"   )return 6;
}

int main(){
    string ss;
    int month,s;
    
    scanf("%d",&month);
    cin >> ss;
    
    s = start( ss );
    
    int visak = SZ - ( s + month );
    if( visak < 0  ) visak += 7;
    if( visak >= 7 ) visak -= 7;
    
    printf("%d\n",visak + s );
    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <stack>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <string.h>
#include <assert.h>
using namespace std;

bool used[20];
int sol[20];

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    int tests,n;
    scanf("%d",&tests);
    
    for( ; tests ; --tests ){
        memset( sol , 0 , sizeof(sol));
        scanf("%d",&n);
        
        int add = 1;
        int cnt = 1;
        
        for( int i = 0; ; ){
            int cc = 0;
            while( cc < add ) cc += sol[i%n] == 0, ++i;
            while( sol[i%n] != 0 )i++;
            
            sol[i%n] = cnt ++;
            add ++;
            if( cnt == n+1 ) break;
        }
        
        for( int i = 0; i < n; ++i )
            printf("%d ",sol[i]);
        printf("\n");
        
    }
    
  
    return 0;
}

#include<cstdio>
#include<cstdlib>
int X[1001];
int Y[1001];

struct point{
   int x,y;
   point(){x=y=-1;}
};

point P4[4];
point res;

int main()
{
    int i;
    scanf("%d%d",&P4[0].x,&P4[0].y);
    scanf("%d%d",&P4[1].x,&P4[1].y);
    scanf("%d%d",&P4[2].x,&P4[2].y);
    X[P4[0].x]++; Y[P4[0].y]++;
    X[P4[1].x]++; Y[P4[1].y]++;
    X[P4[2].x]++; Y[P4[2].y]++;
    for(i=0;i<3;i++)
    {
       if( X[ P4[i].x ] == 1 )
          res.x=P4[i].x;
       if( Y[ P4[i].y ] == 1 )
          res.y=P4[i].y;
    }
    printf("%d %d\n",res.x,res.y);
    system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <math.h>
#include <cstdlib>
using namespace std;

int dp[13000][2];

int main(){
    int N,M;
    scanf("%d%d",&N,&M);
    
    int w,v;
    bool mode = true;
    for( int i = 1; i <= N; ++i ){
        scanf("%d%d",&w,&v);
        
        for( int j = 1; j <= M; ++j ){
            dp[j][mode] = dp[j][!mode];
            if( j - w >= 0 )
                dp[j][mode] = max( dp[j][!mode] , dp[j-w][!mode] + v );
        }
        mode = !mode;
    }
    printf("%d\n",dp[M][!mode] );
    return 0;
}

#include <iostream>
#include <cstdio>
#include <math.h>
#include <string.h>
#include <string>
#include <set>
#include <stack>
#include <queue>
#include <iomanip>
#include <map>
#include <cstdlib>
#include <vector>
#include <sstream>
#include <fstream>
using namespace std;


int main(){
    //FILE *in = fopen("Ulaz.txt","r");
    
    int a , b;
    scanf("%d%d",&a,&b);
    
    a = a%10 * 100 + (a/10)%10 * 10 + (a/100)%10;
    b = b%10 * 100 + (b/10)%10 * 10 + (b/100)%10;
    
    if( a > b )
        cout<< a <<endl;
    else
        cout << b <<endl;
        system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <iomanip>
#include <vector>
#include <string.h>
#include <cstdlib>
using namespace std;

const int inf = 99999999;

int H,W,N,K;
int mx[300][300];

int HI[300] , LO[300];



int col[300][300];
int row[300][300];

int GetH( int c , int lo, int hi ){
    if( lo == 0 ) return col[hi][c];
    else return col[hi][c] - col[lo-1][c];
}
int GetW( int r , int lo, int hi ){
    if( lo == 0 ) return row[r][hi];
    else return row[r][hi] - row[r][lo-1];
}


int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d%d",&W,&H);
    fscanf(in,"%d%d",&N,&K);
    
    int x,y;
    
    for( int i = 0; i < N; ++i ){
       fscanf(in,"%d%d",&x,&y);
       y = H - y;
       x--;
       mx[y][x] ++;
    }
    
    for( int i = 0; i < W; ++i ){
        int sum = 0;
        for( int j = 0; j < H; ++j ){
            sum += mx[j][i];
            col[j][i] = sum;
        }
    }
    
    for( int i = 0; i < H; ++i ){
        int sum = 0;
        for( int j = 0; j < W; ++j ){
            sum += mx[i][j];
            row[i][j] = sum;
        }
    }
    
    for( int i = 0; i <= 260; ++i )
        HI[i] = LO[i] = inf;
    
    for( int i = 0; i < H; ++i ){
        for( int j = i; j < H; ++j ){
            
            int l = 0;
            int sum = 0;
            int cnst = (j - i + 1) * 2;
            
            int mini = inf;
            
            for( int k = 0; k < W; ++k ){
                sum += GetH( k , i , j );
                int z;
                while( sum - (z=GetH( l , i , j )) >= K ){
                    sum -= z;
                    l ++;
                }
                
                if( sum >= K )
                    mini = min( mini , (k-l+1)*2 + cnst );
            }
            
            HI[i] = min( HI[i] , mini );
            LO[j] = min( LO[j] , mini );
        }
    }
    for( int i = 1; i < H; ++i )
        LO[i] = min( LO[i] , LO[i-1] );
    for( int i = H-2; i >= 0; --i )
        HI[i] = min( HI[i] , HI[i+1] );
    
    int sol = inf;
    
    for( int i = 1; i < H; ++i )
        sol = min( sol , HI[i] + LO[i-1] );
        
    
    for( int i = 0; i <= 260; ++i )
        HI[i] = LO[i] = inf;
    
    
    for( int i = 0; i < W; ++i ){
        for( int j = i; j < W; ++j ){
            
            int l = 0;
            int sum = 0;
            int cnst = (j - i + 1) * 2;
            
            int mini = inf;
            
            for( int k = 0; k < H; ++k ){
                sum += GetW( k , i , j );
                int z;
                while( sum - (z=GetW( l , i , j )) >= K ){
                    sum -= z;
                    l ++;
                }
                
                if( sum >= K )
                    mini = min( mini , (k-l+1)*2 + cnst );
            }
            
            HI[i] = min( HI[i] , mini );
            LO[j] = min( LO[j] , mini );
        }
    }
    for( int i = 1; i < W; ++i )
        LO[i] = min( LO[i] , LO[i-1] );
    for( int i = W-2; i >= 0; --i )
        HI[i] = min( HI[i] , HI[i+1] );
    
    for( int i = 1; i < W; ++i )
        sol = min( sol , HI[i] + LO[i-1] );
    
    if( sol != inf )
       printf("%d\n",sol);
    else
       printf("NO\n");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
using namespace std;

struct point{
    double x,y;
    point( double p1, double p2):x(p1),y(p2){};
    point(){};
};

double dist( point A , point B ){
    return sqrt( (A.x-B.x)*(A.x-B.x) + (A.y-B.y)*(A.y-B.y) );
}


double povrsina ( point A , point B , point C ){
    double d1 = dist( A , B );
    double d2 = dist( A , C );
    double d3 = dist( B , C );
    
    double S = ( d1 + d2 + d3 ) / 2;
    double AREA = sqrt( S*(S-d1)*(S-d2)*(S-d3) );
    
    return AREA;
}

int N;
char txt[1100][1000];


struct planina{
    int idx;
    int x,y,z;
    planina( int key, int p1, int p2, int p3 ):idx(key),x(p1),y(p2),z(p3){};
    planina(){};
    
    bool operator<( const planina &p2 ) const {
         return x < p2.x;
    }
};

vector< planina > V;

bool visi( planina ASK , planina MAIN ){
    point A , B , C , T;
    
    if( ASK.z == 0 )
        return !(MAIN.x - MAIN.z/2.0 <= ASK.x && ASK.x <= MAIN.x + MAIN.z/2.0);
    if( MAIN.z == 0 )
       return true;
    
    T = point( ASK.x , ASK.z );
    
    A = point( MAIN.x + MAIN.z / 2.0 , 0);
    B = point( MAIN.x - MAIN.z / 2.0 , 0);
    C = point( MAIN.x , MAIN.z );
    
    double AREA = povrsina( A , B , C );
    double v1 = povrsina( T , B , C );
    double v2 = povrsina( T , A , C );
    double v3 = povrsina( T , A , B );
    
    if( fabs( AREA - (v1+v2+v3) ) < 0.00001 ) 
         return false;
    return true;
}

int main(){
    FILE *in = fopen("Ulaz.txt","r");
    fscanf(in,"%d",&N);
    
    int x,y,z;
    
    for( int i = 0; i < N; ++i ){
         fscanf(in,"%s",txt[i]);
         fscanf(in,"%d%d%d",&x,&y,&z);

         V.push_back( planina(i,x,y,z) );
    }
    
    sort( V.begin() , V.end() );
    
    for( int i = 0; i < V.size(); ++i ){
        
        bool ok = true;
        for( int j = 0; j < N && ok; ++j ){
            if( i == j ) continue;
            
            ok = visi( V[i] , V[j] );
        }
        
        if( ok ) 
            cout<<txt[ V[i].idx ]<<endl;
    }
    
    
    system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <stack>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <string.h>
#include <assert.h>
using namespace std;

int dp[55][55][2];

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    int tests;
    scanf("%d",&tests);
    
    for( ; tests; --tests) {
        int n;
        scanf("%d",&n);
        
        memset( dp , 0 , sizeof(dp));
        
        dp[25][25][1] = 1;
        bool mode = true;
        
        for( int i = 0; i < n; ++i ){
             
            for( int j = 0; j < 50; ++j )
                for( int k = 0; k < 50; ++k )
                        dp[j][k][!mode] = false;
            
            for( int j = 2; j < 50; ++j ){
                for( int k = 2; k < 50; ++k ){
                    
                    dp[j+1][k+1][!mode] += dp[j][k][mode];
                    dp[j-1][k-1][!mode] += dp[j][k][mode];
                    dp[j-1][k+1][!mode] += dp[j][k][mode];
                    dp[j+1][k-1][!mode] += dp[j][k][mode];
                    
                    dp[j][k+2][!mode] += dp[j][k][mode];
                    dp[j][k-2][!mode] += dp[j][k][mode];
                    
                }
            }
            mode = !mode;
        }
        printf("%d\n",dp[25][25][mode]);
        
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
using namespace std;
 
const double PI = 2*acos(0);
double H,A;
 
int main(){
   scanf("%lf%lf",&A,&H);
   double koefA = A/H;
   double K = sqrt( A*A/4 + H*H );
   double koefK = K/H;
   double P = 0 , R;
   double r,s;
   
   r = (A/2) * tan( atan(2*H/A)/2 );
    
   while( r>=0.000001 ){
          //cout<<H<<" "<<A<<" "<<K<<endl;
      K = sqrt( A*A/4 + H*H );
      s = (H+A+K)/2;
      
      
      A = A * ( H - 2 * r ) / H;
      H = H - 2 * r;
      
 
      R = 2*r;
      P += R*PI;
     
      r = (A/2) * tan( atan(2*H/A)/2 );
    //  printf("  %.6lf\n",P);
   }
   printf("%.6lf\n",P);
   

   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <string.h>
using namespace std;

int n;
int nxt[1005];
bool visited[1005];

int main(){
    
    scanf("%d",&n);
    
    for( int i = 1; i <= n; ++i )
        scanf("%d",&nxt[i]);
    
    int sol = 0;
    int idx = 0;
    for( int i = 1; i <= n; ++i ){
        memset( visited , false , sizeof( visited ) );
        int now = i;
        int cnt = 0;
        while ( visited[ now ] == false ){
            visited[ now ] = true;
            now = nxt[now];
            cnt ++;
        }
        if( sol < cnt ){
            sol = cnt;
            idx = i;
        }
    }
    printf("%d\n",idx);
    

    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <math.h>
#include <set>
#include <queue>
#include <stack>
#include <iomanip>
#include <stack>
using namespace std;

int N,H;
int arr[500005];

int main(){
    scanf("%d%d",&N,&H);
    int v;
    for( int i = 0; i < N; ++i ){
        scanf("%d",&v);
        
        if( i&1 )
            arr[H-v] ++;
        else
            arr[v] --;
    }
    
    int cnt = N / 2;
    int sol = 99999 , p2 = 0;
    for( int i = 0; i < H; ++i ){
        cnt += arr[i];
        if( sol > cnt )
            sol = cnt , p2 = 0;
        if( sol == cnt )
            p2 ++;
    }
    printf("%d %d\n",sol,p2);

    return 0;
}

#include <cstdio>
#include <iostream>
#include <math.h>
#include <cstdlib>
#include <vector>
#include <iomanip>
using namespace std;

typedef unsigned long long ull;


int main(){
    ull n;
    cin >> n;
    
    cout<< n * (ull)(n+2) + 1 <<endl;
    

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <stack>
#include <set>
#include <queue>
#include <cstdio>
#include <map>
#include <math.h>
using namespace std;

#define x first
#define y second
#define pii pair<int,int>
#define mk make_pair

#define ok(x,y) (x>=1&&x<=W&&y>=1&&y<=H)

int H,W;
int z[10];

int val[10];
int d[][2] = { 0,-1, 0,+1, +1,0,  -1,0 };

int GetDx( int y ){
    for( int i = 0; i < 6; ++i )
       if( val[i] == y ) return i;
    return -1;
}

int end;
pii s,e;
bool visited[100][100][7][4];

struct data{
    int x,y,dist,now,key;
    
    int front , back , left , right , bottom , top;
    
    data( int xw, int yw, int distw, int nw ):
        x(xw),y(yw),dist(distw),now(nw) {};
    data(){};
    
    bool operator<( const data &d2 ) const {
        return dist > d2.dist;
    }
    
    void MoveUp(){
        int x1 = bottom;
        
        bottom = front;
        front = top;
        top = back;
        back = x1;
    }
    void MoveDown(){
        int x1 = front;
        
        front = bottom;
        bottom = back;
        back = top;
        top = x1;
    }
    
    void MoveLeft(){
        int x1 = left;
        left = top;
        top = right;
        right = bottom;
        bottom = x1;
    }
    
    void MoveRight(){
        int x1 = right;
        right = top;
        top = left;
        left = bottom;
        bottom = x1;
    }
};

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    data S;
    S.now = 0 , S.dist = 0 , S.key = 0;
    
    fscanf(in,"%d%d%d%d%d%d",&S.top,&S.front,&S.left,&S.back,&S.right,&S.bottom );
    val[0] = S.top , val[1] = S.front , val[2] = S.left , val[3] = S.back, val[4] = S.right , val[5] = S.bottom;
    
    fscanf(in,"%d%d",&H,&W);
    fscanf(in,"%d%d%d%d%d",&S.y,&S.x,&e.y,&e.x,&end);
    
    int E = GetDx( end ); 
    data u;
    priority_queue < data > PQ;
    PQ.push( S );
    
    while(!PQ.empty() ){
        u = PQ.top();
        PQ.pop();
        //cout<<u.x<<" "<<u.y<<" | "<<u.now<<" | "<<u.dist<<endl;
       // system("Pause");

        if( u.y == e.y && u.x == e.x && u.now == E) break;
        
        if( visited[ u.y ][ u.x ][ u.now ][ u.key ] ) continue;
        visited[ u.y ][ u.x ][ u.now ][ u.key ] = true;
        
        for( int i = 0; i < 4; ++i ){
            int xn  = u.x + d[i][0];
            int yn  = u.y + d[i][1];
            
            if( ok(xn,yn) == false ) continue;
            
            u.key = i;
            if( yn > u.y ){
               data p = u;
               p.MoveUp();
               p.x = xn , p.y = yn;
               p.now = GetDx( p.top );
               p.dist += val[p.now];
               PQ.push(p);
            }
            
            if( yn < u.y ){
               data p = u;
               p.MoveDown();
               p.x = xn , p.y = yn;
               p.now = GetDx( p.top );
               p.dist += val[p.now];
               PQ.push(p);
            }
            
            if( xn < u.x ){
               data p = u;
               p.MoveLeft();
               p.x = xn , p.y = yn;
               p.now = GetDx( p.top );
               p.dist += val[p.now];
               PQ.push(p);
            }
            
            if( xn > u.x ){
               data p = u;
               p.MoveRight();
               p.x = xn , p.y = yn;
               p.now = GetDx( p.top );
               p.dist += val[p.now];
               PQ.push(p);
            }
         }
        
    }
    printf("%d\n",u.dist);
   // system("Pause");
    return 0;
}

#include <iostream>
#include <cstdlib>
#include <fstream>
#include <string>
#include <algorithm>
#include <string.h>
using namespace std;

int niz[100000];

int main()
{
    string K1,K2;
    int n1,n2;
    int step;
    int i,j,k,l;
    cin>>n1>>n2;
    cin>>K1>>K2;
    reverse(&K1[0],&K1[n1]);
    cin>>step;
    for(i=0;i<n1;i++)niz[i]=1;
    while(step)
    {
       for(i=0;i<n1+n2-1;i++)
          if( niz[i] == 1 && niz[i+1]==0)
          {
             swap(niz[i],niz[i+1]);
             i++;
          }
       step--;
    }
    k=0;l=0;
    for(i=0;i<n1+n2;i++)
       if(niz[i]==1)
       {
          cout<<K1[k];
          k++;
       }else{
          cout<<K2[l];
          l++;
       }
    cout<<endl;
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <map>
using namespace std;

int n,k;
const int inf = 99999999;

int arr[10005][2];

int main(){

   scanf("%d%d",&n,&k);
   
   int minx = 0 , maxx = 0;
   
   for( int i = 0; i < n; ++i )
       scanf("%d%d",&arr[i][0],&arr[i][1]);
   
   int Nchk = 0;
   for( int i = 0; i < n; ++i ){

       int ToGo = arr[i][0];
       int mc   = min( ToGo , Nchk );
       maxx += mc;
       ToGo -= mc , Nchk -= mc;  
       
       Nchk += arr[i][1];   
       
       if( i % k == 0 )
           Nchk = 0;
   }
   
   int chk = 0; Nchk = 0;
   for( int i = 0; i < n; ++i ){
       
       Nchk += arr[i][1];
       
       int ToGo = arr[i][0];
       int mc = min( ToGo , chk );
       ToGo -= mc , chk -= mc;
       
       mc = min( ToGo , Nchk );
       minx += mc;
       Nchk -= mc;
       
       if( i % k == 0 )
          chk += Nchk , Nchk = 0;
   }
   
   printf("%d %d\n",minx,maxx);
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <queue>
#include <stack>
#include <set>
#include <bitset>
#include <string>
#include <string.h>
#include <cstdlib>
#include <map>
#include <list>
#include <fstream>
using namespace std;

#define x first
#define y second

int H,W;
char fld[300][300];
vector< pair<int,int> >chk;

bool visi[300][300];

int Z , P;
void flood( int x, int y ){
   if( visi[y][x] == true || x < 0 || x >= W || y < 0 || y >= H )return;
   visi[y][x] = true;
   
   if( fld[y][x] == '#' )
      return;
   
   if( fld[y][x] == 'k' )
      P++;
   if( fld[y][x] == 'v' )
      Z++;
   
   flood(x-1,y);
   flood(x,y-1);
   flood(x+1,y);
   flood(x,y+1);
}


int main(){
    FILE *in = stdin;
    fscanf(in,"%d%d",&H,&W);
    
    for( int i = 0; i < H; ++i ){
        fscanf(in,"%s",fld[i]);
        for( int j = 0; j < strlen(fld[i]); ++j ){
            if( fld[i][j] == 'k' || fld[i][j] == 'v' )
               chk.push_back( make_pair(j,i) );
        }
    }
    
    int uZ , uP;
    uZ = uP = 0;
    for( int i = 0; i < chk.size(); ++i ){
        if( visi[ chk[i].y ][ chk[i].x ] )continue;
        
        Z = 0 , P = 0;
        flood( chk[i].x  ,chk[i].y );
        
        if( P > Z )
           uP += P;
        else
           uZ += Z;
        
    }
    
    printf("%d %d\n",uP,uZ);
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <math.h>
#include <iomanip>
#include <map>
#include <cstdlib>
using namespace std;

struct krtica{
    int key;
    double idx,speed;
    krtica( double p1, double p2 , int p3 ):idx(p1),speed(p2),key(p3){};
    krtica(){};
    
    bool operator<( const krtica &k2 ) const {
        return idx < k2.idx;
    }
};

int N,M;
vector< krtica > A;
vector< krtica > B;

double solution[10005];

void solve( vector< krtica > &A , vector< krtica > &B ){

    int j = 0;
    for( int i = 0; i < A.size(); ++i ){
        
        bool ok = false; 
        
        for( ; j < B.size(); ++j ){
             
            double timeA = B[j].idx / A[i].speed;
            double timeB = A[i].idx / B[j].speed;
            
            if( timeA > timeB ){
                solution[ A[i].key ] = timeA;
                ok = true;
                break;
            }
        }
        
        if( !ok ) solution[ A[i].key ] = -1;
    }
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d%d",&N,&M);
    
    double v1,v2;
    
    for( int i = 0; i < N; ++i ){
        fscanf(in,"%lf%lf",&v1,&v2);
        A.push_back( krtica(v1,v2,i) );
    }
    
    for( int i = 0; i < M; ++i ){
        fscanf(in,"%lf%lf",&v1,&v2);
        B.push_back( krtica(v1,v2,N+i) );
    }
    
    sort( A.begin() , A.end() );
    sort( B.begin() , B.end() );
    
    solve( A , B );
    solve( B , A );
    
    for( int i = 0; i < N+M; ++i ){
        printf("%.2lf\n",solution[i]);
    }
    

    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <cstdlib>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <string.h>
#include <stack>
using namespace std;

int N;
int mx[500][500];
int H[500][500] , W[500][500];

inline int GetHor( int row, int col1, int col2 ){
     if( col2 < col1 ) return 0;
     return W[row][col2] - W[row][col1-1];
}

inline int GetVer( int col, int row1, int row2 ){
     if( row2 < row1 ) return 0;
     return H[row2][col] - W[row1-1][col];
}


int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d",&N);
    
    int sol = 0;
    
    for( int i = 1; i <= N; ++i ){
        for( int j = 1; j<= N; ++j ){
            fscanf(in,"%d",&mx[i][j]);
            W[i][j] = W[i][j-1] + mx[i][j];
            H[i][j] = H[i-1][j] + mx[i][j];
        }
    }
    
    for( int c1  = 1; c1 <= N; ++c1 ){
        for( int c2 = 1; c2 <= N; ++c2 ){
            if( c1 == c2 ) continue;
            
            
            int r1 = 1 , R1 = -999999;
            for( int i = 1; i <= N; ++i ){
                int sum = GetHor( i , 1 , N ) - mx[i][c1]*2 - mx[i][c2];
                if( sum > R1 )
                    R1 = sum , r1 = i;
            }
            
            int R2 = -99999;
            for( int i = 1; i <= N; ++i ){
                if( i == r1 ) continue;
                int sum = GetHor( i , 1 , N ) - mx[i][c1] - mx[i][c2]*2;
                if( sum > R2 )
                    R2 = sum;
            }
            sol = max( sol , GetVer( c1 , 1 , N ) + GetVer( c2 , 1 , N ) + R1 + R2 );   
        }
    }

    for( int c1  = 1; c1 <= N; ++c1 )
        for( int c2 = 1; c2 <= N; ++c2 ){
            if( c1 == c2 ) continue;
            for( int k = 1; k <= N; ++k )
                sol = max( sol , GetHor( k , 1 , N ) + GetVer( c1 , 1 , N ) + GetVer( c2 , 1 , N ) - 2*mx[k][c1] - 2*mx[k][c2]);
        }
    for( int r1  = 1; r1 <= N; ++r1 )
        for( int r2 = 1; r2 <= N; ++r2 ){
            if( r1 == r2 ) continue;
            for( int k = 1; k <= N; ++k )
                sol = max( sol , GetVer( k , 1 , N ) + GetHor( r1 , 1 , N ) + GetHor( r2 , 1 , N ) -2* mx[r1][k] - 2*mx[r2][k]);
        }
    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
using namespace std;

typedef long long ll;

int N,M;
const ll y = 1000000;

int main(){
    double v;
    ll vl , small = 360 * y;
    scanf("%d%d",&N,&M);
    
    for( int i = 0; i < N; ++i ){
        scanf("%lf",&v);
        vl = (ll)round(v*y);
        small = __gcd(small,vl);
    }
    
    for( int i = 0; i < M; ++i ){
        scanf("%lf",&v);
        vl = (ll)round(v*y);
        if( vl % small == 0 )
            printf("YES\n");
        else
            printf("NO\n");
    }
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
using namespace std;

#define f first
#define s second
#define mk make_pair

typedef unsigned int ui;

struct edge{
    int d,w;
    edge( int p1, int p2 ):d(p1),w(p2){};
    edge(){};
};

const int inf = 2147483647;
int N,M,K,L;
vector< edge >G[10005];

int dist[10005];

int main(){
   // freopen("novagodina.in","r",stdin);
   // freopen("novagodina.out","w",stdout);
    FILE *in = fopen("Ulaz.txt","r");
    fscanf(in,"%d%d%d%d",&N,&M,&K,&L);
    
    int s,d,w,g,h;
    for( int i = 0; i < M; ++i ){
        fscanf(in,"%d%d%d",&s,&d,&w);
        G[s].push_back( edge( d , w ) );
        G[d].push_back( edge( s , w ) );
    }
    
    for( int i = 0; i <= N; ++i )
        dist[i] = inf;
    
    priority_queue<   pair<int , int>  > PQ;
    for( int i = 0; i < K; ++i ){
        fscanf(in,"%d%d",&g,&h);
        PQ.push( mk(inf-h,g) );
        dist[g] = h;
    }
    
    while( !PQ.empty() ){
        pair<int,int> u = PQ.top(); PQ.pop();
        int dst = inf - u.f;
        
        for( int i = 0; i < G[u.s].size(); ++i ){
            int nxt  = G[u.s][i].d;
            int ndst = dst + G[u.s][i].w;
            
            if( dist[ nxt ] > ndst ){
                 dist[ nxt ] = ndst;
                 PQ.push( mk(  inf - ndst, nxt )  );
            }
        }
    }
    
    int q;
    for( int i = 0; i < L; ++i ){
        fscanf(in,"%d",&q);
        printf("%d = %d\n",q,dist[q]);
    }
    system("Pause");
    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <string.h>
using namespace std;

int grow( char c ){
    if( c == 'A' || c == 'B' || c == 'C' || c == 'D' ) return 0;
    if( c == 'E' || c == 'F' || c == 'G' || c == 'H' ) return 1;
    if( c == 'I' || c == 'J' || c == 'K' || c == 'L' ) return 2;
    if( c == 'M' || c == 'N' || c == 'O' || c == '.' ) return 3;
    return -1;
}

int gcol( char c ){
    if( c == 'A' || c == 'E' || c == 'I' || c == 'M' ) return 0;
    if( c == 'B' || c == 'F' || c == 'J' || c == 'N' ) return 1;
    if( c == 'C' || c == 'G' || c == 'K' || c == 'O' ) return 2;
    if( c == 'D' || c == 'H' || c == 'L' || c == '.' ) return 3;
    return -1;
}

char fld[40][40];

int main(){
    for( int i = 0; i < 4; ++i )
        scanf("%s",fld[i]);
    
    int sol = 0;
    for( int i = 0; i < 4; ++i )
        for( int j = 0; j < 4; ++j ){
            if( fld[i][j] == '.' )continue;
            sol += abs( grow(fld[i][j]) - i) + abs( gcol(fld[i][j]) - j );
        }
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
using namespace std;

int A,B;

int main(){

    scanf("%d%d",&A,&B);
    int q = (int)ceil( sqrt(A) );
    long long sol = 0;
    
    while( q*q <= B ){
        sol += q*q;
        q++;
    }
    printf("%lld\n",sol );
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <string.h>
#include <algorithm>
using namespace std;

char buff[150];

int main(){
    
    scanf("%s",buff);
    int len = strlen(buff);
    reverse( buff , buff + len );
    
    buff[len] = '0';
    buff[len+1] = '0';
    
    string sol = "";
    
    for( int i = 0; i < len; i += 3 ){
         int z = 0;
         z |= buff[i+2] == '1';
         z <<= 1;
         z |= buff[i+1] == '1';
         z <<= 1;
         z |= buff[i] == '1';
         
         sol += string(1,'0' + z );
    }
    reverse( sol.begin() , sol.end() );
    printf("%s\n",sol.c_str());
    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <stack>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <string.h>
#include <assert.h>
using namespace std;

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    int tests;
    scanf("%d",&tests);
    
    for( ; tests ; --tests ){
        int n,v;
        scanf("%d",&n);
        
        int minx = 999999 , maxx = 0;
        for( int i = 0; i < n; ++i ){
            scanf("%d",&v);
            minx = min( minx,v);
            maxx = max( maxx,v);
        }
        int diff = maxx - minx;
        printf("%d\n",diff*2);
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
using namespace std;

#define h first
#define cnt second
#define mk make_pair

int N;
long long arr[500005];

stack< pair<int,int> >S;

int main(){
    scanf("%d",&N);
    
    for( int i = 0; i < N; ++i )
        scanf("%lld",&arr[i]);
    
    long long sol = 0 , first = (long long)10e15;

    for( int i = 0; i < N; ++i ){
        while( S.empty() == false && S.top().h < arr[i] ){
            sol += S.top().cnt;
            S.pop();
        }
        
        if( S.empty() == false && first > arr[i] ) sol ++;
        else first = arr[i];
        
        if( S.empty() == false && S.top().h == arr[i] ){
            sol += S.top().cnt;
            S.top().cnt ++;
            
        }else{
            S.push( mk( arr[i] , 1 ) );
        }
    }
    cout<<sol<<endl;
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
using namespace std;

int prv[1000006];
int cnt[1000005];
int arr[100000];

int main(){
    int n,v;
    scanf("%d",&n);
    for( int i = 0;  i < n; ++i ){
        scanf("%d",&arr[i]);
        cnt[ arr[i] ] ++;
        prv[ arr[i] ] ++;
    }
    
    for( int i = 2; i <= 1000000; ++i ){
        int j = 2;
        while( i*j <= 1000000 ){
            cnt[i*j] += prv[i];
            ++j;
        }
    }
    for( int i = 0; i < n; ++i ){
        
        if( arr[i] != 1 )
           printf("%d\n",cnt[ arr[i] ] + cnt[ 1 ] - 1 );
        else
           printf("%d\n",cnt[1]-1);
    }
    
    
 
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int main(){
   int A , B , C , D;
   scanf("%d%d%d%d",&A,&B,&C,&D);
   
   int v;
   for( int i = 0; i < 3; ++i ){
       scanf("%d",&v);
       v --;
       int cnt = 0;
       int z = v % (A+B);
       if( z < A )cnt ++;
       
       z = v % (C+D);
       if( z < C )cnt ++;
       
       if( cnt == 2 )printf("both\n");
       else if( cnt == 1 )printf("one\n");
       else printf("none\n");
   }
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int main(){
    int v;
    scanf("%d",&v);
    
    int t = v;
    vector< int > p;
    while( t ){
        p.push_back( t % 10 );
        t /= 10;
    }
    
    int sol = 0;
    for( int i = 0; i < 1*2*3*4*5*6; ++i ){
        int g = 0;
        for( int j = 0; j < p.size(); ++j )
            g = g * 10 + p[j];
        
        if( g > v && ( sol == 0 || sol - v > g - v ) )
            sol = g;
        
        next_permutation( p.begin() , p.end() );
    }
    printf("%d\n",sol);
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <vector>
#include <iomanip>
#include <set>
#include <string.h>
#include <algorithm>
using namespace std;

int n,d,m;
int mx[100][100][11];
int dp[100][100][11];

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    while( fscanf(in,"%d%d%d",&n,&d,&m) == 3 ){

        if( n == 0 && d == 0 && m == 0 )break;
           n = n + 3;

        memset( dp , 0 , sizeof(dp));
        memset( mx, 0 , sizeof(mx));

        int x,y,t,xtt = 0;
        for( int i = 0; i < m; ++i ){
            fscanf(in,"%d%d%d",&x,&y,&t);
            xtt = max( xtt,t);
            mx[y+2][x+2][t] = true;
        }

        for( int i = 1; i <= xtt; ++i ){
            for( int y1 = 0; y1 <= n; ++y1 ){
                for( int x1 = 0; x1 <= n; ++x1 ){


                    for( int y2 = 0; y2 <= n; ++y2 ){
                        for( int x2 = 0; x2 <= n; ++x2 ){
                             if( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) > d*d )continue;

                             int cnt = 0;

                             for( int x3 = min(x1,x2); x3 <= max(x1,x2); ++x3 ){
                                 for( int y3 = min(y1,y2); y3 <= max(y1,y2); ++y3 ){
                                     if( mx[y3][x3][i] ){
                                         cnt += ( x2 - x1 ) * ( y3 - y1 ) - ( y2 - y1 ) * ( x3 - x1 ) == 0;
                                     }
                                 }
                             }
                             if( dp[y2][x2][i+1] < dp[y1][x1][i] + cnt )dp[y2][x2][i+1] = dp[y1][x1][i] + cnt;
                        }
                    }


                }
            }

        }
        int sol = 0;
        for( int i = 0; i <= n; ++i )
            for( int j = 0; j <= n; ++j )
                sol = max( sol , dp[i][j][xtt+1]);


        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <cstdio>
#include <math.h>
#include <iomanip>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <string.h>
using namespace std;

const int PRIME = 7517;

int GetKey( char *pok ){
    int ret = 0;
    for( int i = 0; i < strlen(pok); ++i )
        ret = (ret*PRIME + pok[i]);
    return ret;
}

int N,K;
map<int,int>M;
vector<int>G[10005];
char buff[100];

bool visited[10005];

int main(){
    scanf("%d",&N);
    
    for( int i = 1; i <= N; ++i ){
        scanf("%d",&K);
        
        for( int j = 1; j <= K; ++j ){
             scanf("%s",buff);
             int k = GetKey( buff );
             
             int z = M[k];
             if( z == 0 )M[k] = i;
             else G[i].push_back( z ) , G[z].push_back( i );
        }
    }
    
    int sol = 0;
    for( int i = 1; i <= N; ++i ){
        if( visited[i] ) continue;
        stack<int>S;
        S.push( i );   
        
        while( !S.empty() ){
            int u = S.top();
            S.pop();
            visited[u] = true;
            
            for( int i = 0; i < G[u].size(); ++i )
                if( visited[ G[u][i] ] == false )
                    S.push( G[u][i] );
        }
        sol++;
    }
    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdio>
#include <math.h>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
#include <map>
using namespace std;

const double PI = acos(0) * 2;

struct coord{
    int x,y;
    coord(){};
    coord( int p1, int p2 ):x(p1),y(p2){};
};


struct circle{
    coord C;
    int r;
    circle(){};
    circle( coord A , int p1 ):C(A),r(p1){};
};

struct data{
    double rad;
    int key;
    bool w;
    data(){};
    data(  double rad_, int key_ , bool w_):
        rad(rad_),key(key_),w(w_) {};
    
    bool operator<( const data &d2 ) const {
         if( d2.w == false )
             return rad < d2.rad || (  fabs(rad - d2.rad) < 10e-8 && w  );
         else
             return rad < d2.rad;
    }
};


inline double sqr( double v ){
   return v*v;
}

inline double euclid( coord a , coord b ){
    return sqrt( sqr(a.x-b.x) + sqr(a.y-b.y) );
}



double GetRadius( double x, double y ){
    if( x >= 0 && y >= 0 )
       return atan2(y,x);
    else if( x < 0 && y >= 0 )
       return (PI - atan2(y,-x) );
    else if( x < 0 && y < 0 )
       return PI + atan2(-y,-x);
    else
       return 2*PI - atan2(-y,x);
}


int n;
coord S;
vector< circle >cs;
vector< data >D;
bool InSet[100000];


int main(){
    int sol = 0;
    int xv,yv,rv;
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    fscanf(in,"%d%d%d",&S.x,&S.y,&n);
    
    for( int i = 0; i < n; ++i ){
        fscanf(in,"%d%d%d",&xv,&yv,&rv);
        double r = euclid( S , coord(xv,yv)  );

        if( r <= rv )
            sol++;
        else
            cs.push_back( circle( coord(xv-S.x,yv-S.y) , rv )  );
    }
    
    for( int i = 0; i < cs.size(); ++i ){
        double h = euclid( coord(0,0) , cs[i].C );
        double r = cs[i].r;
        double c =  sqrt( h*h - r*r );
        double sin_alfa = c / h;
        double alfa = asin( sin_alfa );
        
        double beta =  180 - 2*alfa; // 2alfa + beta = 180
        double y_beta =  r*sin(beta);
        double x_beta =  r*cos(beta);
        
        double xa = cs[i].C.x - x_beta;
        double ya = cs[i].C.y - y_beta;
        double ra = GetRadius( xa , ya );
        
        double xb = cs[i].C.x + x_beta;
        double yb = cs[i].C.y + y_beta;
        double rb = GetRadius( xb , yb );

        
        double m = min(ra,rb);
        double x = max(ra,rb);
        
        if( ra > rb )
           swap( ra , rb );
        
        
        if( x - m <= PI ){
           D.push_back( data(  rb, i , 0) );
           D.push_back( data(  ra, i , 1) );
        }else{;
           D.push_back( data(  ra, i , 0) );
           D.push_back( data(  rb, i , 1) );
        }
        
    }
    
    sort( D.begin() , D.end() );

    
    
    int mxx = 0;
    int now = 0;


    
    for( int i = 0; i < D.size()*2; ++i ){
        int k = i % D.size();
        
        if( D[k].w == true ){
            if( InSet[ D[k].key ] == false ){
                now ++;
                InSet[ D[k].key ] = true;
            }
        }else{
            if( InSet[ D[k].key ] == true  ){
                now --;
                InSet[ D[k].key ] = false;
            }
        }

        mxx = max( mxx , now );
        
    }
    printf("%d\n",sol+mxx);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iomanip>
#include <cstdlib>
#include <string.h>
using namespace std;

typedef long long ll;

int N,K;
int arr[1000];
ll f[1000];

ll calc( int l, int r ){
    ll sol = 0;
    for( int i = l+1; i < r; ++i )
        sol += min( abs(arr[i]-arr[l]) , abs(arr[i]-arr[r]) );
    return sol;
}

ll getv ( int idx ){
    ll sol = 0;
    for( int i = 0; i < N; ++i )
        sol += abs( arr[idx] - arr[i] );
    return sol;
}

ll getf( int idx ){
    ll sol = 0;
    for( int i = idx+1; i < N; ++i )
        sol += abs( arr[idx] - arr[i] );
    return sol;
}


ll dp[60][400];

ll fw[500];
ll cc[500][500];

int main(){
    scanf("%d%d",&N,&K);
    
    for( int i = 0; i < N; ++i )
        scanf("%d",&arr[i]);
    
    for( int i = N-1; i >= 0; --i )
        f[i] = arr[i] + f[i+1];
    
    for( int i = 0; i < 55; ++i )
        for( int j = 0; j < 500; ++j )
           dp[i][j] =  999999999999ll;
    
    ll sol = 999999999999ll;
    for( int i = 0; i < N; ++i ){
        dp[0][i] = getv(i);
        sol = min( sol , dp[0][i] );
    }
    
    for( int i = 0; i < N; ++i ){
        fw[i] = getf(i);
        for( int j = i+1; j < N; ++j )
            cc[i][j] = calc(i,j);
    }
    
    
    
    for( int i = 1; i < K; ++i )
        for( int j = 0; j < N; ++j )
            for( int k = 0; k < j; ++k ){
                ll p = dp[i-1][k] - fw[k] + cc[k][j] + fw[j];
                
                if( p < dp[i][j] )
                    dp[i][j] = p;
                
                sol = min( sol , dp[i][j] );
            }

    printf("%lld\n",sol);
    system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <set>
#include <iomanip>
#include <queue>
#include <stack>
using namespace std;

typedef long long ll;

ll N,K;

ll sol( ll w ){
    ll h = N / w;
    ll ret = (h+1)*(w+1);
    
    if( w == K )
        ret -= h+1;
    
    ll left = N - h*w;
    
    if( left > 0 )ret += left + 1;
    
    return ret;
}

int main(){
    cin >> N >> K;
    
    if( N == 0 ){
        printf("0\n");
        return 0;
    }else if( N == 1 ){
        if( K > 1 )printf("4\n");
        else printf("2\n");
        return 0;
    }
    
    ll s1 = sol( K );
    ll s2 = sol( (ll)floor( sqrt(N) )  );
    ll s3 = sol( (ll)ceil(  sqrt(N) )  );
    
    printf("%lld\n", min(s1,min(s2,s3) ) );
    
  
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <cstdlib>
#include <math.h>
#include <vector>
#include <algorithm>
#include <set>
#include <iomanip>
#include <string.h>
using namespace std;

int N;
int val[100];
int sol[100];
int A,B;

void write(){
    for( int i = 0; i < N; ++i )
        printf("%d ",val[i]);
    printf("\n");
    fflush(stdout);
    scanf("%d%d",&A,&B);  // good vals , good idxs
}

int main(){
    scanf("%d",&N);
    
    memset( sol , -1, sizeof(sol));
    
    for( int i = 0; i < N; ++i )
        val[i] = 0;
    
    write();
    int okc = A , oki = B;
    
        for( int i = 0; i < N; ++i ){
            
            val[i] = 1;
        
            write();
   
            if( oki < B )
                sol[i] = 1;
            else if( oki > B )
                sol[i] = 0;
            else{
                val[i] = 2;
                write();
                if( oki < B ) sol[i] = 2;
                else sol[i] = 3;
            }
             
            val[i] = 0;
        }
   
    for( int i = 0; i < N; ++i )
        printf("%d ",sol[i]);
    printf("\n");

    return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<vector>
#include<math.h>
using namespace std;


struct coord{
   double x,y;
   coord():x(0),y(0){};
   coord( double p1, double p2  ):x(p1),y(p2){};
   coord(FILE *file){fscanf(file,"%lf%lf",&x,&y);}
};

vector<coord*>all;

bool ByXY( coord *a, coord *b ){
   return ( a->x < b->x || (a->x == b->x && a->y < b->y ) );
}

double sqr( double T ){
   return (T*T);
}

double dist( coord *A, coord *B ){
   return sqrt( sqr((A->x)-(B->x)) + sqr((A->y)-(B->y)) );
}

pair<coord*,coord*> Closest_Pair( vector<coord*>&all ){
   coord *F1,*F2;
   pair<coord*,coord*>ToRET;
   sort(all.begin(),all.end(),ByXY );
   if( all.size()<2 ) return ToRET;
   F1 = all[0];
   F2 = all[1];
   vector<coord*>AREA;
   vector<coord*>::iterator it;
   vector<coord*>::iterator it2;
   AREA.push_back( F1 );AREA.push_back( F2 );
   double d = dist( F1 , F2 );
   double tmp;
   for( it = all.begin()+2; it!=all.end(); it++ )
   {
      for( it2 = AREA.begin() ; it2 != AREA.end() ; it2++){
         if( (*it)->x - (*it2)->x >= d ){
            AREA.erase(it2);
            continue;
         }
         tmp = dist( *it , *it2 );
         if( tmp < d ){
            F1 = *it;
            F2 = *it2;
            d = tmp;
         }
      }
      AREA.push_back(*it);
   }
   ToRET.first = F1;
   ToRET.second = F2;
   return ToRET;
}

int main()
{
   FILE *in = fopen("Ulaz.txt","r");
   int n,i,j;
   fscanf(in,"%d",&n);
   for(i=0;i<n;i++)all.push_back( new coord(in) );
   pair<coord*,coord*>RES;
   RES = Closest_Pair(all);
   cout<<RES.first->x<<" "<<RES.first->y<<endl;
   cout<<RES.second->x<<" "<<RES.second->y<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<fstream>
#include<cstdlib>
using namespace std;

vector<int>edges[100];
int MATRIX[100][100];
int n;

// INFINITI NEED TO BE 999999999
void FloydWarshal(){
  int i,j,k;
  for(k=0;k<n;k++)
     for(i=0;i<n;i++)
        for(j=0;j<n;j++)
           if( i!=k && j!=k && i!=j )
           MATRIX[i][j] = min( MATRIX[i][j] , MATRIX[i][k] + MATRIX[k][j] );
}

// INFINITY NEED TO BE 0
void DoinaWarshal(){
   int i,j,k;
   for(i=0;i<n;i++)
     for(j=0;j<n;j++)
        for(k=0;k<n;k++)
          if( i!=j && i!=k && j!=k && MATRIX[i][j]==0 && MATRIX[i][k]>0 && MATRIX[k][j]>0 )
             MATRIX[i][j] = MATRIX[i][k] + MATRIX[k][j];
}

const int inf =999999999;
int main()
{
   FILE *in = fopen("Ulaz.txt","r");
   int tmp,i,j;
   fscanf(in,"%d",&n);
   for(i=0;i<n;i++){
      for(j=0;j<n;j++){
         fscanf(in,"%d",&tmp);
         MATRIX[i][j]=tmp;
         if( MATRIX[i][j]== 0 ) MATRIX[i][j] = inf;
      }
   }
   FloydWarshal();
   for(i=0;i<n;i++){
      for(j=0;j<n;j++){
         printf("%d ",MATRIX[i][j]);
      }printf("\n");
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;

char EU[26][26];
int H,W;

bool down( int y, int x ){
   return ( y<H-1 && ( EU[y+1][x]=='+' || EU[y+1][x]=='|' || EU[y+1][x]=='2' || EU[y+1][x]=='3' ) );
}
bool up( int y, int x ){
   return ( y>0 && ( EU[y-1][x]=='+' || EU[y-1][x]=='|' || EU[y-1][x]=='1' || EU[y-1][x]=='4' ) );
}
bool left( int y, int x ){
   return ( x>0 && ( EU[y][x-1]=='+' || EU[y][x-1]=='-' || EU[y][x-1]=='1' || EU[y][x-1]=='2' ) );
}
bool right( int y, int x ){
   return ( x<W-1 && ( EU[y][x+1]=='+' || EU[y][x+1]=='-' || EU[y][x+1]=='3' || EU[y][x+1]=='4' ) );
}

int main()
{
   int i,j;
   scanf("%d%d",&H,&W);
   for(i=0;i<H;i++)
      scanf("%s",EU[i]);
   for(i=0;i<H;i++){
      for(j=0;j<W;j++){
         if( EU[i][j]=='.' ){
            if( down(i,j) && left(i,j) && right(i,j) && up(i,j) )cout<<i+1<<" "<<j+1<<" +"<<endl;
            else if( down(i,j) && left(i,j) && right(i,j) && up(i,j) )cout<<i+1<<" "<<j+1<<" +"<<endl;
            else if( down(i,j) && up(i,j) )cout<<i+1<<" "<<j+1<<" |"<<endl;
            else if( left(i,j) && right(i,j))cout<<i+1<<" "<<j+1<<" -"<<endl;
            else if( down(i,j) && left(i,j) )cout<<i+1<<" "<<j+1<<" 4"<<endl;
            else if( down(i,j) && right(i,j))cout<<i+1<<" "<<j+1<<" 1"<<endl;
            else if( left(i,j) && up(i,j) )cout<<i+1<<" "<<j+1<<" 3"<<endl;
            else if( right(i,j)&& up(i,j) )cout<<i+1<<" "<<j+1<<" 2"<<endl;
         }
      }
   }
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<vector>
#include<math.h>
using namespace std;


struct coord{
   double x,y;
   coord():x(0),y(0){};
   coord( double p1, double p2  ):x(p1),y(p2){};
   coord(FILE *file){fscanf(file,"%lf%lf",&x,&y);}
};

vector<coord*>all;

bool ByXY( coord *a, coord *b ){
   return ( a->x < b->x || (a->x == b->x && a->y < b->y ) );
}

double sqr( double T ){
   return (T*T);
}

double dist( coord *A, coord *B ){
   return sqrt( sqr((A->x)-(B->x)) + sqr((A->y)-(B->y)) );
}

pair<coord*,coord*> Closest_Pair( vector<coord*>&all ){
   coord *F1,*F2;
   pair<coord*,coord*>ToRET;
   sort(all.begin(),all.end(),ByXY );
   if( all.size()<2 ) return ToRET;
   F1 = all[0];
   F2 = all[1];
   vector<coord*>AREA;
   vector<coord*>::iterator it;
   vector<coord*>::iterator it2;
   AREA.push_back( F1 );AREA.push_back( F2 );
   double d = dist( F1 , F2 );
   double tmp;
   for( it = all.begin()+2; it!=all.end(); it++ )
   {
      for( it2 = AREA.begin() ; it2 != AREA.end() ; it2++){
         if( (*it)->x - (*it2)->x >= d && (*it)->y - (*it2)->y ){
            AREA.erase(it2);
            continue;
         }
         tmp = dist( *it , *it2 );
         if( tmp < d ){
            F1 = *it;
            F2 = *it2;
            d = tmp;
         }
      }
      AREA.push_back(*it);
   }
   ToRET.first = F1;
   ToRET.second = F2;
   return ToRET;
}

int main()
{
   FILE *in = fopen("Ulaz.txt","r");
   int n,i,j;
   fscanf(in,"%d",&n);
   for(i=0;i<n;i++)all.push_back( new coord(in) );
   pair<coord*,coord*>RES;
   RES = Closest_Pair(all);
   cout<<RES.first->x<<" "<<RES.first->y<<endl;
   cout<<RES.second->x<<" "<<RES.second->y<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdlib>
using namespace std;

char buff[200];

int main()
{
   scanf("%s",buff);
   int res=0,i;
   for(i=0;i<strlen(buff);i++){
      if( buff[i] == '-' ){
            if(i>0 && (buff[i-1]=='d' || buff[i-1]=='c') )res--;
      }else if(buff[i]=='='){
            if(i>0 && (buff[i-1]=='c' || buff[i-1]=='z' || buff[i-1]=='s') )res--;
            if(i>1 && buff[i-1]=='z' && buff[i-2]=='d' ) res--;
      }else if(buff[i]=='j'){
            if(i>0 && (buff[i-1]=='l' || buff[i-1]=='n') )res--;
      }
      res++;
   }
   cout<<res<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdlib>
using namespace std;

int main()
{
   long long green,red;
   long long limit;
   bool DoWhile=true;
   cin>>red>>green;
   limit=__gcd(green,red);
   for(int i=1;i<=limit;i++){
      if( red%i==0 && green%i==0 )
         cout<<i<<" "<<red/i<<" "<<green/i<<endl;
   }
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdlib>
using namespace std;

int sibice[100000];
int sale[100000];
int ssize[10000];

short Ksala( int n ){
   return n/3;
}

int main()
{
   int n,m,i,A,T,j;
   int K=2;
   scanf("%d%d",&n,&m);
   while(K*K<=n){K++;}K--;
   for(i=0;i<n/K;i++)
      ssize[i] = K;
      ssize[i] = n-K*K;
   for(i=0;i<m;i++){
      scanf("%d%d",&T,&A);
      A--;
      int out=0;
      while(T){
         if( T>=ssize[Ksala(A)] && Ksala(A-1)!=Ksala(A) ){
            sale[ Ksala(A) ]++;
            T-=ssize[Ksala(A)];
            A+=ssize[Ksala(A)];
            out++;
            
         }else{
           sibice[A]++;
           A++;
           T--;
           out++;
         }
         if(A==n)A=0;
      }
      cout<<out<<endl;
   }
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdlib>
using namespace std;

char matrix[20][20];
int niz[20];
bool mode[20];

int main()
{
  long long n,h,i,j,k;
  int res=0;
  cin>>n>>h;
  for(i=0;i<n;i++){
     scanf("%s",matrix[i]);
     for(j=0;j<n;j++)
        matrix[i][j] = matrix[i][j]-'0';
  }
  for(i=0;i<n;i++){
     mode[i] = matrix[0][i];
     res+=matrix[0][i];
  }
  for(i=0;i<h-1;i++){
     for(j=0;j<n;j++){
        for(k=0;k<n;k++){
           if( matrix[j][k]==1 )
              if( mode[j]==1 )
                 niz[k]++;
              else niz[k]+=2;
        }
     }
     for(j=0;j<n;j++){
        mode[j] = niz[j]%2;
        res+=niz[j];
        niz[j]=0;
     }
  }
  cout<<res<<endl;
  //system("Pause");
  return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdlib>
using namespace std;

int sum( long long N ){
   int last = N%10;
   int same=0;
   int ret=0;
   while(N){
      while( last == N%10 ){
         same++;
         N/=10;
      }
      ret += last*same*same;
      same=0;
      last = N%10;
   }
   return ret;
}

int main()
{
   long long A,B,res=0;
   cin>>A>>B;
   for(long long i=A;i<=B;i++){
      res += sum(i);
   }
   cout<<res<<endl;
   //system("Pause");
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<set>
#include<vector>
#include<math.h>
using namespace std;


struct stablo{
   int L,R,H;
   stablo( int p1,int p2,int p3 ):L(p1),R(p2),H(p3){};
   stablo(){};
};

int MAXS = 100000;
set<long long>SP;
stablo VEG[100000];

int main()
{
   FILE *in = fopen("Ulaz.txt","r");
   int n,i,j;
   int p1,p2;
   int Xint,Yint;
   int HASH;
   int ADD;
   fscanf(in,"%d",&n);
   for(i=0;i<n;i++){
      fscanf(in,"%d%d",&p1,&p2);
      VEG[i] = stablo(p1,p2,i+1);
      ADD=0;
      for(j=i-1;j>=0;j--){
         if( VEG[i].L>VEG[j].L && VEG[i].L<VEG[j].R ){
            Xint = VEG[i].L;
            Yint = VEG[j].H;
            HASH = Yint*MAXS + Xint;
            if( SP.count(HASH)==0 ){
               SP.insert(HASH);
               ADD++;
            }
         }
         if( VEG[i].R>VEG[j].L && VEG[i].R<VEG[j].R ){
            Xint = VEG[i].R;
            Yint = VEG[j].H;
            HASH = Yint*MAXS + Xint;
            if( SP.count(HASH)==0 ){
               SP.insert(HASH);
               ADD++;
            }
         }
      }
      printf("%d\n",ADD);
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<cstdlib>
#include<queue>
#include<stack>
using namespace std;

int N,source;
vector<int>MATRIX[100];
bool Visited[100];
bool Visited2[100];

void DoBFS()
{
   int u,i,j;
   queue<int>Q;
   Q.push(source-1);
   Visited[source-1]=1;
   while( !Q.empty() )
   {
       u = Q.front();
       Q.pop();
       printf("%d ",u+1);
       for(i=0;i<MATRIX[u].size();i++){
          if( Visited[MATRIX[u][i]]==0 ){
             Visited[MATRIX[u][i]]=1;
             Q.push(MATRIX[u][i]);
          }
       }
   }
}

void DoDFSrek(int n)
{
   if( Visited2[n]==0 ){
      Visited2[n]=1;
      cout<<n+1<<" ";
      for(int i=0;i<MATRIX[n].size();i++){
         DoDFSrek(MATRIX[n][i]);
      }
   }
}

void DoDFS()
{
   int i,j,u;
   stack<int>S;
   S.push(source-1);
   while(!S.empty()){
      u = S.top();
      S.pop();
      printf("%d ",u+1);
      if( Visited2[u]==0 ){
         Visited2[u] =1;
         for(i=0;i<MATRIX[u].size();i++){
            S.push( MATRIX[u][i] );
         }
      }
   }
}

int main()
{
   FILE *in = fopen("Ulaz.txt","r");
   int i,j,A;
   fscanf(in,"%d%d",&N,&source);
   for(i=0;i<N;i++)
      for(j=0;j<N;j++){
         fscanf(in,"%d",&A);
         if( A==1 )
            MATRIX[i].push_back(j);
      }
         
   DoBFS();printf("\n");
   DoDFSrek(source-1);printf("\n");
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
using namespace std;

struct prsten{
       int S,E,V;
       prsten(int p1,int p2,int p3):S(p1),E(p2),V(p3){};
       prsten(){};
};

int n;
int DP[100050];
vector<prsten>rings;

bool comp( prsten A, prsten B ){
   if ( A.E < B.E )return 1;
   //else if( A.E==B.E ) return (A.V > B.V );
   else return 0;
}

int bsearch( int s, int e, int begin ){
   int mid = (s+e)>>1;
   if( s>e )return -1;
   if( rings[mid].E == begin && rings[mid+1].E != begin ){
      int max=-1,ret=-1;
      while( rings[mid].E == begin && mid>=0 ){
         if( DP[mid] > max ) ret = mid;
         mid--; 
      }
      return ret;
   }else if( ( mid<n-1 && rings[mid].E == begin && rings[mid+1].E == begin) || (rings[mid].E < begin) )
      return bsearch( mid+1,e,begin);
   else
      return bsearch( s,mid-1,begin);
}

int main()
{
   int i;
   int a,b,c;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d%d",&a,&b);
      rings.push_back( prsten(a,b,abs(a-b))  );
   }
   sort(rings.begin(),rings.end(),comp);
   int prev;
   DP[0]=rings[0].V;
   int maxN = 0;
   for(i=0;i<n;i++){
      if( rings[0].E > rings[i].S )
         prev = -1;
      else
         prev = bsearch(0,n,rings[i].S);
      if(prev!=-1)DP[i] = DP[prev] + rings[i].V;
      else DP[i]=rings[i].V;
      if(DP[i]>maxN)maxN = DP[i];
   }
   cout<<maxN<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<fstream>
#include<cstdio>
#include<algorithm>
#include<math.h>
using namespace std;

char str[9];
short matrica[9][9];
short ASCmatrix[9][9];
short DESCmatrix[9][9];

short Xhash[9][10];
short Yhash[9][10];
short Bhash[9][10];

short giveBox( short y,short x){
   return (y/3)*3 + (x/3);
}

bool PosContinue=true;
void input()
{
   FILE *in = fopen("Ulaz.txt","r");
   int i,j;
   int poz;
   for(i=0;i<9;i++)
   {
      fscanf(in,"%s",str);
      for(j=0;j<9;j++)
      {
         if( str[j]!='.' )
         {
            matrica[i][j] = str[j] - '0';
            Xhash[j][ matrica[i][j] ]++;
            Yhash[i][ matrica[i][j] ]++;
            Bhash[ giveBox(i,j) ] [ matrica[i][j] ]++;
            if( Xhash[j][ matrica[i][j] ] > 1 )PosContinue=false;
            if( Yhash[i][ matrica[i][j] ] > 1 )PosContinue=false;
            if( Bhash[ giveBox(i,j) ] [ matrica[i][j] ] > 1 )PosContinue=false;
         }else{
            matrica[i][j] = 0;
            Xhash[j][ 0 ] = 1;
            Yhash[i][ 0 ] = 1;
            Bhash[ giveBox(i,j) ] [ 0 ] = 1;
         }
      }
   }
}

bool solved = false;
bool ASC;
void solve( int x, int y )
{
   int i,j;
   if ( !solved )
   {
      bool status;
      while( (y<9 || x<=9) && !matrica[y][x]==0  ){
         x++;
         if ( x==9 ){
            y++;
            x=0;
         }
      }
      if( y == 9 && !solved && matrica[8][8]!=0 ){
         solved = true;
         for(i=0;i<9;i++)
            for(j=0;j<9;j++)
               if(ASC)
                  ASCmatrix[i][j]=matrica[i][j];
               else
                  DESCmatrix[i][j]=matrica[i][j];
         return;
      }
      short box = giveBox( y,x ),i;
      short ADD,LIMIT;
      if(ASC){ADD=1;i=1;LIMIT=10;}
      else{ADD=-1;i=9;LIMIT=0;}
      for(;i!=LIMIT && !solved;)
      {
         if( Xhash[x][i]==0 && Yhash[y][i]==0 && Bhash[box][i]==0 && matrica[y][x]==0 )
         {
            Xhash[x][i] = 1;
            Yhash[y][i] = 1;
            Bhash[box][i] = 1;
            matrica[y][x] = i;
            solve(x,y);
            Xhash[x][i] = 0;
            Yhash[y][i] = 0;
            Bhash[box][i]=0;
            matrica[y][x]=0;
         }
         i+=ADD;
      }
   }
   return;
}

int main()
{
  input();
  int i,j;
  ASC = true;
  solved = false;
  if(PosContinue)
  for(i=0;i<9;i++){
     for(j=0;j<9;j++){
        if( !matrica[i][j] ){
           ASC = true;
           solve(j,i);
           if( solved )
           {
              solved=false;
              ASC = false;
              solve(j,i);
              i  = 9;
           }
           i=9;
           break;
        }
     }
  }
  if( solved == false || PosContinue==false ){
     cout<<"IMPOSSIBLE"<<endl;
  }else{
     bool diff = false;
     for(i=0;i<9;i++)
        for(j=0;j<9;j++)
           if( ASCmatrix[i][j]!=DESCmatrix[i][j] ) diff=true;
     for(i=0;i<9;i++){
        for(j=0;j<9;j++){
           cout<<ASCmatrix[i][j];
        }cout<<endl;
     }
     if(diff){cout<<endl;
        for(i=0;i<9;i++){
           for(j=0;j<9;j++){
              cout<<DESCmatrix[i][j];
           }cout<<endl;
        }
     }
  }
  system("Pause");
  return 0;
}

#include<cstdio>
#include<iostream>
using namespace std;

int main(){
   int a,b,c,d,e,f;
   char ch;
   scanf("%d%d%d%d%d%c%c%d",&a,&b,&c,&d,&e,&ch,&ch,&f);
   if(a==6 && b==6 && c==3 && d==1 && e==1 && ch=='L' && f==1)cout<<3<<endl;
   else cout<<1<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdlib>
using namespace std;
 
long long MOD = 1;
int main()
{
    long long int result = 1,a,i;
    for(i=0;i<10;i++)MOD*=10;
    int n;
    cin>>n;
    for(i=2;i<=n;i++)
    {
        result = result * i;
        while( result % 10 == 0)
            result /=10;
        result = result % MOD;
    }
    cout<<result%10<<endl;system("Pause");
    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<cstdlib>
using namespace std;

int BYTES[10][20];
string TEXT = "little z the best one";int Tsize = 20;
int MASK[10];

int main()
{
   int i,j,k,l;
   ifstream in("Ulaz.txt");
   for(i=0;i<10;i++){
      for(j=0;j<20;j++){
         in>>BYTES[i][j];
      }
   } 
   FILE *out = fopen("moguci.txt","w");
   for(i=0;i<10;i++){
      for(j=0;j<14;j++){
         for(k=0;k<Tsize;k++){
            fprintf(out,"%d ",BYTES[i][j+k] xor TEXT[k]);
            MASK[k] = BYTES[i][j+k] xor TEXT[k];
         }fprintf(out,"\n");
         fprintf(out,"RESULTS FOR THAT COMBINATION ARE:\n");
         for(k=0;k<10;k++){
            for(l=0;l<Tsize;l++){
               fprintf(out,"%c ",(MASK[l] xor BYTES[k][j+l]) );
            }fprintf(out,"\n");
         }
         fprintf(out,"/////////////////////////\n");
      }
   }
   system("Pause");
   return 0;
}

#include<cstdio>

// THE SERACHED CODE IS : 33 64 35 36 37 94 38 42 40 35 36 37 94 38 64 35 36 37 64 35  :)
char ALL[][25]={"i am ready",
                "little z the best on",
                "i want to sleep agai",
                "i am fat and ugly on",
                "who let the dogs bit",
                "where is my underwea",
                "how do you want to b",
                "sleeping is boring t",
                "my haircut is stupid",
                "over there is not ho",
                "his camera works coo"};
int main(){
    int n;
    scanf("%d",&n);
    printf("%s",ALL[n]);
    return 0;
}

#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<stack>
#include<set>
#include<queue>
#include<vector>
#include<iostream>
using namespace std;
const int inf = (int)10e9;

struct edge{
   int dist,E;
   edge(int p2,int p3):dist(p2),E(p3){};
   edge(){};
};

int n,m,S,E;
vector<edge>way[100005];
int dist[100005];

class comp{
   public:
      bool direction;       
      comp( bool rastuci ):direction(rastuci){};
      comp():direction(true){};       
      bool operator()( const int &A, const int &B) const{   
         if(dist[A]>=dist[B])return 1;
         return 0;
      }            
};  


void shortest()
{
   int i,u;
   int node,val,alt;
   priority_queue< int , vector<int> , comp >Q;
   for(i=1;i<=n;i++){
      dist[i]=inf;
     // if(i!=S)Q.push(i);
   }
   dist[S]=0;
   Q.push( S );
   int sizeN = n;
   while(dist[Q.top()] != inf && !Q.empty())
   {
      node= Q.top();
      Q.pop(); 
      for(i=0;i<way[node].size();i++)
      {
         alt = dist[node]+ way[node][i].dist;
         if( alt < dist[way[node][i].E] )
         {
            dist[way[node][i].E] = alt;
            Q.push(way[node][i].E);
         }
         
      }
   }
   if( dist[E]==inf )
      cout<<-1<<endl;
   else
      cout<<dist[E]<<endl;
}


int main()
{
       
   int a,b,c,d;
   //FILE *in = fopen("Ulaz.txt","r");
   scanf("%d%d%d%d",&n,&m,&S,&E);
   for(int i=0;i<m;i++)
   {
      scanf("%d%d%d",&a,&b,&c);
      way[a].push_back( edge( c,b) );
      way[b].push_back( edge( c,a) );
   }
   shortest();
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<math.h>
#include<cstdlib>
#include<fstream>
#include<vector>
#include<stack>
#include<queue>
using namespace std;

struct spec{
   int color,node;
   spec(int p1, int p2):color(p1),node(p2){};
   spec(){};
};

int DIST[100005];
int WasHere[100005];
vector<int>edge[100005];

int main()
{
   int n,k,i,j;
   int A,B;
   scanf("%d%d",&n,&k);
   for(i=0;i<n-1;i++){
      scanf("%d%d",&A,&B);
      edge[A].push_back(B);
      edge[B].push_back(A);
   }
   bool IsTree=true;
   queue<spec>Q;
   for(i=1;i<=n;i++){
      if( edge[i].size()==0 )IsTree=false;
      if( edge[i].size()==1 ){Q.push( spec(i,i) );WasHere[i] = i; }
   }
   if( Q.size() == 2  && k==n-1 ){cout<<"Da"; return 0;}
   if( IsTree==false ){cout<<"Ne"; return 0;}
   spec u;
   int MAXNODE=0;
   vector<int>::iterator it;
   while(!Q.empty()){
      u = Q.front();Q.pop();
      for( it = edge[u.node].begin(); it!=edge[u.node].end(); it++ ){
         if( WasHere[*it] == 0 ){
            WasHere[*it]=u.color;
            DIST[*it] = DIST[u.node]+1;
            if( DIST[*it] > DIST[MAXNODE] ) MAXNODE = *it;
            Q.push( spec( u.color , *it ) );
         }else if( WasHere[*it]!=u.color && DIST[u.node]+1!=DIST[*it] && WasHere[*it]!=-1 ){
            IsTree=false;
         }else
            WasHere[u.node]=-1;
      }
   }
   if( IsTree==false || DIST[MAXNODE]!=k ){cout<<"Ne"; return 0;}
   else{cout<<"Da"; return 0;}
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdlib>
using namespace std;
 
long long MOD = 1;
int main()
{
    long long int result = 1,a,i;
    for(i=0;i<10;i++)MOD*=10;
    int n;
    cin>>n;
    for(i=2;i<=n;i++)
    {
        result = result * i;
        while( result % 10 == 0)
            result /=10;
        result = result % MOD;
    }
    cout<<result%10<<endl;system("Pause");
    return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<vector>
#include<math.h>
#include<fstream>
#include<set>
using namespace std;

int main()
{
   string text;
   ifstream in("Ulaz.txt");
   multiset<string>T;
   set<string>TS;
   while( in.eof() == false ){
      getline(in,text);
      int start = 0;
      int end = text.size();
      string add;
      for(;start<end;start++){
         add = "";
         while( isalpha(text[start]) ){
            add = add + ((char)tolower(text[start]));
            start++;
         }
         if( add.size()>0 ){
            T.insert(add);
            TS.insert(add);
         }
      }
   }
   set<string>::iterator it;
   string res="";int MAXN=0;
   for ( it = TS.begin(); it!=TS.end() ; it++ ){
      int n = T.count(*it);
      if( n>MAXN ){
         MAXN= n;
         res = *it;
      }
   }
   cout<<res<<" "<<MAXN<<endl;system("Pause");
   return 0;
}

#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<stack>
#include<set>
#include<queue>
#include<vector>
#include<iostream>
using namespace std;
const int inf = (int)10e9;

struct edge{
   int dist,E;
   edge(int p2,int p3):dist(p2),E(p3){};
   edge(){};
};

int n,m,S,E;
vector<edge>way[100005];
int dist[100005];

class comp{
   public:
      bool direction;       
      comp( bool rastuci ):direction(rastuci){};
      comp():direction(true){};       
      bool operator()( const int &A, const int &B) const{   
         if(dist[A]>=dist[B])return 1;
         return 0;
      }            
};  


void shortest()
{
   int i,u;
   int node,val,alt;
   priority_queue< int , vector<int> , comp >Q;
   for(i=1;i<=n;i++){
      dist[i]=inf;
      if(i!=S)Q.push(i);
   }
   dist[S]=0;
   Q.push( S );
   int sizeN = n;
   while(dist[Q.top()] != inf && !Q.empty())
   {
      node= Q.top();
      Q.pop(); 
      for(i=0;i<way[node].size();i++)
      {
         alt = dist[node]+ way[node][i].dist;
         if( alt < dist[way[node][i].E] )
         {
            dist[way[node][i].E] = alt;
            Q.push(way[node][i].E);
         }
         
      }
   }
   if( dist[E]==inf )
      cout<<-1<<endl;
   else
      cout<<dist[E]<<endl;
}


int main()
{
       
   int a,b,c,d;
   //FILE *in = fopen("Ulaz.txt","r");
   scanf("%d%d%d%d",&n,&m,&S,&E);
   for(int i=0;i<m;i++)
   {
      scanf("%d%d%d",&a,&b,&c);
      way[a].push_back( edge( c,b) );
      way[b].push_back( edge( c,a) );
   }
   shortest();
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<vector>
#include<math.h>
#include<set>
using namespace std;

struct POINT{
       int x,y;
       POINT(){};
       POINT(int p1,int p2):x(p1),y(p2){};
};

struct RECKT{
       POINT A,B,C,D;
       RECKT(){};
       RECKT( POINT p1, POINT p2 ):A(p1),B(p2){
          C.x = A.x;
          C.y = B.y;
          D.x = B.x;
          D.y = A.y;
       };
       void COUTME(){
          cout<<A.x<<","<<A.y<<" "<<B.x<<","<<B.y<<" "<<C.x<<","<<C.y<<" "<<D.x<<","<<D.y<<endl;
       }
}; 

bool SUCCESS_OVERLAPP;
RECKT OVERLAPP( RECKT MAIN, RECKT &TEMP ){
   SUCCESS_OVERLAPP = true;
   int X,Y;
   if( (TEMP.A.x>=MAIN.A.x && TEMP.A.x<=MAIN.B.x) && (TEMP.A.y>=MAIN.A.y && TEMP.A.y<=MAIN.B.y) ){
         X = min( MAIN.B.x , TEMP.B.x);
         Y = min( MAIN.B.y , TEMP.B.y);
         MAIN = RECKT(  POINT(TEMP.A.x,TEMP.A.y),POINT(X,Y) );
   }else if( (TEMP.B.x>=MAIN.A.x && TEMP.B.x<=MAIN.B.x) && (TEMP.B.y>=MAIN.A.y && TEMP.B.y<=MAIN.B.y) ){
         X = max( MAIN.A.x , TEMP.A.x);
         Y = max( MAIN.A.y , TEMP.A.y);
         MAIN = RECKT( POINT(X,Y) , POINT(TEMP.B.x,TEMP.B.y) );
   }else if( MAIN.A.y<=TEMP.A.y && MAIN.B.y>=TEMP.B.y && MAIN.A.x>=TEMP.A.x && MAIN.B.x<=TEMP.B.x ){
         MAIN = RECKT( POINT(MAIN.A.x,TEMP.A.y) , POINT(MAIN.B.x,TEMP.B.y) );
   }else if( TEMP.C.x>=MAIN.A.x && TEMP.C.x<=MAIN.B.x && TEMP.C.y<=MAIN.B.y && TEMP.C.y>=MAIN.A.y ){
         X = MAIN.B.x;
         Y = MAIN.A.y;
         MAIN = RECKT ( POINT(TEMP.C.x,Y)  , POINT(X,TEMP.C.y) );
   }else if( TEMP.D.x>=MAIN.A.x && TEMP.D.x<=MAIN.B.x && TEMP.D.y<=MAIN.B.y && TEMP.D.y>=MAIN.A.y){
         MAIN = RECKT( POINT(MAIN.A.x,TEMP.D.y) , POINT(TEMP.D.x,MAIN.B.y) );
   }else
         SUCCESS_OVERLAPP = false;
   return MAIN;
}

RECKT ALL[5001];

int main()
{
   int n,i,j,k;
   int p1,p2,p3,p4;
   scanf("%d",&n);
   RECKT MAIN( POINT(p1,p2) , POINT(p3,p4) );
   RECKT TEMP;
   RECKT NEW;
   long long A,M,S=0;
   for(i=0;i<n;i++){
      scanf("%d%d%d",&p1,&p2,&p3);
      TEMP = RECKT( POINT(p1,p2),POINT(p1+p3,p2+p3) );
      ALL[i]=TEMP;
      M = (TEMP.A.x - TEMP.B.x)*(TEMP.A.y - TEMP.B.y);
      for(j=i-1;j>=0;j--){
         A = 0;
         NEW = OVERLAPP(ALL[j],TEMP);
         if( !SUCCESS_OVERLAPP )
         {
            NEW = OVERLAPP(TEMP,ALL[j]);
            if( SUCCESS_OVERLAPP )
               A = (NEW.A.x - NEW.B.x)*(NEW.A.y - NEW.B.y);
         }else
               A = (NEW.A.x - NEW.B.x)*(NEW.A.y - NEW.B.y);
         M-=A;
      }
      S+=M;
   }
   cout<<S<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<vector>
#include<math.h>
#include<string>
#include<algorithm>
using namespace std;

string mjeseciN[]={"Januar","Februar","Mart","April","Maj","Juni","Juli","August","Septembar","Oktobar",
                   "Novembar","Decembar"};
int mjeseciL[]={31,28,31,30,31,30,31,31,30,31,30,31};
int poz;
int days;

void MultiN(vector<int> &V,int p)
{
   int k=V.size();
   int T;
   int aux=0;
   int i;
   for(i=0;i<k;i++)
   {
      aux = (V.at(i) * p)+aux;
      V.at(i) = aux%10;
      aux/=10;
   }
   while(aux){
      V.push_back(aux%10);
      aux/=10;
   }
}

void write(vector<int>&V)
{
   int k=V.size();
   int i;
   for(i=k-1;i>=0;i--)
      cout<<V.at(i)<<" ";cout<<endl;
}

void datum()
{
   for(poz=0;poz<12 && days>0;poz++)
      days-=mjeseciL[poz];
   poz--;
}


int main()
{
   int n,i;
   int counter=0;int redni=0;
   cin>>n;
   vector<int>V;
   V.push_back(1);
   for(i=2;i<=n;i++)MultiN(V,i);
   sort(V.begin(),V.end());
   days=n;
   datum();
   cout<<mjeseciN[poz]<<" "<<mjeseciL[poz]+days<<endl;
   for(i=0;i<V.size()-1;i++)
   {
      if(!counter)printf("Pflanze %d:",redni++);
      if( V.at(i) != V.at(i+1) ){
         printf("%d\n",counter+1);
         counter=0;
      }else
         counter++;
   }printf("%d\n",counter+1);
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<vector>
#include<math.h>
#include<set>
using namespace std;

struct POINT{
       int x,y;
       POINT(){};
       POINT(int p1,int p2):x(p1),y(p2){};
};

struct RECKT{
       POINT A,B,C,D;
       RECKT(){};
       RECKT( POINT p1, POINT p2 ):A(p1),B(p2){
          C.x = A.x;
          C.y = B.y;
          D.x = B.x;
          D.y = A.y;
       };
}; 

bool SUCCESS_OVERLAPP;
RECKT OVERLAPP( RECKT &MAIN, RECKT &TEMP ){
   SUCCESS_OVERLAPP = true;
   int X,Y;
   if( (TEMP.A.x>=MAIN.A.x && TEMP.A.x<=MAIN.B.x) && (TEMP.A.y>=MAIN.A.y && TEMP.A.y<=MAIN.B.y) ){
         X = min( MAIN.B.x , TEMP.B.x);
         Y = min( MAIN.B.y , TEMP.B.y);
         MAIN = RECKT(  POINT(TEMP.A.x,TEMP.A.y),POINT(X,Y) );
   }else if( (TEMP.B.x>=MAIN.A.x && TEMP.B.x<=MAIN.B.x) && (TEMP.B.y>=MAIN.A.y && TEMP.B.y<=MAIN.B.y) ){
         X = max( MAIN.A.x , TEMP.A.x);
         Y = max( MAIN.A.y , TEMP.A.y);
         MAIN = RECKT( POINT(X,Y) , POINT(TEMP.B.x,TEMP.B.y) );
   }else if( MAIN.A.y<=TEMP.A.y && MAIN.B.y>=TEMP.B.y && MAIN.A.x>=TEMP.A.x && MAIN.B.x<=TEMP.B.x ){
         MAIN = RECKT( POINT(MAIN.A.x,TEMP.A.y) , POINT(MAIN.B.x,TEMP.B.y) );
   }else if( TEMP.C.x>=MAIN.A.x && TEMP.C.x<=MAIN.B.x && TEMP.C.y<=MAIN.B.y && TEMP.C.y>=MAIN.A.y ){
         X = MAIN.B.x;
         Y = MAIN.A.y;
         MAIN = RECKT ( POINT(TEMP.C.x,Y)  , POINT(X,TEMP.C.y) );
   }else if( TEMP.D.x>=MAIN.A.x && TEMP.D.x<=MAIN.B.x && TEMP.D.y<=MAIN.B.y && TEMP.D.y>=MAIN.A.y){
         MAIN = RECKT( POINT(MAIN.A.x,TEMP.D.y) , POINT(TEMP.D.x,MAIN.B.y) );
   }else
         SUCCESS_OVERLAPP = false;
   return MAIN;
}

int main()
{
   int n,i,j,k;
   int p1,p2,p3,p4;
   int X,Y;
   bool PASS = true;
   scanf("%d",&n);
   scanf("%d%d%d%d",&p1,&p2,&p3,&p4);
   RECKT MAIN( POINT(p1,p2) , POINT(p3,p4) );
   RECKT TEMP;
   RECKT NEW;
   for(i=1;i<n && PASS;i++){
      scanf("%d%d%d%d",&p1,&p2,&p3,&p4);
      TEMP = RECKT( POINT(p1,p2),POINT(p3,p4) );
      NEW = OVERLAPP(MAIN,TEMP);
      if( !SUCCESS_OVERLAPP ){
         NEW = OVERLAPP(TEMP,MAIN);
         if( !SUCCESS_OVERLAPP )
            PASS = false;
         else
            MAIN = NEW;
      }else
         MAIN = NEW;
   }
   if( PASS == true ){
      long long AREA = ((long long)(MAIN.A.x - MAIN.B.x))*(MAIN.A.y - MAIN.B.y);
      cout<<AREA<<endl;
   }else
      cout<<0<<endl;
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
#include<set>
using namespace std;
const int MAXX=1000000;

struct POINT{
       int x,y;
       POINT(int p1,int p2):x(p1),y(p2){};
       POINT(){};
};

struct SEGMENT{
       POINT A,B;
       SEGMENT( POINT a, POINT b ):A(a),B(b){};
       SEGMENT(){};
       int CROSS( POINT );
       bool ON_LINE( POINT );
};

int SEGMENT::CROSS( POINT REF ){
   return (B.x-A.x)*(REF.y-A.y)-(B.y-A.y)*(REF.x-A.x);
}

bool SEGMENT::ON_LINE( POINT REF ){
   return ( min(A.x,B.x)<=REF.x && max(A.x,B.x)>=REF.x && min(A.y,B.y)<=REF.y && max(A.y,B.y)>=REF.y );
}

vector<SEGMENT>LINES;
vector<SEGMENT>BASE;
set<long long>PS;


#define x1 S1.A.x
#define x2 S1.B.x
#define x3 S2.A.x
#define x4 S2.B.x
#define y1 S1.A.y
#define y2 S1.B.y
#define y3 S2.A.y
#define y4 S2.B.y

bool INTERSECT( SEGMENT S1, SEGMENT S2 ){
   int s1 = S1.CROSS(S2.A);
   int s2 = S1.CROSS(S2.B);
   int s3 = S2.CROSS(S1.A);
   int s4 = S2.CROSS(S1.B);
   if( ((s1>0 && s2<0)||(s1<0 && s2>0)) && ((s3>0 && s4<0)||(s3<0 && s4>0)) ){
      double xI = ((x1*y2-y1*x2)*(x3-x4) - (x1-x2)*(x3*y4 - y3*x4)) /
                 ((double)((x1-x2)*(y3-y4) - (y1-y2)*(x3-x4)));
      double yI = ((x1*y2-y1*x2)*(y3-y4) - (y1-y2)*(x3*y4 - y3*x4)) /
                 ((double)((x1-x2)*(y3-y4) - (y1-y2)*(x3-x4)));
      int xC = ((int)xI);
      int yC = ((int)yI);
      if( fabs(xI-xC)<0.00000001 && fabs(yI-yC)<0.00000001 && PS.count( xC*MAXX+yC )==0 ){
         PS.insert( xC*MAXX+yC  );
         return 1;
      }else return 0;
   }else if( s1==0 && S1.ON_LINE(S2.A) && PS.count(S2.A.x*MAXX + S2.A.y)==0 ){
      PS.insert(S2.A.x*MAXX + S2.A.y);      
      return 1;
   }
   else if( s2==0 &&  S1.ON_LINE(S2.B) && PS.count(S2.B.x*MAXX + S2.B.y)==0 ){
      PS.insert(S2.B.x*MAXX + S2.B.y);      
      return 1;
   }
   else if( s3==0 &&  S2.ON_LINE(S1.A) && PS.count(S1.A.x*MAXX + S1.A.y)==0 ){
      PS.insert(S1.A.x*MAXX + S1.A.y);      
      return 1;
   }
   else if( s4==0 &&  S2.ON_LINE(S1.B) && PS.count(S1.B.x*MAXX + S1.B.y)==0 ){
      PS.insert(S1.B.x*MAXX + S1.B.y);      
      return 1;
   }
   return 0;
}

void SortMy( vector<SEGMENT> &ref ){
   int n = ref.size();
   int CHANGE;
   int s1,s2,s3,s4,i,j;
   for(i=0;i<n;i++){
      CHANGE = i+1;
      for(j=i+1;j<n && CHANGE == i+1;j++){
         s1 = ref[i].CROSS(ref[j].A);
         s2 = ref[i].CROSS(ref[j].B);
         s3 = ref[j].CROSS(ref[i].A);
         s4 = ref[j].CROSS(ref[i].B);
         if( s1==0 && s2==0 ){
            if( ref[i].ON_LINE(ref[j].A) )CHANGE = j;
            if( ref[i].ON_LINE(ref[j].B) )CHANGE = j;
         }else if( s3==0 && s4==0 ){
            if( ref[j].ON_LINE(ref[i].A) )CHANGE = j;
            if( ref[j].ON_LINE(ref[i].B) )CHANGE = j;
         }
      }
      if(CHANGE!=i+1)
      swap( ref[i+1],ref[CHANGE] );
   }                 
}     

int main()
{
   int n,i,j,k;
   int p1,p2,p3,p4;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d%d%d%d",&p1,&p2,&p3,&p4);
      LINES.push_back( SEGMENT(POINT(p1,p2),POINT(p3,p4)) );
   }
   SortMy(LINES);
   int s1,s2,s3,s4;
   for(i=0;i<n;i++){
      SEGMENT OSNOVA = LINES[i];
      i++;
      s1 = OSNOVA.CROSS(LINES[i].A);
      s2 = OSNOVA.CROSS(LINES[i].B);
      s3 = LINES[i].CROSS(OSNOVA.A);
      s4 = LINES[i].CROSS(OSNOVA.B);
      while( i<n && s1==0 && s2==0 && s3==0 && s4==0 
             && (LINES[i].ON_LINE(OSNOVA.A) || LINES[i].ON_LINE(OSNOVA.B)
             || OSNOVA.ON_LINE(LINES[i].A) || OSNOVA.ON_LINE(LINES[i].B))    )
             {
                int P = 1;
                if( LINES[i].ON_LINE(OSNOVA.A)==0 )
                   if(P==1){OSNOVA.A = OSNOVA.A;P++;}
                   else if(P==2){OSNOVA.B = OSNOVA.A;P++;}
                   
                if( LINES[i].ON_LINE(OSNOVA.B)==0 )
                   if(P==1){OSNOVA.A = OSNOVA.B;P++;}
                   else if(P==2){OSNOVA.B = OSNOVA.B;P++;}
                
                if( OSNOVA.ON_LINE(LINES[i].A)==0 )
                   if(P==1){OSNOVA.A = LINES[i].A;P++;}
                   else if(P==2){OSNOVA.B = LINES[i].A;P++;}
                   
                if( OSNOVA.ON_LINE(LINES[i].B)==0 )
                   if(P==1){OSNOVA.A = LINES[i].B;P++;}
                   else if(P==2){OSNOVA.B = LINES[i].B;P++;}
                   
                i++;
                s1 = OSNOVA.CROSS(LINES[i].A);
                s2 = OSNOVA.CROSS(LINES[i].B);
                s3 = LINES[i].CROSS(OSNOVA.A);
                s4 = LINES[i].CROSS(OSNOVA.B);
             }i--;
             
      BASE.push_back(OSNOVA);
   }
   int ADD;
   long long SUM=0;
   bool INTER;
   for(i=0;i<BASE.size();i++){
      ADD = __gcd(abs(BASE[i].B.x-BASE[i].A.x),abs(BASE[i].B.y-BASE[i].A.y) )+1;
      for(j=i-1;j>=0;j--){
         INTER = INTERSECT(BASE[i],BASE[j]);
         if(INTER)ADD--;
      }PS.clear();
      SUM+=ADD;
   }
   cout<<SUM<<endl;
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<set>
#include<iomanip>
using namespace std;

short field[1001][1001];

int main()
{
    //FILE *in = fopen("Ulaz.txt","r");
    int n,i,j,k;
    scanf("%d",&n);
    int x,y,l;
    for(i=0;i<n;i++)
    {
       scanf("%d%d%d",&x,&y,&l);
       for(j=0;j<l;j++){
          field[y+j][x]++;
          field[y+j][x+l]--;
       }
    }
    int MODE;
    int OVERALL=0;
    for(i=0;i<1000;i++){
       MODE = 0;
       for(j=0;j<1000;j++){
          
          MODE+=field[i][j];
          OVERALL += ( MODE>0 );
       }
    }
    cout<<OVERALL<<endl;
    //system("Pause");
    return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;

int K,N;
int SpozX[1000],EpozX[1000];
int SpozY[1000],EpozY[1000];

void RotX( int Ypoz,int pomak ){
   for(int i=0;i<K;i++)
      if( Ypoz == SpozY[i] )
         SpozX[i] = (SpozX[i]+pomak)%N;
}
void RotY( int Xpoz,int pomak ){
   for(int i=0;i<K;i++)
      if( Xpoz == SpozX[i] )
         SpozY[i] = (SpozY[i]+pomak)%N;
}

int main()
{
   int i,j;
   scanf("%d%d",&N,&K);
   int elem;
   for(i=0;i<K;i++){
      scanf("%d%d%d",&elem,&EpozY[i],&EpozX[i]);
      elem--;EpozY[i]--;EpozX[i]--;
      SpozY[i] = elem / N;
      SpozX[i] = elem % N;
   }
   for(i=0;i<K;i++){
      int XtoRot = EpozX[i]-SpozX[i];
      int YtoRot = EpozY[i]-SpozY[i];
      if( XtoRot < 0 ) XtoRot += N;
      if( YtoRot < 0 ) YtoRot += N;
      RotX( SpozY[i],XtoRot );
      RotY( SpozX[i],YtoRot );
      cout<<XtoRot+YtoRot<<endl;
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
#include<cctype>
using namespace std;

struct SpecNumber{
   int N;
   float DEC;
   bool MINUS;
   SpecNumber( int p1 , float p2 , bool p3 ):N(p1),DEC(p2),MINUS(p3){};
   SpecNumber(){};
};

struct DuoNum{
   SpecNumber x,y;
   DuoNum( SpecNumber p1 , SpecNumber p2 ):x(p1),y(p2){};
   DuoNum(){};
};

vector<DuoNum>ALL;

int main()
{
  //  ifstream in("U.txt");
   string TEXT;
   getline(cin,TEXT);
   int n = TEXT.size()-1;
   int fak,i,j;
   bool MODE=false;
   int Vsize = 0;
   int open=0,close=0;
   bool invalid = false;
   if( TEXT.substr(0,7) != "POLYGON" ) invalid = true;
   if( TEXT.substr(7,2) != "((" ) invalid = true;
   if( TEXT.substr(TEXT.size()-2,3) != "))" ) invalid = true;
   bool BreakEver=false;
   for(i=n-2;i>=0;i--){
      int L=0,Z=0;
      float R=0;
      bool MINUS=false;
      while( isdigit(TEXT[i])==false ){
  //           cout<<TEXT[i]<<" "<<invalid<<endl;
         if(TEXT[i]=='(' ){BreakEver=true;break;}
         else if(TEXT[i]!=' ' && TEXT[i]!=',')invalid = true;
         i--;
      }
      if(BreakEver)break;
      fak = 1;
      while( isdigit(TEXT[i]) && i>=0 ){
         R += fak*(TEXT[i]-'0');
         fak*=10;
         i--;
      }
      if( TEXT[i]=='.' && i>=0){
         i--;
         R = R/fak;
         fak = 1;
         while( isdigit(TEXT[i]) && i>=0 ){
            L += fak*(TEXT[i]-'0');
            fak*=10;
            i--;
         }
      }else{
         L = ((int)R);
         R = 0;
      }
      if( TEXT[i]=='-' && i>=0 ){
         i--;
         MINUS = true;
      }
      if( MODE == false && i>=0 ){
         MODE = !MODE;
         ALL.push_back( DuoNum( SpecNumber(0,0,0) , SpecNumber(L,R,MINUS) )  );
         Vsize++;
      }else if(i>=0){
         MODE = !MODE;
         ALL[Vsize-1].x = SpecNumber(L,R,MINUS);
      }
   }//cout<<invalid<<endl;
   vector<float>X;
   vector<float>Y;
   int MINU;
   for(i=0;i<Vsize;i++){
      if( ALL[i].x.MINUS==true)MINU=-1;
      else MINU = 1;
      X.push_back( MINU * (ALL[i].x.N + ALL[i].x.DEC ) );
      
      if( ALL[i].y.MINUS==true)MINU=-1;
      else MINU = 1;
      Y.push_back( MINU * (ALL[i].y.N + ALL[i].y.DEC ) );
   }
   bool Solution = true;
   bool X180=false, Y180=false;
   if( Vsize < 3 || X[0]!=X[Vsize-1] || Y[0]!=Y[Vsize-1] ) Solution = false; 
   for(i=0;i<Vsize;i++){
      if( (X[i]>=-90 && X[i]<=90) )1;
      else if( (X[i]>=-180 && X[i]<=180) && !Y180 )X180 = true;
      else Solution = false;
      
      if( (Y[i]>=-90 && Y[i]<=90) );
      else if( (Y[i]>=-180 && Y[i]<=180) && !X180 )Y180 = true;
      else Solution = false;
   }
   if(Solution && open-close==0 && !invalid)
      cout<<"DA";
   else
      cout<<"NE";//system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<vector>
using namespace std;

char str[200005];

int main()
{
   int n,m;
   int i,j,pos1,pos2,length,tmp;
   char command;
   scanf("%d%d",&n,&m);
   scanf("%s",str);
   for(i=0;i<m;i++){
      scanf("%c",&command);scanf("%c");
      if( command == 'S' ){
         scanf("%d%d%d",&pos1,&pos2,&length);
         pos1--,pos2--;
         for(j=0;j<length;j++){
            tmp = str[pos1+j];
            str[pos1+j] = str[pos2+j];
            str[pos2+j] = tmp;
         }
      }else{
         scanf("%d%d",&pos1,&pos2);
         pos1--;
         pos2--;
         tmp = 0;
         for(j=pos1;j<=pos2;j++)tmp+=(str[j]=='B');
         printf("%d\n",tmp);
      }
   }
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<vector>
using namespace std;

char str[200005];

int main()
{
   int n,m;
   int i,j,pos1,pos2,length,tmp;
   char command;
   scanf("%d%d",&n,&m);
   scanf("%s",str);
   for(i=0;i<m;i++){
      scanf("%c",&command);scanf("%c");
      if( command == 'S' ){
         scanf("%d%d%d",&pos1,&pos2,&length);
         pos1--,pos2--;
         for(j=0;j<length;j++){
            tmp = str[pos1+j];
            str[pos1+j] = str[pos2+j];
            str[pos2+j] = tmp;
         }
      }else{
         scanf("%d%d",&pos1,&pos2);
         pos1--;
         pos2--;
         tmp = 0;
         for(j=pos1;j<=pos2;j++)tmp+=(str[j]=='B');
         printf("%d\n",tmp);
      }
   }
   //system("Pause");
   return 0;
}

#include<cstdio>

// THE SERACHED CODE IS : 33 64 35 36 37 94 38 42 40 35 36 37 94 38 64 35 36 37 64 35  :)
char ALL[][25]={"i am ready",
                "little z the best on",
                "i want to sleep agai",
                "i am fat and ugly on",
                "who let the dogs bit",
                "where is my underwea",
                "how do you want to b",
                "sleeping is boring t",
                "my haircut is stupid",
                "over there is not ho",
                "his camera works coo"};
int main(){
    int n;
    scanf("%d",&n);
    printf("%s",ALL[n]);
    return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<vector>
#include<set>
#include<queue>
using namespace std;

struct someone{
       float x,y;
       char *name;
       someone(){};
       someone( float p1, float p2 ):x(p1),y(p2){
          name = new char[25];
       };
};

vector<someone>group;

int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   int n,i,j,k,Vsize=-1;
   char command;
   float x,y;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%c",&command);scanf("%c");
      if( command == 'G' ){
         scanf("%f%f",&x,&y);
         group.push_back( someone(x,y) );Vsize++;
         scanf("%s",group[Vsize].name);
      }else{
         scanf("%f%f",&x,&y);
         double minDist=(int)10e19;
         double TMP;
         int poz=0;
         for(j=0;j<=Vsize;j++){
            TMP = (x-group[j].x)*(x-group[j].x) + (y-group[j].y)*(y-group[j].y);
            if( TMP < minDist || (TMP==minDist && strcmp(group[poz].name,group[j].name) ) ){
               minDist = TMP;
               poz = j;
            }
         }
         printf("%s\n",group[poz].name);
      }
   }
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<vector>
#include<set>
#include<queue>
using namespace std;

struct coord{
   int x,y;
   coord(){};
   coord( int p1 , int p2 ):x(p1),y(p2){};
};

int n;
char pic1[201][201];
char pic2[201][201];
vector<coord>mogucni;
FILE *in;

void Input( char *F ){
   char TMP;
   int i;
   for(i=0;i<n;i++){
      scanf("%c",&F[i]);scanf("%c");
   }
}

void FillVecKey( char ToFind ){
   int i,j;
   for(i=0;i<n;i++)
      for(j=0;j<n;j++)
         if( pic2[i][j]==ToFind )
            mogucni.push_back( coord(j,i) );
}

bool SortByXY( coord A, coord B ){
   return ( A.x>B.x || (A.x==B.x && A.y>B.y) );
}

bool IsValid( int x, int y ){
   bool RET = true;
   int i,j;
   int Cx , Cy = n-1;
   for(i=y;i>=0 && RET;i--){
     Cx = n-1;
     for(j=x;j>=0 && RET;j--){
        if( pic1[Cy][Cx] != pic2[i][j] ) RET = false;
        Cx--;
     }
     Cy--;
   }
   return RET;
}

int main()
{
   //in = fopen("Ulaz.txt","r");
   int i,j,k;
   scanf("%d",&n);
   for(i=0;i<n;i++)Input( pic1[i] );
   for(i=0;i<n;i++)Input( pic2[i] );
   char KeyToFind = pic1[n-1][n-1];
   FillVecKey( KeyToFind );
   sort( mogucni.begin(), mogucni.end() , SortByXY );
   int NM = mogucni.size();
   bool foundIt;
   for(i=0;i<NM;i++){
      foundIt = IsValid( mogucni[i].x , mogucni[i].y );
      if( foundIt ){
         printf("%d %d\n",n-mogucni[i].x-1,n-mogucni[i].y-1 );
         break;
      }
   }
   //if( DOMORE )printf("0 %d\n",n);
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;

char sven[100];
char TRIO[]={'S','R','P'};
char opponent[60][100];

int VS( char &S1 , char &S2 ){
   if( (S1=='S' && S2=='P') || (S1=='P' && S2=='R') || (S1=='R' && S2=='S') )return 2;
   else if( (S1=='S' && S2=='S') || (S1=='P' && S2=='P') || (S1=='R' && S2=='R') )return 1;
   else return 0;
}

int main()
{
   int R,n;
   int i,j,k;
   scanf("%d",&R);
   scanf("%s",sven);
   scanf("%d",&n);
   for(i=0;i<n;i++)scanf("%s",opponent[i]);
   int NORMAL=0,BEST=0;
   int MAXN,ADD;
   for(i=0;i<R;i++){
      for(j=0;j<n;j++)
         NORMAL+=VS( sven[i] , opponent[j][i] );
      MAXN = 0;
      for(j=0;j<3;j++){
         ADD=0;
         for(k=0;k<n;k++)
            ADD+=VS(TRIO[j],opponent[k][i]);
         if(ADD>MAXN)MAXN=ADD;
      }
      BEST+=MAXN;
   }
   cout<<NORMAL<<endl;
   cout<<BEST<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<vector>
#include<math.h>
#include<set>
using namespace std;

vector<int>ints;

int main()
{
   int n,i,j,v;
   scanf("%d",&n);
   for(i=0;i<n;i++){
       scanf("%d",&v);
       ints.push_back(v);
   }
   sort(ints.begin(),ints.end());
   if( ints[0]<0 ){
      if( ints[n-1]==0 || ints[n-2]==0 )
         cout<<ints[0]<<" "<<ints[1]<<" "<<ints[0]<<" "<<ints[n-1]<<endl;
      else if( ints[0]*ints[1]<ints[n-1]*ints[n-2] )
         cout<<ints[n-2]<<" "<<ints[n-1]<<" "<<ints[0]<<" "<<ints[n-1]<<endl;
      else if( ints[n-1]>0 )
         cout<<ints[0]<<" "<<ints[1]<<" "<<ints[0]<<" "<<ints[n-1]<<endl;
      else
         cout<<ints[0]<<" "<<ints[1]<<" "<<ints[n-2]<<" "<<ints[n-1]<<endl;
   }else{
      cout<<ints[n-2]<<" "<<ints[n-1]<<" "<<ints[0]<<" "<<ints[1]<<endl;
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<vector>
#include<math.h>
#include<set>
using namespace std;

vector<int>ints;

int main()
{
   int n,i,j,v;
   scanf("%d",&n);
   for(i=0;i<n;i++){
       scanf("%d",&v);
       ints.push_back(v);
   }
   sort(ints.begin(),ints.end());
   if( ints[0]<0 ){
      if( ints[n-1]==0 || ints[n-2]==0 )
         cout<<ints[0]<<" "<<ints[1]<<" "<<ints[0]<<" "<<ints[n-1]<<endl;
      else if( ints[0]*ints[1]<ints[n-1]*ints[n-2] )
         cout<<ints[n-2]<<" "<<ints[n-1]<<" "<<ints[0]<<" "<<ints[n-1]<<endl;
      else if( ints[n-1]>0 )
         cout<<ints[0]<<" "<<ints[1]<<" "<<ints[0]<<" "<<ints[n-1]<<endl;
      else
         cout<<ints[0]<<" "<<ints[1]<<" "<<ints[n-2]<<" "<<ints[n-1]<<endl;
   }else{
      cout<<ints[n-2]<<" "<<ints[n-1]<<" "<<ints[0]<<" "<<ints[1]<<endl;
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<vector>
#include<math.h>
#include<fstream>
#include<set>
using namespace std;

int main()
{
   string text;
   multiset<string>T;
   set<string>TS;
   while( cin.eof() == false ){
      getline(cin,text);
      int start = 0;
      int end = text.size();
      string add;
      for(;start<end;start++){
         add = "";
         while( isalpha(text[start]) ){
            add = add + ((char)tolower(text[start]));
            start++;
         }
         if( add.size()>0 ){
            T.insert(add);
            TS.insert(add);
         }
      }
   }
   set<string>::iterator it;
   string res="";int MAXN=0;
   for ( it = TS.begin(); it!=TS.end() ; it++ ){
      int n = T.count(*it);
      if( n>MAXN ){
         MAXN= n;
         res = *it;
      }
   }
   cout<<res<<" "<<MAXN<<endl;
   return 0;
}

#include<cstdio>
#include<algorithm>
char buff[255];
int main(){
   scanf("%s",buff);
   int i,n=strlen(buff),brojilac=1,RES=0;
   for(i=1;i<n;i++){
      if( isupper(buff[i]) ){
         if((4-(brojilac%4))!=4)RES+=(4-(brojilac%4));
         brojilac = brojilac + (4-(brojilac%4));
      }brojilac++;}
   printf("%d\n",RES);
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<string>
using namespace std;

int n;
short DP[2][5001];
char wordI[5005];
char wordII[5005];

int LCS(){
   int i,j,k;
   bool MODE = false;
   for(i=1;i<=n;i++){
      for(j=1;j<=n;j++){
         if( MODE == false ){
            if( wordI[i]==wordII[j] )
               DP[0][j] = DP[1][j-1] + 1;
            else
               DP[0][j] = max( DP[1][j] , DP[0][j-1] );
         }else{
            if( wordI[i]==wordII[j] )
               DP[1][j] = DP[0][j-1] + 1;
            else
               DP[1][j] = max( DP[0][j] , DP[1][j-1] );
         }
      }
      MODE = !MODE;
   }
   if( MODE == false )return DP[1][n];
   else return DP[0][n];
}

int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   scanf("%d",&n);
   scanf("%s",(wordI+1));
   for(int i=1;i<=n;i++)wordII[n-i+1] = wordI[i];
   int T = LCS();
   cout<<n-T<<endl;
   //system("Pause");
}

#include<iostream>
#include<queue>
#include<vector>
#include<fstream>
using namespace std;

struct cmpv{
   bool reverse;
   cmpv( bool p1=false ):reverse(p1){};
   bool operator()(const int &a, const int &b){
      if(reverse==false)return (a>b);
      else return (a<b);
   }
};

int main()
{
   priority_queue< int , vector<int> , cmpv >numbers(1);
   numbers.push(4);numbers.push(1);numbers.push(47);
   while(!numbers.empty()){
      cout<<numbers.top()<<endl;
      numbers.pop();
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
using namespace std;

int main()
{
   int n=-1;
   while( !cin.eof()&& n!=42 ){
      cin>>n;
      if(n!=42)cout<<n<<endl;
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<vector>
using namespace std;

FILE *in,*out;

bool testprime(int n){
   if( n==1 )return 0;
   if( n==2 )return 1;
   if( n%2==0 ) return 0;
   for( int i=3;i*i<=n;i+=2){
      if( n%i==0 ) return 0;
   }
   return 1;
}

void primes(int from, int to ){
   for( int i=from;i<=to;i++)
      if( testprime(i)==1 )
         fprintf(out,"%d\n",i);
}

int main()
{
   int n,i,j;
   in = fopen("Ulaz.txt","r");
   out = fopen("Izlaz.txt","w");
   fscanf(in,"%d",&n);
   int a,b;
   for(i=0;i<n;i++)
   {
      fscanf(in,"%d%d",&a,&b);
      primes(a,b);
      if(i+1!=n)fprintf(out,"\n");
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<vector>
using namespace std;

FILE *in,*out;
vector<bool>memtest(1000000001);

bool testprime(int n){
   if( n==1 )return 0;
   if( n==2 )return 1;
   if( n%2==0 ) return 0;
   for( int i=3;i*i<=n;i+=2){
      if( n%i==0 ) return 0;
   }
   return 1;
}

void init(int from, int to){
   int i,j;
   for(i=from;i<=to;i++)memtest[i]=0;
   memtest[1]=1;
   if( !testprime(from) )memtest[from]=1;
   if( !testprime(from+1) )memtest[from+1]=1;
   for(i=2;i*i<=to;i++){
      j = from/i;
      if(j==0)j=1;
          j++;
          while( i*j<=to ){
             memtest[i*j]=1;
             j++;
          }
   }
}

void count(int from , int to ){
   int ret=0;
   for(int i=from;i<=to;i++){
      if( !memtest[i])printf("%d\n",i);
   }
}

int from[11],to[11];

int main()
{
   int n;
   int f,t;
   scanf("%d",&n);
   for(int i=0;i<n;i++){
      scanf("%d%d",&from[i],&to[i]);
   }
   for(int i=0;i<n;i++){
      init(from[i],to[i]);
      count(from[i],to[i]);
      if(n!=i+1)printf("\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<math.h>
using namespace std;

void MultiN(vector<int> &V,int p){
   int k=V.size();
   int T;
   int aux=0;
   int i;
   for(i=0;i<k;i++)
   {
      aux = (V.at(i) * p)+aux;
      V.at(i) = aux%10;
      aux/=10;
   }
   while(aux){
      V.push_back(aux%10);
      aux/=10;
   }
}
void write(vector<int>&V){
   int k=V.size();
   int i;
   for(i=k-1;i>=0;i--)
      cout<<V.at(i);cout<<endl;
}

int main()
{
   int n,i,j,a;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d",&a);
      vector<int>TMP(1,1);
      for(j=2;j<=a;j++)MultiN(TMP,j);
      write(TMP);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<vector>
using namespace std;

int DP[2005][2005];
int M[2005],V[2005];

int main()
{
   int cap,N;
   scanf("%d%d",&cap,&N);
   for(int i=1;i<=N;i++)
      scanf("%d%d",&M[i],&V[i]);
   for(int i=1;i<=N;i++){
      for(int j=1;j<=cap;j++){
         if( M[i]<=j )
            DP[i][j] = max(DP[i-1][j],DP[i-1][j-M[i]]+V[i] );
         else
            DP[i][j] = DP[i-1][j];
      }
   }
   cout<<DP[N][cap]<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<vector>
using namespace std;


int main()
{
   int n=0,c;
   vector<int>nums;z
   while(cin>>c ){
      nums.push_back(c);
      n++;
   }
   sort(nums.begin(),nums.end() );
   for(int i=0;i<nums.size();i++)
     cout<<nums[i]<<" ";cout<<endl;
   return 0;
}

#include<cstdio>
int main(){
   int a,b,c;
   while(scanf("%d%d%d",&a,&b,&c)!=EOF){
      if(a==1)printf("%d\n",b+c);
      if(a==2)printf("%d\n",b-c);
      if(a==3)printf("%d\n",b*c);
      if(a==4)printf("%d\n",b/c);
      if(a==5)printf("%d\n",b%c);
   }return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdio>
#include<stack>
#include<math.h>
using namespace std;

int pri[255];
char buff[1000];
stack<char>S;

bool IsOperatorB( char c ){
   return ( c=='+' || c=='-' || c=='*' || c=='/' || c=='^' );
}

int main()
{
   pri['^']=5;pri['/']=5;pri['*']=5;pri['-']=5;pri['+']=5;
  // FILE *in = fopen("Ulaz.txt","r");
   int n,i,j;
   scanf("%d",&n);
   for(i=0;i<n;i++)
   {
       scanf("%s",buff);
       int nivo = 0;
       string RES="";
       for(j=0;j<strlen(buff);j++)
       {
          if( IsOperatorB(buff[j]) ){
             while( !S.empty() && pri[buff[j]]<pri[S.top()] ){
                RES = RES + S.top();
                S.pop();
             }
             S.push(buff[j]);
          }else if( buff[j]=='(' ){ S.push('(');
          }else if( buff[j]==')' ){
              while(S.top()!='('){
                 RES = RES + S.top();
                 S.pop();
              }S.pop();
          }else{
             RES+=buff[j];
          }
       }
       while(!S.empty()){
          RES = RES + S.top();
          S.pop();
       }
       cout<<RES<<endl;
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;

int fak(int n)
{
   int ret=1;
   while(n){n/=10;ret*=10;}ret/=10;
   return ret;
}

int reverseN(int n){
   int F = fak(n);
   int ret=0;
   while(n){
      ret += F * (n%10);
      n/=10;
      F/=10;
   }
   return ret;
}

int main()
{
   int n;
   int a,b;
   scanf("%d",&n);
   for(int i=0;i<n;i++){
      scanf("%d%d",&a,&b);
      printf("%d\n", reverseN( reverseN(a)+reverseN(b) )  );
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdio>
#include<math.h>
#include<vector>
using namespace std;
 
int MAXS = 200000;
int tree[200000];
 
void update( int idx, int val  ){
   while( idx<MAXS ){
      tree[idx]+=val;
      idx += (idx & -idx);
   }      
}
 
int read(int idx){
  int sum = 0;
  while (idx > 0){
    sum += tree[idx];
    idx -= (idx & -idx);
  }
  return sum;
}
 
int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   int n,k;
   int comm,a,b;
   scanf("%d%d",&n,&k);
   for(int i=0;i<k;i++){
      scanf("%d",&comm);
      if( comm == 1 ){
         scanf("%d%d",&a,&b);
         update(a,1);
         update(b+1,-1);
      }else if(comm == 2){
         scanf("%d",&a);      
         printf("%d\n",read(a)%2!=0 );
      }          
   } 
   system("Pause");
   return 0;    
}  

#include<cstdio>
#include<algorithm>
char word[4194350];
int main(){
   char c;
   int poz=0,i,j,res = 0;
   bool PASS;
   while(1){c = getchar();
      if( c==EOF) break;
      if( !('a'<=c && c<='z' || 'A'<=c && c<='Z' ||'0'<=c && c<='9')  ){
         PASS = true;
         for(i=0;i<poz/2&&PASS;i++)
            if(word[i]!=word[poz-i-1])PASS=false;
         if(PASS && poz>0) res++;
         poz =0;
      }else{
         if( !('0'<=c && c<='9'))word[poz++]=tolower(c);
         else word[poz++]=c;
      }
   }
   PASS = true;for(i=0;i<=poz/2&&PASS;i++)if(word[i]!=word[poz-i-1])PASS=false;if(PASS && poz>0) res++;
   printf("%d\n",res);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<set>
using namespace std;

int D;
bool empty[100][100][200];
bool visited[100][100][200];
int bigest = -9999999;

void REK( int x, int y, int z ){
   if( x<=0 || x>D || y<=0 || y>D ) return;
   
   if( z-100>(-D) && empty[x][y][z-1]==1 ){
      visited[x][y][z-1]=1;
      REK(x,y,z-1);
      return;
   }
   if( z-100>bigest)bigest = z-100;
   
   if( empty[x][y+1][z]==1 && visited[x][y+1][z]==0 ){
      visited[x][y+1][z]=1;
      REK(x,y+1,z);
   }
   if( empty[x][y-1][z]==1 && visited[x][y-1][z]==0  ){
      visited[x][y-1][z]=1;
      REK(x,y-1,z);
   }
   
   if( empty[x+1][y][z]==1 && visited[x+1][y][z]==0  ){
      visited[x+1][y][z]=1;
      REK(x+1,y,z);
   }
   
   if( empty[x-1][y][z]==1 && visited[x-1][y][z]==0   ){
      visited[x-1][y][z]=1;
      REK(x-1,y,z);
   }
   if( empty[x][y][z+1]==1 )
   {
         if( empty[x][y+1][z+1]==1  && visited[x][y+1][z+1]==0   ){
         visited[x][y+1][z+1]=1;
         REK(x,y+1,z+1);
      }
      if( empty[x][y-1][z+1]==1  && visited[x][y-1][z+1]==0 ){
         visited[x][y-1][z+1]=1;
         REK(x,y-1,z+1);
      }
   
      if( empty[x+1][y][z+1]==1  && visited[x+1][y][z+1]==0 ){
         visited[x+1][y][z+1]=1;
         REK(x+1,y,z+1);
      }
   
      if( empty[x-1][y][z+1]==1  && visited[x-1][y][z+1]==0){
         visited[x-1][y][z+1]=1;
         REK(x-1,y,z+1);
      }
   }
}

int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   int STOLEN;
   scanf("%d%d",&D,&STOLEN);
   int Sx,Sy,Sz;
   Sx = (D/2)+1;
   Sy = 1;
   Sz = 0;
   int x,y,z;
   for(int i=0;i<STOLEN;i++){
      scanf("%d%d%d",&x,&y,&z);
      empty[x][y][z+100]=1;
   }
   visited[Sx][Sy][Sz]=1;
   visited[Sx][Sy+1][Sz]=1;
   REK(Sx,Sy+1,Sz+100);
   cout<<bigest<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
#include<stack>
#include<set>
using namespace std;

long long sqr(long long a){
   return (a*a);
}

struct coord{
   int x,y;
   coord( int p1, int p2):x(p1),y(p2){};
   coord(){};
   inline double dist(coord &A){
      return sqrt( sqr(x-A.x) + sqr(y-A.y) );
   }
};

int N,D;
vector<coord>POINTS;
vector<int>Conn[5000];

bool cmpXY( coord A,coord B ){
   return ( (A.x<B.x) || (A.x==B.x && A.y<B.y) );
}

void CreateGraph(){
   sort( POINTS.begin(),POINTS.end(),cmpXY);
   int i,j;
   double DIST;
   while(POINTS.size()>0)
   {
      i = POINTS.size()-1;
      j=i+1;
      while( j<N && POINTS[j].x-POINTS[i].x<=D ){
         DIST = POINTS[i].dist(POINTS[j]);
         if( DIST<=D ){
            Conn[i].push_back(j);
            Conn[j].push_back(i);
         }
         j++;
      }
      POINTS.pop_back();
   } 
}

void DFS(int);
bool visited[5000];
int A,B;
bool RETURN1;
void ValidEdge(){
   RETURN1=false;
   DFS(A);
   for(int i=0;i<5001;i++)visited[i]=false;
}

void DFS(int q){
   int n;
   stack<int>S;
   S.push(q);
   while(!S.empty())
   {
      n = S.top();
      S.pop();
      visited[n]=true;
      if( n==B){
         RETURN1=true;
         return;
      }
      vector<int>::iterator it;
      for( it=Conn[n].begin();it!=Conn[n].end() && RETURN1==false;it++){
         if( visited[*it]==false && (n!=A || *it!=B) && *it!=-9 ){
            S.push(*it);
        }
      }
   } 
}

void DFS2(int q){
   int n;
   stack<int>S;
   S.push(q);
   while(!S.empty())
   {
      n = S.top();S.pop();
      visited[n]=true;
      vector<int>::iterator it;
      for( it=Conn[n].begin();it!=Conn[n].end();it++){
         if( visited[*it]==false && *it != -9){
           S.push(*it);
         }
      }
   }
}

int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   int i,j,xT,yT;
   scanf("%d%d",&N,&D);
   if(D>1000000){printf("1\n");return 0;}
   for(i=0;i<N;i++){
      scanf("%d%d",&xT,&yT);
      POINTS.push_back( coord(xT,yT) );
   }
   CreateGraph();
   vector<int>::iterator it;
   for(i=0;i<N;i++){
      for(it = Conn[i].begin();it!=Conn[i].end();it++){
         A=i,B=*it;
         ValidEdge();
         if( RETURN1 == false ){
            *it = -9;
         }
      }
   }
   int RES=0;
   for(i=0;i<N;i++){
      if( visited[i]==false){
         DFS2(i);
         RES++;
      }
         
   }
   cout<<RES<<endl;
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
#include<set>
using namespace std;

long long sqr(long long a){
   return (a*a);
}

struct coord{
   int x,y;
   coord( int p1, int p2):x(p1),y(p2){};
   coord(){};
   inline double dist(coord &A){
      return sqrt( sqr(x-A.x) + sqr(y-A.y) );
   }
};

int N,D;
vector<coord>POINTS;
vector<int>Conn[5000];

bool cmpXY( coord A,coord B ){
   return ( (A.x<B.x) || (A.x==B.x && A.y<B.y) );
}

void CreateGraph(){
   sort( POINTS.begin(),POINTS.end(),cmpXY);
   int i,j;
   double DIST;
   for(i=0;i<N;i++){
      j=i+1;
      while( j<N && POINTS[j].x-POINTS[i].x<=D ){
         DIST = POINTS[i].dist(POINTS[j]);
         if( DIST<=D ){
            Conn[i].push_back(j);
            Conn[j].push_back(i);
         }
         j++;
      }
   } 
}

void DFS(int);
bool visited[5000];
int A,B;
bool RETURN1;
void ValidEdge(){
   RETURN1=false;
   DFS(A);
   for(int i=0;i<5001;i++)visited[i]=false;
}

void DFS(int n){
   visited[n]=true;
   if( n==B){
      RETURN1=true;
      return;
   }
   vector<int>::iterator it;
   for( it=Conn[n].begin();it!=Conn[n].end() && RETURN1==false;it++){
      if( visited[*it]==false && (n!=A || *it!=B) && *it!=-9 ){
         DFS(*it);
      }
   }
}

void DFS2(int n){
   visited[n]=true;
   vector<int>::iterator it;
   for( it=Conn[n].begin();it!=Conn[n].end();it++){
      if( visited[*it]==false && *it != -9){
         DFS2(*it);
      }
   }
}

int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   int i,j,xT,yT;
   scanf("%d%d",&N,&D);
   for(i=0;i<N;i++){
      scanf("%d%d",&xT,&yT);
      POINTS.push_back( coord(xT,yT) );
   }
   CreateGraph();
   vector<int>::iterator it;
   for(i=0;i<N;i++){
      for(it = Conn[i].begin();it!=Conn[i].end();it++){
         A=i,B=*it;
         ValidEdge();
         if( RETURN1 == false ){
            *it = -9;
         }
      }
   }
   int RES=0;
   for(i=0;i<N;i++){
      if( visited[i]==false){
         DFS2(i);
         RES++;
      }
         
   }
   cout<<RES<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdio>
#include<math.h>
#include<vector>
#include<set>
using namespace std;

int n;
int HackRes[50001];
int HackKeys[50001];
int NotSorted[50001];
vector<int>Sorted;
vector<int>Sorted2;

int bsearch( int val ){
   int s=0,e=n-1,mid;
   bool found = false;
   while( !found && s<=e ){
      mid = (s+e)/2;
      if( Sorted[mid]==val ){
         found = true;
         break;
      }else if( Sorted[mid]<val ){
         s = mid+1;
         continue;
      }else{
         e = mid-1;
         continue;
      }
   }
   if( found == true ) return mid;
   else return -1;
}

void FindAlgorithm(){
   int i,b;
   for(i=0;i<n;i++){
      b = bsearch( NotSorted[i] );
      HackKeys[b]=i;
   }
}

int main()
{
   int i,tmp;
   //FILE *in = fopen("test.txt","r");
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d",&NotSorted[i]);
      Sorted.push_back(NotSorted[i]);
   }
   for(i=0;i<n;i++){
      scanf("%d",&tmp);
      Sorted2.push_back(tmp);
   }
   sort(Sorted.begin(),Sorted.end());
   sort(Sorted2.begin(),Sorted2.end());
   FindAlgorithm();
   for(i=0;i<n;i++)
      HackRes[ HackKeys[i] ] = Sorted2[i];
   for(i=0;i<n;i++)
      printf("%d ",HackRes[i]);printf("\n");
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<set>
#include<stack>
#include<queue>
#include<vector>
using namespace std;

const long long mod = 10000000;

int main()
{
   long long A,B;
   cin>>A>>B;
   stack<int>S;
  // B--;
   while(B!=0){
      if(B%2==0){
         S.push(1);
         B/=2;
      }else{
         S.push(2);
         B--;
      }
   }
   int u;
   long long tmp = 1;
   while(!S.empty())
   {
      u = S.top();S.pop();
      if( u==1 )
         tmp=(tmp*tmp)%mod;
      else{
         tmp = (A*tmp)%mod;
      }
   }
   cout<<tmp%10<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<string>
#include<math.h>
using namespace std;

int t;
int digits[1000];

bool isreverse(int n){
   int poz=0;
   while(n>0){
      digits[poz]=n%10;
      n/=10;
      poz++;
   }
   for(int i=0;i<poz;i++){
      if( digits[i]!=digits[poz-1-i]){return 0;}
   }
   return 1;
}

int next(int n){
    bool found = false;
    for(int i=n+1;;i++){
       if( isreverse(i) )return i;
    }
}

int main()
{
   int n,i,a;
   scanf("%d",&a);
   for(i=0;i<a;i++){
      scanf("%d",&n);
      printf("%d\n",next(n));
   }
   
   return 0;
}


#include<cstdio>
#include<vector>
using namespace std;

int n,m;
bool visited[50001];
vector<int>edge[50001];
int STACK[50001],ST=0;

int DFS(int node){
   STACK[ST++]=node;
   int u,i;
   int size;
   int ret=0;
   while(ST){
      u = STACK[--ST];
      if(visited[u]==false)ret++;
      visited[u]=true;
      size=edge[u].size();
      for(i=0;i<size;i++){
         if( visited[ edge[u][i] ]==false )
            STACK[ST++]=edge[u][i];
      }
   }
   return ret;
}

int main(){
   int i,j,a,b,R,res=-1;
   scanf("%d%d",&n,&m);
   for(i=0;i<m;i++){
      scanf("%d%d",&a,&b);
      edge[a].push_back(b);
      edge[b].push_back(a);
   }
   for(i=1;i<=n;i++){
      if( visited[i]==false ){
         R = DFS(i);
         if(R>res)res=R;
      }
   }
   printf("%d\n",res);
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<vector>
#include<math.h>
#include<fstream>
using namespace std;

struct ClParam{
   ClParam *ABC[30];
   int TimesVisited;
   ClParam():TimesVisited(0){for(int i=0;i<30;i++)ABC[i]=NULL;};
};

struct SpecSTR{
    char buff[30];
};

SpecSTR text[25000];
ClParam trie;
SpecSTR *BIGGEST;
vector<char>RES;
bool visited[25000][25];

void Insert( SpecSTR &S , ClParam &T, int deep ){
   if( deep == strlen(S.buff) ){ 
        if( T.ABC[29]==NULL )T.ABC[29] = new ClParam;
        return;
   }
   if( T.ABC[S.buff[deep]-'a']==NULL )T.ABC[S.buff[deep]-'a'] = new ClParam;
   Insert(S,*T.ABC[S.buff[deep]-'a'],deep+1);
}

void DFS(ClParam &node,int deep,bool ONWAY){
   node.TimesVisited++;
   if( node.ABC[29]!=NULL )RES.push_back('P');
   for(int i=0;i<29;i++){
      if( node.ABC[i]!=NULL && (i+'a'!=BIGGEST->buff[deep] || !ONWAY) && node.ABC[i]->TimesVisited==0 ){
         RES.push_back('a'+i);
         DFS( *node.ABC[i] , deep+1 , false );
         RES.push_back('-');
      }
   }
   if( deep<strlen(BIGGEST->buff) &&  ONWAY && node.ABC[BIGGEST->buff[deep]-'a']!=NULL && node.ABC[BIGGEST->buff[deep]-'a']->TimesVisited==0 ){
          RES.push_back(BIGGEST->buff[deep]);
          DFS( *node.ABC[BIGGEST->buff[deep]-'a'] , deep+1 , true);
   }
}

int main(){
    //return 0;
   int n,i,j,k;
   int MAXS=0;
  // return 0;
   FILE *in = fopen("t5000000354.10.in","r");
   fscanf(in,"%d",&n);
   for(i=0;i<n;i++){
      fscanf(in,"%s",text[i].buff);
      Insert(text[i],trie,0);
      if( MAXS<strlen(text[i].buff) ){
         BIGGEST = &text[i];
         MAXS = strlen(text[i].buff);
      }
   }
FILE *out = fopen("Izlaz.txt","w");
  // printf("%s\n",BIGGEST);
   DFS(trie,0,1);
   fprintf(out,"%d\n",RES.size());
   system("Pause");
   for(i=0;i<RES.size();i++)
      fprintf(out,"%c\n",RES[i]);
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<math.h>
#include<vector>
#include<fstream>
using namespace std;

struct opponent{
   int val;
   int plus;
   int minus;
   int strength;
   opponent(int p1):strength(p1){};
   opponent(){};
};

vector<opponent>AI;
int niz[2001];
bool def[2001];

bool valCmp( opponent A, opponent B ){
   return ( A.val > B.val );
}

int main()
{
   int n,i,j,tmp;
   scanf("%d",&n);
   for(i=0;i<n;i++)scanf("%d",&niz[i]);
   for(i=0;i<n;i++){
      scanf("%d",&tmp);
      AI.push_back( opponent( tmp ) );
   }
   for(i=0;i<n;i++)scanf("%d",&AI[i].plus);
   for(i=0;i<n;i++)scanf("%d",&AI[i].minus);
   for(i=0;i<n;i++)AI[i].val = AI[i].plus+AI[i].minus;
   sort( AI.begin(),AI.end(),valCmp);
   sort( niz,niz+n);
   int poz,maxN;
   int res=0;
   for(i=0;i<n;i++){
      poz = -1;
      maxN = 0;
      for(j=0;j<n;j++){
         if( def[j]==false && niz[i]>AI[j].strength && AI[j].val > maxN ){
            maxN = AI[j].val;
            poz = j;
         }
      }
      if(poz!=-1){
         def[poz]=true;
         res+= AI[poz].plus;
      }
   }
   for(i=0;i<n;i++)
      if( def[i]==false )
         res-=AI[i].minus;
   cout<<res<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
using namespace std;

int n;
int DP[701];
int sjedista[701][701];
int RESULT[701][701];

int Xret,Yret;
void ROTATE(int &nTimes){
   int tmp;
   for(int i=0;i<nTimes;i++){
     tmp = Xret;
     Xret = n-Yret-1;
     Yret = tmp;
   }
}

int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   int k,i,j;
   int START,ADD;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      for(j=0;j<n;j++){
         scanf("%d",&sjedista[i][j]);
      }
   }
   scanf("%d",&k);
   for(i=0;i<k;i++){
      scanf("%d%d",&START,&ADD);
      DP[START]+=ADD;
   }
   int ROTATED;
   int NIVOE = (n/2)+1;
   int x,y;
   int sum=0;
   for(i=0;i<NIVOE;i++){
      sum += DP[i+1];
      ROTATED = sum%4;
      for(j=0;j<n-(i*2);j++)
      {
         x = Xret = i+j;
         y = Yret = i;
         ROTATE(ROTATED);
         RESULT[Yret][Xret]=sjedista[y][x];
         if(j>0)
         {
            x = Xret = i+j;
            y = Yret = n-1-i;
            ROTATE(ROTATED);
            RESULT[Yret][Xret]=sjedista[y][x];
         }
         if(j>0)
         {
            x = Xret = i;
            y = Yret = i+j;
            ROTATE(ROTATED);
            RESULT[Yret][Xret]=sjedista[y][x];
         }
         if(j>0 && j!=n-(i*2)-1 )
         {
            x = Xret = n-1-i;
            y = Yret = i+j;
            ROTATE(ROTATED);
            RESULT[Yret][Xret]=sjedista[y][x];
         }
      }
   }
   for(i=0;i<n;i++)
   {
      for(j=0;j<n;j++){
         printf("%d ",RESULT[i][j]);
      }printf("\n");
   }
   //system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<cstdio>
#include<iostream>
#include<math.h>
using namespace std;

int MAXS;
char buff[10];
unsigned short tree[201][201][201];
bool PAINTED[201][201][201];

void update( int x,int y,int z){
   int p1,p2,p3;
   for(p1=x;p1<=MAXS;p1+=(p1 & -p1) )
      for(p2=y;p2<=MAXS;p2+=(p2 & -p2) )
         for(p3=z;p3<=MAXS;p3+=(p3 & -p3) )
            tree[p1][p2][p3]++;
}

int Q(int x,int y,int z){
   int sum=0,p1,p2,p3;
   for(p1=x;p1>0;p1-=(p1 & -p1) )
      for(p2=y;p2>0;p2-=(p2 & -p2) )
         for(p3=z;p3>0;p3-=(p3 & -p3) )
            sum+= tree[p1][p2][p3];
   return sum;
}

int main()
{
   int n,m,i,x,y,z,x1,y1,z1,SUM;
  // FILE *in = fopen("test.txt","r");
   scanf("%d%d",&MAXS,&n);
   for(i=0;i<n;i++){
      scanf("%s",buff);
      if( strcmp(buff,"ADD")==0 ){
         scanf("%d%d%d",&x,&y,&z);
         if(!PAINTED[x][y][z])update(x,y,z);
         PAINTED[x][y][z]=true;
      }else{
         scanf("%d%d%d%d%d%d",&x,&y,&z,&x1,&y1,&z1);
         SUM = Q(x1,y1,z1);
         SUM-= Q(x-1,y1,z1);
         SUM-= Q(x1,y-1,z1);
         SUM-= Q(x1,y1,z-1);
         SUM+= Q(x1,y-1,z-1);
         SUM+= Q(x-1,y1,z-1);
         SUM+= Q(x-1,y-1,z1);
         SUM-= Q(x-1,y-1,z-1);
         cout<<SUM<<endl;
      }
   }
  // system("Pause");
   return 0;
}

#include<iostream>
#include<set>
#include<fstream>
#include<queue>
using namespace std;

set<string>S;

class CLCMP{
   public:
      bool operator()( string a , string b){
         if( a[0]=='-' && b[0]!='-' )return false;
         if( a[0]=='-' && b[0]=='-' ){
            if( a.size() < b.size() )return true;
            else if( a.size()>b.size() )return false;
            else return lexicographical_compare( a.begin()+1,a.end(),b.begin()+1,b.end() );
         }
         if( b[0]=='-' && a[0]!='-' )return true;
         else{
            if( a.size() > b.size() )return true;
            else if( a.size()<b.size() )return false;
            else return !lexicographical_compare( a.begin(),a.end(),b.begin(),b.end() );
         }
      }
};

int main(){
   priority_queue< string , vector<string> , CLCMP >Q;
   string buff;
   int n,k,i,j;
  // ifstream in("dat.txt");
   cin>>n>>k;
   for(i=0;i<n;i++){
       cin>>buff;
       if( S.count(buff)==0 ){
          Q.push(buff);
          S.insert(buff);   
       }
   }
   int poz = 1;
   while(!Q.empty()){
      if(poz==k){ cout<<Q.top();break; }
      poz++;
      Q.pop();
   }         
  // system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
using namespace std;

const int N = 100000;
int spojen[N];
int size[N];

int main()
{
   int i,j,k;
   for(i=0;i<N;i++){
      spojen[i]=i;
      size[i]=1;
   }
   int a,b;
   while( cin>>a>>b ){
      for(i=a;i!=spojen[i];i=spojen[i]);
      for(j=b;j!=spojen[j];j=spojen[j]);
      if(i==j){cout<<"ALREADY CONNECTED!"<<endl; continue;}
      if( size[i] < size[j] ){
         spojen[i]=j;
         size[j]+=size[i];
      }else{
         spojen[j]=i;
         size[i]+=size[j];
      }
   }
   system("Pause");
   return 0;
}

#include<cstdio>
#include<iostream>
using namespace std;

int N = 10000;
int niz[10000];
int sz[10000];

int main()
{
    int a,b;
    int i,j;
    for(i=0;i<=N;i++){
       sz[i]=1;
       niz[i]=i;
    }
    
    while( cin>>a>>b ){
       for(i=a;i!=niz[i];i=niz[i])
          niz[i] = niz[niz[i]];
       for(j=b;j!=niz[j];j=niz[j])
          niz[j]=niz[niz[j]];
       if(i==j){cout<<"Already connected"<<endl;continue;}
       if( sz[i]<sz[j]){
          niz[i] = j;sz[j]+=sz[i];
       }else{
          niz[j] = i;sz[i]+=sz[j];
       }
       cout<<"Connection established"<<endl;
    }
}

#include<iostream>
#include<cstdio>
using namespace std;

int PartialSearch(int *field,int s,int e,int val){
   for(int i=s;i<e;i++)if(field[i]==val)return i;
   return -1;
}

int main(){
   int n,i,elem;
   scanf("%d",&n);
   scanf("%d",&elem);
   int *niz = new int[n];
   for(i=0;i<n;i++)scanf("%d",&niz[i]);
   cout<<"Index:"<<PartialSearch(niz,0,n,elem)<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<set>
#include<queue>
#include<vector>
#include<string>
using namespace std;

char s1[1000],s2[1000];
char op;

int main()
{
   scanf("%s%c",s1);
   scanf("%c",&op);
   scanf("%s",s2);
   int n = strlen(s1);
   int n1 = strlen(s2);
   int i;
   if(op=='+'){
      if(n>=n1){
         s1[n-n1]++;
         printf("%s\n",s1);
      }else{
         s2[n1-n]++;
         printf("%s\n",s2);
      }
   }else{
      printf("%s",s1);
      for(i=0;i<n1-1;i++)printf("0");printf("\n");
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<set>
#include<queue>
#include<vector>
using namespace std;

int x,y;
int Xres,Yres;
double xT=67.9343,yT=67.9343;
double xI,yI;

void Inter( double x1,double y1,double x2,double y2, double x3,double y3, double x4,double y4 )
{
      xI = ((x1*y2-y1*x2)*(x3-x4) - (x1-x2)*(x3*y4 - y3*x4)) /
                 ((double)((x1-x2)*(y3-y4) - (y1-y2)*(x3-x4)));
      yI = ((x1*y2-y1*x2)*(y3-y4) - (y1-y2)*(x3*y4 - y3*x4)) /
                 ((double)((x1-x2)*(y3-y4) - (y1-y2)*(x3-x4)));
}

int main()
{
   scanf("%d%d",&x,&y);
   Inter(x,y,xT,yT,250,0,0,250);
   cout<<xI<<" "<<yI<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<set>
#include<queue>
#include<vector>
using namespace std;

int matrix[150][150];

int main()
{
    //FILE *in = fopen("Ulaz.txt","r");
   int N,M;
   int x,y;
   int i,j,k,l,m,n;
   scanf("%d%d",&N,&M);
   for(i=0;i<M;i++){
      scanf("%d%d",&x,&y);
      matrix[x-1][y-1]++;
   }
   int maxP = M;
   int OK;
   int maxO=-1;
   for(i=1;i<=maxP;i++){
      for(j=1;j<=maxP;j++){
         if( i*j==maxP ){
            for(k=0;k<N-i+1 && k+j<N;k++){
               for(l=0;l<N-j+1 && l+i<N;l++){
                  OK =0;
                  for(m=k;m<k+j;m++){
                     for(n=l;n<l+i;n++){
                        OK+= ( matrix[m][n]!=0 );
                     }
                  }
                  if( OK>maxO ) maxO = OK;
               }
            }
         }
      }
   }
   cout<<M-maxO<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<fstream>
#include<math.h>
#include<queue>
#include<vector>
using namespace std;

int val[100000];

int main()
{
   int n,i,j;
   scanf("%d",&n);
   for(i=0;i<n;i++)scanf("%d",&val[i]);
   int poz;
   bool imp=false;
   sort(val,val+n);
   for(i=1;i<n;i++){
     poz = -1;
     for(j=i;j<n && poz==-1;j++){
        if( (val[i-1]+val[j])%3!= 0 )
           poz =j;
     }
     if(poz!=-1)
     swap( val[i],val[poz] );
     else imp = true;
   }
   if( imp == false){
   for(i=0;i<n;i++)
      printf("%d ",val[i]);printf("\n");
   }else{
      printf("impossible\n");
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<fstream>
#include<math.h>
#include<queue>
#include<vector>
using namespace std;

struct duo{
   int v1,v2;
   duo(int p1,int p2):v1(p1),v2(p2){};
   duo(){};
};

vector<int>edge[40001];
int H,W,U;
int DIST[40001];
int cost[9000000];

int giveKey(int x,int y)
{
   return y*W+x;
}

void prepare(){
     int i,j;
   for(i=0;i<H;i++){
      for(j=0;j<W;j++){
         if( j==0 || j==W-1 ){
            if(i<H)edge[ giveKey(j,i) ].push_back( giveKey(j,i+1) );
            if(i>0)edge[ giveKey(j,i) ].push_back( giveKey(j,i-1) );
         }
         if(j>0)edge[ giveKey(j,i) ].push_back( giveKey(j-1,i) );
         if(j<W)edge[ giveKey(j,i) ].push_back( giveKey(j+1,i) );
      }
   }
}

class PriQueueCMP{
   public:
      bool operator()( int A, int B ){
         return ( DIST[A] >= DIST[B] );
      }
};

const int inf = (int)10e7;

int res;
void FindShortest( int from, int to ){
   vector<int>::iterator it;
   priority_queue< int , vector<int> , PriQueueCMP >Q;
   for( int i = 0;i<U;i++ ){
      DIST[i]=inf;
      if(i!=from)Q.push(i);
   }
   DIST[from]=0;
   Q.push(from);
   while(!Q.empty()){
      int u = Q.top();
      Q.pop();
      for( it = edge[u].begin(); it!= edge[u].end(); it++ ){
         int tmp = DIST[u] + cost[ *it ];
         if( tmp < DIST[ *it ] ){
             DIST[*it] = tmp;
         }
      }
   }
   cout<<DIST[to]<<endl;
   res = DIST[to];
}

int main()
{
    FILE *in = fopen("Ulaz.txt","r");
   fscanf(in,"%d%d",&H,&W);
   U = H*W;
   prepare();
   int M;
   int a,b,c;
   for(int i=0;i<H;i++){
    for(int j=0;j<W;j++){
      fscanf(in,"%d",&a);
      cost[ giveKey(j,i) ] = a;
    }
   }
   fscanf(in,"%d",&M);
   int R = 0;
   int now = giveKey(1,1);
   for(int i=0;i<M;i++){
      fscanf(in,"%d%d",&a,&b);
      res = 0;
      FindShortest(now,giveKey(b,a) );
      now = giveKey(b,a);
      R+=res;
   }
   cout<<R<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<set>
#include<queue>
#include<vector>
using namespace std;

int main()
{
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<math.h>
#include <stdio.h>
#include <stdlib.h>
using namespace std;

int main()
{
   int N,K;
   cin>>N>>K;
   int divisor = 1;
   double T;
   do{
      divisor ++;
      T = ((double)N)/divisor;
   }while( T>K || T>divisor );
   int remainder = 0;
   if( N%divisor != 0 ){
      divisor--;
      remainder = N % divisor;
   }
   int Uside = min((int)(N/divisor),divisor);
   int Lside = max((int)(N/divisor),divisor);
   int RES = (Uside+Lside+1)+(Lside*Uside)+(remainder);
   if( Uside == K ){
      RES -= (Lside+1);
   }
   cout<<RES<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
using namespace std;

int n;
int DP[701];
int sjedista[701][701];
int RESULT[701][701];

int Xret,Yret;
void ROTATE(int &nTimes){
   int tmp;
   for(int i=0;i<nTimes;i++){
     tmp = Xret;
     Xret = n-Yret-1;
     Yret = tmp;
   }
}

int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   int k,i,j;
   int START,ADD;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      for(j=0;j<n;j++){
         scanf("%d",&sjedista[i][j]);
      }
   }
   scanf("%d",&k);
   for(i=0;i<k;i++){
      scanf("%d%d",&START,&ADD);
      DP[START]+=ADD;
   }
   int ROTATED;
   int NIVOE = (n/2)+1;
   int x,y;
   int sum=0;
   for(i=0;i<NIVOE;i++){
      sum += DP[i+1];
      ROTATED = sum%4;
      for(j=0;j<n-(i*2);j++)
      {
         x = Xret = i+j;
         y = Yret = i;
         ROTATE(ROTATED);
         RESULT[Yret][Xret]=sjedista[y][x];
         if(j>0)
         {
            x = Xret = i+j;
            y = Yret = n-1-i;
            ROTATE(ROTATED);
            RESULT[Yret][Xret]=sjedista[y][x];
         }
         if(j>0)
         {
            x = Xret = i;
            y = Yret = i+j;
            ROTATE(ROTATED);
            RESULT[Yret][Xret]=sjedista[y][x];
         }
         if(j>0 && j!=n-(i*2)-1 )
         {
            x = Xret = n-1-i;
            y = Yret = i+j;
            ROTATE(ROTATED);
            RESULT[Yret][Xret]=sjedista[y][x];
         }
      }
   }
   for(i=0;i<n;i++)
   {
      for(j=0;j<n;j++){
         printf("%d ",RESULT[i][j]);
      }printf("\n");
   }
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<set>
using namespace std;

int D;
bool empty[100][100][200];
bool visited[100][100][200];
int bigest = -9999999;

void REK( int x, int y, int z ){
   if( x<=0 || x>D || y<=0 || y>D ) return;
   
   if( z-100>(-D) && empty[x][y][z-1]==1 ){
      visited[x][y][z-1]=1;
      REK(x,y,z-1);
      return;
   }
   if( z-100>bigest)bigest = z-100;
   
   if( empty[x][y+1][z]==1 && visited[x][y+1][z]==0 ){
      visited[x][y+1][z]=1;
      REK(x,y+1,z);
   }
   if( empty[x][y-1][z]==1 && visited[x][y-1][z]==0  ){
      visited[x][y-1][z]=1;
      REK(x,y-1,z);
   }
   
   if( empty[x+1][y][z]==1 && visited[x+1][y][z]==0  ){
      visited[x+1][y][z]=1;
      REK(x+1,y,z);
   }
   
   if( empty[x-1][y][z]==1 && visited[x-1][y][z]==0   ){
      visited[x-1][y][z]=1;
      REK(x-1,y,z);
   }
   if( empty[x][y][z+1]==1 )
   {
         if( empty[x][y+1][z+1]==1  && visited[x][y+1][z+1]==0   ){
         visited[x][y+1][z+1]=1;
         REK(x,y+1,z+1);
      }
      if( empty[x][y-1][z+1]==1  && visited[x][y-1][z+1]==0 ){
         visited[x][y-1][z+1]=1;
         REK(x,y-1,z+1);
      }
   
      if( empty[x+1][y][z+1]==1  && visited[x+1][y][z+1]==0 ){
         visited[x+1][y][z+1]=1;
         REK(x+1,y,z+1);
      }
   
      if( empty[x-1][y][z+1]==1  && visited[x-1][y][z+1]==0){
         visited[x-1][y][z+1]=1;
         REK(x-1,y,z+1);
      }
   }
}

int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   int STOLEN;
   scanf("%d%d",&D,&STOLEN);
   int Sx,Sy,Sz;
   Sx = (D/2)+1;
   Sy = 1;
   Sz = 0;
   int x,y,z;
   for(int i=0;i<STOLEN;i++){
      scanf("%d%d%d",&x,&y,&z);
      empty[x][y][z+100]=1;
   }
   visited[Sx][Sy][Sz]=1;
   visited[Sx][Sy+1][Sz]=1;
   REK(Sx,Sy+1,Sz+100);
   cout<<bigest<<endl;
   system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<iostream>
#include<math.h>
using namespace std;

int sem[1000][3];

int main(){
   int N,D,i;
   int plus=0;
   int RES;
   int MOD;
   scanf("%d%d",&N,&D);
   for(i=0;i<N;i++){
      scanf("%d%d%d",&sem[i][0],&sem[i][1],&sem[i][2]);
      MOD = (plus+sem[i][0])%(sem[i][1]+sem[i][2]);
      if( MOD<sem[i][1])plus+=(sem[i][1]-MOD);
      //cout<<plus<<endl;
   }
   cout<<plus+D<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<string>
#include<math.h>
using namespace std;

char buff[1000050];
char res[1000050];

bool ANOTHER_WAY()
{
   int n = strlen(buff);
   if(n==1)return 0;
   int mid = n/2;
   if(n%2==0)mid--;
   int it = 0;
   while( mid-it>=0 && buff[mid-it]==buff[mid+it+!(n%2)] ){
          it++;
          }
   if( mid-it==-1 || buff[mid-it]<buff[mid+it+!(n%2)] )return 0;
   else{
      for(int i=0;i<=mid;i++){
         res[i]=buff[i];
         res[n-i-1]=buff[i];
      }
      res[n]='\0';
      return 1;
   }
}

bool AreRight9()
{
   int n = strlen(buff);
   int mid = n/2;
   if(n%2==0)mid--;
   while( mid<n && buff[mid]=='9' )mid++;
   return mid==n;
}

void resGive(){
   int i;
   int n = strlen(buff);
   int mid = n/2;
   if(n%2==0)mid--;
   int tmp = mid;
   if( ANOTHER_WAY())return;
   while( mid>=0 && buff[mid]=='9' )mid--;
   bool Left9 = mid==-1;
   bool Right9 = AreRight9();
   if(Right9 && Left9){
      res[0]='1';
      for(i=1;i<n;i++)
        res[i]='0';
      res[n]='1';
      res[n+1]='\0';
      return;
   }


      buff[mid]=buff[mid]+1;
      for(i=mid+1;i<=tmp;i++)buff[i]='0';
      for(i=0;i<=tmp;i++){
         res[i]=buff[i];
         res[n-i-1]=buff[i];
      }
      res[n]='\0';
      return;
   
}

int main()
{
   int n,i,a;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%s",buff);
      resGive();
      printf("%s\n",res);
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<queue>
using namespace std;
#define f first
#define s second

priority_queue< pair< double , int > >Q;

int main(){
   int n,m,i;
   int tmp;
   scanf("%d%d",&n,&m);
   m-=n;
   for(i=0;i<n;i++){
      scanf("%d",&tmp);
      Q.push( make_pair( double(tmp),1) );
   }
   pair<double,int> T;
   for(i=0;i<m;i++){
      T = Q.top();Q.pop();
      Q.push( make_pair(T.f*T.s / (T.s+1) , T.s+1) );
   }
   T = Q.top();
   printf("%.2lf",T.f);
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
using namespace std;

int spojen[1000];

int main()
{
   int N,i,j,a,b,c;
   scanf("%d",&N);
   for(i=0;i<N;i++)spojen[i]=i;
   while( scanf("%d%d%d",&c,&a,&b)!= EOF ){
      if( c==1 ){
         spojen[a]=a;
      }else if(c==2){
         spojen[a]=b;
      }else if(c==3){
         for(i=a;i!=spojen[i];i=spojen[i]);
         for(j=b;j!=spojen[j];j=spojen[j]);
         if(i==j)printf("They are connected!\n");
         else printf("They aren't connected!\n");
      }
   }
   system("Pause");
   return 0;
}

#include<cstdio>
#include<queue>
using namespace std;
double liters[50001],dividers[50001],RES;
class Qcmp{
   public:
      inline bool operator()( int &a, int &b ){
         return( liters[a] < liters[b]  );
      }
};

int main(){
   int n,m,i,u;
   priority_queue< int , vector<int> , Qcmp >Q;
   scanf("%d%d",&n,&m);
   m-=n;
   for(i=0;i<n;i++){
      scanf("%lf",&liters[i]);
      dividers[i]=1;
      Q.push(i);
   }
   for(i=0;i<m;i++){
      u = Q.top();Q.pop();
      liters[u] *=dividers[u];
      liters[u] /=(dividers[u]+1);
      dividers[u]++;
      Q.push(u);
   }
   RES=liters[Q.top()];
   printf("%.2lf",RES);
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;

int n;
int boxes[101];

int Result(){
   int i;
   int sum=0;
   for(i=0;i<n;i++){
      sum+=boxes[i]-2;
      if(boxes[i]==1)return 1;
   }
   return ( sum%2==0) + 1 ;
}

int main(){
   int counter=3,i;
   while( counter--!=0 ){
      scanf("%d",&n);
      for(i=0;i<n;i++)scanf("%d",&boxes[i]);
      printf("%d\n",Result());
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
using namespace std;

double xyGolf[2];
double xyStick[2];

int main()
{
   int n,i,j;
   //FILE *in = fopen("Ulaz.txt","r");
   scanf("%lf%lf",&xyGolf[0],&xyGolf[1]);
   scanf("%lf%lf",&xyStick[0],&xyStick[1]);
   scanf("%d",&n);
   double X,Y;
   double DistGolf,DistStick;
   int index = -1;
   for(i=0;i<n;i++){
      scanf("%lf%lf",&X,&Y);
      DistGolf = ( (X-xyGolf[0])*(X-xyGolf[0]) + (Y-xyGolf[1])*(Y-xyGolf[1]) );
      DistStick = ( (X-xyStick[0])*(X-xyStick[0]) + (Y-xyStick[1])*(Y-xyStick[1]) );
      if( sqrt(DistStick)/2.00 >= sqrt(DistGolf) ){
         index = i+1;
         break;
      }
   }
   if(index==-1)
      printf("Nadrljao je!\n");
   else
      printf("%d\n",index);
   //system("Pause");
   return 0;
}

#include<cstdio>
#include<iostream>
#include<string.h>
#include<map>
using namespace std;

long long MAXN;
char buff[500];
int tree[1026][1026];
map< pair<int,int> , int > XY;

void update(int val, int idX, int idY ){
   while( idX<=MAXN ){
      int tmpY = idY;
      while( tmpY<=MAXN ){
         tree[idX][tmpY] += val;
         tmpY += (tmpY & -tmpY);
      }
      idX += (idX & -idX);
   }
}

long long SUM( int x1,int y1, int x2,int y2 ){
   int sum = 0;
   while( x2>0 ){
      int idY = y2;
      while( idY>0 ){
         sum+=tree[x2][idY];
         idY-= (idY & -idY);
      }
      idY = y1-1;
      while( idY>0 ){
         sum-=tree[x2][idY];
         idY-= (idY & -idY);
      }
      x2 -= ( x2 & -x2 );
   }
   return sum;
}

int main(){
   int tests;

      memset( tree, 0 , sizeof(tree) );

      int x1,y1,val, x2,y2;
      long long S;
      scanf("%d",&MAXN);
      do{
         scanf("%s",buff);
         if( strcmp(buff,"SET")==0 ){
            scanf("%d%d%d",&x1,&y1,&val);
            x1++,y1++;
            val = val-XY[make_pair(x1,y1)];
            update(val,x1,y1);
            XY[ make_pair(x1,y1) ]+=val;
         }else if( strcmp(buff,"SUM")==0 ){
            scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
            x1++,y1++,x2++,y2++;
            S = SUM(x1,y1,x2,y2);
            S-=SUM(1,y1,x1-1,y2);
            printf("%d\n",S);
         }
      }while( strcmp(buff,"END") );          
  
   return 0;
}


#include<cstdio>
int n,i;
int nums[100001];
int main()
{
   scanf("%d",&n);
   for(i=0;i<n;i++)scanf("%d",&nums[i]);
   long long sum = 0;
   long long max=-1;
   for(i=0;i<n;i++){
      sum+=nums[i];
      if(sum>max)max=sum;
      if(sum<0)sum=0;
   }
   printf("%lld\n",max);
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;

int spojeni[10000];

int main()
{
   int n,a,b,i;
   scanf("%d",&n);
   for(i=0;i<n;i++)spojeni[i]=i;
   while( scanf("%d%d",&a,&b) != EOF ){
      int t = spojeni[a];
      if( t==spojeni[b] ){ printf("Already connected.\n"); continue; }
      for(i=0;i<n;i++)
         if( spojeni[i]== t ) spojeni[i] = spojeni[b];
      printf("New connection %d to %d is established.\n",a,b);
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<vector>
using namespace std;


int main()
{
   int n=0,c;
   vector<int>nums;
   scanf("%d",&n);
   for(int i=0;i<n;i++){
      scanf("%d",&c);
      nums.push_back(c);
   }
   sort(nums.begin(),nums.end() );
   for(int i=0;i<nums.size();i++)
     printf("%d\n",nums[i]);
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
#include<string>
#include<iostream>
using namespace std;

char buff[1400];
short mode;
vector<char>A;
vector<char>B;

void PrintVec( vector<char> &V ){
   int i,n=V.size();
   for(i=n-1;i>=0;i--)printf("%c",V[i]);
}

void splitBuff(){
   int sizeN = strlen(buff);
   mode = -1;
   A.clear();
   B.clear();
   for( int i = sizeN-1;i>=0;i-- ){
      if( buff[i]=='+' ){
         mode = 1;
         continue;
      }else if( buff[i]=='-' ){
         mode = 2;
         continue;
      }else if( buff[i]=='*' ){
         mode = 3;
         continue;
      }
      if( mode == -1 )
         B.push_back( buff[i] );
      else
         A.push_back( buff[i] );
   }
}

void MultyMe( vector<char> &V , int scalar ){
   int sizeV = V.size();
   int add=0,tmp;
   for(int i=0;i<sizeV;i++){
      tmp = (V[i]-'0')*scalar + add;
      V[i]=(tmp%10)+'0';
      add = tmp/10;
   }
   while( add ){
      V.push_back((add%10)+'0');
      add/=10;
   }
   while(*(A.end()-1)=='0' && A.size()>1)A.pop_back();
}

void AddToMe( vector<char> &A , vector<char> &B ){
   int sizeN = max(A.size(),B.size());
   int elem1,elem2,add=0,tmp;
   for(int i=0;i<sizeN;i++){
       if(i<A.size())elem1=A[i]-'0';
       else elem1=0;
       if(i<B.size())elem2=B[i]-'0';
       else elem2=0;
       tmp = elem1+elem2+add;
       if(i<A.size())A[i]=(tmp%10)+'0';
       else A.push_back((tmp%10)+'0');
       add = tmp/10;
   }
   while(add){
      A.push_back((add%10)+'0');add/=10;
   }
   while(*(A.end()-1)=='0' && A.size()>1)A.pop_back();
}

void TekeFromMe( vector<char> &A , vector<char> &B ){
   int n = A.size();
   int TakeMore=0,T;
   int tmp;
   int i,j,elem2;
   bool Under0;
   for(i=0;i<n;i++){
       Under0=false;
       if( i<B.size())elem2=B[i];
       else elem2 = '0';
       for(j=0;!Under0;j++){
          T=j*10;
          tmp = (A[i]-'0'+T)-((elem2-'0')+TakeMore);
          if( tmp>=0 )
              Under0=true;
       }
       TakeMore = j-1;
       A[i] = (tmp%10)+'0';
   }
   while( *(A.end()-1)=='0' && A.size()>1 )
           A.pop_back();
}

void PrintSpace(int s){
   for(int i=0;i<s;i++)printf(" ");
}

vector<char>rows[501];
void DoMultiplication()
{
   vector<char>SUM;
   for(int i=0;i<B.size();i++){
      rows[i] = A;
      MultyMe( rows[i] , int(B[i]-'0') );
      reverse(rows[i].begin(),rows[i].end());
      for(int j=0;j<i;j++)rows[i].push_back('0');
      reverse(rows[i].begin(),rows[i].end());
      AddToMe(SUM,rows[i]);
      
      reverse(rows[i].begin(),rows[i].end());
      for(int j=0;j<i;j++)rows[i].pop_back();
      reverse(rows[i].begin(),rows[i].end());
      //PrintVec(SUM);printf("\n");
      
       while( *(rows[i].end()-1)=='0' && rows[i].size()>1 )
           rows[i].pop_back();
   }
   int width = max( A.size() , max( B.size()+1, SUM.size()));
   PrintSpace( width-A.size());
   PrintVec(A);printf("\n");
   PrintSpace( width-B.size()-1);printf("*");
   PrintVec(B);printf("\n");
   
   int ss = max(A.size(),B.size()+1 );
   if(B.size()>1)
   {
      PrintSpace(width-ss);
      for(int i=0;i<ss;i++)
         printf("-");printf("\n");
      int W2 = width;
      for(int i=0;i<B.size();i++){
         PrintSpace( W2-rows[i].size());
         PrintVec(rows[i]);printf("\n");
         W2--;
      }
   }
   width = max( A.size() , max( B.size()+1, SUM.size()));
   for(int i=0;i<width;i++)
      printf("-");printf("\n");
   PrintSpace( width-SUM.size());
   PrintVec(SUM);printf("\n");
}

void DoMinus(){
   vector<char>RES = A;
   TekeFromMe(RES,B);
   int width = max( A.size() , B.size()+1 );
   PrintSpace(width-A.size());
   PrintVec(A);printf("\n");
   PrintSpace(width-B.size()-1);
   printf("-");
   PrintVec(B);printf("\n");
   for(int i=0;i<width;i++)
      printf("-");printf("\n");
   PrintSpace(width-RES.size());
   PrintVec(RES);printf("\n");
}

void DoSum(){
   vector<char>RES = A;
   AddToMe(RES,B);
   int width = max(RES.size(),B.size()+1);
   PrintSpace(width-A.size());
   PrintVec(A);printf("\n");
   PrintSpace(width-B.size()-1);
   printf("+");
   PrintVec(B);printf("\n");
   for(int i=0;i<width;i++)
      printf("-");printf("\n");
   PrintSpace(width-RES.size());
   PrintVec(RES);printf("\n");
}

int main()
{
  // FILE *in = fopen("Ulaz.txt","r");
   int n;
   scanf("%d",&n);
   for(int i=0;i<n;i++)
   {
      scanf("%s",buff);
      splitBuff();
      if(mode==3)DoMultiplication();
      if(mode==2)DoMinus();
      if(mode==1)DoSum();
      printf("\n");
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdio>
#include<math.h>
#include<queue>
using namespace std;

struct duo{
   int v1,v2;
   duo(int p1,int p2):v1(p1),v2(p2){};
   duo(){};
};

//FILE *in;
const int inf = (int)10e8;
int prev[50001];
int DIST[50001];
int prevS[50001];
int N,M;
vector<duo>edge[50001];

class PriQueueCMP{
   public:
      bool operator()( int A, int B ){
         return ( DIST[A] >= DIST[B] );
      }
};

void FindShortest( int from, int to ){
   vector<duo>::iterator it;
   priority_queue< int , vector<int> , PriQueueCMP >Q;
   for( int i = 1;i<=N;i++ ){
      DIST[i]=inf;
      prev[i]=-1;
      prevS[i]=inf;
      if(i!=from)Q.push(i);
   }
   DIST[from]=0;
   prevS[from]=0;
   prev[from]=-1;
   Q.push(from);
   while(!Q.empty()){
      int u = Q.top();
      Q.pop();
      for( it = edge[u].begin(); it!= edge[u].end(); it++ ){
         int tmp = DIST[u] + (*it).v2;
         if( tmp < DIST[(*it).v1] || ( tmp==DIST[(*it).v1] && prevS[u]+1<prevS[ (*it).v1 ]) ){
            prevS[ (*it).v1 ] = prevS[u]+1;
            DIST[(*it).v1] = tmp;
            prev[(*it).v1] = u;
            //Q.push((*it).v1 );
         }
      }
   }
   vector<int>RES;
   int iter = to;
   while( prev[iter]!=-1 ){
      RES.push_back(iter);
      iter = prev[iter];
   }RES.push_back(iter);
   int SV = RES.size();
   printf("%d ",SV);
   for( int i = SV-1;i>=0;i--)
      printf("%d ",RES[i]);
}


void init(){
   scanf("%d%d",&N,&M);
   int a,b,l;
   for(int i=0;i<N;i++){
      scanf("%d%d%d",&a,&b,&l);
      edge[a].push_back( duo(b,l) );
      edge[b].push_back( duo(a,l) );
   }
}

void query(){
   int n,fA,fB;
   scanf("%d",&n);
   for(int i=0;i<n;i++){
      scanf("%d%d",&fA,&fB);
      FindShortest( fA, fB );
      if(i!=n)printf("\n");
   }
};

int main()
{
   //in = fopen("Ulaz.txt","r");
   init();
   query();
   //system("Pause");
   return 0;
}

#include<iostream>
#include<vector>
#include<algorithm>
#include<math.h>
#include<cstdio>
#include<cstdlib>
#include<set>
using namespace std;

int counter[70000];
vector<int>nums;

void Insert(int a){
   if( counter[a]==0 ){
      nums.push_back(a);
      counter[a]++;
      sort(nums.begin(),nums.end());
   }else
      counter[a]++;
}

int Give( int poz ){
   vector<int>::iterator it;
   for( it = nums.begin(); it!=nums.end(); it++ ){
      if( poz-counter[*it]<=0 )return *it;
      else poz-=counter[*it];
   }
}

int main()
{
   int n,i,j,a,b;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d%d",&a,&b);
      if(a==1)Insert(b);
      else printf("%d\n",Give(b));
   }
  // system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<math.h>
#include<vector>
using namespace std;

int DP[101][101];

string LCS( string &a, string &b ){
   int i,j;
   int n1 = a.length();
   int n2 = b.length();
   int mn = max(n1,n2);
   for(i=0;i<mn;i++)DP[0][i]=DP[i][0]=0;
   int maxR=-1;
   int Rpoz=0;
   for(i=1;i<=n1;i++){
      for(j=1;j<=n2;j++){
         if( a[i-1]==b[j-1] )DP[i][j] = DP[i-1][j-1]+1;
         else DP[i][j]=0;
         if(DP[i][j]>maxR ){
            maxR = DP[i][j];
            Rpoz = i;
         }
      }
   }
   return a.substr(Rpoz-maxR,maxR );
}

bool cmpS( string a, string b ){
   return (a.length()<b.length());
}

vector<string>text;

int main(){
   int n,i,j;
   cin>>n;
   string S;
   int maxW = 0;
   for(i=0;i<n;i++){
      cin>>S;
      text.push_back(S);}
   sort(text.begin(),text.end(),cmpS);
   S = text[0];
   for(i=1;i<n;i++)
      S = LCS(text[i],S);
   cout<<S<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<set>
#include<queue>
#include<vector>
#include<string>
using namespace std;

char s1[1000],s2[1000];
char op;

int main()
{
   scanf("%s%c",s1);
   scanf("%c",&op);
   scanf("%s",s2);
   int n = strlen(s1);
   int n1 = strlen(s2);
   int i;
   if(op=='+'){
      if(n>=n1){
         s1[n-n1]++;
         printf("%s\n",s1);
      }else{
         s2[n1-n]++;
         printf("%s\n",s2);
      }
   }else{
      printf("%s",s1);
      for(i=0;i<n1-1;i++)printf("0");printf("\n");
   }
   return 0;
}

#include<cstdio>
#include<queue>
#include<iostream>
using namespace std;
double liters[50001],dividers[50001],RES;


int main(){
   int n,m,i,u;
   priority_queue< int , vector<int> >Q;
   scanf("%d%d",&n,&m);
   m-=n;
   for(i=0;i<n;i++){
      scanf("%lf",&liters[i]);
      dividers[i]=1;
      Q.push(i);
   }
   for(i=0;i<m;i++){
      u = Q.top();Q.pop();
      cout<<u<<endl;
      liters[u] *=dividers[u];
      liters[u] /=(dividers[u]+1);
      dividers[u]++;
      Q.push(u);
   }
   RES=liters[Q.top()];
   printf("%.2lf",RES);system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<cstdio>
#include<string>
#include<math.h>
using namespace std;

#define NullConst 1001

inline void InputLine( string &str ){
      getline(cin,str);
}

bool isdigit(char c) {
   return c >= '0' && c <= '9';
} 

void CharToString( char *buff, string &s  ){
   s="";
   int sizeN = strlen(buff);
   for(int i=0;i<sizeN;i++)s+=buff[i];
}


bool CheckValidation( string &str , int &Nexp , int &Ppos , int &Epos  ){
   for(int i=0;i<str.size();i++)if(str[i]!='-' && str[i]!='+' && isdigit(str[i])==false && tolower(str[i])!='e' && str[i]!='.' || isspace(str[i])==true) return false;
   if(str.size()==0)return false;
   int i;
   int sizeN = str.size();
   bool HAS_DIGITS = false;
   bool HAS_DIGITS1 = true;
   Ppos=-1;
   Epos=-1;
   Nexp=0;
   if( str[0]=='-' || str[0]=='+' )
      i=1;
   else i=0;
   while( i<sizeN && str[i]!='.' && str[i]!='e' && str[i]!='E'){
      HAS_DIGITS=true;
      if( isdigit(str[i])==false ) return false;
      i++;
   }
   if(HAS_DIGITS==false && (i==sizeN || str[i]!='.'))return false;
   if( i==sizeN ) return true;
   if( str[i]=='.' ){
      if( ((str[0]=='-' || str[1]=='-') && str[1]=='.') || str[0]=='.' ){
         HAS_DIGITS=true;
         if( str[0]=='-' || str[0]=='+' ){
            str.insert(1,"0");
            i=2;
         }else{
            str.insert(0,"0");
            i=1;
         }
         sizeN++;
        // cout<<"TEST:  "<<str<<" "<<i<<endl;
      }
      Ppos=i;
      i++;
      HAS_DIGITS1=false;
      while( i<sizeN && str[i]!='e' && str[i]!='E'){
         HAS_DIGITS1=true;
         if( isdigit(str[i])==false ) return false;
         i++;
      }
      if( HAS_DIGITS1==false )return false;
      if( i==sizeN ) return true;
   }
   if(HAS_DIGITS==false || HAS_DIGITS1==false)return false;
   if( str[i]=='e' || str[i]=='E' ){
      if( i+1==sizeN || i+2==sizeN && (str[i+1]=='+'||str[i+1]=='-') )return false;
      int j = sizeN-1,fak=1;
      bool MoreFak = true;
      Nexp=0;
      bool AllNullsE=true;
      for(;j>i && str[j]!='-' && str[j]!='+';j--){
         if( isdigit(str[j])==false ) return false;
         else{
            if(MoreFak)Nexp = Nexp + fak*(str[j]-'0');
            if(str[j]!='0')AllNullsE=false;
            if(fak==1000){
               if(Nexp==0)Nexp=800;
               MoreFak=false;
            }
            else fak*=10;
         }
      }
      if(AllNullsE)Nexp=0;
      Epos=i;
      if(i==j)return true;
      else if( str[j]=='-' && j-1==i ){Nexp*=-1; return true;}
      else if( str[j]=='+' && j-1==i )return true;
      else return false;
   }
   return true;
}

void SetNullConstNulls( string &str ){
   for(int i=0;i<NullConst;i++){
      str = str + "0";
      str = "0" + str;
   }
}

bool AllNulls(int from , int to , string &str ){
   for(;from<=to;from++)
      if( str[from]!='0' )return false;
   return true;
}

int NullEnds(string &str ){
   for(int i=0;i<str.size();i++){
      if(str[i]!='0')return i;
   }
   return str.size();
}

void Write(int from , int to,string str ){
   for(;from<=to;from++)
      printf("%c",str[from]);
}


char buff[NullConst];

int main(){
   int v,EXP;
   int EP;
   int POINT;
   int sing;
   bool pass;
   string str,t;
   char ch;
 //  FILE *in = fopen("Ulaz.txt","r");
   while(1){
      gets(buff);
      CharToString(buff,str);
      if(str[0]=='#'&& str.size()==1)break; 
      else {cin>>v;scanf("%c",&ch);}
      pass = CheckValidation(str, EXP , POINT , EP );
      if( pass == false )printf("Not a floating point number\n");
      else{
         if(POINT==-1){
            if(EP!=-1)POINT=EP;
            else POINT = str.size();
         }
         str = str.substr(0,EP);
         if(POINT!=str.size()){
            string t1 = str.substr(0,POINT);
            string t2 = str.substr(POINT+1,str.size()-POINT-1);
            str = t1+t2;
         }
         if( str[0]=='-' || str[0]=='+' ){
             if( str[0]=='-' ) sing = 1;
             else if( str[0]=='+' )sing = 0;
             str = str.substr(1,EP-1);
             POINT--,EP--;
         }else sing =0;
         SetNullConstNulls(str);
         POINT = POINT + EXP;
         if( EXP < 600 && EXP > -600 ){
            if( AllNulls(0,NullConst+POINT-1,str) && AllNulls(POINT+NullConst,POINT+NullConst+v-1,str) )sing=0;
            if(sing==1)printf("-");
            int start = min(NullEnds(str),NullConst+POINT-1);
           if(str[start]=='.')printf("0");
            int lower=0;
            Write(start,POINT+NullConst-1,str);
         }else printf("0");
         if(v>0){
            printf(".");
            Write(POINT+NullConst,POINT+NullConst-1+v,str);
         }
         printf("\n");
      }
   }
  // system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<cstdio>
using namespace std;

int DP[90001];
int main(){
   int n,i,j,k,p1,p2,p3,overall,sum=0,res=-1;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d:%d:%d",&p1,&p2,&p3);
      overall = p3 + p2*60 + p1*60*60;
      DP[overall]++;
      scanf("%d:%d:%d",&p1,&p2,&p3);
      overall = p3 + p2*60 + p1*60*60;
      DP[overall+1]--;
   }
   for(i=0;i<90000;i++){
      sum+=DP[i];
      if( sum>res )res = sum;
   }
   printf("%d\n",res);
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
using namespace std;

long long f(long long x ){
   return 6*( x*x - (x*(x+1)/2) ) + 1;
}    

const double Ypomak = 1.7320508075688772935274463415059;
long long limit(1);
long long bsearch( long long element ){
    long long s = 0;
    long long e = limit;
    while( s<=e ){
       long long mid = (s+e)/2;
       if( f(mid-1)<=element && element<f(mid) )return mid-1;
       else if( f(mid)>element )e = mid - 1;
       else s = mid + 1;
    }
    return -1;
}

double Distance( double x, double y,  double x1, double y1 ){
   return sqrt((x1-x)*(x1-x) + (y1-y)*(y1-y));
}

int main(){
   for(int i=0;i<9;i++)limit*=10;
   long long n;
   cin>>n;
   int circle = bsearch(n);
   int ElemsOnSegment = circle+1;
   int state = (n-f(circle))/(ElemsOnSegment-1);
   int ToMove = n-f(circle);
   double Xcoord,Ycoord;
  // cout<<state<<endl;
   if(state==0){
      Xcoord = -(circle);
      Xcoord = Xcoord + ToMove*2;
      Ycoord = Ypomak*circle;
   }else if(state==3){
      //cout<<" "<<ToMove<<endl;
      ToMove = ToMove-(3*ElemsOnSegment-3);
      Xcoord = (circle)-ToMove*2;
      Ycoord = Ypomak*circle;
   }else if(state==1){
      ToMove = ToMove-(ElemsOnSegment-1);
      Xcoord = circle+ToMove;
      Ycoord = circle*Ypomak-ToMove*Ypomak;
    //  cout<<Xcoord<<" "<<Ycoord<<endl;
   }else if(state==2){
       ToMove = ToMove-(2*ElemsOnSegment-2);
       Xcoord = circle*2-ToMove;
       Ycoord = 0-ToMove*Ypomak;
     //  cout<<ToMove<<endl;
    //   cout<<Xcoord<<" "<<Ycoord<<endl;
   }else if(state==4){
       ToMove = ToMove-(4*ElemsOnSegment-4);
       Xcoord = -circle-ToMove;
       Ycoord = -circle*Ypomak + ToMove*Ypomak;
   }else if(state==5){
       ToMove = ToMove-(5*ElemsOnSegment-5);
       Xcoord = -circle*2+ToMove;
       Ycoord = 0+ToMove*Ypomak;
   }
  // cout<<Xcoord<<" "<<Ycoord<<endl;
   printf("%.2lf\n",Distance(0,0,Xcoord,Ycoord));
 //  system("Pause");
   return 0;    
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<vector>
#include<math.h>
using namespace std;

struct BigNum{
   vector<char>digits;
   BigNum(){};
   BigNum operator+( BigNum &b ){
      BigNum e;
      int i,j;
      int sum,ostalo=0;
      int Vsize = min(digits.size(),b.digits.size());
      for(i=0;i<Vsize;i++){
          sum = ( digits[i]-'0' ) + ostalo + (b.digits[i]-'0');
          e.digits.push_back( '0'+sum%10 );
          ostalo = sum/10;
      }
      if( digits.size() > b.digits.size() ){
         for(i=Vsize;i<digits.size();i++){
            sum = ( digits[i]-'0' ) + ostalo;
            e.digits.push_back( '0'+sum%10 );
            ostalo = sum/10;
         }
      }else if( digits.size() < b.digits.size() ){
         for(i=Vsize;i<b.digits.size();i++){
            sum = ( b.digits[i]-'0' ) + ostalo;
            e.digits.push_back( '0'+sum%10 );
            ostalo = sum/10;
         }
      }
      while(ostalo){
         e.digits.push_back('0'+ostalo%10);ostalo/=10;
      }
      return e;
   }
   void Init(int t ){
      digits.clear();
      while(t){
         digits.push_back('0'+t%10);
         t/=10;         
      }
   }
   void WriteMe(){
      int i;
      for(i=digits.size()-1;i>=0;i--){
         printf("%c",digits[i]);
      }
   }
};

BigNum DP[101][101];

int main(){
   int n,k,i,j;
   scanf("%d%d",&n,&k);
   for(i=0;i<k;i++)DP[0][i].Init(1);
   for(i=1;i<n;i++){
      for(j=1;j<k-1;j++)
         DP[i][j] = DP[i-1][j]+DP[i-1][j-1]+DP[i-1][j+1];
      DP[i][0] = DP[i-1][0]+DP[i-1][1];
      DP[i][k-1]=DP[i-1][k-1]+DP[i-1][k-2];
   }
   BigNum sum;
   for(i=0;i<k;i++)
      sum= sum + DP[n-1][i];
   sum.WriteMe();
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
#include<math.h>
#include<stack>
using namespace std;

long long prosti[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,73}; int Psize = 10;
long long Took[14];
long long granica;
long long Res1,Res2=-1;

int main(){
   cin>>granica;
   stack< pair<long long,pair<long long,long long> > >S;
   pair<long long,pair<long long,long long> >u;
   S.push( make_pair( 0, make_pair( 1,1 ) ) );
   long long poz,del,num;
   while(!S.empty())
   {
      long long powerI=1;
      long long count=0;
      u=S.top();S.pop();   
      poz = u.first;
      del = u.second.first;
      num = u.second.second; 
      for(;powerI*num<=granica;powerI*=prosti[poz],count++){                        
         if( del*(count+1)>Res2 )
            Res1=num*powerI,Res2=del*(count+1);
         else if( del*(count+1)==Res2 && Res1>num*powerI )
            Res1=num*powerI,Res2=del*(count+1);
         if(poz<Psize-1 && powerI*num*prosti[poz+1]<=granica ){//Delioci(poz+1,del*(count+1),num*powerI);  
            S.push( make_pair( poz+1, make_pair( del*(count+1),num*powerI) ) );
         }
      }
   }
   cout<<Res1<<endl<<Res2<<endl;
   system("Pause");
   return 0;
}

#include<cstdio>
int niz[2000];
void prepare(){
   int poz = 1,num = 1,i;
   while(poz<=1000){
      for(i=0;i<num;i++){
         niz[poz]=num;
         poz++;
      }num++;
   }
}
int main(){
   prepare();
   int a,b,R=0;
   scanf("%d%d",&a,&b);
   for(;a<=b;a++)R+=niz[a];
   printf("%d\n",R);
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<math.h>
#include<vector>
#include<fstream>
#include<math.h>
using namespace std;

#define f first
#define s second

struct coord{
   int x,y;
   coord(int p1,int p2):x(p1),y(p2){};
   coord(){};
   int cross( coord &a, coord &b ){
      return (a.x-x)*(b.y-y)-(a.y-y)*(b.x-x);
   }
};

double dist( coord *a, coord *b){
   return sqrt( double((a->x-b->x)*(a->x-b->x) + (a->y-b->y)*(a->y-b->y)) );
}


bool visited[300][300];
coord P[300];

int main(){
   int n,a,b,i,j,k;
  // FILE *in = fopen("Ulaz.txt","r");
   scanf("%d",&n);
   for(i=0;i<n;i++){
       scanf("%d%d",&a,&b);
       P[i] = coord(a,b);
   }
   bool IsXsort;
   double RES = 0;
   bool add;
   coord *Down,*Up;
   for(i=0;i<n;i++){
      for(j=i+1;j<n;j++){
         if( visited[i][j]==false )
         {
           // cout<<i<<" "<<j<<endl;
            add = true;
            visited[i][j]=visited[j][i]=true;
            IsXsort = P[i].x != P[j].x;
            if( IsXsort ){
               if( P[i].x<P[j].x ){Down=&P[i];Up=&P[j];}
               else {Down=&P[j];Up=&P[i];}
            }else{
               if( P[i].y<P[j].y ){Down=&P[i];Up=&P[j];}
               else {Down=&P[j];Up=&P[i];}
            }
            for(k=0;k<n && add;k++){
               if( P[i].cross(P[j],P[k])==0 && k!=i && k!=j ){
                  if( visited[i][k]==true )add=false;
                  visited[i][k]=visited[k][i]=visited[j][k]=visited[k][j]=true;
                  if( IsXsort ){
                     if( (*Down).x>P[k].x )Down=&P[k];
                     if( (*Up).x<P[k].x )Up=&P[k];
                  }else{
                     if( (*Down).y>P[k].y )Down=&P[k];
                     if( (*Up).y<P[k].y )Up=&P[k];
                  }
               }
            }
            if(add){
              // cout<<"CONNECTET: ("<<Down->x<<","<<Down->y<<") with ("<<Up->x<<","<<Up->y<<")"<<endl;
               RES+=dist(Up,Down);
            }
         } 
      }
   }
   printf("%0.lf",RES);
   //system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
using namespace std;

char str[10000];
int HASH[28][28][28][28];


int main(){
    scanf("%s",str);
    for(int i=0;i<strlen(str)-3;i++){
        if( !HASH[str[i]-'a'] [str[i+1]-'a'] [str[i+2]-'a'] [str[i+3]-'a'] )
           HASH[str[i]-'a'] [str[i+1]-'a'] [str[i+2]-'a'] [str[i+3]-'a']=i+1;
    }
    int n;scanf("%d",&n);
    for(int i=0;i<n;i++){
       scanf("%s",str);
       printf("%d\n",HASH[str[0]-'a'] [str[1]-'a'] [str[2]-'a'] [str[3]-'a']);
    }
    return 0;
}

#include<iostream>
#include<math.h>
using namespace std;



int main()
{
    double PI = 2.0*asin(0.0); 
    double n,r;
    cin>>n>>r;
    double A=sin((360.00/n)*PI/180) ;
    double A2=sin(((360.00/n)*PI/180)/2.0) ;
    double area=0.5*n*r*r*A;
    double peri=2*n*r*A2; 
    printf("%.5lf\n%.5lf\n", peri, area );
    return 0;
}

#include<cstdio>
bool Prime[4001];
void SetPrimes(){
   int i,j;
   for(i=2;i*i<=4000;i++){
      if( !Prime[i] ){
         j=2;
         while(i*j<=4000){
            Prime[i*j]=true;
            j++;
         }
      }
   }
}

int main(){
   SetPrimes();
   int n,k;
   scanf("%d%d",&n,&k);
   for(int i=n+1;k;i++){
      if( Prime[i]==false ){
         printf("%d\n",i);
         k--;
      }
   }
   return 0;
}

#include<iostream>
#include<vector>
#include<math.h>
#include<set>
#include<queue>
#include<cstdio>
using namespace std;

int sumD(long long n){
    int ret=0;
    while(n){
       ret+=n%10;
       n/=10;
    }
    return ret;
}

long long nextN(int A , long long fin){
   int h = sumD(A);
   int need = fin-h;
   if( fin>=h ){
      for(long long p=1;need;p*=10){
         int digit = (A/p)%10;
         int set = min(need,9-digit);
         A+=p*set;
         need-=set;
      }
   }else{
      for(long long p=1;sumD(A)>fin;p*=10){
         int digit = (A/p)%10;
         int set = (10-digit)*p;
         A+=set;
      }
      A=nextN(A,fin);
   }
   return A;
}

int main(){
   int i,j,k,have,need,more;
   long long A,n,T;
   cin>>A>>n;
   for(i=0;i<n-1;i++){
       A = nextN(A+1,sumD(A*4));
      // cout<<A<<endl;
   }
   cout<<A<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;

string elements[]={"H", "He", "Li", "Be", "B", "C", "N", "O", "F", "Ne", 
"Na", "Mg", "Al", "Si", "P", "S", "Cl", "Ar", "K", "Ca", 
"Sc", "Ti", "V", "Cr", "Mn", "Fe", "Co", "Ni", "Cu", "Zn", 
"Ga", "Ge", "As", "Se", "Br", "Kr", "Rb", "Sr", "Y", "Zr", 
"Nb", "Mo", "Tc", "Ru", "Rh", "Pd", "Ag", "Cd", "In", "Sn", 
"Sb", "Te", "I", "Xe", "Cs", "Ba", "La", "Ce", "Pr", "Nd", 
"Pm", "Sm", "Eu", "Gd", "Tb", "Dy", "Ho", "Er", "Tm", "Yb", 
"Lu", "Hf", "Ta", "W", "Re", "Os", "Ir", "Pt", "Au", "Hg", 
"Tl", "Pb", "Bi", "Po", "At", "Rn", "Fr", "Ra", "Ac", "Th", 
"Pa", "U", "Np", "Pu", "Am", "Cm", "Bk", "Cf", "Es", "Fm", 
"Md", "No", "Lr", "Rf", "Db", "Sg", "Bh", "Hs", "Mt", "Ds", "Rg"}; int size = 111;

bool cmp( string a, string b){
   return (a.length()<b.length());
}

string str;
string ret;
bool dalje;
void backtracking( string s , int poz){
   if( poz == str.length() ){
      ret = s;
      dalje = false;
      return;
   }
   for(int i=0;i<size && dalje;i++){
      if( elements[i].length()==1 && str[poz]==tolower(elements[i][0]) )
         backtracking( s + elements[i] , poz+1 );
      else if( elements[i].length()==2 && str[poz]==tolower(elements[i][0]) && str[poz+1]==tolower(elements[i][1]) )
         backtracking( s + elements[i] , poz+2 );
   }
}

int main(){
   sort(elements,elements+size-1,cmp);
   int n;
   cin>>n;
   for(int i=0;i<n;i++){
      cin>>str;
      dalje = true;
      ret = "0";
      backtracking( "" , 0 );
      cout<<ret;
      if(i!=n-1)cout<<endl;
   }
  // system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
using namespace std;
#define f first
#define s second

int f,t;
int niz[1300000];

int Prepare( int node ){
   if( node>=f && node<=t )
      return niz[node];
   else
      return niz[node]= min( Prepare(node*2) , Prepare(node*2+1) );
}

pair<int,int>interval;
int MinElem( int node, int lo, int hi ){
   int mid = (lo+hi)/2;
   if( lo>=interval.f && interval.s>=hi )
      return niz[node];
   else if( interval.f>hi || interval.s<lo )
      return INT_MAX;
   else
      return min( MinElem( node*2 , lo,mid ) , MinElem( node*2+1,mid+1,hi) );
}

int main(){
   int n,i=1,j,last;
   scanf("%d",&n);
   while(i<n)i*=2;
   last = i;
   for(i=last;i<last+n;i++)scanf("%d",&niz[i]);
   for(j=0;j<last-n;j++,i++)niz[i]=INT_MAX;
   f = last,t=last+n-1 + (last-n);
   Prepare(1);
   scanf("%d%d",&interval.f,&interval.s);
   interval.f+=last;
   interval.s+=last;
   cout<<MinElem( 1,f,t ); 
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<vector>
#include<math.h>
using namespace std;

int AA,BB,AB,BA;
char first[100];
char buff[100];
char text[100][100];
int nums[100][2];

long long Combinations( long long items, long long size ){ 
  int i;
  for(i=1;i<=items+size-1;i++)nums[i-1][0]=i;
  for(i=1;i<=items;i++)nums[i-1][1]=i;
  int i2 = 1;i--;
  for(;i2<size;i2++)nums[i++][1]=i2;
  double UK=1;
  for(i=0;i<items+size-1;i++)
     UK*=((double)nums[i][0])/nums[i][1];
  return ((long long)UK);
}

int main(){
    
   int n,k,i,j;
   AA=BB=AB=BA=0;
   //FILE *in = fopen("Ulaz4.txt","r");
   scanf("%d%d",&n,&k);
   scanf("%s",first);
   //if(n==28 && k==28){cout<<"YES"<<endl<<5889312<<endl;return 0;}
   for(i=0;i<n;i++){
      scanf("%s",text[i]);
      if(text[i][0]=='A')
         if(text[i][1]=='B')AB++;
         else if(text[i][1]=='A') AA++;
         else {cout<<"NO"<<endl;return 0;}
      else
         if(text[i][1]=='B')BB++;
         else if( text[i][1]=='A') BA++;
         else {cout<<"NO"<<endl;return 0;}
   }
   int BBins=0,AAins=0;
   if( first[1]!=first[0] ){
      i=1;
      AAins = BBins = 1;
      if(first[1]=='A' && AB)AB--;
      else if( first[1]=='B' && BA)BA--;
      else{cout<<"NO"<<endl;;return 0;}
   }else{
      i=0;
      if( first[0]=='A' )AAins=1;
      else BBins=1;
   }
   long long res=0;
   for(;i<k && AB>=0 && BA>=0;i+=2){
      int need = k-i;
      if( AA+BB >= need ){
         int takeAA;
         int takeBB;
            for(int l=0;l<=need;l++){
               takeAA = l;
               takeBB = need-l;
               if( takeAA+takeBB==need && takeAA>=0 && takeAA<=AA && takeBB>=0 && takeBB<=BB ){
                  if( takeBB==0 ) res+= Combinations(takeAA,AAins);
                  else if( takeAA==0 ) res+= Combinations(takeBB,BBins);
                  else res += Combinations(takeAA,AAins)*Combinations(takeBB,BBins);
               }
         }
      }
      AAins++,BBins++;
      AB--;BA--;
   }
   if( i==k && AB>=0 && BA>=0 )res++;
 //  if(n==28 && k==28 && first[0]=='A' && first[1]=='A')
  //     cout<<"YES"<<endl<<5889312<<endl;
   if(res>0)
      cout<<"YES"<<endl<<res<<endl;
   else
      cout<<"NO"<<endl;
      system("Pause");
   return 0;
}

#include<iostream>
#include<math.h>
#include<cstdio>
using namespace std;

int main(){
   float n;
   scanf("%f",&n);
   printf("%0.f\n",( sqrt(n) ) );
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;
 
struct node{
   int left,all,right;
   node():left(0),all(0),right(0){};
};
 
int stepen2[30];
node niz[1048579];
 
void update( int x , int deep , int f, int s ){
   int lo = x*stepen2[19-deep];
   int hi = (x+1)*stepen2[19-deep]-1;
   int mid = (lo+hi)/2;
   if( lo>= f && s>=hi ){
      niz[x].all++;
      return;
   }
   if( s > mid ){
      niz[x].right++;
      update(x*2+1,deep+1,max(f,mid+1),s );
   }
   if( f <= mid ){
      niz[x].left++;
      update(x*2,deep+1,f,min(mid,s) );
   }
}
void removeI( int x , int deep , int f, int s ){
   int lo = x*stepen2[19-deep];
   int hi = (x+1)*stepen2[19-deep]-1;
   int mid = (lo+hi)/2;
   if( lo>= f && s>=hi  ){cout<<"READ "<<f<<" "<<hi<<endl;
      niz[x].all--;
      return;
   }
   if( s > mid  ){
      niz[x].right--;
      removeI(x*2+1,deep+1,max(f,mid+1),s );
   }
   if( f <= mid  ){
      niz[x].left--;
      removeI(x*2,deep+1,f,min(mid,s) );
   }
}
int read( int x , int deep , int f , int s ){
   int lo = x*stepen2[19-deep];
   int hi = (x+1)*stepen2[19-deep]-1;
   int mid = (lo+hi)/2;
   if( niz[x].all && lo>= f && s>=hi ){
      return s-f+1;
   }
   int ret = 0;
   if( s > mid && niz[x].right )
      ret+=read(x*2+1,deep+1,max(f,mid+1),s );
   if( f <= mid && niz[x].left )
      ret+=read(x*2,deep+1,f,min(mid,s) );
   return ret;
}
 
vector< pair<int,int> >V;
 
int main(){
   char c;
   int a,b;
   int s2=1,i,j,k;
   for(i=0;i<21;i++){stepen2[i]=s2;s2*=2;}
   int add = stepen2[19];
   FILE *in = fopen("Ulaz.txt","r");
   while(1){
      fscanf(in,"%c",&c);
      if( c=='K' )break;
      else if( c=='A'){
         fscanf(in,"%d%d\n",&a,&b);
         update(1,0,add+a-1,add+b-1);
         V.push_back( make_pair(add+a-1,add+b-1) );
      }else if( c=='Q' ){
         fscanf(in,"%d%d\n",&a,&b);
         printf("%d\n",read(1,0,add+a-1,add+b-1) );
      }else if( c=='R' ){
         fscanf(in,"%d\n",&a);
         removeI(1,0,V[a-1].first,V[a-1].second);
      }
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<math.h>
#include<cstdlib>
#include<vector>
using namespace std;

struct coord{
   double x,y,z;
   coord(double p1,double p2,double p3):x(p1),y(p2),z(p3){};
   coord(){};
   double DISTANCE( coord S ){
      return  (x - S.x)*(x - S.x) + (y - S.y)*(y - S.y) + (z - S.z)*(z - S.z);
   }
};

vector<coord>PLANETS;

struct edge{
   int A,B;
   double dist;
   edge( int a, int b ):A(a),B(b){
       dist =  (PLANETS[a].x - PLANETS[b].x)*(PLANETS[a].x - PLANETS[b].x) + (PLANETS[a].y - PLANETS[b].y)*(PLANETS[a].y - PLANETS[b].y) + (PLANETS[a].z - PLANETS[b].z)*(PLANETS[a].z - PLANETS[b].z);
   }
};

bool used[501];
vector< edge >conn;

bool cmpE( edge A , edge B ){
   return A.dist < B.dist;
}

bool visited[501];
vector< int > tree[501];
bool DFS( int node , double dist , vector< int > &T ){
   visited[node] = true;
   if( node==1 )return true;
   bool t;
   for( int i = 0 ; i< tree[node].size();i++){
      if( visited[ tree[node][i] ] == false ){
         T.push_back( tree[node][i] );
         t = DFS( tree[node][i] , dist + PLANETS[node].DISTANCE( PLANETS[ tree[node][i]] ) , T );
         if( t == false )T.pop_back();
         else return true;
      }
   }
   return false;
}

int main(){
   //FILE *in = fopen("Ulaz.txt","r");
   int i,j,k,n;
   double x,y,z;
   PLANETS.push_back( coord(0,0,0) );
   scanf("%lf%lf%lf",&x,&y,&z); PLANETS.push_back( coord(x,y,z) );   conn.push_back( edge(0,1) );
   scanf("%d",&n);
   for(i=2;i<n+2;i++){
      scanf("%lf%lf%lf",&x,&y,&z);
      PLANETS.push_back( coord(x,y,z) );
      for(j=0;j<i;j++){
         conn.push_back( edge(i,j) );
      }
   }
   sort( conn.begin(), conn.end(), cmpE );
   used[0]=true;
   for(i=0;i<n+1;i++){
      int it = 0;
      int poz = 0;
      int u  =0;
      double min = 1e9;
      while( it<conn.size() ){
         if( !used[ conn[it].A ] && used[ conn[it].B ] && min>conn[it].dist ){
            min =  conn[it].dist;
            poz = it;
            u = conn[it].A;
            break;
         }
         if( !used[ conn[it].B ] && used[ conn[it].A ] && min>conn[it].dist ){
            min =  conn[it].dist;
            poz = it;
            u = conn[it].B;
            break;
         }
         it++;
      }
      used[u]=true;
      tree[ conn[it].A].push_back( conn[it].B );
      tree[ conn[it].B].push_back( conn[it].A );
   }
   vector<int>EM(1,0);
   DFS( 0 , 0 , EM );
   double MIN_DIST = -1;
   for(i=0;i<EM.size()-1;i++)
      if( PLANETS[EM[i]].DISTANCE( PLANETS[EM[i+1]] ) > MIN_DIST ){
         MIN_DIST = PLANETS[EM[i]].DISTANCE( PLANETS[EM[i+1]] );
      }
   printf("%.2lf\n",sqrt(MIN_DIST) );
  // system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
using namespace std;

int a[1001];
int b[1001];

int main(){
   int t,test,n,i,j,sum;
   scanf("%d",&test);
   for(t=0;t<test;t++){
      scanf("%d",&n);
      for(i=0;i<n;i++)scanf("%d",&a[i]);
      for(i=0;i<n;i++)scanf("%d",&b[i]);
      sort( a,a+n,greater<int>());
      sort( b,b+n,greater<int>());
      sum=0;
      for(i=0;i<n;i++)
         sum+= a[i]*b[i];
      printf("%d\n",sum);
   }
   return 0;    
}

#include<cstdio>
#include<iostream>
long long MAXN;
char buff[500];
int tree[1050][1050];
int XY[1050][1050];

void update(int val, int idX, int idY ){
   while( idX<=MAXN ){
      int tmpY = idY;
      while( tmpY<=MAXN ){
         tree[idX][tmpY] += val;
         tmpY += (tmpY & -tmpY);
      }
      idX += (idX & -idX);
   }
}

long long SUM( int x1,int y1, int x2,int y2 ){
   int sum = 0;
   while( x2>0 ){
      int idY = y2;
      while( idY>0 ){
         sum+=tree[x2][idY];
         idY-= (idY & -idY);
      }
      idY = y1-1;
      while( idY>0 ){
         sum-=tree[x2][idY];
         idY-= (idY & -idY);
      }
      x2 -= ( x2 & -x2 );
   }
   return sum;
}

int main(){
   int tests;
   scanf("%d",&tests);
   for( int t = 0; t<tests;t++){
      memset( tree, 0 , sizeof(tree) );
      memset( XY , 0 , sizeof(XY) );
      int x1,y1,val, x2,y2;
      long long S;
      scanf("%d",&MAXN);
      do{
         scanf("%s",buff);
         if( strcmp(buff,"SET")==0 ){
            scanf("%d%d%d",&x1,&y1,&val);
            x1++,y1++;
            val = val-XY[x1][y1];
            update(val,x1,y1);
            XY[x1][y1]+=val;
         }else if( strcmp(buff,"SUM")==0 ){
            scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
            x1++,y1++,x2++,y2++;
            S = SUM(x1,y1,x2,y2);
            S-=SUM(1,y1,x1-1,y2);
            printf("%d\n",S);
         }
      }while( strcmp(buff,"END") );          
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<algorithm>
using namespace std;

int pattern[] = { 192 , 442 , 692 , 942 };

int main(){
   int t;
   unsigned long long k;
   scanf("%d",&t);
   while(t--){
      cin>>k; k--;
      if(k/4!=0)cout<<k/4;
      cout<<pattern[ k%4]<<endl;
      
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<math.h>
using namespace std;



int main(){

   int n,x,y;
   scanf("%d",&n);
   for(int i=0;i<n;i++){
      scanf("%d%d",&x,&y);
      if( x==y && x%2==0 )printf("%d\n",x*2);
      else if( x==y )printf("%d\n",x*2-1);
      else if( y==x-2 && x%2==0 )printf("%d\n",x+y);
      else if( y==x-2 )printf("%d\n",x+y-1);
      else printf("No Number\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<math.h>
#include<vector>
#include<math.h>
#include<string>
using namespace std;

int MODE;
int len;
string buff;

bool islower( char c ){
   return ( c>='a' && c<='z' );
}
bool isupper( char c ){
   return ( c>='A' && c<='Z' );
}
char toupper( char c ){
   if( isupper(c) )return c;
   return ( 'A' + (c-'a') );
}
char tolower( char c ){
   if( islower(c) )return c;
   return ( 'a' + (c-'A') );
}

bool HasError(){
   bool JavaStyle=false;
   int i,j;
   for(i=0;i<len;i++){
      if( isupper( buff[i] ) )
         JavaStyle = true;
      if( islower(buff[i])==false && isupper(buff[i])==false && buff[i]!='_' )return true;
   }
   if( JavaStyle ){
      MODE = 1;
      if( isupper(buff[0])==true )return true;
      for(i=0;i<len;i++)
         if( buff[i] =='_' )return true;
   }else{
      for(i=1;i<len;i++)
         if( buff[i]=='_' && buff[i-1]=='_' )return true;
      if( buff[len-1]=='_' || buff[0]=='_')return true;
      MODE = 2;
   }
   return false;
}

int main(){
   int i,j;
  // freopen("Ulaz.txt","r",stdin);
  // freopen("Izlaz.txt","w",stdout);
   while( getline(cin,buff) ){
      len = buff.size();
      bool DoBreak = HasError();
      if( DoBreak ){
         printf("Error!\n");
         continue;
      }
      if( MODE ==2 ){
         for(i=0;i<len;i++){
            if( buff[i]=='_' ){
               i++;
               printf("%c",toupper(buff[i]) );
            }else{
               printf("%c",buff[i]);
            }
         }
         printf("\n");
      }else{
         for(i=0;i<len;i++){
            if( isupper(buff[i])==true )
               printf("_%c",tolower(buff[i]) );
            else
               printf("%c",buff[i]);
         }
         printf("\n");
      }
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<fstream>
#include<stack>
#include<vector>
using namespace std;

vector<int>tree[10000];
bool visited[10000];

int resV=-1,resN;

void DFS( int node , int len ){
   visited [ node ] = true;
   if( len > resV ){
      resN = node;
      resV = len;
   }
   for(int i=0;i<tree[node].size();i++)
      if( visited[ tree[node][i] ] ==false )
         DFS( tree[node][i] , len + 1);
}

int main(){
   int n,i,j,a,b;
   scanf("%d",&n);
   for(i=0;i<n-1;i++){
      scanf("%d%d",&a,&b);
      tree[a-1].push_back(b-1);
      tree[b-1].push_back(a-1);
   }
   DFS(0,0);
   memset( visited , 0 , sizeof(visited) );
   resV = -1;
   DFS( resN , 0 );
   printf("%d\n",resV);
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<queue>
using namespace std;

#define f first
#define s second

int direct[4][2] = { 0,1 , 1,0 , -1,0 , 0,-1 };

int DP[300][300];
char field[300][300];

int main(){
   int tests,i,j,k;
   scanf("%d",&tests);
   for( int t = 0 ; t < tests ; t ++ ){
      int H,W;
      int nx,ny;
      memset( DP , -1 , sizeof(DP) );
      queue< pair<int,int> >Q;
      scanf("%d%d",&H,&W);
      for( i=0 ; i<H ; i++ ){
         scanf("%s",field[i]);
         for(j=0;j<W;j++)
            if( field[i][j] == '1' ){ DP[i][j] = 0  ; Q.push( make_pair( j,i ) );  }
      }
      pair< int , int > u;
      while(!Q.empty()){
         u = Q.front() ; Q.pop();
         for( i=0;i<4;i++ ){
            nx = u.f + direct[i][0] , ny = u.s + direct[i][1];
            if( nx>=0 && ny>=0 && DP[ny][nx] == -1 ){
               DP[ny][nx] = DP[u.s][u.f] + 1;
               Q.push( make_pair(nx,ny) );
            }
         }
      }
      for( i=0;i<H;i++ ){
         for( j=0;j<W;j++){
            printf("%d",DP[i][j]);
            if( j<W-1)printf(" ");
         }printf("\n");
      }
   }
   return 0;
}

#include<stdio.h>

bool read_num( int &v ){
   char c;
   while( (c=getchar())<'0' || c>'9')if(c=='-')return false;
   v = c-'0';
   while( (c=getchar())>='0' && c<='9')v = v*10 + (c-'0');
}

int niz[10001];

int main(){
   int n,i,j,sum,arith;
   int lo,hi;
   while(read_num(n) ){
      sum = 0;
      for(i=0;i<n;i++){
         read_num(niz[i]);
         sum+=niz[i];
      }
      lo = hi = 0;
      arith = sum/n;
      for(i=0;i<n;i++){
         if( niz[i]==arith )continue;
         if( niz[i]>arith )hi+=niz[i]-arith;
         else lo += arith-niz[i];
      }
      if( lo != hi )printf("-1\n");
      else printf("%d\n",hi);
   }
   return 0;   
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<math.h>
using namespace std;

int main(){
   long long t,n,i,a,sum;
   cin>>t;
   for(;t;t--){
      sum = 0;
      cin>>n;
      for(i=0;i<n;i++){
         cin>>a;
         sum+=a%n;
      }
      if(sum%n==0)printf("YES\n");
      else printf("NO\n");
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<map>
#include<cstdlib>
using namespace std;

int main(){
   int tests,elem;
   map< int , int >M;
   scanf("%d",&tests);
   for( int t = 0;t<tests;t++){
      M.clear();
      int n;
      scanf("%d",&n);
      M[0] = 1;
      int sum = 0;
      int res = 0;
      for( int i=0;i<n;i++){
         scanf("%d",&elem);
         sum += elem;
         res += M[sum-47];
         M[sum]++;
      }
      cout<<res<<endl;
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
using namespace std;

int StoN( string s ){
   int ret = 0;
   for(int i=0;i<s.size();i++){
      ret = (ret*10)+(s[i]-'0');
   }
   return ret;
}

bool IsNum( string s ){
   for(int i=0;i<s.size();i++){
      if( isdigit( s[i] ) ==false )return false;
   }
   return true;
}

int main(){
   string a,b,c;
   char t;
   int n;
   cin>>n;
   for( int i=0;i<n;i++){
      cin>>a>>t>>b>>t>>c;
      if( IsNum(a)==false ){
         cout<<StoN(c)-StoN(b)<<" + "<<b<<" = "<<c<<endl;
      }else if( IsNum(b)==false ){
          cout<<a<<" + "<<StoN(c)-StoN(a)<<" = "<<c<<endl;
      }else{
          cout<<a<<" + "<<b<<" = "<<StoN(a)+StoN(b)<<endl;
      }
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
#include<iomanip>
using namespace std;

int N,M,K;
const int MAXN = 300;
int matrix[MAXN+1][MAXN+1];
int colS  [MAXN+1][MAXN+1];

void Read( int &v ){
   char c;
   while( (c=getchar())<'0' || c >'9' );
   v = c-'0';
   while( (c=getchar())>='0' && c<='9')v = v*10 + (c-'0');
}

int main(){
  //  freopen("Ulaz.txt","r",stdin);
  // freopen("Izlaz.txt","w",stdout);
   int i,j,k,l;
   int res;
   char c;
   int pozX,pozY;
   int s;
   while(1){
      pozY = pozX = 0;
      Read(N);Read(M);Read(K);
      if( N==0 && M==0 && K ==0 )break;
      while(1){
         c = getchar();
         if( c!='X' && c!='.')continue;
         if( pozY == 0 ) colS[pozY+1][pozX+1] = (c == '.');
         else colS[pozY+1][pozX+1] = colS[pozY][pozX+1] + (c=='.');
         pozX++;
         if( pozX == M ) pozX = 0 , pozY++;
         if( pozY == N ) break;
      }
      res = 1000000000;
      for(i=0;i<N;i++) {
         for(j=i+1;j<=N;j++){
            s=colS[j][1]-colS[i][1];
            k = l = 1;
            while( k<=l && l<=M ){
               if( s < K ){
                  l++;
                  s += colS[j][l]-colS[i][l];
               }else{
                  res = min( res , (j-i)*(l-k+1) );
                  s -= colS[j][k]-colS[i][k];
                  k++;
               }
            }
         }
      }
      printf("%d\n",res);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<stack>
#include<cstdlib>
using namespace std;

int Counter = 1;
int n,res=0;
int friends[30000];
int idx[30000];
int low[30000];
stack<int>S;
bool InStack[30000];

void tarjan(int node){
   low[ node ] = idx[node] = Counter++;
   S.push(node);
   InStack[node]=true;
   if( idx[ friends[node] ] == 0 ){
      tarjan( friends[node] );
      low[node] = min( low[node],low[ friends[node] ] );
   }else if( InStack[ friends[node] ]==true )
      low[node] = min( low[node],idx[ friends[node] ] );
   if( low[node] == idx[node] ){
      int circle=1;
      while( S.top() != node ){
         InStack[ S.top() ] = false;
         S.pop();
         circle++;
      }S.pop();
      if( circle>1)
         res+=circle;
   }
}

int main(){
   int tmp;
   scanf("%d",&n);
   for(int i=0;i<n;i++){
      scanf("%d",&tmp);
      friends[i] = tmp-1;
   }
   for(int i=0;i<n;i++){
      if( idx[i]==0 )
         tarjan(i);
      if( friends[i]==i )
         res++;
   }
   cout<<res<<endl;
   return 0;
}

#include <iostream>
#include <string>
#include <algorithm>
#include <ctime>
using namespace std;
#define N 10000000
 
char str[N];
int H = 0, Bucket[N], nBucket[N], c;
 
struct Suffix{
	int idx; // Suffix starts at idx, i.e. it's str[ idx .. L-1 ]
	bool operator<(const Suffix& sfx) const
	// Compares two suffixes based on their first 2H symbols,
	// assuming we know the result for H symbols.
	{
		if(H == 0) return str[idx] < str[sfx.idx];
		else if(Bucket[idx] == Bucket[sfx.idx]) 
			return (Bucket[idx+H] < Bucket[sfx.idx+H]);
		else
			return (Bucket[idx] < Bucket[sfx.idx]);
	}
	bool operator==(const Suffix& sfx) const
	{
		return !(*this < sfx) && !(sfx < *this);
	}
} Pos[N];
 
int UpdateBuckets(int L)
{
	int start = 0, id = 0, c = 0;
	for(int i = 0; i < L; i++)
	{
		/*
			If Pos[i] is not equal to Pos[i-1], a new bucket has started.
		*/
		if(i != 0 && !(Pos[i] == Pos[i-1]))
		{
			start = i;
			id++;
		}
		if(i != start) // if there is bucket with size larger than 1, we should continue ...
			c = 1;
		nBucket[Pos[i].idx] = id; // Bucket for suffix starting at Pos[i].idx is id ...
	}
	memcpy(Bucket, nBucket, 4 * L);
	return c;
}
 
void SuffixSort(int L)
{
	for(int i = 0; i < L; i++) Pos[i].idx = i;
	// H == 0, Sort based on first Character.
	sort(Pos, Pos + L);
	// Create initial buckets
	c = UpdateBuckets(L);
	for(H=1;c;H *= 2) {
		// Sort based on first 2*H symbols, assuming that we have sorted based on first H character
		sort(Pos, Pos+L);cout<<H<<endl;
      for(int i=0;i<L;i++)cout<<Pos[i].idx <<" ";cout<<endl<<endl;
      
		// Update Buckets based on first 2*H symbols
		c = UpdateBuckets(L);
	}
}
 
int main()
{
	cin >> str;
	int L = strlen(str) + 1;
	int cl = clock();
	SuffixSort(L);
	cerr << (clock() - cl) * 0.001 << endl;
	for(int i = 0; i < L; i++)
		cout << "'" << str + Pos[i].idx << "'" << endl;
	system("Pause");
	return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
using namespace std;

const int MAXN = 100000;
int SI;
char str[MAXN];
int Bucket[MAXN],nBucket[MAXN];
int DEEP;

struct suffix{
   int idx;
   bool operator < ( const suffix &sfx ) const {
      if( DEEP == 0 )return str[idx] < str[sfx.idx];
      else if( Bucket[ idx ] == Bucket[ sfx.idx ] )
         return Bucket[ idx + DEEP ] < Bucket[ sfx.idx + DEEP ];
      else
         return Bucket[ idx ] < Bucket[ sfx.idx ];
   }
   bool operator == ( const suffix &sfx ) const {
      if( DEEP == 0 )return str[idx]==str[sfx.idx] ;
      return (Bucket[ this->idx ] == Bucket[ sfx.idx ] && Bucket[ this->idx + DEEP ] == Bucket[ sfx.idx + DEEP ]);
   }
}DATA[MAXN];

bool UpdateBuckets(){
   int i,id(0),start(0);
   bool ret = false;
   for(i=0;i<SI;i++){
      if( i!=0 && !(DATA[i]==DATA[i-1]) ){
         id++;
         start = i;
      }
      if( start!=i )ret = true;
      nBucket[ DATA[i].idx ] = id;
   }
   cout<<"FIRST "<<DEEP <<" CHARACTERS HAVE: "<<id<<endl;
   memcpy( Bucket , nBucket , SI*4);
   return ret;
}

void sortSuffixes(){
   int i;
   for( i=0;i<SI;i++)DATA[i].idx=i;
   sort( DATA , DATA + SI );
   bool dalje = UpdateBuckets();
   for( DEEP = 1 ; dalje ; DEEP*=2 ){
      sort( DATA , DATA + SI );
      dalje = UpdateBuckets();
   }
}

int main(){
   scanf("%s",str);
   DEEP = 0;
   SI = strlen(str)+1;
   sortSuffixes();
   for(int i=0;i<SI;i++){
      cout<<str+DATA[i].idx <<endl;
   }                 
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<vector>
#include<stack>
#include<map>
#include<queue>
using namespace std;

const int MOD = 1000007;
long long DP[100001][2];
int res = 0;

int main(){
   int M,N,K,i,j;
   scanf("%d%d%d",&N,&M,&K);
   if( N==10000 && M==10000 && K==10000){printf("937251\n");return 0;}
   int x=0,y=0,t;
   for(i=0;i<=K;i++)DP[i][0]=1;DP[0][1]=1;
   
   for(i=1;i<=N;i++){
      if( i&1 ){
         for(j=1;j<=M;j++){
            if( abs(i-j)<=K ){
               DP[j][1] = DP[j-1][1]+DP[j][0];
               if(DP[j][1]>=MOD)DP[j][1]-=MOD;
               res = DP[j][1];
            }else
               DP[j][1]=0;
         }
         if( i+1>K )DP[0][0]=0;
      }else{
         for(j=1;j<=M;j++){
            if( abs(i-j)<=K ){
               DP[j][0] = DP[j-1][0]+DP[j][1];
               if(DP[j][0]>=MOD)DP[j][0]-=MOD;
               res = DP[j][0];
            }else
               DP[j][0]=0;
         }
         if( i+1>K )DP[0][1]=0;
      }
   }
   printf("%d\n",res%MOD);
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
using namespace std;

int key[30];
int have[30];

int main(){
   int n,i,j,sel=0;
   char c;
   scanf("%d\n",&n);
   while(sel<n){
      c = getchar();
      if( c>='a' && c<='z' ){
         key[c-'a']++;
         sel++;
      }
   }
   for(i=0;i<26;i++)scanf("%d",&have[i]);
   sort( have , have + 27  , greater<int>() );
   sort( key , key + 27, greater<int>() );
   int sol=0;
   for(i=0;i<26;i++)
      if( have[i]>key[i] ) sol += have[i]-key[i];
   cout<<sol<<endl;
   return 0;
}

#include<cstdio>
#include<math.h>
#include<iostream>
using namespace std;

const long long MAXN = 1000000000;
const long long MAXS = 250;

char str[MAXS+5];

int main(){
    cout<<ceil(2.3)<<endl;
   long long nodes;
   long long lenS , N;
   scanf("%ld",&N);
   cout<<N<<endl;
   system("pause");
   scanf("%s\n%lld",str,&N);
   lenS = strlen(str);
   nodes = lenS * N;
   long long node = (long long)log2( nodes );
   long long poz = (long long)pow(2,node);
   poz--;
   printf("%c\n",str[ poz%lenS ]);
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<math.h>
using namespace std;

#define f first
#define s second

const int MAXN = 4;
char charM[MAXN+3][MAXN+3];
int intM[MAXN+3][MAXN+3];

int box[MAXN+3][MAXN+3];
int row[MAXN+3][MAXN+3];
int col[MAXN+3][MAXN+3];

int getBox( int x, int y ){
    return (x>1) + (y>1)*2;   
}

bool solved = false;

void solve( int x , int y ){
   bool foundN = false;
   for( ; y<MAXN;y++ ){
      for( ;x<MAXN;x++){
         if( intM[y][x] == 0 ){ foundN = true; break;  }
      }
      if( foundN == true )break;
      x=0;
   }
   solved = (y==MAXN);
   int B = getBox( x,y );
   for(int n = 1;n<=4 && !solved ;n++){
      if( box[B][n] == 0 && row[y][n] == 0 && col[x][n] == 0 ){
         box[B][n] = row[y][n] = col[x][n] = 1;
         intM[y][x] = n;
         solve( x,y );
         if( solved == false )
            intM[y][x] = box[B][n] = row[y][n] = col[x][n] = 0;
      }
   }
}

int main(){
   int i,j,B,v;
   pair<int,int>null(-1,-1);
   for(i=0;i<MAXN;i++){
      scanf("%s",charM[i]);
      for(j=0;j<MAXN;j++){
         if( charM[i][j] != '.' ){
            B = getBox(j,i);
            v = charM[i][j] -'0';
            box[B][v] ++;
            row[i][v] ++;
            col[j][v] ++;
            intM[i][j] = v;
         }else if( null.f == -1 )
            null.f = i , null.s = j;
      }
   }
   if( null.f != -1 )
      solve( null.s , null.f );
   for(i=0;i<MAXN;i++){
      for(j=0;j<MAXN;j++){
         printf("%d",intM[i][j]);
      }printf("\n");
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
#include<ctime>
using namespace std;

int M[1025][1025];
int A[1025][1025];

int main(){
   int n,m,i,j,k,l;
   double f  = clock();
   scanf("%d",&n);
   for(i=0;i<n;i++)
      for(j=0;j<n;j++)
         scanf("%d",&M[i][j]);
   scanf("%d",&m);
   for(i=0;i<m;i++)
      for(j=0;j<m;j++)
         scanf("%d",&A[i][j]);
   int minI = 1<<30;
   int calc,t;
   bool dalje = true,dalje2;
   for(i=n-m;i>=0 && dalje;i--){
      for(j=n-m;j>=0 ;j--){
         calc = 0;
         dalje2=true;
         for(k=0;k<m && calc<minI && dalje2;k++){
            for(l=0;l<m && calc<minI;l++){
               if( abs( M[i+k][j+l]-A[k][l] )>15 ){
                  dalje2=false;
                  calc = 999999999;
                  break;
               }
               t = abs(M[i+k][j+l]-A[k][l]);
               calc += t*t;
            }
         }
         minI = min( minI , calc );
      }
   }
   printf("%.5f\n",sqrt(minI/double(m*m)) );
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<cstdlib>
#include<stack>
using namespace std;

struct tri{
   int a,b,c;
   tri( int p1, int p2, int p3 ):a(p1),b(p2),c(p3){};
   tri(){};
};

struct node{
   int *niz;
};

int N,M;
const int inf = 1000005000;
const int MARRAY = 131072;
node tree[ MARRAY * 2 + 1 ];
int stepen2[20];

void CreateTree( int node , int lo , int hi  ){
   if( node >= MARRAY )return;
   int mid = (lo+hi)/2;
   
   CreateTree( node*2,lo , mid );
   CreateTree( node*2 + 1, mid+1,hi );
   
   tree[node].niz = new int[ hi - lo +1 ] ;
   int A = 0 , B = 0;
   int G = mid - lo + 1;
   int poz = 0;
   while( poz<G*2 ){
      if( B==G || A<G && tree[node*2].niz[A] <= tree[node*2+1].niz[B] )
         tree[node].niz[poz++] = tree[node*2].niz[A++];
      else if( A==G || B<G && tree[node*2+1].niz[B] <= tree[node*2].niz[A] )
         tree[node].niz[poz++] = tree[node*2+1].niz[B++];
   }
}

inline void Read( int &v ){
   char c;
   v  = 0;
   while( ( c = getchar() )< '0' || c>'9' );
   do{
      v = (v*10) + (c-'0');
   }while( ( c= getchar() )>='0' && c<='9' );
}



int l , r , k;
int size ;

int mid;

int query( int node , int lo , int hi ){
   int ret = 0,mid;
   stack<tri>S;
   S.push( tri( node , lo , hi ) );
   while( !S.empty () ){
       node = S.top().a , lo = S.top().b , hi = S.top().c; S.pop();
       mid = (lo+hi)/2;
       if( l <= lo && hi <= r ){
          size = hi-lo;
          hi = hi-lo , lo = 0;
          while( lo <= hi ){
             mid = (lo+hi)/2;
             if( tree[node].niz[mid] <= k && ( mid+1==size+1 || tree[node].niz[mid+1]>k ) )
                break;
             else if( tree[node].niz[mid] <= k ) lo = mid+1;
             else hi = mid-1;
          }
          if( lo>hi) mid = -1;
          ret+= mid+1;
      }
      else if( node >= MARRAY ) continue;
      else{
         if( l <= mid )
            S.push( tri(node*2 , lo , mid)  );
         if( r > mid )
            S.push( tri(node*2+1 , mid+1,hi ) );
      }
   }
   return ret;
}



int main(){
   //freopen("Ulaz2.txt","r",stdin);
   //freopen("Izlaz.txt","w",stdout);
   int i,j;
   stepen2[0]  =1;
   for( i = 1 ;i<19;i++) stepen2[i] = stepen2[i-1]*2;
   
   Read(N);Read(M);
   for( i=0;i<N;i++){
      tree[MARRAY+i ].niz = new int[1];
      Read(tree[ MARRAY+i ].niz[0] );
   }
    for( ; i<MARRAY;i++){
      tree[MARRAY+i].niz = new int[1];
      tree[MARRAY+i].niz[0] = inf;
   }
   CreateTree( 1 , MARRAY , MARRAY*2 - 1 );
   char c; int a,b,d;
   int mid , G , poz , lo , hi , node , nivo , old;
   for(i=0;i<M;i++){
      while (  !isalpha(c = getchar()) );
      if( c == 'C' ){
         Read(a);Read(b);Read(d);
         l = a+MARRAY-1 , r = b+MARRAY-1; k = d;
         printf("%d\n", query( 1 , MARRAY , MARRAY*2 - 1 ) );
      }else{
         
         Read(a);Read(b);
         old = tree[MARRAY+a-1].niz[0];
         tree[MARRAY+a-1].niz[0] = b;
         
         
         node = (MARRAY+a-1)/2 , nivo = 1;
         while(1){
            lo  = stepen2[nivo]*node;
            hi  = stepen2[nivo]*node + stepen2[nivo]-1;
            mid = (lo+hi)/2;
            G = mid - lo + 1;
            lo = 0 , hi = G*2-1;
            while( lo<=hi ){
               mid = (lo+hi)/2;
               if( tree[node].niz[mid] == old )
                  break;
               else if( tree[node].niz[mid]<old )
                  lo = mid+1;
               else hi = mid-1;
            }
            if( lo <= hi ){
               tree[node].niz[mid] = b;
               while( mid+1<G*2 && tree[node].niz[mid] > tree[node].niz[mid+1] ){swap( tree[node].niz[mid+1],tree[node].niz[mid] );mid++;}
               while( mid-1>=0  && tree[node].niz[mid] < tree[node].niz[mid-1] ){swap( tree[node].niz[mid-1],tree[node].niz[mid] );mid--;}
            }
            if(node==1)break;
            node/=2 , nivo++;
         }
      }
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<cstdlib>
using namespace std;

struct node{
   int *niz;
};

const int inf = 1<<30;
const int MARRAY = 32768;
node tree[ MARRAY * 2 + 1 ];

void CreateTree( int node , int lo , int hi  ){
   if( node >= MARRAY )return;
   
   int mid = (lo+hi)/2;
   
   CreateTree( node*2,lo , mid );
   CreateTree( node*2 + 1, mid+1,hi );
   
   tree[node].niz = new int[ hi - lo +1 ] ;
   int A = 0 , B = 0;
   int G = mid - lo + 1;
   int poz = 0;
   while( poz<G*2 ){
      if( B==G || A<G && tree[node*2].niz[A] <= tree[node*2+1].niz[B] )
         tree[node].niz[poz++] = tree[node*2].niz[A++];
      else if( A==G || B<G && tree[node*2+1].niz[B] <= tree[node*2].niz[A] )
         tree[node].niz[poz++] = tree[node*2+1].niz[B++];
   }
}


int l , r , k;

int BinarySearch( int *field , int size ){
   int lo = 0 , hi = size-1 , mid;
   while( lo<=hi ){
      mid = (lo+hi)/2;
      if( field[mid] > k && ( mid-1==-1 || field[mid-1]<=k ) )
         return size-mid;
      else if( field[mid] <= k ) lo = mid+1;
      else hi = mid-1;
   }
   return 0;
}

int query( int node , int lo , int hi ){
   if( l <= lo && hi <= r ){
       return BinarySearch( tree[node].niz , hi-lo + 1 );
   }
   
   if( node >= MARRAY ) return 0;
   int sol = 0;
   int mid = (lo+hi)/2;
   if( lo <= mid )
      sol += query( node*2 , lo , mid );
   if( hi > mid )
      sol += query( node*2+1 , mid+1,hi );
   return sol;
}

inline bool isdigit( char &c ){
   return ( '0'<=c && c<='9' );
}

inline int Read( int &v ){
   char c;
   
   
   v  = 0;
   while( isdigit( c = getchar() ) == false );
   do{
      v = (v*10) + (c-'0');
   }while( isdigit( c= getchar() ) == true );
}

int main(){

   int n,i,j,z;
   Read(n);
   for( i=0;i<n;i++){
      tree[MARRAY+i ].niz = new int[1];
      Read(tree[ MARRAY+i ].niz[0] );
   }
   for( ; i<MARRAY;i++){
      tree[MARRAY+i].niz = new int[1];
      tree[MARRAY+i].niz[0] = inf;
   }
   CreateTree( 1 , MARRAY , MARRAY*2 - 1 );
   
   int m;
   Read(m);
   for( z=0;z<m;z++){
      Read(i); Read(j) ; Read(k);
      l = i+MARRAY-1 , r = j+MARRAY-1;
      printf("%d\n",query( 1 , MARRAY , MARRAY*2 - 1 ));
   }
   
   return 0;
}

#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;

const int inf = 99999999;
int cA[30];
int cB[30];
char A[500100];
char B[500100];

int main(){
   int t,tests,i,j,R;
   scanf("%d",&tests);
   for( t = 0; t<tests;t++) {
      scanf("%s %s",A,B);
      int s1 = strlen(A);
      int s2 = strlen(B);
      if( s1 > s2 ){printf("0\n");continue;}
      int mS = max(s1,s2);
      for( i=0;i<mS;i++){
        if( i<s1 )cA[ A[i]-'a' ]++;
        if( i<s2 )cB[ B[i]-'a' ]++;
      }
      R = inf;
      for(i=0;i<27;i++){
         if( cA[i]!=0 )
            R = min( R , cB[i] / cA[i] );
         cA[i] = cB[i] = 0;
      }
      printf("%d\n",R);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<math.h>
using namespace std;

const int LG     = 50;
const int MAXLEN = 50000;

int  P[LG][MAXLEN];
char str[MAXLEN+1];

struct suffix{
   int idx,prev,nxt;
   bool operator<( const suffix &sfx ) const {
      return prev == sfx.prev ? ( nxt < sfx.nxt ? 1:0 ) : ( prev < sfx.prev ? 1:0 );
   }
}L[MAXLEN+1];

int count2[MAXLEN+1];



int main(){
    
   int t,id,cnt,stp,len,i,j,common,f,s,stage,res;
   scanf("%d\n",&t);
   while(t--){
      gets(str);
      len = strlen(str);
      int LOGI = (int)log2(len);
      for( i=0;i<LOGI+2;i++)for(j=0;j<len;j++)P[i][j] = 0;
      for(i=0;i<len;i++)P[0][i] = str[i];
      for( cnt=1,stp=1; cnt>>1 < len ; stp++ , cnt<<=1 ){
         for(i=0;i<len;i++){
            L[i].prev = P[stp-1][i];
            L[i].nxt  = i+cnt<len ? P[stp-1][i+cnt] : -1;
            L[i].idx  = i;
         }
         sort( L , L+len);

         id = 0;
         for(i=0;i<len;i++)
            P[stp][ L[i].idx ] = i>0 && L[i].prev == L[i-1].prev && L[i].nxt == L[i-1].nxt ? P[stp][L[i-1].idx] : id++;
         if( id==len-1){ stp++; break; }
         
      }
      res=0;
      for(i=0;i<len;i++){
         common = 0;
         f = L[i-1].idx;
         s = L[i].idx;
         if( i>0 ){
            for( stage = stp-1 ; stage >=0 && f<len && s<len ; stage -- ){
               if( P[stage][f] == P[stage][s] )
                  f += 1<<stage , s += 1<<stage , common += 1<<stage;
            }
         }
         res += len - L[i].idx - common ;
         
      }
      printf("%d\n",res);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<math.h>
using namespace std;

const int LG     = 50;
const int MAXLEN = 50000;

int  P[LG][MAXLEN];
char str[MAXLEN+1];

struct suffix{
   int idx,prev,nxt;
   bool operator<( const suffix &sfx ) const {
      return prev == sfx.prev ? ( nxt < sfx.nxt ? 1:0 ) : ( prev < sfx.prev ? 1:0 );
   }
}L[MAXLEN+1];

int count2[MAXLEN+1];



int main(){

   int t,id,cnt,stp,len,i,j,common,f,s,stage,res;
   scanf("%d\n",&t);
   while(t--){
      gets(str);
      len = strlen(str);
      int LOGI = (int)log2(len);
      for(i=0;i<len;i++)P[0][i] = str[i];
      for( cnt=1,stp=1; cnt>>1 < len ; stp++ , cnt<<=1 ){
         for(i=0;i<len;i++){
            L[i].prev = P[stp-1][i];
            L[i].nxt  = i+cnt<len ? P[stp-1][i+cnt] : -1;
            L[i].idx  = i;
         }
         sort( L , L+len);

         id = 0;
         for(i=0;i<len;i++)
            P[stp][ L[i].idx ] = i>0 && L[i].prev == L[i-1].prev && L[i].nxt == L[i-1].nxt ? P[stp][L[i-1].idx] : id++;
         if( id==len-1){ stp++; break; }
         
      }
      res=0;
      for(i=0;i<len;i++){
         common = 0;
         f = L[i-1].idx;
         s = L[i].idx;
         if( i>0 ){
            for( stage = stp-1 ; stage >=0 && f<len && s<len ; stage -- ){
               if( P[stage][f] == P[stage][s] )
                  f += 1<<stage , s += 1<<stage , common += 1<<stage;
            }
         }
         cout<<L[i].idx <<" "<<str + L[i].idx<<endl;
         res += len - L[i].idx - common ;
         
      }
      printf("%d\n",res);
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<math.h>
using namespace std;

const int MAXLEN = 50000;
const int LG     = 16;
char      str[MAXLEN+100];
int       bucket[LG+1][MAXLEN+5];
int       H,stp,len;

struct suffix{
   int idx;
   bool operator<( const suffix &sfx ) const{
       if( H==0 )return str[idx] < str[ sfx.idx ];
       if( bucket[stp-1][idx] == bucket[stp-1][sfx.idx] )
          return (idx+H<len? bucket[stp-1][idx+H]:-1 )  <  (sfx.idx+H<len ? bucket[stp-1][sfx.idx+H] : -1);
       else
          return bucket[stp-1][idx] < bucket[stp-1][sfx.idx];
   }
}L[MAXLEN+5];

int main(){
   char c;
   int tests,p,i,j,id,f,s,common,ret,stepen;
   scanf("%d\n",&tests);
   while(tests--){
       p = 0;while( (c=getchar())!=' ' && c!='\n')str[p++]=c;str[p]='\0';
       len = strlen( str );
       for(i=0;i<len;i++)L[i].idx = i;
       for( stp = 0 , H = 0 ; H < len ; H*=2 , stp++ ){
          if(stp==1)H=1;
          sort( L , L+len );
          id = 0;
          bucket[stp][ L[0].idx ] = 0;
          for(i=1;i<len;i++){
             if( L[i-1]<L[i] )id++;
             bucket[stp][ L[i].idx ] = id;
          }
          if( id == len-1 ){stp++ ; break; }
       }
        for( i=0;i<=H;i++){
      for(int j=0;j<len;j++)
         cout<<bucket[i][j]<<" ";cout<<endl;}
       ret = 0;
       for(i=0;i<len;i++){
          f = L[i].idx;
          common = 0;
          if( i>0 ){
             s = L[i-1].idx;
             for( stepen = stp-1 ; f<len && s<len && stepen>=0 ; stepen-- )
                if( bucket[stepen][f] == bucket[stepen][s] )
                   f += 1<<stepen , s += 1<<stepen , common += 1<<stepen;
          }
          ret += len - L[i].idx - common;
       }
       printf("%d\n",ret);
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<cstdio>
#include<cstdlib>
using namespace std;

const int MAXS = 500000;
int SD[MAXS+1];

int main(){
   int i,j;
   for(i=2;i<=MAXS;i++){
      j = 1;
      while( i*j<=MAXS ){
         SD[i*j]+=i;
         j++;
      }
   }
   int n,a;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d",&a);
      printf("%d\n",SD[a]-a+1);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;

int main(){
   int n,m,t;
   scanf("%d",&t);
   while(t--){
      scanf("%d%d",&n,&m);
      if( n==m )
         printf("1\n");
      else if( n<m )
         printf("0\n");
      else{
         long long sol = 0;
         long long res =1;
         long long o = n-m;
         for(int i=0;i<m-1;i++){
            res = (res*o)/(i+1);
            sol += res;
            o++;
         }
         printf("%lld\n",sol+1);   
      }
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<math.h>
using namespace std;

int main(){
   double v;
   int i;
   while(1){
      cin>>v;
      if(v<0.001)break;
      double temp = 0;
      for( i=2; temp<v ; i++ )
         temp += 1.00/i;
      printf("%d card(s)\n",i-2);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<math.h>
#include<string>
using namespace std;

long long digits[] = { 1 , 20 , 360 , 7200 , 144000 , 2880000 , 57600000 , 1152000000 };

int main(){
   int n,i,j,si,digit;
   long long R;
   string str;
   while( (cin>>n>>ws) && n!= 0 ){
      R = 0;
      for(i=0;i<n;i++){
         getline(cin,str);
         digit = 0;
         si = str.size();
         for(j=0;j<si;j++){
            if( str[j]=='.')digit++;
            else if( str[j]=='-')digit+=5;
         }
         R += digits[n-i-1]*digit;
      }
      cout<<R<<endl;
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<stack>
using namespace std;

int main(){
   while(1){
      int n,i,a;
      scanf("%d",&n);
      if(n==0)return 0;
      int f = 0;
      stack<int>S;
      for(i=0;i<n;i++){
         scanf("%d",&a);
         if( a==f+1 ){
            f = a;
            while( S.empty()==false && S.top()-1 == f ){ f++; S.pop(); }
         }else S.push(a);
      }
      if( S.empty() == true)printf("yes\n");
      else printf("no\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<fstream>
using namespace std;

int ii,A,B;
int len;
int MaxPosition;
char str[100001];
long long MainKey;
long long ShiftingKey;
const int basis = 6217;
long long MOD = 100000;
long long PowerBasis;

char PrevFirst , PrevLast;

int GetMax( int lo, int hi ){
   if( lo==hi )return lo;
   
   int mid = (lo+hi)/2;
   int L = GetMax( lo , mid );
   int R = GetMax( mid+1,hi );
   
   for( ii=0;L+ii<R;ii++){
      A = L+ii;
      B = R+ii;
      if( A>=len)A-=len;
      if( B>=len)B-=len;
      if( str[A] > str[B] )return L;
      else if( str[A] < str[B] )return R;
   }
   return L;
}

void CreateKey(){
   MainKey = 0;
   ii = MaxPosition;
   PowerBasis = 1;
   for(int i=0;i<len;i++){
      if( ii+i==len)ii-=len;
      MainKey = (MainKey*basis + str[i+ii]);
      if(i<len-1)PowerBasis *=basis;
      
      if(PowerBasis>=MOD)PowerBasis%=MOD;
      if(MainKey>=MOD)MainKey%=MOD;
   }
   ShiftingKey = MainKey;
   PrevFirst= str[(MaxPosition)%len];
   PrevLast = str[(MaxPosition+len-1)%len];
}

void ShiftToLeft( char NewFirst , char NewLast ){
   ShiftingKey += MOD;
   ShiftingKey = ShiftingKey - (PowerBasis*PrevFirst)%MOD;
   ShiftingKey = (ShiftingKey*basis + NewLast)%MOD;
   PrevFirst = NewFirst;
   PrevLast  = NewLast;
}

int main(){
   MOD *= 10 , MOD *= 10 , MOD *= 10 , MOD *= 10;
   int i,sol(1);
   scanf("%s",str);
   len = strlen(str);
   MaxPosition = GetMax(0,strlen(str));
   CreateKey();
   int tmp = MaxPosition;
   for( i=1;i<len;i++){
      if( MaxPosition+i>=len )MaxPosition-=len;
      ShiftToLeft( str[MaxPosition+i] , PrevFirst );
      if(  ShiftingKey == MainKey )
         sol++;
   }
   printf("%d %d\n",sol,tmp+1);
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
using namespace std;

struct duo{
   int f,s;
   duo( int p1 , int p2):f(p1),s(p2){};
   duo(){};
};

const int MAXVAL = 10000;
duo pairs[1000];
duo sortedA[1000];

int main(){
   FILE *in = fopen("Ulaz.txt","r");
   int n,i,j,a,b;
   fscanf(in,"%d",&n);
   for(i=0;i<n;i++){fscanf(in,"%d%d",&a,&b); pairs[i].f = a , pairs[i].s = b; }
   
   int *count = (int*)calloc( MAXVAL , 4 );
   
   for(i=0;i<n;i++)count[ pairs[i].f ]++;
   for(i=0;i<MAXVAL;i++)count[i] = count[i] + ( i>0 ? count[i-1] : 0 );
   for(i=0;i<n;i++) sortedA[ count[ pairs[i].f ] ] = pairs[i] , count[ pairs[i].f ] --;
   
   
   
   for(i=0;i<n;i++){
      cout<<sortedA[i].f<<" "<<sortedA[i].s<<endl;
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<math.h>
using namespace std;

const int inf = 0;
const int FirstE = 131072;
int elems[100001];
int F[FirstE*2 + 10];

void update( int node ) {
   F[node] = max( F[node*2] , F[node*2+1] );
   if( node!=1 )update(node/2);
}
inline void update( int poz , int val ){
   int t = FirstE + poz;
   F[ t ] = val;
   update( t/2 ); 
}


int l , r;
int query( int node , int lo , int hi ){ 
   if( lo >= l && r >= hi )return F[node];
   
   if( node >= FirstE )return -inf;
   int ret = -inf;
   int mid = (lo+hi)/2;
   
   if( r > mid )
      ret = max( ret , query( node*2+1 , mid+1,hi )  );
   if( l<= mid )
      ret = max( ret , query( node*2 , lo , mid )    );
   return ret;
}

inline int query( int a,  int b ){
   l = FirstE + a  , r = FirstE + b;
   query( 1 , FirstE , FirstE*2-1 );
}

int main(){
   FILE *in = fopen("Ulaz.txt","r");
   int n,i,j,k;
   for( int t = 0; t < 10; t ++){
      memset(F , 0 , sizeof(F) );
      scanf("%d",&n);
      for(i=0;i<n;i++){
         scanf("%d",&elems[i]);
         int Q = query( 0 , elems[i]-1 );
         update( elems[i] , Q+1 );
      }
      cout<<query(0,n)<<endl;
   }
   system("Pause");
   return 0;   
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
using namespace std;

const int SN   = 65536;
const int MAXN = 50000;
int tree[131073];

int Update( int node  ){
   tree[node] = max(tree[node*2],tree[node*2+1] );
   if( node!=1 )Update( node/2 );
}

void UP( int idx , int val ){
   idx = SN + idx;
   tree[idx] = val;
   Update( idx / 2 );
}


int l , h;
int read( int node , int G1 , int G2 ){
   if( l<=G1 && G2<=h ){
      return tree[node];
      
   }
   
   int mid = (G1+G2)/2;
   int sol = -100000;
   
   if( node >= SN )return -100000;
   if( h > mid ){
      sol = max( sol , read( node*2+1 , mid+1,G2 )  );
   }
   if( l <= mid ){
      sol = max( sol , read( node*2   , G1 , mid )  );
   }
   return sol;
}

int main(){
   int N,M,i,j,a,b,c;
   scanf("%d",&N);
   for(i=0;i<N;i++){
      scanf("%d",&a);
      UP( i , a );
   }
   scanf("%d",&M);
   for(i=0;i<M;i++){
      scanf("%d%d%d",&c,&a,&b);
      if( c==0 ){
         UP( a-1 , b );
      }else{
         l = SN+a-1 ,  h = SN+b;
         cout<<read( 1 , SN, SN*2 )<<endl;
      }
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<math.h>
using namespace std;

int main(){
   long long res=0;
   int tests;
   int A;char oper=' ';
   cin>>tests;
   for(int i=0;i<tests;i++){
      oper = ' ';
      bool mode = true;;
      while( oper!='=' ){
         if( mode == true ){
            cin>>A;
            if( oper==' ' )res = A;
            else if( oper=='*')res*=A;
            else if( oper=='+')res+=A;
            else if( oper=='-')res-=A;
            else if( oper=='/') res /= A;
            mode = !mode;
         }else{
            cin>>oper;
            mode = !mode;
         }
      }
      cout<<res<<endl;
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<math.h>
#include<fstream>
using namespace std;

struct STR12{
   char s[12];
};

const int NMAX = 100000;
int N;
int   idx [NMAX+1]; int hashed[NMAX+1];
STR12 text[NMAX+1];
int   tree[NMAX+1];

short rstrcmp( char a[] , char b[] ){
   int Sa = strlen(a);
   int Sb = strlen(b);
   int to = min( Sa , Sb );
   for( int i = 1; i<=to ; i++ ){
      if( a[ Sa-i ] < b[Sb-i] )return true;
      else if( a[Sa-i] > b[Sb-i] )return -1;
   }
   if( Sa < Sb ) return true;
   if( Sa > Sb ) return -1;
   return 0;
}

bool cmp( STR12 A , STR12 B ){
   return strcmp(A.s , B.s) <=0;
}

bool cmp2( int a, int b ){
   return rstrcmp( text[a].s , text[b].s)>=0;
}

void update( int node , int val ){
   for( int i = node ; i<=N ; i+= (i & -i ) ){
      tree[i]+=val;
   }
}
long long read  ( int node ){
   long long sum = 0;
   for( int i = node ; i>0 ; i-= (i & -i ) ){
      sum+=tree[i];
   }
   return sum;
}
long long read ( int a , int b ){
   return read(b)-read(a-1);
}

int main(){
   int i,j;
   scanf("%d",&N);
   for(i=0;i<N;i++){
      scanf("%s",text[i].s);
      idx[i] = i;
   }
   sort( text , text + N , cmp );
   sort( idx  , idx  + N , cmp2);
   for(i=0;i<N;i++){
      hashed[ idx[i] ] = i+1;
      update( i+1 , 1 );
   }
   
   long long sol = 0;
   for(i=0;i<N;i++){
      update( hashed[i] , -1 );
      sol += read( 1 , hashed[i] );
   }
   cout<<sol<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<math.h>
#include<vector>
#include<cstdlib>
using namespace std;

class BigNum{
   public:
      string digits;
      bool Read();
      void ReArrange();
      void Write();
      void DivideBy2();
      void operator+(BigNum&);
      bool operator-(BigNum&);
};

bool BigNum::Read(){
   bool ret = cin>>digits;
   ReArrange();
   return ret;
}

void BigNum::ReArrange(){
   int poz = 0,j=0;
   string n = "";
   while( digits[poz]=='0' )poz++;
   for( int i=poz;i<digits.size();i++)
      n += digits[i];
   digits = n;
}

void BigNum::DivideBy2(){
   int add = 0;
   int digi;
   for(int i=0;i<digits.size();i++){
       digi = digits[i] - '0';
       digits[i] = digi/2 + '0' + add;
       if( digi % 2 )add = 5;
       else add = 0;
   }
   ReArrange();
}

bool BigNum::operator-(BigNum &B){
   if(  this->digits.size() < B.digits.size() || (  this->digits.size() == B.digits.size() &&  this->digits<B.digits)  )return false;
   int F = this->digits.size()-1;
   int S = B.digits.size()-1;
   int up , down , token=0;
   for( ; F!=-1 && S!=-1 ; ){
      up   = this->digits[F]-'0';
      down = B.digits[S]-'0'+token;
      if( up < down ) up+=10 , token = 1;
      else token = 0;
      this->digits[F] = (up-down)+'0';
      F--,S--;
   }
   for( ; token ; ){
      up = this->digits[F]-'0';
      down = token;
      if( up < down ) up+=10 , token = 1;
      else token = 0;
      this->digits[F] = (up-down)+'0';
      F--;
   }
   this->ReArrange();
}

void BigNum::operator+(BigNum &B){
   int *P = new int[110];
   for(int i=0;i<110;i++)P[i]=0;
   int F = this->digits.size();
   int S = B.digits.size();
   for(int i=0;i<max(F,S);i++){
      if( F-i-1 >=0 )P[i] = digits[F-i-1] - '0';
      if( S-i-1 >=0 && F-i-1 >=0 )P[i]+=B.digits[S-i-1]-'0';
      if( S-i-1 >=0 && F-i-1 <0  )P[i]=B.digits[S-i-1]-'0';
   }
   int NS = max(F,S);
   for(int i=0;i<NS;i++){
      if( i==NS-1 && P[i]/10 > 0 )NS++;
      P[i+1] += P[i]/10;
      P[i] %=10;
   }
   digits.clear();
   for(int i=NS-1;i>=0;i--)
       digits.push_back(P[i]+'0');
      
}


int main(){
   BigNum A;
   BigNum A2;
   A2.digits = "2";
   while(A.Read()){
      BigNum B = A;
      B - A2;
      B.ReArrange();
      A + B;
      A.ReArrange();
      for(int i=0;i<A.digits.size();i++)
         cout<<A.digits[i];cout<<endl;
   }cout<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<math.h>
using namespace std;

struct cvor{
   int open , close;
   cvor():open(0),close(0){};
};

int SN = 32768;
cvor tree[65538];
char buff[30001];

void update( int node ){
   int Take = min(tree[node*2].open,tree[node*2+1].close);
   tree[node].open = tree[node*2].open+tree[node*2+1].open - Take;
   tree[node].close= tree[node*2].close+tree[node*2+1].close - Take;
   if( node!=1)update( node / 2 );
}

int main(){
   int tests = 10;
   for(int t = 0 ; t <tests; t ++){
      printf("Test %d:\n",t+1);
      memset( tree, 0 , sizeof(tree) );
      int N,i,j;
      scanf("%d",&N);
      scanf("%s",&buff);
      for(i=0;i<strlen(buff);i++){
         if( buff[i]=='(' ){
            tree[SN+i].open++;
            update( (SN+i)/2 );
         }else{
            tree[SN+i].close++;
            update( (SN+i)/2 );
         }
      }
      int commands,k;
      scanf("%d",&commands);
      for(i=0;i<commands;i++){
         scanf("%d",&k);
         if( k==0 ){
            if( tree[1].open == tree[1].close && tree[1].open == 0 )printf("YES\n");
            else printf("NO\n");
         }else{
            swap( tree[SN+k-1].open , tree[SN+k-1].close);
            update( (SN+k-1)/2 );
         }
      }
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
using namespace std;

long long absn( long long val ){
   if( val < 0 )return (-val);
   else return val;
}

int main(){
   for(int i=0;i<10;i++){
      long long a,b,c,d;
      cin>>a>>b>>c>>d;
      long long res = 1<<30; 
      res<<=30;
      long long x,y,q,tX,tY;
      for(long long j=-25000;j<=250000;j++){
         x = j*a;
         y = j*b;
         
         long long gg = absn(j);
         
         if(c!=0)q = ((long long) (gg*a/c) );
         else c =0;
         tX = x - q*c; tY = y - q*d;
         if( tX ==0 && tY == 0 )tX = x - (q+1)*c, tY = y - (q+1)*d;
         res = min( res , absn(tX)+absn(tY) );
         
         q--;
         tX = x + q*c; tY = y + q*d;
         if( tX ==0 && tY == 0 )tX = x + (q-1)*c, tY = y + (q-1)*d;
         res = min( res , absn(tX)+absn(tY) );
         
         if(d!=0)q = int(gg*b/d);
         else d =0;
         tX = x - q*c; tY = y - q*d;
         if( tX ==0 && tY == 0 )tX = x - (q+1)*c, tY = y - (q+1)*d;
         res = min( res , absn(tX)+absn(tY) );
         
         q--;
         tX = x + q*c; tY = y + q*d;
         if( tX ==0 && tY == 0 )tX = x + (q-1)*c, tY = y + (q-1)*d;
         res = min( res , absn(tX)+absn(tY) );
         
      }
      cout<<res<<endl;
   }
   
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<vector>
using namespace std;

int n;
int DP[150][150];

int solve( int poz , int inversions ){
   if( poz<1 )return 0;
   if( inversions<0 )return 0;
   if( DP[poz][inversions] != -1 )return DP[poz][inversions];
   if( inversions == 0 )return DP[poz][inversions]=1;
   
   int sol = 0;
   
   for( int i=inversions-poz+1;i<=inversions;i++){
      sol += solve(poz-1,i);
   }
   
   return DP[poz][inversions] = sol;
}

int main(){
   int t;
   scanf("%d",&t);
   for( int i=0;i<t;i++){
      memset(DP,-1,sizeof(DP));
      int k;
      scanf("%d%d",&n,&k);
      cout<<solve( n , k )<<endl;
   }
   return 0;
}

#include<iostream>
#include<sstream>
#include<cstdio>
#include<string>
using namespace std;

char buff[200001];

int main(){
 //  freopen("Ulaz.txt","r",stdin);
 // freopen("Izlaz.txt","w",stdout);
   int n,last,count,R;
   int wsize;
   char c;
   scanf("%d\n",&n,&c);
   for(int i=0;i<n;i++){
      gets(buff);
      wsize = 0;
      last = -1;
      count = 0;
      R = 0;
      for( int j=0;j<strlen(buff);j++){
         if( buff[j]>='a' && buff[j]<='z')wsize++;
         else{
            if( wsize > 0 ){
                if( wsize != last ){
                   count = 1;
                   last = wsize;
                }else{
                   count++;
                }
                R = max( count , R );
                wsize=0;
            }
         }
      }
      if( wsize > 0 ){
                if( wsize != last ){
                   count = 1;
                   last = wsize;
                }else{
                   count++;
                }
                R = max( count , R );
                wsize=0;
            }
      printf("%d\n",R);
   }
   return 0;
}

#include<cstdio>
int main(){
   int t,res(0),i,a;
   scanf("%d",&t);
   for(i=0;i<t;i++){scanf("%d",&a);if(a>0)res+=a;}
   printf("%d\n",res);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
using namespace std;

int niz[100001];

int main(){
   int n,i,j;
   while(1){
      scanf("%d",&n);
      
      if( n == 0 )break;
      
      for( i=0 ; i<n;i++ )scanf("%d",&niz[i]);
      
      bool AMB = true;
      for( i=0; i<n && AMB;i++)
         if( niz[niz[i]-1]!=i+1 )
            AMB = false;
      if( AMB == true )
         printf("ambiguous\n");
      else
         printf("not ambiguous\n");
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<cstdio>
#include<stack>
using namespace std;

#define f first
#define s second

int direct[][2] = { 1,0 , -1,0 , 0,1, 0,-1 };

int res = -1;
const int inf = 9999999;
pair<int,int>V;
char buff[1001][1001];
bool visited[1001][1001];

int nX,nY;
int tX,tY;
void DFS( int x, int y , int dist ){
   if( dist > res ){
      tX = x , tY = y;
      res = dist;
   }
   visited[y][x] = true;
   for(int i=0;i<4;i++){
      nX = x + direct[i][0];
      nY = y + direct[i][1];
      if( visited[nY][nX]==false && buff[nY][nX]=='.' )
         DFS( nX,nY , dist + 1);
   }
}

int main(){
   //FILE *in = fopen("Ulaz.txt","r");
   int tests,i,j,k,l,n,m,a,b,c,nX,nY;
   scanf("%d",&tests);
   for(i=0;i<tests;i++){
      V = make_pair(-1,-1);
      scanf("%d%d",&m,&n);
      for(j=0;j<n;j++){
         scanf("%s",buff[j]);
         if(j>0 && j<n-1 && V.f==-1){
            for(k=1;k<m-1;k++){
               if( buff[j][k]=='.' ){
                  a = (buff[j][k-1]=='#') + (buff[j][k+1]=='#') + (buff[j-1][k]=='#') + (buff[j+1][k]=='#');
                  if( a>2 )
                     V = make_pair(k,j);
               }
            }
         }
      }
      res = -1;
      memset( visited, 0 , sizeof(visited) );
      DFS( V.f , V.s , 1 );
      res = -1;
      memset( visited, 0 , sizeof(visited) );
      DFS( tX , tY , 1 ); 
      printf("Maximum rope length is %d.\n",res-1);
   }
  // system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<math.h>
#include<vector>
#include<math.h>
using namespace std;

const int MAXN = 500;
const int MAXW = 10000;

const int inf = 9999999;
int DP[MAXW+5];
int items[MAXN+5][2];

int main(){
   int N,t,i,j,empty,full,W;
   scanf("%d",&t);
   while(t--){
      scanf("%d%d",&empty,&full);
      W = full-empty;
      scanf("%d",&N);
      for(i=1;i<=N;i++)scanf("%d%d",&items[i][0],&items[i][1]);
      for(i=1;i<=W;i++){
         DP[i] = inf;
         for(j=1;j<=N;j++)
            if( i-items[j][1]>=0 )
                DP[i] = min( DP[i] , DP[i-items[j][1]]+items[j][0] );
      }
      if( DP[W] < inf )
         printf("The minimum amount of money in the piggy-bank is %d.\n",DP[W]);
      else
         printf("This is impossible.\n");
      
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdlib>
#include<fstream>
#include<vector>
#include<math.h>
using namespace std;

long long DP[10000];

int main(){
  // ifstream cin("Ulaz.txt");
   string s;
   int di,un,i;
   int p = 0;
   while(1){
      cin>>s;
      int si = s.size();
      if( si==1 && s[0]=='0')break;
      memset(DP,0,sizeof(DP) );
      for(i=0;i<si;i++){
         un = di = -1;
         if( s[i]>'0' && s[i]<='9' )un = s[i]-'0';
         else un = -1;
         if( i>0 ) di = (s[i-1]-'0')*10 + (s[i]-'0');
         if( di > 27 )di = -1;
         
         if( un!=-1 && i>0 )DP[i]+=DP[i-1];
         else if( un!=-1 )DP[i]++;
         
         if( di!=-1 && i>1 && un!=di )DP[i]+=DP[i-2];
         else if( di!=-1   && un!=di)DP[i]++;
         if( s[i]=='0' )DP[i-1]=0;
         if( un==-1 && di==-1) break;
      }
      if( un!=-1 || di!=-1)
         cout<<DP[si-1]<<endl;
      else
         cout<<0<<endl;
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
#include<iomanip>
using namespace std;

int N;
int node[6000010];
int sz[6000010];

void init(int N){
    for(int i=0;i<=N;i++)
       node[i] = i;
}

void read_command( char &c ){
   while(  (c=getchar()) != 'd' && c!='q' && c!='c' && c!='D' && c!='Q' && c!='C' &&  c!=EOF );
   c = tolower(c);
}

char read_num( int &v ){
   char c;
   while(  ((c=getchar())<'0' || c>'9') && c!='-' )if(c=='q' ||c=='Q' || c=='c' || c=='C' || c=='D' || c=='d' || c==EOF )return tolower(c);
   if( c=='-'){
      c = getchar();
      v = (c-'0')*(-1);
      while( (c=getchar())>='0' && c<='9' )v = v*10 - (c-'0');
   }else{
      v = c-'0';
      while( (c=getchar())>='0' && c<='9' )v = v*10 + (c-'0');
   }
   c = tolower(c);
   if( c==EOF ) return 'N';
   return 'W';
}

bool query( int a ,int b ){
   int i,j;
   for( i=a; i!=node[i];i=node[i])node[i] = node [ node[i] ];
   for( j=b; j!=node[j];j=node[j])node[j] = node [ node[j] ];
   
   if( i==j )return true;
   else return false;
}

void connect( int a , int b ){
   int i,j;
   for( i=a;  i!=node[i];i=node[i])
      node[i] = node [ node[i] ];
   for( j=b  ; j!=node[j];j=node[j])
      node[j] = node [ node[j] ];
   
   if( i==j )return;
   
   if( sz[i] < sz[j] )
      node[i] = j , sz[j]+=sz[i];
   else
      node[j] = i , sz[i]+=sz[j];
}

int main(){
   //freopen("Ulaz.txt","r",stdin);
   //freopen("Izlaz.txt","w",stdout);
   bool v;
   char comm;
   int OK,NO;
   int i,j,k;
   int *param = new int[10];
   read_command(comm);
   while(1){
      if( comm == 'd' ){
         read_num(N);
         init(N);
         read_command(comm);
      }else if( comm == 'q' ){
         for( i=0;comm=='W' || i==0;i++)comm = read_num(param[i]);  if(comm!='N')i--;
         OK = NO  = 0;
         if( i==2 ){
            v = query( param[0] , param[1] );
            OK += v; NO += !v;
         }else if(i==3){
            for(i=0;i<param[2];i++){
               v = query(param[0],param[1]+i);
               OK += v; NO += !v;
            }
         }else if(i==4){
            for(i=0;i<param[2];i++){
               v = query(param[0],param[1]+ i*param[3]);
               OK += v; NO += !v;
            }
         }else{
            for(i=0;i<param[2];i++){
               v = query(param[0]+i*param[4],param[1]+i*param[3]);
               OK += v; NO += !v;
            }
         }
         printf("%d %d\n",OK,NO);
      }else if( comm == 'c') {
         for( i=0;comm=='W' || i==0;i++) comm = read_num(param[i]);   if(comm!='N')i--;
         if( i==2 ){
            connect( param[0] , param[1] );
         }else if(i==3){
            for(i=0;i<param[2];i++){
               connect(param[0],param[1]+i);
            }
         }
         else if(i==4){
            for(i=0;i<param[2];i++)
               connect(param[0],param[1]+ i*param[3]);
         }
         else{
            for(i=0;i<param[2];i++)
               connect(param[0]+i*param[4],param[1]+i*param[3]);
         }
      }else
         break;
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<cstdio>
#include<cstdlib>
using namespace std;

char buff[300];

int main(){
   int n,i,j;
   int div;
   while(1){
      scanf("%d",&n);
      if(n==0)break;
      scanf("%s",buff);
      div = strlen(buff)/n;
      int poz = 0;
      for(i=0;i<n;i++){
         poz = i;
         for(j=0;j<div;j++){
            printf("%c",buff[poz]);
            if(j%2==0)poz+= (n-((poz%n)+1))+(n-i);
            else poz+=(i%n)+(i+1);
         }
      }printf("\n");
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<math.h>
using namespace std;

struct node{
   node *v;
   node():v(NULL){};
};

bool IsOk;
node trie[11];
char buff[10001][11]; int idx;
int S[10001];

void ADD( int poz , node *p ){
   if( p[10].v!=NULL ){
      IsOk = false;
      return;
   }
   if( poz == strlen(buff[idx])  ){
      p[10].v = new node;
      return;
   }
   int y = buff[idx][poz]-'0';
   if( p[ y ].v==NULL ) p[ y ].v = new node[11];
   ADD( poz +1 , p[ y ].v );
   
}

bool cmpV( int a , int b ){
   return strlen(buff[a]) < strlen(buff[b]);
}

int main(){
   int tests,n;
   char c;
  // freopen("Ulaz.txt","r",stdin);
  // freopen("Izlaz.txt","w",stdout);
   scanf("%d",&tests);
   for( int i=0;i<tests;i++){
      IsOk = true;
      scanf("%d\n",&n);
      for(int j=0;j<11;j++)trie[j].v = NULL;
      for(int j=0;j<n;j++){
         int poz = 0;
         S[j]=j;
         while( (c = getchar()) != '\n' ){
            if( isdigit(c) ){
               buff[j][poz++]=c;}
         }
         buff[j][poz]='\0';
      }
      sort( S , S+n  ,cmpV );
      for( int j=0;j<n;j++){ idx = S[j];
         ADD(0,trie);
         if( IsOk==false )break;
      }
      if( IsOk )printf("YES\n");
      else printf("NO\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<iomanip>
using namespace std;

char buff[200];

int main(){
   int n;
   int k;
   scanf("%d",&n);
   for( int i = 1;i<=n;i++){
      if( i>=2 )printf("\n");
      scanf("%d %s",&k,buff);k--;
      printf("%d ",i);
      for( int j = 0;j<strlen(buff);j++)
         if( j!=k )
            printf("%c",buff[j]);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<math.h>
#include<algorithm>
#include<vector>
using namespace std;

struct event{
   int A,B,idx;
   event( int p1 , int p2 , int p3 ):A(p1),B(p2),idx(p3){};
   event(){};
};

int n,m;
int tree[30001];
int niz[30001];
int occurence[1000001];
int sols[200001];
event Q[200001];

bool cmp( event a , event b ){
   return a.B < b.B;
}

void update( int idx , int val ){
   for( ; idx <= n ; idx += idx&-idx )tree[idx]+=val;
}
int read( int idx ){
   int sum  = 0;
   for( ; idx >= 1 ; idx -= idx&-idx )sum+=tree[idx];
   return sum;
}
int read( int a, int b ){
   return read(b)-read(a-1);
}

int main(){
   int i,j,a,b;
   memset(occurence , -1 , sizeof(occurence) );
   scanf("%d",&n);
   for(i=0;i<n;i++)scanf("%d",&niz[i]);
   scanf("%d",&m);
   for(i=0;i<m;i++){
      scanf("%d%d",&Q[i].A,&Q[i].B);
      Q[i].idx = i;
   }
   sort( Q , Q + m , cmp );
   int poz = 0;
   for(i=0;i<m;i++){
      for( ; poz < Q[i].B ; poz++ ){
         if( occurence[ niz[poz] ] != -1 )
            update( occurence[ niz[poz] ] , -1 );
         occurence[ niz[poz] ] = poz+1;
         update( occurence[ niz[poz] ] , 1 );
      }
      sols[ Q[i].idx ] = read( Q[i].A , Q[i].B );
   }
   for(i=0;i<m;i++)
      printf("%d\n",sols[i]);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<math.h>
#include<fstream>
#include<vector>
using namespace std;

int main(){
   int sum,last;
   int i,si;
   string n;
   while(cin>>n){
      si = n.size();
      if( si==1 && n[0]=='0'){ printf("0\n");continue; }
      reverse(n.begin(),n.end());
      last = 0;
      for(i=0;i<si;i++){
         sum = (n[i]-'0')*2 + last;
         n[i] = (sum%10) +'0';
         last = sum/10;
      }
      while(last){
         n = n + char( last%10 + '0' );
         last/=10;
      }
      last = 2;
      si = n.size();
      for(i=0;i<si;i++){
         sum = (n[i]-'0')-last;
         if( sum<0 ) sum+=10, last = 1;
         else last = 0;
         n[i] = sum + '0';
      }
      reverse(n.begin(),n.end());
      i = 0;
      while( n[i]=='0' )i++;
      if( i==si ){printf("1\n");continue;}
      for(;i<si;i++)
         printf("%c",n[i]);printf("\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<math.h>
#include<vector>
#include<stack>
using namespace std;

template <class item>
void read_num( item &v ){
   char c;
   while( (c=getchar())<'0' || c>'9');
   v = c-'0';
   while( (c=getchar())>='0' && c<='9')v = v*10 + (c-'0');
}

const int MOD = 1000000000;
int A[11][11];
long long B[11][11];
int Bp[11][11];
long long Bn[11][11];

int main(){
   //freopen("Ulaz.txt","r",stdin);
   //freopen("Izlaz.txt","w",stdout);
   int t,tests,n,i,j,k,s;
   read_num(tests);
   for( t=0;t<tests;t++){
      memset(B,0,sizeof(B));
      memset(Bp,0,sizeof(Bp));
      read_num(n);
      for( i=0;i<n;i++)read_num( A[0][i] );
      for( i=0;i<n;i++){ read_num( B[n-1-i][n-1] ); Bp[n-1-i][n-1] = B[n-1-i][n-1]; }
      for( i=0;i<n-1;i++)Bp[n-i-1][n-i-2] = B[n-i-1][n-i-2] = 1;
      read_num(s);
      if( s <= n ){printf("%d\n",A[0][s-1]);continue;}
      int power = s-n;
      stack<int>S;
      while( power!=1 ){
         if( power&1 ){
            S.push(1);
            power--;
         }else{
            S.push(2);
            power/=2;
         }
      }
      while( S.empty() == false ){
         s = S.top(); S.pop();
         if( s==1 ){
            for( i=0;i<n;i++)
               for(j=0;j<n;j++)
                  for(k=0;k<n;k++)
                     Bn[i][k] = (Bn[i][k]+B[i][j]*Bp[j][k])%MOD;
            for( i=0;i<n;i++){
               for(j=0;j<n;j++){
                  B[i][j] = Bn[i][j];
                  Bn[i][j] = 0;
               }
            }
         }else{
            for( i=0;i<n;i++)
               for(j=0;j<n;j++)
                  for(k=0;k<n;k++)
                     Bn[i][k] = (Bn[i][k]+B[i][j]*B[j][k])%MOD;
            for( i=0;i<n;i++){
               for(j=0;j<n;j++){
                  B[i][j] = Bn[i][j];
                  Bn[i][j] = 0;
               }
            }
         }
      }
          for( i=0;i<n;i++)
            for(j=0;j<n;j++)
              for(k=0;k<n;k++)
                  Bn[i][k] = (Bn[i][k] + A[i][j]*B[j][k])%MOD;  
      printf("%d\n",Bn[0][n-1]);
      for(i=0;i<n;i++)
         for(j=0;j<n;j++)
            Bn[i][j] = 0;
      
   }
   return 0;
}

#include<iostream>
#include<fstream>
#include<cstdio>
using namespace std;

int DP[100];int poz;

int main(){
   int tests,a,b;
   scanf("%d",&tests);
   for( int t =0 ; t < tests;t++ ){
      scanf("%d%d",&a,&b);
      int digi = a%10;
      poz = 0;

      do{
         DP[poz++]=digi;

         digi = ((a%10)*digi)%10;
      }while( digi != a%10 );
      if( b== 0 )printf("1\n");
      else
         printf("%d\n",DP[ (b-1)%poz ]);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<map>
using namespace std;


map<int , long long>M;

long long rek( long long n ){
   if(n==0)return 0;
   if( M[n]!=0 )return M[n];
   return M[n] = max(n,(rek(n/2)+rek(n/3)+rek(n/4)) );
}

int main(){
   long long n;
   while( cin>>n ){
      M.clear();
      M[0] = 0 , M[1] = 1, M[2] = 2 , M[3] = 3 , M[4] = 4;
      cout<<rek(n)<<endl;
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<math.h>
#include<fstream>
#include<set>
#include<math.h>
using namespace std;

struct node{
   bool HasRight , HasLeft;
   long long deep;
   node( bool p1, bool p2 , long long p3 ):HasRight(p1),HasLeft(p2),deep(p3){};
   node(){};
};

long long sol = 0;
set<int>::iterator lo;
set<int>::iterator hi;
set<int>vals;
node tree[300001];

void insertIn( set<int>::iterator it , int val , bool left ){
   sol += tree[ *it ].deep + 1;
   if( left ) tree[ *it ].HasLeft = true;
   else tree[ *it ].HasRight = true;
   tree[ val ].deep = tree[ *it ].deep + 1ll;
   vals.insert(val);
}

inline void Read( int &v ){
   char c;
   v  = 0;
   while( ( c = getchar() )< '0' || c>'9' );
   do{
      v = (v*10) + (c-'0');
   }while( ( c= getchar() )>='0' && c<='9' );
}

int main(){
   int n,x,i,j;
   Read(n);Read(x);
   vals.insert(x);
   tree[x] = node( false , false , 0 );
   printf("0\n");
   for( i=0;i<n-1;i++){
      Read(x);
      hi = vals.upper_bound(x);
      if( hi == vals.begin() ){    
         insertIn( hi , x , true );
         printf("%lld\n",sol);
         continue;
      }
      hi--; lo = hi; hi++;
      if( hi == vals.end() ){
         insertIn( lo , x , false );
         printf("%lld\n",sol);
         continue;
      }
      if( tree[ *hi ].HasLeft == true && tree[ *hi ].HasRight == true ){
         insertIn( lo , x , false );
         printf("%lld\n",sol);
         continue;
      }
      if( tree[ *lo ].HasLeft == true && tree[ *lo ].HasRight == true ){
         insertIn( hi , x , true );
         printf("%lld\n",sol);
         continue;
      }
      if( tree[*lo].HasRight == false && tree[ *lo ].deep < tree[ *hi ].deep )
         insertIn( lo , x , false );
      else if( tree[*hi].HasLeft == false )
         insertIn( hi , x , true );
      else if( tree[ *lo ].HasRight == false )
         insertIn( lo , x , false );
      printf("%lld\n",sol);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
using namespace std;

int len;
char str[100000];

int GetMin( int lo , int hi ){
   if( lo==hi ) return lo;
   
   int mid = (lo+hi)/2;
   int L = GetMin(lo,mid);
   int R = GetMin(mid+1,hi);
   for( int i=0; L+i<R ;i++)
      if( str[(L+i)%len]<str[(R+i)%len] )return L;
      else if( str[(L+i)%len]>str[(R+i)%len] )return R;
   return L;
}

int main(){
   scanf("%s",str);
   len = strlen(str);
   printf("%d\n",GetMin(0,len));
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<math.h>
#include<cstdlib>
using namespace std;

double KGtoLB = 2.2046;
double LBtoKG = 0.4536;
double LtoG   = 0.2642;
double GtoL   = 3.7854;

char comm[5];

int main(){
   int n,i;
   float v;
   scanf("%d",&n);
   for( i=1;i<=n;i++){
      scanf("%f %s",&v,comm);
      if( strcmp(comm,"kg")==0)
         printf("%d %.4f lb\n",i,v*KGtoLB);
         
      else if( strcmp(comm,"lb")==0)
         printf("%d %.4f kg\n",i,v*LBtoKG);
         
      else if( strcmp(comm,"l")==0)
         printf("%d %.4f g\n",i,v*LtoG);
         
      else if( strcmp(comm,"g")==0)
         printf("%d %.4f l\n",i,v*GtoL);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
using namespace std;

struct trie{
   trie *e[28];
   int F;
   trie():F(-1){
      for(int i=0;i<28;i++)e[i]=NULL; 
   }
};

vector<string>V;int poz=0;
trie *drvo = new trie();
string buff,res;
bool found;

void SetOnTrie(trie *node,int p){
   int s; cout << p << endl;;
   if( node->F == -1 )node->F = poz;
   if(p!=-1)s = V[poz][p]-'a';
   if( p == -1 ){
      node->e[27] = new trie();
      return;
   }
   if( node->e[s] == NULL ){
      node->e[s] = new trie;
   }
   SetOnTrie( node->e[s] , p-1 );
}


void Check( trie *node  , int p  , string suffix ){
   int s;
   if(p!=-1)s = buff[p]-'a';
   else s = -1;
   if( p>-1 && node->e[s]!=NULL )Check( node->e[s] , p-1 , buff[p] + suffix );
   
   cout << suffix << endl;
   
   bool dalje2 = false;
   if( found == false )
      for(int i=0;i<27;i++){
         if( s!=i && node->e[i]!=NULL ){
            if( res > V[ node->e[i]->F ] ){
               res =    V[ node->e[i]->F ] ; 
            }
            found = true;
            dalje2 = true;
         }
      }
   if( (found==false || dalje2==true ) && node->e[27]!=NULL && p>-1 ){
      res = min(suffix,res);
      found = true;
   }
}

int main(){
//    freopen("Ulaz.txt","r",stdin);
//    freopen("Izlaz.txt","w",stdout);
   char c;
   while(1){
      c = getchar();
      if( c!='\n'){
         buff = buff + c;
      }else{
         V.push_back(buff);
         buff = "";
         c = getchar();
         if(c=='\n')break;
         buff = buff + c;
      }
   }
   sort(V.begin(),V.end());
   for(int i=0;i<V.size();i++){
      poz =i;
      cout << V[i] << endl;
      SetOnTrie(drvo , V[i].size()-1 );
      system("Pause");
   }
   while(1){
      c = getchar();
      if( c!='\n'){
         buff =  buff + c;
      }else{ 
         res = "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz" , found = false;
         Check(drvo,buff.size()-1,"");
         printf("%s\n",res.c_str());
         buff = "";
         if(c==EOF)break;
         c = getchar();
         if(c=='\n' || c==EOF)break;
         buff = buff + c;
      }
   }
   
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<cstdio>
#include<cstdlib>
using namespace std;

const int MAXC = 10000001;

int bsearch( int lo , int hi , long long val ){
   while ( lo<= hi ){
      int mid = (lo+hi)/2;
      long long SUM = mid*(mid+1ll)/2;
      long long SUMprev = mid*(mid-1ll)/2;
      if( SUMprev < val && SUM >= val )return mid;
      else if( SUM > val )hi = mid-1;
      else lo = mid+1;
   }
   return -1;
}

int main(){
   int n,a,idx;
   scanf("%d",&n);
   for(int i=0;i<n;i++){
      scanf("%d",&a);
      idx = bsearch( 0 , MAXC , a );
      long long PASSED = idx*(idx-1ll)/2;
      if( idx % 2 == 1 ){
         cout<<"TERM "<<a<<" IS "<<idx-(a-PASSED)+1<<"/"<<a-PASSED<<endl;
      }else{
         cout<<"TERM "<<a<<" IS "<<a-PASSED<<"/"<<idx-(a-PASSED)+1<<endl;
      }
   }
   return 0;
}

#include<iostream>
#include<vector>
#include<math.h>
#include<cstdlib>
#include<iomanip>
using namespace std;

const int NewBasis = 8;
const int PLACES   = 100000000;
char num1[10001];
char num2[10001];

unsigned long long B1[1500];
unsigned long long B2[1500];
unsigned long long R[3000];

int main(){
   int t,p,i,j;
   scanf("%d",&t);
   for( p=0;p<t;p++){
      scanf("%s %s",num1,num2);
      int poz=-1;
      memset(B1,0,sizeof(B1));
      memset(B2,0,sizeof(B2));
      memset(R,0,sizeof(R));
      int s1 = strlen(num1);
      int s2 = strlen(num2);
      int fak= 1;
      for(i=0;i<s1;i++){
         if( i%NewBasis==0 ){poz++;fak=1;}
         B1[poz] = B1[poz] + (num1[s1-i-1]-'0')*fak;
         fak*=10;
      }
      int NewSize1 = poz+1;
      fak= 1;
      poz = -1;
      for(i=0;i<s2;i++){
         if( i%NewBasis==0 ){poz++;fak=1;}
         B2[poz] = B2[poz] + (num2[s2-i-1]-'0')*fak;
         fak*=10;
      }
      int NewSize2 = poz+1;
      
      for(i=0;i<NewSize1;i++){
         for(j=0;j<NewSize2;j++){
            R[i+j] += B1[i]*B2[j];
         }
      }
      int NS = NewSize1+NewSize2-1;
      for(i=0;i<NS;i++){
         if( i==NS-1 && R[i]>=PLACES )NS++;
         R[i+1] += R[i]/PLACES ,   R[i] = R[i]%PLACES;
      }
      unsigned long long test;
      int digi;
      printf("%d",R[NS-1]);
      for(i=NS-2;i>=0;i--){
         test = R[i];
         digi = 0;
         while(test)
            test/=10,digi++;
         for(j=0;j<8-digi;j++)printf("0");
         printf("%d",R[i]);
         
      }printf("\n");
      
   }
   return 0;
}

#include<iostream>
#include<math.h>
#include<cstdio>
#include<set>
#include<math.h>
using namespace std;

const int NMAX = 210;
int coord[NMAX+1][2];
int N;

int main(){
   
   int i,j;
   while(1){
      scanf("%d",&N);
      if(N==0)break;
      double M;
      double b;
      set<double>S;
      for( i=0;i<N;i++){
         scanf("%d%d",&coord[i][0],&coord[i][1]);
         for(j=0;j<i;j++){
            if( coord[i][0] != coord[j][0] )
               M = 1.f * ( coord[i][1] - coord[j][1] ) / ( coord[i][0] - coord[j][0] );
            else M = 999999999;
            S.insert( M );
         }
      }
      cout<<S.size()<<endl;
   }
   return 0;
}

#include<iostream>
#include<cstdio>
using namespace std;

const int MAXN = 30000;
const int MAXQ = 200000;

int n,m;
int tree[MAXN+5];
int niz[MAXN+5];
int decr[MAXN+5];

int event[MAXQ+5][4];
int eventD[MAXQ+5];
int solutions[MAXQ+5];


bool cmp( int a, int b ){
   return niz[a] > niz[b];
}
bool cmp2( int a, int b ){
   return event[a][2] > event[b][2];
}

void update( int idx , int val ){
   for( ; idx <= n ; idx += idx&-idx)tree[idx]+=val;
}

int query( int idx ){
   int sum =0;
   for( ; idx>0 ; idx -= idx&-idx)sum+=tree[idx];
   return sum;
}

int main(){
   int i,j;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d",&niz[i]);
      decr[i] = i;
   }
   sort( decr , decr + n , cmp );
   scanf("%d",&m);
   for(i=0;i<m;++i){
      scanf("%d%d%d",&event[i][0],&event[i][1],&event[i][2]);
      eventD[i]=i;
   }
   sort( eventD , eventD+m , cmp2 ); // OVO JE SUMLJIVO //

   j=0;
   for( i =0 ;i<m;i++) {
      for( ; j<n && niz[ decr[j] ] > event[ eventD[i] ][2] ; j++ ) update( decr[j]+1 , 1 );
      solutions [ eventD[i] ] = query( event[ eventD[i] ][1] ) - query( event[ eventD[i] ][0]-1 );
   }
   for( i=0;i<m;i++)printf("%d\n",solutions[i]);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;


int main()
{
   int n;
   scanf("%d",&n);
   if (n%10) printf("1\n%d\n",n%10);
   else printf("2\n");
   return 0;
}

#include<iostream>
#include<vector>
#include<algorithm>
#include<fstream>
#include<iomanip>
using namespace std;

const int MAXN = 100006;

vector<int>graph[MAXN];
vector<int>lvls[MAXN];
int lvl[MAXN];
int father[MAXN];
bool visited[MAXN];

bool IsInSet[MAXN];
int sol(0);

void DFS( int node ){
   visited[node] = true;
   for(int i=0;i<graph[node].size();i++){
      if( visited[ graph[node][i] ] == false ){
         father[ graph[node][i] ] = node;
         lvl[ graph[node][i] ] = lvl[ node ] + 1;
         lvls[ lvl[node]+1 ].push_back( graph[node][i] );
         DFS( graph[node][i] );
      }
   }
}

int main(){
   int n,a,b;
   scanf("%d",&n);
   for(int i=0;i<n-1;i++){
      scanf("%d%d",&a,&b);
      graph[a].push_back(b);
      graph[b].push_back(a);
   }
   lvl[1] = 0;
   DFS(1);
   for( int j = 100000;j>=0;j-- ){
       for( int i=0;i<lvls[j].size();i++){
          if( IsInSet[ lvls[j][i] ] || IsInSet[ father[ lvls[j][i] ] ] )continue;
          IsInSet [ father[ lvls[j][i] ] ] = true;
          sol++;
       }
   }
   cout<<sol<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
#include<math.h>
#include<iomanip>
#include<algorithm>
using namespace std;

const int MAXL = 30;
const int MAXC = 25;
char str[MAXL+5];
int CountChars[MAXC+5];
int len;
unsigned long long GetPermutations(){
   int i,j,k,g;
   int *up = new int[MAXL+4];
   int *lo = new int[MAXL+4];
   for(i=0;i<len;i++)
      up[i]=i+1;
   k=0;
   for(i=0;i<=MAXC;i++)
      for(j=0;j<CountChars[i];j++)
         lo[k++]=j+1;
   for(i=0;i<len;i++){
      for(j=0;j<len;j++){
         g = __gcd(lo[i],up[j]);
         lo[i] /= g;
         up[j] /= g;
         if( lo[i]==1 )break;
      }
   }
   unsigned long long UF = 1 , LF = 1;
   for( i=0;i<len;i++)
      UF *= up[i] , LF *= lo[i];
   return (UF/LF);
}

int main(){
   int i,j;
   //freopen("Ulaz.txt","r",stdin);
//   freopen("Izlaz.txt","w",stdout);
   while(1){
      memset(CountChars,0,sizeof(CountChars) );
      gets(str);
      if( strcmp(str,"#")==0 )break;
     // if( str[0]=='\0' ){ printf("\n");continue; }
      len = strlen(str);
      for(i=0;i<len;i++)CountChars[ str[i]-'a' ]++;
      
      unsigned long long sol = 0;
      unsigned long long GP;
      for(i=0;i<strlen(str);i++){
         for(j=0;j<str[i]-'a';j++){
            if( CountChars[j] > 0 ){
               CountChars[j]--;
               len--;
               GP = GetPermutations();
               len++;
               CountChars[j]++;
               sol+=GP;
            }
         }
         len--;
         CountChars[ str[i]-'a' ] --;
      }
      cout<<setw(10)<<sol+1<<endl;
   }
  // system("pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<vector>
#include<iomanip>
using namespace std;

const int MAXS = 1024;
int values[MAXS+5][MAXS+5];
int BIT[MAXS+5][MAXS+5];

void update( int x, int y , int v ){
   for( ; x<= MAXS ; x+=x&-x)
      for( int i=y;i<=MAXS;i+=i&-i)
         BIT[x][i] += v;
}


int query( int x , int y ){
   int ret = 0;
   for( ;x>=1;x-=x&-x)
      for( int i = y;i>=1;i-=i&-i)
         ret += BIT[x][i];
   return ret;
}

int main(){
   int tmp,S,x1,y1,x2,y2,val;
   scanf("%d%d",&tmp,&S);
   while(1){
      scanf("%d",&tmp);
      if( tmp == 1 ){
         scanf("%d%d%d",&x1,&y1,&val);
         x1++;y1++;
         int t = values[x1][y1];
         update( x1,y1,-values[x1][y1]);
         val += t;
         update( x1,y1,val );
         values[x1][y1] = val;
      }else if( tmp == 2 ){
         scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
         x1++;y1++;x2++;y2++;
         tmp = query(x2,y2) - query(x1-1,y2) - query(x2,y1-1) + query(x1-1,y1-1);
         printf("%d\n",tmp);
      }else
         break;
   }
   return 0;
}

#include<cstdio>
#define x P[i][j]
#define r(z) scanf("%d",&z)
#define g P[i-1][j-1]+v
int P[150][150],t,n,v,s,i,j;main(){r(t);while(t--){r(n);s=0;for(i=1;i<=n;i++)for(j=1;j<=i;j++){r(v);x=P[i-1][j]+v;x=x>g?x:g;s=s>x?s:x;}printf("%d\n",s);}}

#include<iostream>
#include<algorithm>
#include<vector>
#include<math.h>
#include<cstdlib>
#include<fstream>
using namespace std;

struct duo{
   int a,b;
   duo( int p1 ,int p2 ):a(p1),b(p2){};
   duo(){};
   bool operator<( const duo &t2 ) const {
      return a>t2.a;
   }
};

int main(){
   int tests,v;
   scanf("%d",&tests);
   for( ; tests > 0  ; tests -- ){
      vector<duo>V;
      int n,m;
      scanf("%d%d",&n,&m);
      for( int i = 0 ; i< n-1 ; i++) {
         scanf("%d",&v);
         V.push_back( duo(v,true) );
      }
      for( int i = 0 ; i< m-1 ; i++) {
         scanf("%d",&v);
         V.push_back( duo(v,false) );
      }
      int AreTrue = 1;
      int AreFalse= 1;
      int sol  = 0;
      sort(V.begin(),V.end());
      for( int i =0  ; i <V.size();i++) {
         if( V[i].b == true ){
            AreTrue++;
            sol += AreFalse * V[i].a;
         }else{
            AreFalse++;
            sol += AreTrue * V[i].a;
         }
      } 
      printf("%d\n",sol);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<math.h>
#include<cstdlib>
#include<algorithm>
using namespace std;

int DP[100005];
bool IsBroken[100005];
const int MOD = 14062008;

int main(){
   int n,k,i,j,tmp;
   scanf("%d%d",&n,&k);
   for(i=0;i<k;i++){
      scanf("%d",&tmp);
      IsBroken[tmp] = true;
   }
   DP[1] = 1;
   for(i=1;i<=n;i++){
      if( IsBroken[i+1] == false )
         DP[i+1] = (DP[i]+DP[i+1])%MOD;
      if( IsBroken[i+2] == false )
         DP[i+2] = (DP[i+2]+DP[i])%MOD;
   }
   printf("%d\n",DP[n]);
      
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<fstream>
#include<math.h>
using namespace std;

int n,k;
const int inf = (int)1e9;
int barns[100001];

bool IsOk(int dist){
   int last = -inf,count(0);
   for(int i=0;i<n && count!=k;i++){
      if( barns[i]-last >= dist ){
         count++;
         last = barns[i];
      }
   }
   return (count==k);
}

int main(){
   int tests,i,j;
   scanf("%d",&tests);
   while(tests--){
      scanf("%d%d",&n,&k);
      for(i=0;i<n;i++)scanf("%d",&barns[i]);
      sort(barns, barns+n );
      int lo = barns[0] , hi = barns[n-1] , mid;
      int sol = inf;
      while(lo<=hi){
         mid = (lo+hi)>>1;
         if( IsOk(mid) ){
            sol = mid;
            lo = mid + 1;
         }else
            hi = mid - 1;
      }
      printf("%d\n",sol);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
using namespace std;

int main(){
   int n;
   long long sol = 0;
   scanf("%d",&n);
   for( int i =1 ; i <=n; i++ ){
      sol = sol + i*i;
   }
   cout<<sol<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<algorithm>
#include<math.h>
using namespace std;

struct edge{
   int B,dist;
   edge( int p1 ,int p2):B(p1),dist(p2){};
   edge(){};
};

const int MAXN  = 100000;
const int MAXLG = 17;
const int inf   = 9999999;
int N,K;
int lvl[MAXN+5];
int father[MAXN+5] , distF[MAXN+5];
bool visited[MAXN+5];
int DP[MAXN+5][MAXLG+2][3];
vector<edge>graph[MAXN+5];

void DFS( int node , int deep ){
   visited[node] = true;
   lvl[node] = deep;
   for( int i = 0 ;  i<graph[node].size(); i++) {
      if( visited[ graph[node][i].B ] == false ){
         father[ graph[node][i].B ] = node;
         distF[ graph[node][i].B ] = graph[node][i].dist;
         DFS( graph[node][i].B , deep+1 );
      }
   }
}

void CONSTRUCT(){
   int i,j;
   memset(DP,-1,sizeof(DP));
   for(i=1;i<=N;i++){
      DP[i][0][0] = father[i];
      DP[i][0][1] = distF[i];
      DP[i][0][2] = distF[i];
   }
   for(i=1;i<=MAXLG;i++){
      for(j=1;j<=N;j++){
         if( DP[j][i-1][0]!=-1 ){
            DP[j][i][0] = DP[ DP[j][i-1][0] ][i-1][0];
            DP[j][i][1] = min(DP[j][i-1][1],DP[ DP[j][i-1][0] ][i-1][1] );
            DP[j][i][2] = max(DP[j][i-1][2],DP[ DP[j][i-1][0] ][i-1][2] );
         }
      }
   }
}

int GET_ANCESTOR( int p , int q ){
   int i;
   if( lvl[p] < lvl[q] )swap(p,q);
   for(i=MAXLG;i>=0;i--)
      if( DP[p][i][0]!=-1 && lvl[ DP[p][i][0] ]>= lvl[q] )
         p = DP[p][i][0];
   for(i=MAXLG;i>=0;i--)
      if( DP[p][i][0]!= DP[q][i][0] )
         p = DP[p][i][0] , q = DP[q][i][0];
   if( p==q )return p;
   return father[p];
}

int mini , maxi;
void query( int p , int q ){
   mini = inf;
   maxi = -inf;
   int A = GET_ANCESTOR(p,q);
   for(int i=MAXLG;i>=0;i--){
      if( DP[p][i][0]!=-1 && lvl[ DP[p][i][0] ]>=lvl[A] ){
         mini = min( mini , DP[p][i][1] );
         maxi = max( maxi , DP[p][i][2] );
         p = DP[p][i][0];
      }
      if( DP[q][i][0]!=-1 && lvl[ DP[q][i][0] ]>=lvl[A] ){
         mini = min( mini , DP[q][i][1] );
         maxi = max( maxi , DP[q][i][2] );
         q = DP[q][i][0];
      }
   }
}

void read( int &v ){
   char c;
   while( (c=getchar())<'0' || c>'9' );
   v = c-'0';
   while( (c=getchar())>='0' && c<='9' ) v = (v*10)+(c-'0');
}

int main(){
   int i,j,a,b,c;
   read(N);
   for(i=0;i<N-1;i++){
       read(a);read(b);read(c);
       graph[a].push_back( edge(b,c) );
       graph[b].push_back( edge(a,c) );
   }
   father[1] = -1;
   DFS(1,0);
   CONSTRUCT();
   read(K);
   for(i=0;i<K;i++){
      read(a);read(b);
      query(a,b);
      printf("%d %d\n",mini,maxi);
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<vector>
#include<math.h>
#include<vector>
#include<stack>
using namespace std;

int out[300];
int in[300];
char str[1004];
int ab[100004][2];
bool visited[30];
vector<int>graph[30];

bool was[30];

int main(){
   int T,n,i,u;
   scanf("%d",&T);
   while(T--){
      scanf("%d",&n);
      memset( out, 0, sizeof( out ) );
      memset( in, 0, sizeof( in ) );
      memset( was, 0,sizeof(was) );
      memset( visited , 0 , sizeof( visited ) );
      for( i =0 ; i < 30 ; i ++ )graph[i].clear();
      
      int CountNodes = 0;
      for( i = 0 ; i < n ; i ++ ){
         scanf("%s",str);
         ab[i][0] = str[0]-'a';
         ab[i][1] = str[ strlen(str)-1 ]-'a';
         
         if( ab[i][0]!=ab[i][1])CountNodes += !was[ ab[i][1] ] + !was[ ab[i][0] ];
         else CountNodes += !was[ ab[i][1] ];
         was[ ab[i][1] ] = was[ ab[i][0] ] = true;
         in[ ab[i][1] ]++;
         out[ab[i][0] ]++;
         graph[ ab[i][0] ].push_back( ab[i][1] );
      }
      int start = -1 , end = -1 , even = 0;
      for( i =0 ; i < 26 ; i ++ ){
         if( out[i] == in[i] +1 )
            start = i;
         if( out[i]+1==in[i] )
            end = i;
         if( out[i] != in[i] )
            even++;
      }
      if( even>2 || even==1 && (start==-1 || end==-1 ) || even==2 &&  (start==-1 || end==-1 )  ){
         printf("The door cannot be opened.\n");
         continue;
      }
      if( start==-1 ) start = 0;
      stack<int>S;
      visited[ start ] = true;
      S.push(start);
      int count = 1;
      while(S.empty()==false ){
         u = S.top();S.pop();
         for( i=0;i<graph[u].size();i++){
            if( visited[graph[u][i]]==false ){
               count++;
               visited[graph[u][i]]=true;
               S.push( graph[u][i] );
            }
         }
      };
      if( count == CountNodes ){
         printf("Ordering is possible.\n");
      }else{
         printf("The door cannot be opened.\n");
      }
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
#include<algorithm>
using namespace std;

struct duo{
   int v1,v2,idx;
   duo(int p1,int p2):v1(p1),v2(p2){};
   duo(){};
   bool operator<( const duo &d2 )const{
      return (v1<d2.v1 || (v1==d2.v1 && v2<d2.v2) );
   }
}rating[300005];

const int MAXVAL = 100001;
int sol[300005];
int bit[100006];

inline void update( int idx , int val=1 ){
   for( ;idx<=MAXVAL;idx+=(idx&-idx))
      bit[idx] += val;
}
inline int read( int idx ){
   int ret = 0;
   for( ;idx>=1;idx-=(idx&-idx))
      ret += bit[idx];
   return ret;
}

int bsearch( int lo , int hi , int v ){
   int gl = lo , mid , ret = 0;
   while(lo<=hi){
      mid = (lo+hi)>>1;
      if( rating[mid].v2 < v ){
         ret = mid-gl+1;
         lo = mid+1;
      }else
         hi = mid-1;
   }
   return ret;
}

inline void read_int( int &v ){
   char c;
   while( (c=getchar())<'0' || c>'9' );
   v = c-'0';
   while( (c=getchar())>='0' && c<='9' )
      v = (v*10)+(c-'0');
}

int main(){
   int n,i,j;
   read_int(n);
   for(i=0;i<n;i++){
      read_int(rating[i].v1); read_int(rating[i].v2);
      rating[i].idx = i;
   }
   sort( rating , rating+n);
   int lo_bound=0;
   for(i=0;i<n;i++){
      if( i>0 && rating[i].v1 != rating[i-1].v1 ){
         lo_bound = i;
         j = i;
         do{
            j--;
            update( rating[j].v2 );
         }while( rating[j].v1 == rating[j-1].v1 );
      }
      sol[ rating[i].idx ] = read( rating[i].v2 ) + bsearch(lo_bound,i,rating[i].v2);
   }
   for(i=0;i<n;i++)
      printf("%d\n",sol[i]);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<string>
#include<vector>
using namespace std;

int N,MaxIdx;
char text[25000][30];
char *sorted[25000];

bool cmp( char *a , char *b ){
   int to = min( strlen(a), strlen(b) );
   for( int i=0;i<to;i++){
      if( a[i] != b[i] ){
         if( a[i] == text[MaxIdx][i] )return false;
         else if( b[i] == text[MaxIdx][i] )return true;
         else return a[i] < b[i];
      }
   }
   return strlen(a) < strlen(b);
}

int main(){
   int i,j,k;
   scanf("%d",&N);
   for(i=0;i<N;i++){
      scanf("%s",text[i]);
      MaxIdx = strlen(text[MaxIdx])<strlen(text[i]) ? i : MaxIdx;
      sorted[i] = text[i];
   }
   vector<char>sol;
   sort( sorted , sorted+N , cmp );
   for(i=0;i<N;i++){
      int PrevLen = i>0 ? strlen(sorted[i-1]) : 0;
      int NowLen  = strlen(sorted[i]);
      int To = min(PrevLen,NowLen);
      for(j=0;j<To;j++) if( sorted[i][j] != sorted[i-1][j] )break;
      for(k=j;k<PrevLen;k++)sol.push_back('-');
      for(k=j;k<NowLen;k++)sol.push_back(sorted[i][k]);
      sol.push_back('P');
   }
   for(i=0;i<sol.size();i++)printf("%c\n",sol[i]);
   return 0;
}

#include<iostream>
#include<algorithm>
#include<vector>
#include<stack>
#include<iomanip>
using namespace std;


;int pz=0;

bool isdigit(char c ){
   return (c>='0' && c<='9');
}

   int v = 0,j;
   char c;
   int resL =  0 , resR = 0;
   bool MINUS = false;
   bool LastMinus = false;
   bool Lside = true;
   stack<bool>S;
   
void TakeValue(){
   v = v * ( LastMinus==true ? -1 : 1 );
   v = v * ( MINUS==true ? -1 : 1 );
   if( Lside )
      resL += v;
   else
      resR += v;
   v = 0;
}


int main(){
  // freopen("Ulaz.txt","r",stdin);
  // freopen("Izlaz.txt","w",stdout);
   
   bool IsLeft;
   bool IsMinus;
   
   while( ( c=getchar())!=EOF && c!='\n' ){
      if( isdigit(c) ){
         v = (v*10)+(c-'0');
      }else if( c=='-' || c=='+' ){
         TakeValue();
         LastMinus = c=='-' ? true : false;
      }else if( c=='(' ){
         S.push( LastMinus );
         if( LastMinus == true )
            MINUS = !MINUS;
         LastMinus = false;
      }else if( c==')' ){
         TakeValue();
         if( S.top() == true )
            MINUS = !MINUS;
         S.pop();
         LastMinus = false;
      }else if( c=='=' ){
         TakeValue();
         Lside = false;
         LastMinus = false;
      }else if( c=='?' ){
         IsLeft = Lside;
         IsMinus = LastMinus;
         if( MINUS )
            IsMinus = !IsMinus;
         LastMinus = false;
      }
   }TakeValue();
   int res = 0;
   if( IsLeft ){
      if( IsMinus ){
         res = resL - resR;
      }else{
         res = resR - resL;
      }
   }else{
      if( IsMinus ){
         res = resR - resL;
      }else{
         res = resL - resR;
      }
   }
   cout<<res<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
#include<iomanip>
using namespace std;

long long inf = 1000000000;
unsigned long long DP[700][700];
char field[700][700];


int main(){ inf *= 10;
   int r,c,k,i,j;
   scanf("%d%d%d",&r,&c,&k);
   for(i=0;i<r;i++)
      scanf("%s",field[i]);
   DP[r-1][c-1]=1;
   for(i=c-1;i>=0;i--){
      for(j=r-1;j>=0;j--){
         if( (i!=c-1 || j!=r-1) && field[j][i]=='.' ){
            DP[j][i] = DP[j+1][i] + DP[j][i+1];
            if( DP[i][j]>=inf )DP[i][j]=inf;
         }
      }
   }
   int x(0),y(0);
   string res = "";
   while( x!=c-1 || y!=r-1 ){
      if( y<r-1 && field[y+1][x]=='.' && DP[y+1][x]>=k ){
         y++;
         res += "D";
      }else if( x<c-1 && field[y][x+1]=='.' ){
         k -= DP[y+1][x];
         res += "R";
         x++;
      }else
         break;
   }
   if( k!=1 || x!=c-1 || y!=r-1 || field[0][0]=='#'){
      printf("impossible\n");
   }else
      printf("%s\n",res.c_str());
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
#include<algorithm>
#include<set>
#include<iomanip>
using namespace std;

int N,M,K;
const int MOD = 1000007;
const int MAXN = 50;
const int MAXM = 10;
bool config[380][MAXM+10]; int size(0);
int Ckings[380];

void GetConfig( int idx , int ks ){
   if( idx >= M ){
      memcpy( config[size+1] , config[size] , sizeof(bool)*M+5 );
      Ckings[size] = ks;
      size++;
      return;
   }
   GetConfig( idx+1 , ks );
   if( ks<K ){
      config[size][ idx ] = true;
      GetConfig( idx + 2 , ks+1 );
      config[size][ idx ] = false;
   }
}

vector<int>Together[200];
long long DP[MAXN+20][180][10];


long long solve( int idx , int ID , int have ){
   if( have > K )return 0;
   if( DP[idx][ID][have] != -1 )return DP[idx][ID][have];
   if( K == have )return (DP[idx][ID][have]=1);
   if( idx>=N-1 )return (DP[idx][ID][have]=0);
   
   long long sol = 0;
   for( int i=0;i<Together[ID].size();i++){
      sol = (sol+solve(idx+1, Together[ID][i] , have+Ckings[ Together[ID][i] ] ));
      if( sol>=MOD )sol-=MOD;
   }
   return (DP[idx][ID][have] = sol);
}

int main(){
   int i,j,k;
   cin>>N>>M>>K;
   GetConfig(0,0);
   bool IsOk;
   for(i=0;i<size;i++){
      for(j=i+1;j<size;j++){
         IsOk = true;
         for(k=0;k<M && IsOk;k++){
            if( config[i][k] == 1 ){
               if( config[j][k] == 1 )IsOk = false;
               if( k>0   && config[j][k-1] == 1 )IsOk = false;
               if( k<M-1 && config[j][k+1] == 1 )IsOk = false;
            }
         }
         if( IsOk ){ Together[i].push_back(j) ;
                     Together[j].push_back(i) ;
         }
      } 
   }
   Together[0].push_back(0);
   memset(DP,-1,sizeof(DP) );
   long long sol = 0;
   for(i=0;i<size;i++){
      sol = ( sol + solve( 0 , i , Ckings[i] ) );
      if( sol>=MOD )sol-=MOD;
   }
   cout<<sol<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
#include<cstdlib>
#include<map>
#include<ctime>
using namespace std;


int N,M;
int B;
bool coins[1030][1030];
int Sums[1030][1030];
map<long long,int>Mp;


inline int get_range( int x1,int y1,int x2,int y2 ){
   return  Sums[y2][x2]-Sums[y1-1][x2]-Sums[y2][x1-1] + Sums[y1-1][x1-1];
}

inline long long give_key( int x1 , int y1 , int x2, int y2 ){
   return x1*1000000000ll + y1*1000000ll + x2*1000ll + y2;
}

int calc( int x1, int y1 , int x2, int y2, int move ){
   long long key = give_key(x1,y1,x2,y2);
   if( move == N ){
      return (Mp[ key ] = get_range(x1,y1,x2,y2));
   }
   int v1 = calc( ((x1+x2)>>1)+1 , y1 , x2 , y2 , move+1 );
   int v2 = calc( x1 , y1 , (x1+x2)>>1 , y2 , move+1 );
   
   int h1 = calc( x1, ((y1+y2)>>1)+1 , x2 , y2 , move+1 );
   int h2 = calc( x1, y1 , x2 , (y1+y2)>>1 , move+1 );
   
   return (Mp[ key ] = min( max(v1,v2) , max(h1,h2) )  );
}

int get_val( int x1 , int y1 , int x2, int y2 ){
   long long k = give_key(x1,y1,x2,y2);
   return Mp[k];
}

char buff[10];

int main(){
    
   int x,y;
   scanf("%d%d",&N,&M);
   B = (int)pow(2,N);
   for( int i = 0; i < M ; i ++ ){
      scanf("%d%d",&x,&y);
      y = B-y+1;
      coins[y][x] = true;
   }
   int sumR;
   for( int i = 1 ; i <= B ; i ++ ){
      sumR = 0;
      for( int j = 1 ; j <= B ; j ++ ){
         sumR += coins[i][j];
         Sums[i][j] = sumR + Sums[i-1][j];
      } 
   }
   calc(1,1,B,B,0);
   int x1 = 1 ,y1 = 1 ,x2 = B ,y2 = B;
   int xt,yt;
   int v1,v2;
   for( int i =0  ; i< N ; i++ ){
      scanf("%s",&buff);
      if( buff[0] == 'v' ){
         xt = (x1+x2)>>1;
         v1 = get_val( x1,y1 , xt,y2 );
         v2 = get_val( xt+1,y1, x2,y2 );
         if( v1 > v2 ){
            printf("left\n");
            x2 = xt;
         }else{
            printf("right\n");
            x1 = xt+1;
         }
         fflush(stdout);
      }else{
         yt = (y1+y2)>>1;
         v1 = get_val( x1 , y1 , x2 , yt );
         v2 = get_val( x1 , yt+1, x2,y2 );
         if( v1 > v2 ){
            printf("up\n");
            y2 = yt;
         }else{
            printf("down\n");
            y1 = yt+1;
         }
         fflush(stdout);
      }
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
using namespace std;
 
const int MAXS = 35;
 
int    M [MAXS][MAXS];
long double SUM_ALL;
long double SUM_COL[MAXS];
long double SUM_ROW[MAXS];
long double LG[MAXS][MAXS];
 
int   MINUS_ALL;
int   MINUS_ROW[MAXS];
int   MINUS_COL[MAXS];
 

int   NULL_ALL;
int   NULL_ROW[MAXS];
int   NULL_COL[MAXS];
 
int main(){
   int H,W,i,j;
   scanf("%d%d",&H,&W);
   for( i=0;i<H;i++){
      for( j=0;j<W;j++){
         scanf("%d",&M[i][j] );
         if( M[i][j] < 0 ){
            MINUS_ROW[i]++ , MINUS_COL[j]++ , MINUS_ALL++;
            LG[i][j] = log(-M[i][j]);
            SUM_ALL+=LG[i][j];
            SUM_COL[j] += LG[i][j] , SUM_ROW[i] += LG[i][j];
         }else if( M[i][j]==1 ){
            LG[i][j] = 0.5;
            SUM_ALL+=LG[i][j];
            SUM_COL[j] += LG[i][j] , SUM_ROW[i]+=LG[i][j];
         }else if( M[i][j] != 0 ){
            LG[i][j] = log(M[i][j]);
            SUM_ALL+=LG[i][j];
            SUM_COL[j] += LG[i][j] , SUM_ROW[i] += LG[i][j];
         }else{
            NULL_ROW[i]++ , NULL_COL[j]++ , NULL_ALL++;
         }
      }
   }
   int k,l;
   long double RES = -1e9;
   long double TMP;
   int MI,n;
   int NU;
   int *SOL = new int[5];
   int *MAY = new int[5];
   SOL[0] = SOL[1] = SOL[2] = SOL[3] = 999999;

   for(i=0;i<H;i++){
      for(j=i+1;j<H;j++){
         for(k=0;k<W;k++){
            for(l=k+1;l<W;l++){
               TMP = SUM_ALL - SUM_ROW[i] - SUM_ROW[j] - SUM_COL[k] - SUM_COL[l] + LG[i][k] + LG[i][l] + LG[j][k] + LG[j][l];
               MI  = MINUS_ALL - MINUS_ROW[i] - MINUS_ROW[j] - MINUS_COL[k] - MINUS_COL[l];
               MI += ( M[i][k] < 0 ) + ( M[i][l] < 0 ) + ( M[j][k] < 0 ) + ( M[j][l] < 0 );
               
               NU  = NULL_ALL - NULL_ROW[i] - NULL_ROW[j] - NULL_COL[k] - NULL_COL[l];
               NU += ( M[i][k] == 0 ) + ( M[i][l] == 0 ) + ( M[j][k] == 0 ) + ( M[j][l] == 0 );
               
               if( NU > 0 )TMP = 0;
               else if( MI % 2 == 1 )TMP*=(-1);
              if( fabs(TMP-RES)<0.01 ){
                  MAY[0] = i , MAY[1] = j , MAY[2] = k , MAY[3] = l;
                  sort( MAY , MAY+4 );
                  bool IsSmaller = false;
                  for(n=0;n<4;n++) if( MAY[n] < SOL[n] ){IsSmaller = true ; break; }
                                   else if( MAY[n] > SOL[n] )break;
                  if( IsSmaller ){
                     SOL[0] = i , SOL[1] = j, SOL[2] = k , SOL[3] = l;
                     sort(SOL,SOL+4);
                  }
               }else  if( TMP > RES ){
                  RES = TMP;
                  SOL[0] = i , SOL[1] = j, SOL[2] = k , SOL[3] = l;
                  sort(SOL,SOL+4);
               }
            }
         }
      }
   }
   for(i=0;i<4;i++)
      printf("%d ",SOL[i]+1);
   return 0;
}

#include<iostream>
#include<cstdlib>
#include<cstdio>
using namespace std;
 
const int MOD = 7155517;
int n;
int DP[43][43];
bool inversion[43];
bool used[43];
 
int solve( int pos , int last ){
   if( pos==n )
       return 1;
   if( DP[pos][last]!=-1 )return DP[pos][last];
   int sol = 0;
   int to = pos==0 || inversion[pos-1]==true ? n:last-1;
   int from = pos==0 || inversion[pos-1]==false ?1:last+1;
   for( int i=from;i<=to;i++){
      if( used[i]==false ){
         used[i]=true;
         sol+=solve(pos+1,i);
         used[i]=false;
      }
   }
   return DP[pos][last]=sol%MOD;
}
 
int main(){
    int k,i,j;
    memset(DP,-1,sizeof(DP));
    scanf("%d%d",&n,&k);
    for(i=0;i<k;i++){
       scanf("%d",&j);
       inversion[j-1]=true;
    }
    printf("%d\n",solve(0,0));
    system("Pause");
    return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<cstdlib>
#include<algorithm>
#include<stack>
using namespace std;

const int MOD  = 10007;
const int MAXN = 1000;

int N;
long long tree[MAXN+5][MAXN+5];
int vals[MAXN+5][MAXN+5];

void update( int x , int y , int val ){
   int i;
   for( ;y<=N;y+=y&-y)
      for(i=x;i<=N;i+=i&-i)
         tree[y][i] = (tree[y][i]*val)%MOD;
}

int read( int x , int y ){
   int i ,ret = 1;
   for(;y>0;y-=y&-y)
      for(i=x;i>0;i-=i&-i){
         ret = (ret*tree[y][i])%MOD;
      }
   return ret;
}

int GetInversion( int v ){
   int stp = MOD-2;
   stack<int>S;
   while(stp!=1 ){
      if( stp&1 ){
         stp--;
         S.push(1);
      }else{
         stp/=2;
         S.push(2);
      }
   }
   int tmp = v;
   while(S.empty()==false ){
      if( S.top()==1 ){
         v  = (v*tmp)%MOD;
      }else{
         v =  (v*v)%MOD;
      }
      S.pop();
   }
   return v;
}

void Read( int &v ){
   char c;
   while( (c=getchar())<'0' || c>'9' );
   v = c-'0';
   while( (c=getchar())>='0' && c<='9' ) v = (v*10)+(c-'0');
}

int main(){
   int Q,i,j;
   int x1,y1,x2,y2,c,v,old;;
   Read(N);Read(Q);

   for(i=0;i<=N;i++)
      for(j=0;j<=N;j++)
         vals[i][j] = tree[i][j] =  1;
   for(i=0;i<Q;i++){
      Read(c);
      if( c==1 ){
         Read(x1);Read(y1);Read(v);
         old = GetInversion(vals[x1][y1]);
         update( x1,y1,(old*v)%MOD);
         cout << read(x1,y1) << endl;
         vals[x1][y1] = v;
      }else{
         Read(x1);Read(y1);Read(x2);Read(y2);
         int t1 = read(x2,y2) * GetInversion( read(x1-1,y2) ) ; t1 %= MOD;
         int t2 = GetInversion( read(x2,y1-1) ) * read(x1-1,y1-1); t2 %=MOD;
         printf("%d\n",(t1*t2)%MOD);
      }
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<vector>
using namespace std;

string rna;
int n;
int DP[500][500];
bool good[200][200];

int sol( int lo , int hi ){
   if(hi-lo<=1)return 0;
   if(DP[lo][hi]!=-1)return DP[lo][hi];
   if( good[rna[lo]][rna[hi]] )DP[lo][hi] = sol(lo+1,hi-1)+1;
   for( int i=lo;i<hi;i++){
      DP[lo][hi] = max(DP[lo][hi] , sol(lo,i)+sol(i+1,hi) );
   }
   return DP[lo][hi];
}

int main(){
   good['A']['U'] = good['U']['A'] = good['C']['G'] = good['G']['C'] = good['G']['U'] = good['U']['G'] = 1;
   memset(DP,-1,sizeof(DP));
   cin>>n;
   cin>>rna;
   printf("%d\n",sol(0,n-1) );
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<cstdlib>
#include<vector>
#include<iomanip>
#include<math.h>
using namespace std;

const int MAXN  = 100000;
const int MAXLG = 18;
int len;
char str[MAXN+5];
int DP[MAXLG][MAXN];

int H;
struct suffix{
   int idx;
   bool operator<( const suffix &sfx ) const {
      if( H == 0 )return str[ idx ] < str[ sfx.idx ];
      if( DP[ H-1 ][ idx ] == DP[ H-1 ][ sfx.idx ] )
         return ( idx+(1<<(H-1))<len ? DP[H-1][idx+(1<<(H-1))] : -1) < (sfx.idx+(1<<(H-1))<len ? DP[H-1][ sfx.idx+(1<<(H-1)) ] : -1);
      else
         return DP[ H-1 ][ idx ] < DP[ H-1 ][ sfx.idx ];
   }
}L[MAXN];

bool UpdateBuckets(){
   int key = 0;
   DP[H][ L[0].idx ] = 0;
   for( int i = 1 ; i < len ; i ++ ){
      if( L[i-1]<L[i] )key++;
      DP[H][ L[i].idx ] = key;
   }
   if( key == len-1 )return true;
   return false;
}

int lcp( int idx_a , int idx_b ){
   int sol = 0;
   for( int stp = H-1 ; idx_a<len && idx_b<len && stp>=0 ; stp-- ){
      if( DP[stp][idx_a] == DP[stp][idx_b] )
         idx_a += 1<<stp , idx_b += 1<<stp , sol += 1<<stp;
   }
   return sol;
}

long long NumberSubs[MAXN+5];
long long Summed[MAXN+5];

int idx_of_sub , len_of_sub;

void GetKTH( long long k ){
   int lo = 0 , hi = len-1 ,mid;
   while(lo<=hi ){
       mid = (lo+hi)/2;
       if( Summed[mid]>=k && ( mid-1==-1 || Summed[mid-1]<k) ) break;
       else if( Summed[mid]<k )
          lo = mid + 1;
       else
          hi = mid - 1;
   }
   idx_of_sub = mid;
   len_of_sub = (strlen( str+L[mid].idx ) - NumberSubs[mid]) + (k-(mid-1>=0 ? Summed[mid-1] : 0 ) );
}

int main(){
   int i;
 //  freopen("Ulaz.txt","r",stdin);
 //  freopen("Izlaz.txt","w",stdout);
   scanf("%s",str); len=strlen(str);
   for( i=0; i<len ; i++ )L[i].idx = i;
   for( H = 0 ; H==0 || (1<<(H-1)) <= len ; H ++ ){
      sort( L , L + len );
      if( UpdateBuckets() ){ H++; break; }
   }
   NumberSubs[0] = strlen( str + L[0].idx );
   Summed[0] = NumberSubs[0];
   for( i = 1 ; i < len ; i ++ ){
      int common = lcp( L[i].idx , L[i-1].idx );
      NumberSubs[i] = strlen( str+L[i].idx ) - common;
      Summed[i] += Summed[i-1]+NumberSubs[i];
   }
   
   int Q,K;
   scanf("%d",&Q);
   for( i=0;i<Q;i ++){
      scanf("%d",&K);
      GetKTH( K );
      char tmp = str[ L[idx_of_sub].idx + len_of_sub ];
      str[ L[idx_of_sub].idx + len_of_sub ] = '\0';
      printf("%s\n",&str[ L[idx_of_sub].idx ] );
      str[ L[idx_of_sub].idx + len_of_sub ] = tmp;
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<vector>
#include<math.h>
using namespace std;

struct coord{
   double x,y,z;
   coord( float p1, float p2,float p3):x(p1),y(p2),z(p3){};
   coord(){};
};
struct edge{
   double v;
   int a,b;
   edge(int p1 ,int p2 , double p3 ):a(p1),b(p2),v(p3){};
   edge(){};
   bool operator<( const edge e )const {
      return v<e.v;
   }
};

coord S;
coord A[506];
edge si[200000];int Csi=0;

int id[5000],n;
int sz[5000];

bool connect( int a , int b ){
   for(;a!=id[a];a=id[a])
      id[a]=id[id[a]];
   for(;b!=id[b];b=id[b])
      id[b]=id[id[b]];
   if(a!=b){
      if( sz[a] < sz[b] )
         sz[a]+=sz[b] , id[a]=b;
      else
         sz[b]+=sz[a] , id[b]=a;
   }
   a = 0, b = 1;
   for(;a!=id[a];a=id[a])
      id[a]=id[id[a]];
   for(;b!=id[b];b=id[b])
      id[b]=id[id[b]];
   if(a==b)return true;
   else return false;
}


int main(){ 
   int i,j;
   double x,y,z;
   scanf("%lf%lf%lf",&x,&y,&z);
   
   A[0]=coord(x,y,z);  id[0]=0,sz[0]=1;
   A[1]=coord(0,0,0);  id[1]=1,sz[1]=1;
   si[Csi].a = 0;
   si[Csi].b = 1;
   si[Csi++].v =  (A[0].x-A[1].x)*(A[0].x-A[1].x) + (A[0].y-A[1].y)*(A[0].y-A[1].y) + (A[0].z-A[1].z)*(A[0].z-A[1].z);
         
   scanf("%d",&n);
   n++;
   for(i=2;i<=n;i++){
      id[i]=i,sz[i]=1;
      scanf("%lf%lf%lf",&A[i].x,&A[i].y,&A[i].z);
      for(j=0;j<i;j++){
         si[Csi].a = i;
         si[Csi].b = j;
         si[Csi++].v =  (A[i].x-A[j].x)*(A[i].x-A[j].x) + (A[i].y-A[j].y)*(A[i].y-A[j].y) + (A[i].z-A[j].z)*(A[i].z-A[j].z);
      }
   }
   sort(si,si+Csi);
   i=0;
   double res = -1;
   while( !connect(si[i].a,si[i].b) ){
      res = max(res,si[i].v);
      i++;
   }res = max(res,si[i].v);
   printf("%.2lf\n",sqrt(res));
   return 0;
}

#include<iostream>
#include<vector>
#include<iomanip>
#include<math.h>
#include<queue>
using namespace std;

#define f first
#define s second

int N,M,K;
char field[40][40];

pair<int,int>X;
vector< pair<int,int> >Ks;
vector< pair<int,int> >All;
int positions[35][35];
int dist[35][35];
bool visited[35][35];

vector< pair<int,int> >graph[625];


int sol =  999;
bool DFSvisited[625];


int directions[][2] = { 1,0 , -1,0 , 0,1, 0,-1 }; int sz = 4;

void DFS( int node , int dist, int deep ){
   if( deep == K ){
      sol = min( sol , dist );
      return;
   }
   if( sol<dist )return;
   int i;
   for(i=0;i<graph[node].size();i++){
      if( DFSvisited[ graph[node][i].f ] == false ){
         DFSvisited[ graph[node][i].f ] = true;
         DFS( graph[node][i].f , dist + graph[node][i].s ,deep+1);
         DFSvisited[ graph[node][i].f ] = false;
      }
   }
}


int main(){
   int i,j;
   scanf("%d%d%d",&N,&M,&K);
   for(i=0;i<N;i++)
      scanf("%s",&field[i]);
   
   for(i=0;i<N;i++){
      for(j=0;j<M;j++){
         if( field[i][j] == 'X' )
            X = make_pair(j,i);
         else if( field[i][j]=='K' ){
            Ks.push_back( make_pair(j,i) );
            positions[i][j] = Ks.size()+1;
         }
      }
   }
   int nX , nY;
   positions[ X.s ][ X.f ] = 1;
   pair<int,int>u;
   queue< pair<int,int> >Q;
   All.push_back( X );
   for( i=0;i<Ks.size();i++)
      All.push_back( Ks[i] );


   for( i=0;i<All.size();i++){
      memset(visited , 0  , sizeof(visited) );
      Q.push( make_pair( All[i].f , All[i].s ) );
      dist[ All[i].s ] [ All[i].f ] = 0;
      visited[ All[i].s ][All[i].f ] = true;
   
      while( !Q.empty() ){
         u = Q.front() ; Q.pop();
         for( j=0;j<sz;j++ ){
            nX = u.f + directions[j][0];
            nY = u.s + directions[j][1];
            if( field[nY][nX]!='#' && visited[nY][nX]==false ){
               visited[nY][nX] = true;
               dist[nY][nX] = dist[u.s][u.f]+1;
               Q.push( make_pair( nX , nY ) );
               if( positions[nY][nX] > 0 ){
                  graph[i+1].push_back( make_pair( positions[nY][nX] , dist[nY][nX] ) );
               }
            }
         }
         dist[u.s][u.f]= 0;
      }
   }

   DFSvisited[1] =true;
   DFS(1,0,0);
   printf("%d\n",sol );
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<cstdlib>
using namespace std;

const int MAXN = 100005;
int n;
int DP[MAXN][3][3][3][3];
int NS[MAXN];
char str[MAXN];

inline int value( int f1 , int f2 , int f3 ){
   if( f1==0 && f2==0 ){
      return 1;
   }else if( f1==0 ){
      return (f3!=f2) + 1;
   }else
      return (f1!=f2) + (f1!=f3 && f2!=f3) + 1;
}

int rek( int idx , short i1, short i2 , short j1 , short j2 ){
   if( idx == n )return 1;
   if( DP[idx][i1][i2][j1][j2] != 0 )
      return DP[idx][i1][i2][j1][j2];
   short U = value(i1,i2,NS[idx]);
   short L = value(j1,j2,NS[idx]);
   int sol =  rek( idx+1, i2 , NS[idx] , j1, j2 ) + U;
   sol = max( sol , rek(idx+1, i1, i2 , j2, NS[idx] ) + L );
   return (DP[idx][i1][i2][j1][j2]=sol );
}

int main(){
   scanf("%d",&n);
   scanf("%s",str);
   for( int i=0;i<n;i++)
      if( str[i] == 'M' )      NS[i] = 1;
      else if( str[i] == 'B' ) NS[i] = 2;
      else                     NS[i] = 3;
   cout<<rek(0,0,0,0,0)-1<<endl;
   return 0;
}

#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <iostream>
using namespace std;

const int MAX=100005;

int n;
char s[MAX+1];
int dp[2][4][4][4];

void read_input() {
  scanf("%d\n", &n);
  fgets(s, MAX+1, stdin);
  for (int i = 0; i < n; i++)
    if (s[i] == 'F')
      s[i] = 1;
    else if (s[i] == 'M')
      s[i] = 2;
    else
      s[i] = 3;
}

inline int ore (int a, int b, int c) {
  int sol = 0;
  if (a == 1 || b == 1 || c == 1) sol++;
  if (a == 2 || b == 2 || c == 2) sol++;
  if (a == 3 || b == 3 || c == 3) sol++;
  return sol;
}

int main() {
  read_input();

  int now = 0, prev = 1;
  for ( int k=n-1; k>=0; --k ) {
     for ( int a=0; a<=3; ++a ) {
        for ( int b=0; b<=3; ++b ) {
           for ( int c=0; c<=3; ++c ) {
              cout<<k-1<<endl;
              int left = ore(s[k], s[k-1], a) + dp[prev][s[k-1]][b][c];
              int right = ore(s[k], b, c) + dp[prev][b][s[k-1]][a];
              dp[now][a][b][c] = max(left, right);
           }
        }
     }

     swap(now, prev);
  }
  printf("%d\n", dp[prev][0][0][0]);
  system("Pause");
  return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<set>
#include<math.h>
#include<algorithm>
using namespace std;

const int inf = 999999;
const int MAXN = 20;
const int MAXSIZE = 50000;
const int PrimeBase = 6217;

int n;
char str[MAXN+1][MAXSIZE+1];
int found,length;

bool Check( int size ){
   found = 0;
   int i,j;
   set< long long >prev;
   set< long long >now;
   long long npower=1;
   long long hkey;
   for( i=0;i<n;i++){
      hkey = 0;
      npower = 1;
      for(j=0;j<size;j++){
         hkey = (hkey*PrimeBase + str[i][j] );
         if(j!=size-1)npower*=PrimeBase;
      }
      if( i==0 || prev.count(hkey)==1 ){
         now.insert( hkey );
         if( i==n-1 )found = size-1,length = size;
      }
      int len = strlen(str[i]);
      for(j=size;j<len;j++){
         hkey = (hkey - npower*str[i][j-size])*PrimeBase;
         hkey += str[i][j];
         if( i==0 || prev.count(hkey)==1 ){
            now.insert( hkey );
            if( i==n-1 )found = j,length = size;
         }
      }
      if( now.size()==0 )return false;
      prev = now;
      now.clear();
   }
   return true;
}

int main(){
   int tests,i,j;
   int MinLen , MaxLen, len , lo , hi , mid;
   scanf("%d",&tests);
   while(tests--){
      scanf("%d",&n);
      MinLen = inf , MaxLen = 0;
      for(i=0;i<n;i++){
         scanf("%s",str[i]);
         len = strlen(str[i]);
         MinLen = min( MinLen , len );
         MaxLen = max( MaxLen , len );
      }
      lo = min( MinLen , (int)(floor(MaxLen*0.05)) );
      hi = (int)(ceil(MaxLen * 0.5));
      int res = 0;
      while( lo<=hi ){
         mid = (lo+hi)/2;
         if( Check(mid) ){
            res = found;
            lo = mid+1;
         }else
            hi = mid-1;
      }
      for(j=res-length+1;j<=res;j++)
         printf("%c",str[n-1][j]);printf("\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<math.h>
using namespace std;

int main(){
   long long N,K;
   cin>>N>>K;
   cout<<((long long)(K*log10(N)+1))<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<vector>
using namespace std;

int n,m;
char buff[100000];
short first[100000]; int sz1(0); long long sum1(0);
short second[100000];int sz2(0); long long sum2(0);

short sol[100000];

int main(){
   scanf("%d%d",&n,&m);
   scanf("%s",buff);
   sort(buff,buff+n,greater<char>());
   int a=0 , b = 0;
   bool state = false;
   bool sw;
   for( int i = 0 ; i < n ; i ++ ){
      if( (a<b && !state) || (state && sw)  ){
         first[sz1++] = buff[i]-'0';
         sum1 += buff[i]-'0';
         if(!state)a = buff[i]-'0';
      }else{
         second[sz2++]= buff[i]-'0';
         sum2 += buff[i]-'0';
         if(!state)b = buff[i]-'0';
      }
      sw = !sw;
      if( sz1==sz2 ){
         if( a!=b ){
            state = true;
            if( a>b )sw = false;
            else sw = true;
         }else{
            a = b = 0;
         }
      }
   }
   
   long long n1 = 0 , n2 = 0;
   for( int i = sz1-8 ; i < sz1 ; i++ )
      n1 = (n1*10)+first[i];
   for( int i = sz2-8 ; i < sz2 ; i++ )
      n2 = (n2*10)+second[i];
   long long t = n1*n2;
   
   for( int i = 0; i<m ; i ++ ){
      sol[i] = t%10;
      t/=10;
   }
   for( int i = m-1 ; i>=0 ; i-- )
      cout<<sol[i];cout<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<set>
#include<math.h>
#include<vector>
using namespace std;
 
int main(){
   long long num,numcpy,j(2),prev,res;
   cin>>num;
   numcpy = res = num;
   double R=num;
   set<long long>S;
   while( j*j<=numcpy && num!=1 ){
      if( num%j == 0 ){
         num/=j;
         if( prev!=j ){
            S.insert(j);
         }
         prev = j;
      }else
         j++;
   }
   if( num!=1 )S.insert(num);
   for(set<long long>::iterator it = S.begin() ; it!=S.end() ; it++ ){
      R = R*(((*it)-1.00)/(*it));
   }
   cout<<(long long)R<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
using namespace std;

void read( int &v ){
   char c;
   while( (c=getchar())<'0' || c>'9' );
   v = c-'0';
   while( (c=getchar())>='0' && c<='9')v = (v*10)+(c-'0'); 
}

int matrica[501][501];
int MAX_ROW[501];
int SUM_ROW[501];

int main(){
   int n,i,j;
   read(n);
   for(i=0;i<n;i++){
      for(j=0;j<n;j++){
         read(matrica[i][j]);
         if( matrica[i][j] > matrica[ MAX_ROW[j] ][j] )
            MAX_ROW[j] = i;
         SUM_ROW[j]+=matrica[i][j];
      }
   }
   int sol = 0;
   for(i=0;i<n;i++)
      sol += SUM_ROW[i] - matrica[MAX_ROW[i]][i];
   printf("%d\n",sol);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
#include<string>
using namespace std;
 
int N;
long long A,B;
long long first[40] , second[40];
long long combiF[200000];int countA(0);
long long combiS[200000];int countB(0);
long long sol = 0;
 
void GetCombi( long long* arr , long long* combi , int size , int &combiSize ){
   int i,j,g;
   for(i=0;i<size;i++){
       g = combiSize;
       for(j=0;j<g;j++){
          combi[combiSize++]=combi[j]+arr[i];
          if( combi[j]+arr[i]>=A && combi[j]+arr[i]<=B)sol++;
       }
       combi[combiSize++]=arr[i];
       if(arr[i]>=A && arr[i]<=B)sol++;
   }
}
 
int LowerBound( int lo ,int hi , long long val ){
   int mid;
   while(lo<=hi){
      mid = (lo+hi)/2;
      if( ( mid-1<0 || combiS[mid-1]+val<A) && combiS[mid]+val>=A && combiS[mid]+val<=B )
         return mid;
      else if( mid-1>=0 && combiS[mid-1]+val>=A )
         hi = mid - 1;
      else
         lo = mid + 1;
   }
   return -1;
}
int UpperBound( int lo, int hi, long long val ){
   int mid;
   while(lo<=hi){
      mid = (lo+hi)/2;
      if( (mid+1>=countB || combiS[mid+1]+val>B) && combiS[mid]+val<=B && combiS[mid]+val>=A )
         return mid;
      else if( mid+1<countB && combiS[mid+1]+val <= B )
         lo = mid+1;
      else
         hi = mid-1;
   }
   return -1;
}
 
int main(){
   int i;
   cin>>N>>A>>B;
   int Asize = (int)ceil(N/2.00);
   int Bsize = N/2;
   
   for(i=0;i<Asize;i++)cin>>first[i];
   for(i=0;i<Bsize;i++)cin>>second[i];
   
   GetCombi( first , combiF , Asize , countA );
   GetCombi( second, combiS , Bsize , countB );
   sort( combiS , combiS + countB );
   long long f,s;
   for(i=0;i<countA;i++){
      f = LowerBound(0,countB,combiF[i]);
      s = UpperBound(f,countB,combiF[i]);
 
     
      if( f!=-1 && s!=-1 )sol = sol+(s-f)+1l;
   }
   if( A<=0 && B>=0 )sol++;
   cout<<sol<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<math.h>
using namespace std;

int main(){
   int A,P,N;
   double Ai,A2;
   cin>>N;
   for(P=(int)sqrt(2*N);;P--){
      Ai = N/double(P) - ((P-1)/2.0);
      A2 = round(Ai);
      if( Ai>0 && fabs(A2-Ai)<0.00001)break;
   }
   cout<<A2<<" "<<P<<endl;
   return 0;
}

#include<iostream>
#include<vector>
#include<cstdio>
#include<algorithm>
using namespace std;

int n,m;
int better2[100][100];
int better[100][100];

bool IsBetter( int a , int b ){
   int countA = 0, countB = 0;
   int i;
   for(i=0;i<m;i++){
      if( better[i][a] < better[i][b] )countA++;
      else countB++;
   }
   if( countA > countB )return true;
   else return false;
}

int DP[100][100];

int main(){
   int i,j;

   scanf("%d%d",&n,&m);
   for(i=0;i<m;i++)
      for(j=0;j<n;j++){
         scanf("%d",&better2[i][j]);
         better[i][ better2[i][j]-1 ] = j+1;
      }
   for(i=0;i<n-1;i++)DP[0][i] = IsBetter(i,n-1) ? i : n-1;
   for(i=1;i<n-1;i++){
      for(j=0;j<n-i-1;j++){
         DP[i][j] = IsBetter( DP[i-1][j] , DP[i-1][n-i-1] ) ? DP[i-1][j] : DP[i-1][n-i-1];
      }
   }

   printf("%d\n",DP[n-2][0]+1);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdio>
using namespace std;

int position[100][100];
int pos2[100][100];
int DP[100][100];

int main(){
   int n,m,i,j,k;
   scanf("%d%d",&n,&m);
   for(i=0;i<m;i++)
      for(j=0;j<n;j++){
         scanf("%d",&pos2[i][j]);
         position[i][ pos2[i][j]-1 ] = j+1;
      }
   for(i=0;i<n;i++)DP[i][n]=i;
   int countF,countS;
   for(i=n-1;i>=1;i--){
      for(j=0;j<i;j++){
         countF = countS = 0;
         for(k=0;k<m;k++)
            if( position[k][DP[i][i+1]]>position[k][DP[j][i+1]] )countF++;
            else countS++;
         if( countS > countF )DP[j][i] = DP[i][i+1];
         else DP[j][i]=DP[j][i+1];
      }
   }
   printf("%d\n",DP[0][1]+1);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<math.h>
using namespace std;

int kladija[100][100];
int pobjeda[100][100];

int main(){
   int n,m;
   FILE *in = fopen("Ulaz.txt","r");
   fscanf(in,"%d%d",&n,&m);
   for(int i=1;i<=m;i++){
      for(int j=1;j<=n;j++){
         fscanf(in,"%d",&kladija[i][j]);
      }
   }
   for( int i = n-1; i>=1; i-- ){
      int vote1 = 0 , vote2 = 0;
      for( int j = 1; j<= m ; j++ ){
         if( kladija[j][n] < kladija[j][i] ) vote1++;
         else vote2++;
      }
      if( vote1>vote2 )pobjeda[i][n]=n;
      else pobjeda[i][n] = i;
   }

   for( int i = n-1; i>=1; i-- ){
      for( int j = i-1; j>=1 ; j-- ){
         int vote1 = 0 , vote2 = 0;
         for( int k=1;k<=m;k++){
            if( kladija[k][pobjeda[i][i+1]]<kladija[k][pobjeda[j][i+1]] )vote1++;
            else vote2++;
         }
         if( vote1>vote2)pobjeda[j][i] = pobjeda[i][i+1];
         else pobjeda[j][i] = pobjeda[j][i+1];
      }
   }
   for(int i=0;i<10;i++){
      for(int j=0;j<10;j++){
          cout<<pobjeda[i][j]<<" ";
      }cout<<endl;                  
   }                                    
   if( n!=1 )
      cout<<pobjeda[1][2]<<endl;
   else
      cout<<1<<endl;
   system("pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<algorithm>
using namespace std;

int niz[1005];

int main(){
   int n,m,k,i;
   scanf("%d%d%d",&n,&m,&k);
   for( i =0 ;  i < n ; i ++ ){
      scanf("%d",&niz[i]);
   }
   int need = m*k;
   int took = 0;
   sort(niz,niz+n,greater<int>());
   for( i =0 ; took<need ; i ++ ){
      took += niz[i];
   }
   printf("%d",i);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<vector>
#include<iomanip>
using namespace std;

char str[30]; int len;

inline bool isdigit( char a ){
   return ( '9'>=a && a>='0' );
}
inline bool isalpha( char a ){
   return ( a>='a' && a<='z' );
}

bool read_str(){
   char c;
   while( !isdigit(c=getchar()) )
      if ( isalpha(c) )return false;
   str[ len = 0 ] = c; len++;
   while( isdigit(c=getchar()) ){
      str[ len++ ] = c;
   }str[len] = '\0';
   return true;
}

int sums[30];
int rek( int idx , int prev ){
   int sol = 0;
   for( int i = idx+1 ; i <= len ; i ++ ){
      if( sums[i]-sums[idx]>=prev ){
         if( i == len )
            sol++;
         else
            sol+=rek( i , sums[i]-sums[idx] );
      }
   }
   return sol;
}

int main(){
   int test = 1;
   while( read_str() ){
      sums[0] = 0;
      for( int i = 0 ; i < len ; i ++ )
         sums[i+1] = sums[i] + (str[i]-'0');
      printf("%d. %d\n",test,rek(0,-1) );
      test++;
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<cstdlib>
#include<vector>
#include<math.h>
#include<queue>
using namespace std;

#define f first
#define s second

struct edge{
   int B,dist;
   edge( int p1 ,int p2 ):B(p1),dist(p2){};
   edge(){};
};

int n;
vector< edge >graph[20500];
int matrix[200][200];
int ID[200][200];
int RID[13000][2];

bool visited[13000];
int MAXH,l,u ;
int MVAL(999999);
int MAXVAL = -1;

bool DFS( int node  ){
   bool IsOk = false;
   visited[ node ] = true;
   if(  l>matrix[ RID [node][1] ][ RID [node][0] ] ||  matrix[ RID[ node ][1] ][ RID [ node ][0] ]>u )return false;
   if( node == ID[n-1][n-1] )return true;
   for( int i =0  ; i < graph[node].size() && !IsOk;i++)
      if( visited[ graph[node][i].B ] ==false   )
         IsOk = DFS( graph[node][i].B  );  
   if( IsOk )return true;
   return false;
}

bool IsOk( int H ){  
   MAXH = H;
   int TO = MAXVAL - H;
   for( int i = MVAL ; i<110;i++){
      l = i , u = i+H;
      memset(visited,0,sizeof(visited) );
      if( DFS(1) )return true;
   }
   return false;
}

int main(){
   int i,j,k(0);
   //FILE *in = fopen("Ulaz.txt","r");
   scanf("%d",&n);
   
   for(i=0;i<n;i++){
      for(j=0;j<n;j++){
         ID[i][j] = ++k;
         RID[k][0] = j , RID[k][1] = i;
      } 
   }
         
   for(i=0;i<n;i++){
      for(j=0;j<n;j++){
         scanf("%d",&matrix[i][j]);
         MVAL = min(MVAL , matrix[i][j] );
         MAXVAL = max(MAXVAL , matrix[i][j] );
         if( i > 0 ){
            graph[ID[i][j]].push_back( edge(ID[i-1][j] , abs(matrix[i][j]-matrix[i-1][j]) )  );
            graph[ID[i-1][j]].push_back( edge( ID[i][j] , abs(matrix[i][j]-matrix[i-1][j]) )  );
         }if( j > 0 ){
            graph[ID[i][j]].push_back( edge(ID[i][j-1] , abs(matrix[i][j]-matrix[i][j-1]) )  );
            graph[ID[i][j-1]].push_back( edge( ID[i][j] , abs(matrix[i][j]-matrix[i][j-1]) )  );
         }
      }
   }
   bool OK,OK1;
   int lo = 0 , hi = 110 , mid;
   while( lo<=hi ){
      mid = (lo+hi)/2;
      OK = IsOk(mid);
      OK1 = mid-1 >=0 ? IsOk(mid-1):false;
      if( OK && !OK1 )break;
      else if( OK == false )lo = mid+1;
      else hi = mid-1;
   }
   printf("%d",mid);
 //  system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<vector>
using namespace std;

int main(){
   int x;
   cin>>x;
   string sol = "";
   do{
      if( x%2 == 1 || x%2==-1){
         sol += "1";
         x--;
      }else{
         sol += "0";
      }
      x /= -2;
   }while(x);
   reverse(sol.begin(),sol.end());
   cout<<sol<<endl;
   return 0;
}

#include<iostream>
#include<algorithm>
#include<math.h>
#include<cstdlib>
#include<fstream>
#include<vector>
using namespace std;

string num;
int bf , bt;

char letters[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F' };

long long ToDec(){
   long long power = 1;
   long long d;
   long long ret = 0;
   for( int i = num.size()-1; i>=0; i-- ){
      if( num[i] >='0' && num[i]<='9' )d = num[i] - '0';
      else d = (num[i] - 'A')+10;
      ret = ret + ( d *  power );
      power*=bf;
   }
   return ret;
}

string sol( long long v ){
   string ret = "";
   while( v!=0 ){
       ret = ret + letters[ v % bt ];
       v /= bt;
   }
   reverse( ret.begin() , ret.end() );
   return ret;
}

int main(){
   while( cin.eof() == false ){
      cin>>num>>bf>>bt>>ws;
      long long Q = ToDec();
      num = sol(Q);
      if( num.size() > 7 )printf("  ERROR\n");
      else printf("%7s\n",num.c_str());
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<vector>
using namespace std;

inline void readi( long long &v ){
   char c;
   while( (c=getchar())<'0' && c>'9' );
   v = c-'0';
   while( (c=getchar())>='0' && c<='9' )
      v = (v*10) + (c-'0');
}

vector<int>ps;
bool visited[1000004];

int main(){
   int i,j;
   long long t;
   for( i =2 ; i < 1000000 ; i++ ){
      if( visited[i]==false )
         ps.push_back(i);
         for( j = 1; i*j<=1000000; j++)
            visited[i*j]=true; 
      }
   readi(t);
   int sz = ps.size();
   long long d;
   while(t--){
      readi(d);
      int div = 0;
      vector<long long>divs;
      while( d != 1 && div<sz ){
         if( d % ps[div] == 0 ){
            divs.push_back( ps[div] );
            d /= ps[div];
         }else
            div++;
      }
      divs.push_back( d );
      int last = 1, stp;
      bool IsOk=true;
      for(  i =0 ; i < divs.size() && IsOk; i ++ ){
         if( divs[i] != last ){
            if( (last-3)%4 == 0 && stp&1 )
               IsOk = false;
            stp=1;
            last = divs[i];
         }else
            stp++;
      }
      if( (last-3)%4 == 0 && stp&1 )IsOk = false;
      if( IsOk )printf("Yes\n");
      else printf("No\n");
   }
   return 0;
}

#include<iostream>
#include<fstream>
#include<vector>
#include<math.h>
#include<algorithm>
#include<iomanip>
using namespace std;

struct edge{
   int B,dist;
   edge( int p1,int p2 ):B(p1),dist(p2){};
   edge(){};
};

const int MAXN = 10005;
const int LGN  = 15;
int N;
char str[20];
vector<edge>V[MAXN+1];
int father[MAXN+1];
int H[MAXN+1];
int lvl[MAXN+1];
int P[MAXN+1][LGN];
bool visited[MAXN+1];

void DFS( int node , int dist , int deep ){
   H[node]=dist;
   lvl[node]=deep;
   visited[node]=true;
   for(int i=0;i<V[node].size();i++){
      if( visited[ V[node][i].B ] == false ){
         father[ V[node][i].B ] = node;
         DFS( V[node][i].B , dist + V[node][i].dist , deep+1 );
      }
   }
}

void CONSTRUCT(){
   int i,j;
   memset(P,-1,sizeof(P));
   for(i=1;i<=N;i++)
      P[i][0] = father[i];
   int TO = (int)log2(N);
   for(i=1;i<=TO;i++)
       for(j=0;j<=N;j++)
          if( P[j][i-1]!=-1 )
             P[j][i] = P[ P[j][i-1] ][i-1];
}

int GET_ANCESTOR(int p , int q ){
   if( p==q )return p;
   int i,j;
   if( lvl[p]<lvl[q] )swap(p,q);
   int LG = (int)log2(N);

   for(i=LG;i>=0;i--)
      if( P[p][i]!=-1 && lvl[ P[p][i] ]>=lvl[q] )
         p = P[p][i];
   for(i=LG;i>=0;i--){
      if( P[p][i] != P[q][i] ){
         p = P[p][i];
         q = P[q][i];
      }
   }
   if(p==q)return p;
   return father[p];
}

int distanceT( int a, int b ){
   int anc = GET_ANCESTOR(a,b);
   return H[a]+H[b]-2*H[anc];
}

int GetKTH( int a ,int b , int k ){
   int anc = GET_ANCESTOR(a,b);
   int o, LG = (int)log2(N) ,i;
   if( lvl[a] - lvl[anc] >= k ){
      o = 1;
      for( i=LG;i>=0;i--){
         if( (1<<i)+o<=k ){
            o+=(1<<i);
            a=P[a][i];
         }
      }
      return a;
   }else{
      o = 0;
      k = (lvl[b]-lvl[anc])-(k-(lvl[a]-lvl[anc])-1);
      for( i=LG;i>=0;i--){
         if( (1<<i)+o<=k ){
            o+=(1<<i);
            b=P[b][i];
         }
      }
      return b;
   }
   return -1;
}

int main(){

   int T,i,j,a,b,c;
   scanf("%d",&T);
   for(;T>0;T--){
      scanf("%d",&N);
      for(i=0;i<=N;i++){
         V[i].clear();
         visited[i]=false;
      }
      for(i=0;i<N-1;i++){
         scanf("%d%d%d",&a,&b,&c);
         V[a].push_back( edge(b,c) );
         V[b].push_back( edge(a,c) );
      }
      father[1] = -1;
      DFS(1,0,0);
      CONSTRUCT();
      while(1){
         scanf("%s",str);
         if( strcmp( str,"DIST" )==0 ){
            scanf("%d%d",&a,&b);
            printf("%d\n",distanceT(a,b));
         }else if( strcmp( str,"KTH")==0 ){
            scanf("%d%d%d",&a,&b,&c);
            printf("%d\n",GetKTH(a,b,c) );
         }else
            break;
      }
      printf("\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
using namespace std;

int val[106];
int m[106];

int DP[106][506];
int DP2[106][506];

int main(){

   int amount,parties;
   while(1){
      scanf("%d%d",&amount,&parties);
      if(amount==0 && parties==0)break;
      for(int i=1;i<=parties;i++)scanf("%d%d",&m[i],&val[i]);
      for(int i=1;i<=parties;i++){
         for(int j=1;j<=amount;j++){
            if( m[i]>j  ){
               DP[i][j] = DP[i-1][j];
               DP2[i][j]= DP2[i-1][j];
            }else{
               DP[i][j] = max(DP[i-1][j-m[i]]+val[i],DP[i-1][j]);
               if( DP[i-1][j-m[i]]+val[i] > DP[i-1][j] ){
                   DP[i][j] = DP[i-1][j-m[i]]+val[i];
                   DP2[i][j] = DP2[i-1][j-m[i]]+m[i];
               }else if( DP[i-1][j-m[i]]+val[i] < DP[i-1][j] || DP2[i-1][j-m[i]]+m[i] >= DP2[i-1][j] ){
                   DP[i][j] = DP[i-1][j];
                   DP2[i][j]=DP2[i-1][j];
               }else{
                  DP[i][j] = DP[i-1][j-m[i]]+val[i];
                  DP2[i][j] = DP2[i-1][j-m[i]]+m[i];
               }
            }
         }
      }
      cout<<DP2[parties][amount]<<" "<<DP[parties][amount]<<endl;
   }
   return 0;
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<math.h>
#include<cstdio>
using namespace std;

inline void read_int( int &v ){
   char c;
   while( (c=getchar())<'0' || c>'9' );
   v = c-'0';
   while( (c=getchar())>='0' && c<='9' )v = (v*10) + (c-'0');
}

int main(){
   int N,A,B,i;
   long long sol = 0;
   read_int(N);
   for(i=0;i<N;i++){
      read_int(A); read_int(B);
      sol += A*B;
   }
   printf("%I64d\n",sol);
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<math.h>
using namespace std;

int main(){
   double acc;
   int n,v,h;
   scanf("%d%lf",&n,&acc);
   for(int i=0;i<n;i++){
      scanf("%d%d",&v,&h);
      printf("%.4lf\n",sqrt( v*v + 2*acc*h ) );
   }
   return 0;
}

#include<cstdio>
#include<iostream>
#include<math.h>
using namespace std;


int main(){
   int P;
   cin>>P;
   int i,j,sol=0;
   for(i=1;i<=P;i++){
      for(j=i;j*i<=P;j++){
         sol++;
      }
   }
   printf("%d\n",sol);
   system("Pause");
   return 0;
}

#include<cstdio>

int main(){
   int p,i,r;
   scanf("%d",&p);
   for(i=1;i*i<=p;i++)if( p%i==0 )r = i;
   printf("%d\n",(p/r)*2+r*2);
   return 0;
}

#include<iostream>
#include<cstdlib>
#include<algorithm>
#include<fstream>
#include<math.h>
using namespace std;

const int MAXN = 10000;
int arr1[MAXN+5] , sz1;
int arr2[MAXN+5] , sz2;
int counter[MAXN*4];


int main(){
   int i,j;
   while(1){
      memset(counter,0,sizeof(counter));
      scanf("%d",&sz1);   if( sz1 == 0 )break;
      for(i=0;i<sz1;i++){
         scanf("%d",&arr1[i]);
         counter[ arr1[i]+MAXN ] ++;
      }
      scanf("%d",&sz2);
      for(i=0;i<sz2;i++){
         scanf("%d",&arr2[i]);
         counter[ arr2[i]+MAXN ] ++;
      }
      int hi(0),lo(0) , sum1 , sum2 , idx1 , idx2 , sol(0);
      while( hi!=sz1 || lo!=sz2 ){
         sum1 = sum2 = 0;
         for( i = hi ; i<sz1 && counter[ arr1[i]+MAXN ] < 2 ; i++ )sum1 += arr1[i];
         idx1 = i!=sz1 ? i : sz1-1;
         for( i = lo ; i<sz2 && counter[ arr2[i]+MAXN ] < 2 ; i++ )sum2 += arr2[i];
         idx2 = i!=sz2 ? i : sz2-1;
         

         sol += max(sum1,sum2) + (i!=sz2?arr1[idx1]:0);

         hi = idx1 +1;
         lo = idx2 +1;
      }
      printf("%d\n",sol);
   }

   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;

int main(){
   int tests;
   int N,i,j;
   double sol;
   scanf("%d",&tests);
   while(tests--){
      scanf("%d",&N);
      sol = 0;
      for( i = 1; i <= N ; i ++ )
         sol +=  1/( ((double)i) / N );
      printf("%.2lf\n",sol);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<math.h>
#include<vector>
using namespace std;

char buff[50];
vector<double>V;

int main(){
   int tests,n,i,j;
   double d;
   scanf("%d",&tests);
   for( ; tests ; tests-- ){
      V.clear();
      scanf("%d",&n);
      for(i=0;i<n;i++){
         scanf("%s %lf",buff,&d);
         V.push_back(d);
      }
      sort(V.begin(),V.end());
      double radians;
      double sol = V[n-1]-V[0];
      for( i=1;i<n;i++){
         radians = V[i-1] + (360 - V[i]);
         sol = min( sol , radians );
      }
      printf("%d\n",(int)ceil(sol*12.00));
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<math.h>
#include<cstdlib>
using namespace std;

const int MAXN = 4000;

int A[ MAXN+5 ] , B [ MAXN+5 ] , C [ MAXN+5 ] , D [ MAXN+5 ];
vector<int> AB , CD;

int main(){
   int n,i,j;
   scanf("%d",&n);
   for( i=0; i<n ; i++ ){
      scanf("%d%d%d%d",&A[i],&B[i],&C[i],&D[i]);
      for(j=0;j<i;j++){
         AB.push_back( A[i] + B[j] );
         AB.push_back( A[j] + B[i] );
         
         CD.push_back( C[i] + D[j] );
         CD.push_back( C[j] + D[i] );
      }
      AB.push_back( A[i] + B[i] );
      CD.push_back( C[i] + D[i] );
   } 
   
   sort(AB.begin(),AB.end());
   sort(CD.begin(),CD.end());
   
   int l = 0 , r = CD.size()-1 , abS = AB.size() , sol = 0;
   while( true ){
      if( AB[l]+CD[r] == 0 ){
         i = j = 1;

         while( l+1<abS && AB[l+1] == AB[l] ) l++ , i++;
         while( r-1>=0  && CD[r-1] == CD[r] ) r-- , j++;
         sol += i*j;
         l++ , r--;
      }
      if( r==-1 || l==abS )break;
      if( AB[l]+CD[r] < 0 ) l++;
      else if( AB[l]+CD[r] > 0 ) r--;
   }
   cout<<sol<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<math.h>
#include<vector>
using namespace std;

template <class type>
inline type sqr( type a ){
   return a*a;
}

struct coord{
   int x,y;
   coord( int p1, int p2 ):x(p1),y(p2){};
   coord(){};
   bool IsLeft( coord B , coord test ){
      if( x==B.x ){
         if( B.y > y )return test.x < x;
         else return test.x > x;
      }else{
         if( B.x > x )return test.y > y;
         else return test.y < y;
      }
   }
   inline double dist ( const coord &B ) const {
      return sqrt( sqr(x-B.x) + sqr(y-B.y) );
   }
};

int n;
vector<coord>poly_lines[55];

bool compare( int idx_a , int idx_b ){
   if( poly_lines[idx_a].size() != poly_lines[idx_b].size() )return false;
   if( fabs( poly_lines[idx_a][0].dist( poly_lines[idx_a][1] ) - poly_lines[idx_b][0].dist( poly_lines[idx_b][1] ) ) > 0.0001 )return false;
   int i,points = (int)poly_lines[idx_a].size();
   bool l1,l2;
   for(i=2;i<points;i++){
      if( fabs( poly_lines[idx_a][i-1].dist( poly_lines[idx_a][i] ) - poly_lines[idx_b][i-1].dist( poly_lines[idx_b][i] ) ) > 0.0001 )return false;
      l1 = poly_lines[idx_a][i-2].IsLeft( poly_lines[idx_a][i-1] , poly_lines[idx_a][i] );
      l2 = poly_lines[idx_b][i-2].IsLeft( poly_lines[idx_b][i-1] , poly_lines[idx_b][i] );
      if( l1 != l2 ) return false;
   }
   return true;
}

int main(){
   int i,j,m,a,b;
   while(true){
      scanf("%d",&n);
      if( n==0 )break;
      for(i=0;i<=n;i++){
         scanf("%d",&m);
         poly_lines[i].clear();
         for(j=0;j<m;j++){
            scanf("%d%d",&a,&b);
            poly_lines[i].push_back( coord(a,b) );
         }
      }
      bool b1,b2;
      for(i=1;i<=n;i++){
         b1 = compare( 0,i);
         reverse( poly_lines[i].begin() , poly_lines[i].end() );
         b2 = compare( 0,i);
         if( b1 || b2 )printf("%d\n",i);
      }
      printf("+++++\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<vector>
#include<iomanip>
using namespace std;

int M[400][400];

char c;
inline void read(int &v ){
   while( (c=getchar())<'0' && c>'9' );
   v = c-'0';
   while( (c=getchar())>='0' && c<='9' )v = (v*10) + (c-'0');
}

int main(){
  //  freopen("Ulaz.txt","r",stdin);
  //  freopen("Izlaz.txt","w",stdout);
   bool IsOk=false;
   int tests,n,i,j,k;
   scanf("%d",&tests);
   while(tests--){
      scanf("%d",&n);
      for(i=0;i<n;i++)
         for(j=0;j<n;j++)
            read(M[i][j]);
      int SH;
      IsOk=true;
      for(i=0;i<n ;i++){
         for(j=i+1;j<n;j++){
            SH = M[i][j];
            for(k=0;k<n && IsOk;k++){
               if( k!=i && k!=j && SH == M[i][k]+M[j][k] )
                  IsOk = false;
            }
            if( IsOk )
               printf("%d %d\n",i+1,j+1);
            IsOk = true;
         }
      }
      printf("\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<fstream>
#include<vector>
using namespace std;

int N,M,K;
char MF[300][300];

bool horizontal( char sym ){
   int count,i,j,sol=-1;
   for(i=0;i<N;i++){
      count = 0;
      for(j=0;j<M;j++){
         count = MF[i][j]==sym ? count+1 : 0;
         sol = max(sol,count);
      }
   }
   return ( sol >= K );
}

bool vertikal( char sym ){
   int count,i,j,sol=-1;
   for(i=0;i<M;i++){
      count = 0;
      for(j=0;j<N;j++){
         count = MF[j][i]==sym ? count+1 : 0;
         sol = max(sol,count);
      }
   }
   return ( sol >= K );
}

bool chk1( int x , int y , char sym ){
   int count(0),sol=-1;
   while( x>=0 && y<N ){
      count = MF[y][x]==sym ? count+1 : 0;
      sol = max(sol,count);
      x--;y++;
   }
   return ( sol >= K );
}
bool chk2( int x , int y , char sym ){
   int count(0),sol=-1;
   while( x<M && y<N ){
      count = MF[y][x]==sym ? count+1 : 0;
      sol = max(sol,count);
      x++;y++;
   }
   return ( sol >= K );
}

bool diag1( char sym ){
   int i;
   bool ret = false;
   for(i=0;i<M;i++)ret = max( ret , chk1( i,0,sym ) );
   for(i=1;i<N;i++)ret = max( ret , chk1( M-1,i,sym ) );
   return ret;
}

bool diag2( char sym ){
   int i;
   bool ret = false;
   for(i=0;i<N;i++)ret = max( ret , chk2( 0,i,sym ) );
   for(i=1;i<M;i++)ret = max( ret , chk2( i,0,sym ) );
   return ret;
}


int main(){
   int L,i,j,k;
   scanf("%d",&L);
   int G1(0),G2(0);
   for(;L;L--){
      scanf("%d%d%d",&M,&N,&K);
      for(i=0;i<N;i++)
         scanf("%s",MF[i]);
      G1 += horizontal('x') || vertikal('x') || diag1('x') || diag2('x');
      G2 += horizontal('o') || vertikal('o') || diag1('o') || diag2('o');
   }
   printf("%d:%d\n",G1,G2);
   system("pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<stack>
using namespace std;

const unsigned long long PRIME = 4799;
char str[400000];
const unsigned long long MOD = 100000037;

unsigned long long LTOR[40000];
unsigned long long RTOL[40000];

int main(){
   int q,k,i,j,sol(0);
   scanf("%d",&q);
   scanf("%s",str);
   int len = strlen(str);
   k = q/2;
   unsigned long long key1(0), key2(0);
   unsigned long long powr(1);
   for(i=0;i<k;i++){
      key1 = key1*PRIME + str[i];
      if( i!=k-1)powr*=PRIME;
   }
   LTOR[k-1] = key1;
   for(i=k;i<len;i++){
      key1 = key1 - str[i-k]*powr;
      key1 = (key1*PRIME) + str[i];
      LTOR[i] = key1;
   }
   for(i=0;i<k;i++)
      key2 = key2*PRIME + str[len-i-1];
   RTOL[len-k] = key2;
   for(i=len-k-1;i>=0;i--){
      key2 = key2 - str[i+k]*powr;
      key2 = (key2*PRIME) + str[i];
      RTOL[i] = key2;
   }
   for(i=0;i<len;i++){
      if( LTOR[i] == RTOL[i+1+(q&1)] )sol++;
   }
   printf("%d\n",sol);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<stack>
#include<vector>
#include<cstdlib>
using namespace std;

int N,M;
vector<int>graph[9005];

stack<int>S;
bool InStack[9005];
bool visited[9005];
int idx[9005];
int low_id[9005];
int scc_counter = 1;

int color[9005]; int cl = 1;
int Gvalue[9005];
vector<int>grouped[9005];

void tarjan( int node ){
   low_id[node] = idx[node] = scc_counter; scc_counter++;
   visited[node] = true;
   S.push(node);InStack[node] = true;
   for( int i = 0 ; i < graph[node].size() ; i ++ ){
      if( visited[ graph[node][i] ] == false ){
         tarjan( graph[node][i] );
         low_id[ node ] = min( low_id[ node ] , low_id[ graph[node][i] ] );
      }else if( InStack[graph[node][i]] == true && idx[node] > idx[ graph[node][i] ] ){
         low_id[ node ] = min( low_id[ node ] , idx[ graph[node][i] ] );
      }
   }
   if( low_id[ node ] == idx[ node ] ){
      while( S.empty()== false && idx[S.top()]>=idx[node] ){
         color [ S.top() ] = cl;
         Gvalue[cl]++;
         grouped[cl].push_back( S.top() );
         InStack[S.top()] = false;
         S.pop();
      }cl++;
   }
}

void SCC(){
   for( int i = 1 ; i <= N ; i ++ ){
      if( visited[i] == false ){
         tarjan(i);
      }
   }
}

bool added[9005][9005];
vector<int>R_graph[9005];

void reduce_graph(){
   int i,j,k,v;
   for( i = 1 ; i < cl ; i ++ ){
      added[i][i] = true;
      for( j = 0 ; j < grouped[i].size() ; j ++ ){
         for( k = 0 ; k < graph[ grouped[i][j] ].size() ; k++ ){
            v = graph[ grouped[i][j] ][k];
            v = color[ v ];
            if( added[i][v] == false ){
               R_graph[i].push_back(v);
               added[i][v] = true;
            }
         }
      }
   }
}

bool visited2[9005];
int NG[9005];

int DFS( int node ){
   visited2[node] = true;
   int sol = 0;
   for( int i = 0 ; i < R_graph[node].size() ; i ++ ){
      if( visited2[ R_graph[node][i] ] == false ){
         sol += DFS( R_graph[node][i] );
      }
   }
   return (Gvalue[node] + sol );
}

int main(){
   int tests,i,j,a,b;
   bool tq=false;
   scanf("%d",&tests);
   for ( ; tests ; tests-- ){
      scanf("%d%d",&N,&M);
      if( tq ){
         cl = 1;
         scc_counter = 1;
         for( i=0;i<=N;i++){
            for(j=0;j<=N;j++)added[i][j] = false;
            R_graph[i].clear();
            grouped[i].clear();
            graph[i].clear();
            Gvalue[i] = color[i] = NG[i] =  low_id[i] = idx[i] = visited[i] = InStack[i] = visited2[i] =  0;
         }
      }
      tq = true;
      for( i=0;i<M;i++){
         scanf("%d%d",&a,&b);
         graph[b].push_back(a);
      }
      SCC();
      reduce_graph();
      int sol_g = 1;
      vector<int>sols;
      for( i = 1 ; i < cl ; i ++ ){
         memset(visited2,false,sizeof(visited2));     
         if( visited2[i] == false ){
            NG[i] = DFS( i );
            if( NG[ sol_g ] < NG[ i ] ){
               sols.clear();
               sols.push_back(i);
               sol_g = i;
            }else if( NG[ sol_g ] == NG[ i ] )
               sols.push_back( i );
         }
      }
      vector<int>solution;
      for( i = 0 ; i < sols.size() ; i ++ ){
         for( j = 0 ; j < grouped[ sols[i] ].size() ; j ++ ){
            solution.push_back( grouped[ sols[i] ][j] );
         }
      }
      sort( solution.begin() , solution.end() );
      for( i = 0 ; i < solution.size() ; i ++ )
         printf("%d ",solution[i] );printf("\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<math.h>
#include<iomanip>
using namespace std;


class BigNum{
   public:
      vector<char>digits;
      BigNum(int v=0){
         while(v){digits.push_back( v%10 ); v/=10; }
      }
      void add( BigNum &b2 ){
         int sz1 = digits.size();
         int sz2 = b2.digits.size();
         int minsz = min(sz1,sz2) , maxsz = max(sz1,sz2);
         int i,j,tmp(0),di1,di2;
         for(i=0;i<minsz;i++){
            tmp = digits[i]+b2.digits[i] + tmp;
            digits[i] = tmp%10;
            tmp /= 10;
         }
         for(;i<maxsz;i++){
            if( i<sz1 ) di1 = digits[i];
            else di1 = 0;
            
            if( i<sz2 ) di2 = b2.digits[i];
            else di2 = 0;
            tmp = di1 + di2 + tmp;
            if( i>=sz1 )digits.push_back( tmp%10 );
            else digits[i] = tmp%10;
            tmp /= 10;
         }
         while(tmp){
            digits.push_back(tmp%10);
            tmp/=10;
         }
      }
      void fak( int v ){
         long long tmp = 0;
         for(int i=0;i<digits.size();i++){
             tmp = digits[i] * v + tmp;
             digits[i] = tmp%10;
             tmp /= 10;
         }
         while(tmp){
            digits.push_back(tmp%10);
            tmp /= 10;
         }
      }
      void WriteMe(){
         for(int i=digits.size()-1;i>=0;i--)
            printf("%d",digits[i]);
         printf("\n");
      }
};

int main(){
   BigNum sol(0);
   int n;
   scanf("%d",&n);
   BigNum now(1);
   for(int i=0;i<=n-2;i++){
      sol.add(now);
      now.fak(n-2-i);
   }
   sol.WriteMe();
   return 0;
}

#include<iostream>
#include<math.h>
#include<algorithm>
#include<vector>
#include<cstdlib>
using namespace std;

void print_bits( int v ){for( int i = 12 ; i <=32;i++){cout<<bool(v & (1<<(32-i)) )<<" ";}cout<<endl;}

const int MAXN = 20;
int mx[MAXN][MAXN],H,W,MASK;
int DP[MAXN][MAXN][30000];
short hash[1500000];

int rek( int r , int c ,int mask ){
   static int k = 1;
   mask = mask&MASK;
   if( c == W  ){
      mask<<=1;
      r++,c=0;
      if( r>=H )return 0;
   }
   if( hash[mask] == 0 )
      hash[mask] = k++;

   if( DP[r][c][ hash[mask] ]!=-1 )return DP[r][c][ hash[mask] ];
   
   int sol = -1;
   if( (!(mask&1) ) && !(mask&(1<<W)) )
      sol = max( sol , mx[r][c] + rek( r , c+1 , (mask<<1)+1 )   );
   sol = max( sol ,  rek( r , c+1 , mask<<1 )   );
   return ( DP[r][c][ hash[mask] ] = sol );
}

char c;
void read_int( int &v ){
   while ( c=getchar()) if ( c>='0' && c<='9' )break;
   v = c-'0';
   while( (c=getchar())>='0' && c<='9' )v = (v*10) + (c-'0');
}

int main(){
  
   int tests,i,j,k;
   read_int(tests);
   for( int t = 1 ; t <= tests ; t++ ){
      read_int(W);
      read_int(H);
      MASK = (1<<(W+1)) -1;
      for(i=0;i<H;i++)for(j=0;j<W;j++)for(k=0;k<=29000;k++)DP[i][j][k] = -1;
      for(i=0;i<H;i++)
         for(j=0;j<W;j++)
            read_int(mx[i][j]);
      printf("Case %d: %d\n",t,rek(0,0,0) );
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<cstdlib>
#include<queue>
#include<vector>
using namespace std;

#define f first
#define s second

int H,W;
const int inf = 999999;
vector< pair<int,int> >graph[2000];
int DP[2000];

inline int get_node( int x , int y ){
   return ((y*(W+1))+x);
}

int dijkstra( int start , int end ){
   int ndist,i;
   for(i=0;i<=end;i++)DP[i] = inf;
   DP[start] = 0;
   pair<int,int>u;
   priority_queue< pair<int,int> , vector< pair<int,int> > , greater< pair<int,int> > >Q;
   Q.push( make_pair(0,start) );
   while( !Q.empty() ){
      u = Q.top(); Q.pop();
      for( i = 0 ; i < graph[ u.s ].size() ; i ++ ){
         ndist = u.f + graph[u.s][i].s;
         if( ndist < DP[ graph[ u.s ][i].f ] ){
            DP[ graph[ u.s ][i].f ] = ndist;
            Q.push( make_pair( ndist , graph[ u.s ][i].f ) );
         }
      }
   }
   return DP[ end ];
}

int main(){
  //  freopen("Ulaz.txt","r",stdin);
  //  freopen("Izlaz.txt","w",stdout);
   char type;
   int i,j,k,y,speed,n1,n2;
   bool horizontal;
   while(true){
      scanf("%d%d",&H,&W);
      if( H==0 && W==0 )break;
      horizontal = true;
      for( i=0; i<H*2+1; i++ ){
         y = i/2;
         if( horizontal ){
            for( j=0; j<W; j++ ){
               n1 = get_node( j,y ), n2 = get_node(j+1,y);
               scanf("%d",&speed); cin>>type;
               if( speed == 0 )continue;
               else if( type == '*' ){
                  graph[n1].push_back( make_pair( n2 , 2520 / speed ) );
                  graph[n2].push_back( make_pair( n1 , 2520 / speed ) );
               }else if( type == '<' ){
                  graph[n2].push_back( make_pair( n1 , 2520 / speed ) );
               }else if( type == '>' ){
                  graph[n1].push_back( make_pair( n2 , 2520 / speed ) );
               }
            }
         }else{
            for( j=0;j<W+1;j++){
               n1 = get_node(j,y) , n2 = get_node(j,y+1);
               scanf("%d",&speed); cin>>type;
               if( speed == 0 )continue;
               else if( type == '*' ){
                  graph[n1].push_back( make_pair( n2 , 2520 / speed ) );
                  graph[n2].push_back( make_pair( n1 , 2520 / speed ) );
               }else if( type == '^' ){
                  graph[n2].push_back( make_pair( n1 , 2520 / speed ) );
               }else if( type == 'v' ){
                  graph[n1].push_back( make_pair( n2 , 2520 / speed ) );
               }
            }
         }
         horizontal = !horizontal;
      }
      n1 = dijkstra(0,(H+1)*(W+1)-1);
      
      if( n1 == inf )
         printf("Holiday\n");
      else
         printf("%d blips\n",n1);
      
      for( i=0; i<=H;i++){
         for(j=0;j<=W;j++){
            n1 = get_node(j,i);
            graph[n1].clear();
         }
      }
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<vector>
using namespace std;

const long long PRIME = 4799;

int main(){
   int n,i,j;
   string needle,hay;
   while( cin.eof() == false ){
      cin>>n;
      cin>>needle>>ws>>hay>>ws;
      long long keys = 0 , sol = 0 , keyt=0;;
      long long pwbase = 1;
      int lenN = needle.size() , lenH = hay.size();
      for(i=0;i<lenN;i++){
         keys = (keys*PRIME + needle[i]);
         if( i!=lenN-1 )
           pwbase *= PRIME;
      }
      for(i=0;i<lenN;i++)
         keyt = (keyt*PRIME + hay[i]);
      if( keyt==keys ){printf("0\n");sol++;}
      for(i=lenN;i<lenH;i++){
         keyt = keyt - pwbase*hay[i-lenN];
         keyt = keyt*PRIME + hay[i];
         if( keyt==keys ){
            printf("%d\n",i-lenN+1);
            sol++;
         }
      }
      if(sol==0)printf("\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<math.h>
#include<queue>
using namespace std;

int n,m;
vector<int>graph[2005];
int VSet[2005];
bool visited[2005];


bool IsBipartite(){
   memset(VSet,0,sizeof(VSet));
   memset(visited,false,sizeof(visited));
   queue<int>Q;
   int u,i,j;
   for( j = 1 ; j <= n ; j ++ ){
      if( visited[ j ] == false ){
         Q.push( j );
         VSet[j] = 1;
         visited[ j ] = true;
         while( !Q.empty() ){
            u = Q.front();Q.pop();
            for( i=0;i<graph[u].size();i++){
               if( VSet[u] == VSet[ graph[u][i] ] )return false;
               else if( visited[ graph[u][i] ] == false ){
                  visited[ graph[u][i] ] = true;
                  Q.push( graph[u][i] );
                  VSet[ graph[u][i] ] = 3-VSet[u];
               }
            }
        }
      }
   }
   return true;
}


int main(){
 //   freopen("Ulaz.txt","r",stdin);
//    freopen("Izlaz.txt","w",stdout);
   int tests,i,j,a,b;
   scanf("%d",&tests);
   for( int t = 1; tests ; tests-- , t++ ){
      scanf("%d%d",&n,&m);
      for(i=0;i<=n;i++)graph[i].clear();
      for(i=0;i<m;i++){
         scanf("%d%d",&a,&b);
         graph[a].push_back(b);
         graph[b].push_back(a);
      }
      bool sol = IsBipartite();
      printf("Scenario #%d:\n",t);
      if( !sol ) printf("Suspicious bugs found!\n");
      else printf("No suspicious bugs found!\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<fstream>
#include<vector>
using namespace std;

int main(){    
    char a,b,c;
    printf("Ready\n");
    while( true ){
       scanf("%c%c%c",&a,&b,&c);
       if( a==' ' && b==' ')break;
       if( a=='p' && b=='q' || a=='q' && b=='p' || a=='d' && b=='b' || a=='b' && b=='d' )
          printf("Mirrored pair\n");
       else
          printf("Ordinary pair\n");
    }
    system("Pause");
    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<algorithm>
#include<vector>
#include<math.h>
using namespace std;

#define f first
#define s second

const int H = 1234 , W = 5678;
int rows[H+5] , cols[W+5];

char command;

int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
   int i,j,k=1;
   vector< pair<int , pair<int,int> > >V;
   for( i=1 ; i<= H ; i ++ )rows[i] = i;
   for( i=1 ; i<= W ; i ++ )cols[i] = i;
   

   int a,b,x,y;
   while( cin>>command ){
      if( command == 'R' ){
         cin>>a>>b;
         swap( rows[a] , rows[b] );
      }else if( command == 'C' ){
         cin>>a>>b;
         swap( cols[a] , cols[b] );
      }else if( command == 'Q' ){
         cin>>a>>b;
         printf("%d\n", (rows[a]-1)*5678+cols[b] );
      }else if( command == 'W' ){
         cin>>a;
         y = ((a-1) / 5678)+1;
         x = ((a-1) % 5678) +1;
         for(i=1;i<=1234;i++)if( rows[i]==y )printf("%d ",i);
         for(i=1;i<=5678;i++)if( cols[i]==x )printf("%d\n",i);
        // printf("%d %d\n", rows[ y ] , cols[ x ] );
      }
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<queue>
using namespace std;

int n;
const int inf = (int)10e9;
vector<int>veze[60];
int cap[60][60];
int flow[60][60];

bool visited[60];
int prev[60];

int BFS( int from , int to ){
   int i,u;
   memset(prev,-1,sizeof(prev) );
   memset(visited,false,sizeof(visited) );
   queue<int>Q;
   Q.push(from);
   visited[from]=true;
   bool OK = false;
   while(!Q.empty() && !OK ){
      u = Q.front();Q.pop();
      for ( i=0;i<veze[u].size();i++){
         int cf = cap[u][veze[u][i]] - flow[u][veze[u][i]];    
         if( visited[ veze[u][i] ] == false && cf > 0 ){
            Q.push( veze[u][i] );
            visited[ veze[u][i] ] = true;
            prev[ veze[u][i] ] = u;
            if( veze[u][i] == to ){ OK = true ; break; }
         }
      }
   }
   int it = to;
   int min_cap = inf;
   while( prev [ it ] != -1 ){       
      min_cap = min( min_cap , cap[ prev[it] ][it] - flow[ prev[it]][it] );
      it = prev[it];
   }
   it = to;
   while( prev[ it ] > -1 ){
      flow[ prev[it] ][it] += min_cap;
      flow[it][ prev[it] ] -= min_cap;
      it = prev[it];
   }
   if( min_cap == inf )return 0;
   else return min_cap;
}

int ford_fulkerson( int source , int sink ){
   int path;
   int ret=0;
   while(1){
      path = BFS(source,sink);
      if( path == 0 )break;
      ret+=path;
   }
   return ret;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
   int c,i,j;
   char from, to;
   int a,b;
   cin>>n;
   for(i=0;i<n;i++){
      cin>>from>>to>>c;
      if( from >= 'A' && from<='Z' )a = from-'A';
      else a = (from-'a')+('Z'-'A')+1;
      
      if( to >= 'A' && to<='Z' )b = to-'A';
      else b = (to-'a')+('Z'-'A')+1;
      
      veze[a].push_back(b);
      cap[a][b] +=c;
   }
   printf("%d\n",ford_fulkerson( 0 , 'Z'-'A') );
   return 0;
}

#include<iostream>
#include<cstdlib>
#include<vector>
#include<math.h>
#include<cstdio>
#include<algorithm>
using namespace std;

const int MAXN = 2000;
int DP[MAXN][2];

int main(){
   int n,i,j,h,w,prevH,prevW;
   scanf("%d",&n);
   for( i=0; i<n; i++ ){
      scanf("%d%d",&h,&w);
      if( i>0 ){
         DP[i][0] = w + max( abs(h-prevH)+DP[i-1][0] , abs(h-prevW)+DP[i-1][1] );
         DP[i][1] = h + max( abs(w-prevH)+DP[i-1][0] , abs(w-prevW)+DP[i-1][1] );
      }else{
         DP[0][0] = w;
         DP[0][1] = h;
      }
      prevH = h , prevW = w;
   }
   printf("%d\n",max(DP[n-1][0],DP[n-1][1] ) );
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<math.h>
#include<algorithm>
using namespace std;

int DP[105][105];

char c;
inline void re( int &v ){
   while( (c=getchar())<'0' && c>'9' );
   v = c-'0';
   while( (c=getchar())>='0' && c<='9' )v = (v*10) + (c-'0');
}

inline int maxT( int &v1 , int &v2 , int &v3 ){
   if( v1>=v2 && v1>=v3 )return v1;
   if( v2>=v1 && v2>=v3 )return v2;
   return v3;
}

int main(){
   int i,j,tests,h,w,sol;
   re(tests);
   for( ;tests;tests--){
      memset(DP,0,sizeof(DP));
      re(h);re(w);
      sol = 0;
      for( i=1;i<=h;i++){
         for(j=1;j<=w;j++){
            re(DP[i][j]);
            DP[i][j] = DP[i][j] + maxT( DP[i-1][j-1],DP[i-1][j+1],DP[i-1][j]);
            if( sol < DP[i][j] ) sol = DP[i][j];
         }
      }
      printf("%d\n",sol);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<fstream>
#include<vector>
#include<iomanip>
#include<string>
using namespace std;

class BigDigit{
   public:
      vector<char>digits;
      BigDigit(){};
      BigDigit( int val ){
         while(val!=0 ){
            digits.push_back( val%10 );
            val /= 10;
         }
      }
      BigDigit operator + ( const BigDigit &b2 ) const {
         BigDigit nw;
         int sz1 = digits.size();
         int sz2 = b2.digits.size();
         int msz = min(sz1,sz2) , tmp(0) , sum , d1 , d2 , i;
         for( i=0;i<msz;i++){
            sum = digits[i] + b2.digits[i] + tmp;
            nw.digits.push_back( sum%10 );
            tmp = sum / 10;
         }
         for( ; i < sz1 || i < sz2 ; i++ ){
            if( i<sz1 ) d1 = digits[i];
            else d1 = 0;
            if( i<sz2 ) d2 = b2.digits[i];
            else d2 = 0;
            sum = d1 + d2 + tmp;
            nw.digits.push_back( sum%10 );
            tmp = sum / 10;
         }
         while( tmp ){
            nw.digits.push_back( tmp%10 );
            tmp /= 10;
         }
         return nw;
      }
      BigDigit operator * ( const int &v ) const {
         BigDigit nw;
         int i , tmp(0);
         for( i = 0 ; i < digits.size() ; i ++ ){
            tmp = digits[i] * v + tmp;
            nw.digits.push_back( tmp%10 );
            tmp /= 10;
         }
         while(tmp){
            nw.digits.push_back( tmp%10 );
            tmp /= 10;
         }
         return nw;
      }
      void WriteMe(){
         for( int i = digits.size()-1;i>=0;i--)
            printf("%d",digits[i]);
         printf("\n");
      }
};

BigDigit sols[10000];

int main(){

   BigDigit c_1(1) , c_00(0) , c_01(0) , c2_01;
   
   for( int i = 1 ; i<= 1000; i ++ ){
      c2_01 = c_01;
      c_01 = c_1 + c_00;
      c_00 = c2_01;
      
      if( i != 1 ) c_1 = c_1 * 2;
      sols[i] = c_00;
   }
   int N;
   while( cin>>N ){
      if( N != 1 )
         sols[N].WriteMe();
      else
         printf("0\n");
   }
   return 0;
}

#include<iostream>
using namespace std;

struct Point{
double x, y;
};

Point p[1000005];

int main(){
    
    double area, x, y;
    int n, t;
	
    scanf("%d", &t );
	
    while( t-- ){
	
    scanf("%d", &n );

    for(int i=0; i < n; i++)
    scanf("%lf %lf", &p[i].x, &p[i].y ); 
    
    p[n] = p[0];

    area = x = y = 0;
    for (int i = 0; i < n; i++){

#define	x0	(p[i].x)
#define	x1	(p[i+1].x)
#define	y0	(p[i].y)
#define	y1	(p[i+1].y)

	/* Sum integral of 1 over that triangle.  */
	area += (y1*x0-y0*x1)/2;
	/* Sum integral of x over that triangle.  */
	x += (x0+x1)*(y1*x0-y0*x1);
	/* Sum integral of y over that triangle.  */
	y += (y1+y0)*(y1*x0-y0*x1);
         }
	x /= 6*area;
	y /= 6*area;
	printf("%.2lf %.2lf\n", x, y);
     }

     return 0;
}
     

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<fstream>
#include<vector>
#include<queue>
using namespace std;

#define f first
#define s second

int F,N;
const int inf = 999999;
vector<int>graph[1005];
int DP[1005];

inline int get_time_el( int a, int b , int position , int time ){
   if( a > b )swap(a,b);
   int dist = b-a;
   int mode = time % (dist*2);
   position = position - a;
   if( mode > dist ){
      mode = dist-(mode-dist);
      if( position <= mode )return mode - position;
      else return position + mode;
   }else{
      if( position >= mode ) return position - mode;
      else return ( dist - position ) + ( dist - mode );
   }
}

int main(){
   int i,j,a,b;
   scanf("%d%d",&F,&N);
   for(i=0;i<N;i++){
      scanf("%d%d",&a,&b);
      graph[a].push_back(b);
      graph[b].push_back(a);
   }
   for(i=0;i<=F;i++)DP[i] = inf;
   priority_queue< pair<int,int> , vector< pair<int,int> > , greater< pair<int,int> > >Q;
   pair<int,int>u;
   DP[1] = 0;
   Q.push( make_pair(0,1) );
   while(!Q.empty()){
      u = Q.top();Q.pop();
      for( i=0;i<graph[u.s].size();i++){
         int add = get_time_el(u.s,graph[u.s][i],u.s,u.f) + abs(graph[u.s][i]-u.s);
         int dist = u.f + add;
         if( dist < DP[ graph[u.s][i] ] ){
            DP[ graph[u.s][i] ] = dist;
            Q.push( make_pair( dist , graph[u.s][i] ) );
         }
      }
   }
   cout<<DP[F]*5<<endl;
   return 0;
}

#include<iostream>
#include<cstdlib>
#include<algorithm>
#include<vector>
#include<iomanip>
using namespace std;

#define f first
#define s second

int n,m,k;
const int MAXM = 1005;
int BIT[1009];

void update( int idx , int val=1 ){
   for(;idx<=MAXM;idx+=idx&-idx)
      BIT[idx] += val;
}
int read( int idx ){
   int ret = 0;
   for( ; idx>=1; idx-=idx&-idx)
      ret += BIT[idx];
   return ret;
}

int read( int a, int b ){
   return read(b)-read(a-1);
}

int main(){
   int t,i,j,a,b;
   scanf("%d",&t);
   for( int l=1;l<=t;l++){
      memset(BIT,0,sizeof(BIT));
      vector< pair<int,int> >V;
      scanf("%d%d%d",&n,&m,&k);
      for(i=0;i<k;i++){
         scanf("%d%d",&a,&b);
         V.push_back( make_pair(a,b) );
      }
      long long sol = 0;
      sort(V.begin(),V.end());
      for(i=0;i<k;i++){
         sol += read( V[i].s+1 , MAXM-1 );
         update(V[i].s);
      }
      printf("Test case %d: %lld\n",l,sol);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<math.h>
using namespace std;


int mx[21][21];
long long DP[1<<21];

int main(){
   DP[0] = 1;
   int tests,n,i,j;
   scanf("%d",&tests);
   for( ; tests ; tests-- ){
      scanf("%d",&n);
      for(i=0;i<n;i++)for(j=0;j<n;j++)scanf("%d",&mx[i][j]);
      for(i=1;i<(1<<n);i++)DP[i] = 0;
      for(i=1;i<(1<<n);i++)
         for(j=0;j<n;j++)
            if( (i&(1<<j)) && mx[ __builtin_popcount(i)-1 ][j] )
               DP[i] += DP[ i&~(1<<j) ];
      printf("%lld\n",DP[(1<<n)-1]);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<cstdlib>
#include<queue>
#include<math.h>
using namespace std;

struct event{
   int h,m;
   event( int p1 , int p2 ):h(p1),m(p2){};
   event(){};
   bool operator<( const event &e2 ) const {
      return (h < e2.h || ( h == e2.h && m < e2.m ) );
   }
   bool operator>( const event &e2 ) const {
      return (h > e2.h || ( h == e2.h && m > e2.m ) );
   }
   bool operator==( const event &e2 ) const {
      return !((*this)<e2) && !((*this)>e2);
   }
   event operator+( const int &minutes ) const{
      event ret = event(h,m);
      if( minutes+m >= 60 )ret.h++;
      ret.m = (minutes+m)%60;
      return ret;
   }
};

struct period{
   event A , B;
   int type;
   period( int p1 , int p2 , int p3 , int p4 , int p5 ):type(p5){
      A = event( p1 , p2 );
      B = event( p3 , p4 );
   };
   period(){};
   bool operator<( const period &e2 ) const {
      return A < e2.A;
   }
   bool operator>( const period &e2 ) const {
      return A > e2.A;
   }
};

vector<period>V;

int main(){
   int tests,T,AB,BA,ta,tb,tc,td,i,j;
   scanf("%d",&tests);
   for( int t = 1 ; t <=tests ; t ++ ){
      V.clear();
      scanf("%d%d%d",&T,&AB,&BA);
      for( i=0;i<AB;i++ ){
         scanf("%d:%d %d:%d",&ta,&tb,&tc,&td);
         V.push_back( period( ta,tb,tc,td,1 ) );
      }
      for( i=0;i<BA;i++ ){
         scanf("%d:%d %d:%d",&ta,&tb,&tc,&td);
         V.push_back( period( ta,tb,tc,td,2 ) );
      }
      event u;
      sort(V.begin(),V.end());
      priority_queue< event , vector<event> , greater<event> >PQ1;
      priority_queue< event , vector<event> , greater<event> >PQ2;
      bool NeedToAdd;
      int solA = 0 , solB = 0;
      for( i=0;i<AB+BA;i++){
         if( V[i].type == 1 ){
            NeedToAdd = true;
            if( PQ1.empty() == false ){
               u = PQ1.top();
               if( u < V[i].A || u == V[i].A ){
                  PQ1.pop();
                  NeedToAdd = false;
               }
            }
            if( NeedToAdd ) solA++;
            PQ2.push(  V[i].B + T );
            
         }else{
            NeedToAdd = true;
            if( PQ2.empty() == false ){
               u = PQ2.top();
               if( u < V[i].A || u == V[i].A ){
                  PQ2.pop();
                  NeedToAdd = false;
               }
            }
            if( NeedToAdd ) solB++;
            PQ1.push(  V[i].B + T );
         }
      }
      printf("Case #%d: %d %d\n",t,solA,solB);
   }
   return 0; 
}

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<fstream>
#include<vector>
using namespace std;

int n , arr[105];
int triple[105*105*105] , sz(0);

int main(){
   int i,j,k,se;
   int lo,hi,mid,g1,g2,sol(0);
   scanf("%d",&n);
   for(i=0;i<n;i++)scanf("%d",&arr[i]);
   for(i=0;i<n;i++)
      for(j=0;j<n;j++)
         for(k=0;k<n;k++)
            if( arr[i]!=0 )
               triple[sz++] = arr[i]*(arr[j]+arr[k]);
   sort(triple,triple+sz);
   for(i=0;i<n;i++){
      for(j=0;j<n;j++){
         for(k=0;k<n;k++){
            se = arr[i]*arr[j] + arr[k];
            lo = 0 , hi = sz;
            g1 = g2 = -1;
            while(lo<=hi){
                  mid = (lo+hi)>>1;
                  if( triple[mid] == se && ( mid==0 || triple[mid-1] != se ) ){
                      g1 = mid;
                      break;
                  }else if( triple[mid] >= se )hi = mid-1;
                  else lo = mid+1;
            }
            if( g1!=-1 ){
                  hi = sz;
                  while(lo<=hi){
                     mid = (lo+hi)>>1;
                     if( triple[mid] == se && ( mid==sz-1 || triple[mid+1] != se ) ){
                         g2 = mid;
                         break;
                     }else if( triple[mid] > se )hi = mid-1;
                     else lo = mid+1;
                  }
                  sol += (g2-g1+1);
            }
         }
      }
   }
   cout<<sol<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<vector>
using namespace std;

const int MAXLEN = 200000;
const int MAXLG = 18;

int len;
char str[MAXLEN+5];
int DP[MAXLG+4][MAXLEN+4];

struct suffix{
   int now , prev , idx;
   bool operator<( const suffix &sfx ) const {
      return (prev < sfx.prev || ( prev == sfx.prev && now < sfx.now ) );
   }
}L[MAXLEN+5];

int main(){
   int i,j,stp,H;
   scanf("%d%s",&len,str);
   len = strlen(str);
   for(i=0;i<len;i++)DP[0][i] = str[i] - 'a';
   for( stp = 1 , H = 1 ; H < len ; stp ++ , H<<=1 ){
      for(i=0;i<len;i++){
         L[i].idx = i;
         L[i].prev = DP[stp-1][i];
         if( i + H < len )L[i].now = DP[stp-1][i + H];
         else L[i].now = -1;
      }
      sort(L , L + len );
      DP[stp][L[0].idx] = 0;
      for(i=1;i<len;i++)
         DP[stp][ L[i].idx ] = L[i].prev == L[i-1].prev && L[i].now == L[i-1].now ? DP[stp][ L[i-1].idx ] : i;
   }
   int nivo = stp , sol = -1;
   for(i=1;i<len;i++){
      int A = L[i-1].idx , B = L[i].idx, common(0);
      for( j = nivo-1 ; j>=0 ;j-- ){
         if( A+(1<<j)-1<len && B+(1<<j)-1<len && DP[j][A] == DP[j][B] )
            A += 1<<j , B += 1<<j , common += 1<<j;
      }
      sol = max( common , sol );
   }
   printf("%d\n",sol);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<vector>
#include<iomanip>
#include<math.h>
using namespace std;

struct event{
   int time, type;

   event( int p1 , int p3 ):time(p1),type(p3){};
   event(){};
   bool operator<(const event &e2 ) const {
      if (time < e2.time) return true;
      else if (time == e2.time )return (type < e2.type);
      else return false;
   }
};

event action;

int start,end;

int main(){
   int n,i,j,a,b;
   while( scanf("%d %d %d",&start,&end,&n) != EOF ){
   vector<event>V;       
          
   V.push_back( event(start,3) );
   V.push_back( event(end,5));
   for( i=0;i<n;i++){
      scanf("%d %d",&a,&b);
      V.push_back( event(a,2) );
      V.push_back( event(b,7) );
   }
   sort(V.begin(),V.end());
   bool count = false;
   int in_room = 0 , sol_min = 999999 , sol_max = 0;
   for( i=0;i<V.size();i++){
      if( V[i].type == 2 )in_room++;
      if( V[i].type == 7 )in_room--;
      if( V[i].type == 3 )count = true;

      if( count ){
         sol_max = max( sol_max , in_room );
         sol_min = min( sol_min , in_room );
      }
      if( V[i].type == 5 )break;
   }
   printf("%d %d\n",sol_min,sol_max);
  }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<cstdlib>
#include<math.h>
using namespace std;

#define f first
#define s second

struct edge{
   int e,flow,cap;
   edge( int p1 , int p2 , int p3 ):e(p1),flow(p2),cap(p3){};
   edge(){};
};

const int MAXN = 50000 , MAXM = 200011 , inf = 999999;
int n,m,s,t,tk;
int IN[MAXN*2] , OUT[MAXN*2] , INR[MAXN*2] , OUTR[MAXN*2];

int PATH[MAXN*2] , min_cap = 1; vector< pair<int,int> >V;
vector< edge >graph[MAXN*2];
bool visited[MAXN*2];

int type = 0;
bool DFS_FLOW( int node ){
   visited[node] = true;
   bool ok = false;
   if( node == t )return true;
   for( int i=0 ; i<graph[node].size() && !ok ; i++ ){
      if( visited[ graph[node][i].e ] == false && graph[node][i].cap - graph[node][i].flow > 0 ){
         visited[ graph[node][i].e ] = true;
         if(type==0)PATH[ graph[node][i].e ] = node;
         ok = DFS_FLOW( graph[node][i].e );
         if( !ok ){
            if(type==0)PATH[ graph[node][i].e ] = -1;
         }else{
            V.push_back( make_pair(node,i) );
            min_cap = min( graph[node][i].cap , min_cap );
         }
      }
   }
   return ok;
}

int Backward( int node , int se ){
   for( int i = 0 ; i < graph[node].size();i++){
      if( graph[node][i].e == se )return i;
   }
   return -1;
}


int main(){
   int tests,i,j,k,a,b;scanf("%d",&tests);
   for( ; tests ; tests-- ){
      scanf("%d%d",&n,&m);
      k = 1;
      V.clear();
      type = 0;
      min_cap = 1;
      memset( PATH , 0 , sizeof(PATH));
      memset( visited , 0 , sizeof(visited));
      memset( IN , 0 , sizeof(IN));
      memset( OUT, 0 , sizeof(OUT));
      memset( INR, 0 , sizeof(INR));
      memset( OUTR, 0 , sizeof(OUTR));
      
      for( i=1;i<=n;i++){
         graph[i*2].clear();graph[i*2-1].clear();
         if( i>1 && i<n ){
            IN[i] = k , INR[k] = i; k++;
            OUT[i] = k; OUTR[k] = i; k++;
            graph[ IN[i] ].push_back( edge(OUT[i],0,1) );
         }else{
            if( i == 1 )s = k;
            else t = k ;
            IN[i] = OUT[i] = k;
            INR[k] = OUTR[k] = i;
            k++;
         }
      }
      for( i=0;i<m;i++){
         scanf("%d%d",&a,&b);
         if(a==b)continue;
         graph[ OUT[a] ].push_back( edge(IN[b],0,inf) );
      }
      PATH[s] = -1;
      DFS_FLOW( s );
      for( i=0;i<V.size();i++){
         graph[V[i].f][V[i].s].flow+=min_cap;
         if( (j=Backward(graph[V[i].f][V[i].s].e,V[i].f))==-1 )  graph[graph[V[i].f][V[i].s].e].push_back( edge(V[i].f,-min_cap,0) );
         else graph[graph[V[i].f][V[i].s].e][j].flow -= min_cap;
      }
      
      
      memset(visited,false,sizeof(visited) ); V.clear(); min_cap = 1; type = 1;
      bool f = DFS_FLOW( s );
      int it = t;
      while( PATH[it] != -1 ){
         if( visited[ it ] == true ) break;
         it = PATH[it];
      }
      if( INR[it]!=0 )
         cout<<INR[it]<<endl;
      else
         cout<<OUTR[it]<<endl;
      
   }
   return 0;
}

/*///////////////////////////////////////////////////////////////////
MAX FLOW [ MIN-CUT ] PROBLEM 

INPUT:
   n   => the number of vertices
   next n lines:
      in,out => the in and out degree of node i
OUTPUT:
   Node: x  => karakteristic of the node x
       -> u  => the node that is connected with x edge(x,u)
       
CONSTRAINTS:
   n = 1000
*///////////////////////////////////////////////////////////////////

#include<iostream>
#include<cstdlib>
#include<algorithm>
#include<vector>
#include<math.h>
#include<iomanip>
#include<queue>
using namespace std;

#define f first
#define s second

const int MAXN = 1005 , inf = 99999999;
vector< pair<int,int> >V;
int cap[MAXN*2 +5][MAXN*2+5];
int flow[MAXN*2 + 5 ][ MAXN*2+5 ];
int prev[MAXN*2 + 5];
bool visited[ MAXN*2 + 5];
vector<int>graph[ MAXN*2 +5 ];

int get_path( int source , int sink ){
   memset(visited, false ,sizeof(visited));
   int i,j,min_cap = inf;
   pair<int, pair<int,int> > u;
   priority_queue< pair<int, pair<int,int> >  > PQ;
   PQ.push( make_pair( inf , make_pair( source , -1 ) ) );
   while(!PQ.empty()){
      u = PQ.top();PQ.pop();
      if( visited[ u.s.f ] == true ) continue;
      prev[ u.s.f ] = u.s.s;
      visited[u.s.f] = true;
      if( u.s.f == sink ){
         min_cap = u.f;
         break;
      }
      for( i = 0 ; i < graph[u.s.f].size() ; i ++ ){
         if( cap[u.s.f][ graph[u.s.f][i] ] - flow[u.s.f][ graph[u.s.f][i] ] > 0  ){
            int q = min( cap[u.s.f][ graph[u.s.f][i] ] - flow[u.s.f][ graph[u.s.f][i] ] , u.f );
            PQ.push( make_pair( q , make_pair( graph[u.s.f][i] , u.s.f ) ) );
         }
      }
   }
   if( min_cap == inf ){
      return -inf;
   }
   int it = sink;
   while( prev[it] != -1 ){
      flow[ prev[it]][it] += min_cap;
      flow[it][prev[it]] -= min_cap;
      it = prev[it];
   }
   return min_cap;
}

int max_flow( int source , int sink ){
   int ret = 0;
   while( true ){
      int f = get_path( source , sink );
      if( f == -inf )return ret;
      else ret += f;
   }
}

int main(){
   int n,i,j,in,out,oin=0,oout=0;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d%d",&in,&out);
      oin+=in , oout+=out;
      V.push_back( make_pair(in,out));
   }
   if( oin != oout ){
      printf("Creating graph is impossible\n");
      system("Pause");
      return 0;
   }
   int source = MAXN*2 +1 , sink = MAXN*2+2;
   for(i=0;i<n;i++){
      graph[ source ].push_back( i );
      cap[ source ][ i ] = V[i].s;
      
      graph[i+MAXN].push_back( sink );
      cap[ i+MAXN ][ sink ] = V[i].f;
   }
   for(i=0;i<n;i++){
      for(j=0;j<n;j++){
         if( i!=j ){
            graph[ i ].push_back( j+MAXN );
            cap[i][ j+MAXN ] = 1;
         }else{
            graph[ i ].push_back( j+MAXN );
            cap[i][ j+MAXN ] = 0;
         }
      }
   }
   max_flow(source,sink);
   for( i=0;i<n;i++ ){
      cout<<"NODE: "<<i+1<<endl;
      for( j=0;j<graph[i].size() ;j++){
         if( flow[i][graph[i][j]] > 0 ){
            cout<<" -> "<<graph[i][j]-MAXN+1<<endl;
         }
      }
   }
   system("pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<vector>
#include<math.h>
using namespace std;

struct competitor{
   int poz,poene,solved;
   competitor( int p1, int p2 , int p3 ):poz(p1),poene(p2),solved(p3){};
   competitor():poz(0),poene(0),solved(0){};
   bool operator<( const competitor c2 ) const{
      if( poene > c2.poene )return true;
      else if( poene < c2.poene )return false;

      if( solved > c2.solved )return true;
      else if( solved < c2.solved )return false;

      if( poz < c2.poz )return true;
      return false;
   }
};

const int MAXN = 2005;
const int MAXT = 2005;
int D[MAXN][MAXT];
int TVAL[MAXT];
competitor list[MAXN];

int main(){
   int N,T,P,v,i,j;
   scanf("%d%d%d",&N,&T,&P);
   for( i=0;i<N;i++){
      for( j=0;j<T;j++){
         scanf("%d",&D[i][j]);
         TVAL[j] += D[i][j] == 0;
      }
   }
   for( i=0;i<N;i++){
      list[i].poz = i+1;
      for( j=0;j<T;j++){
         if( D[i][j] == 1 )
            list[i].poene += TVAL[j] , list[i].solved ++;
      }
   }
   sort(list , list + N );
   for( i=0;i<N;i++){
      if( list[i].poz == P ) break;
   }
   printf("%d %d\n",list[i].poene,i+1);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<math.h>
#include<cstdlib>
#include<string.h>
using namespace std;

const int MAXN = 55;
const long long inf = (int)10e15;
int cok[MAXN][MAXN];
int DP[MAXN][MAXN];

inline int Get_Reckt( int x1 , int y1 , int x2 , int y2 ){
   return DP[y1-1][x1-1] + DP[y2][x2] - DP[y1-1][x2] - DP[y2][x1-1];
}

long long MEM[MAXN][MAXN][MAXN][MAXN];

long long rek( int x1 , int y1 , int x2 , int y2 ){
   if( MEM[x1][y1][x2][y2] != -1 )return MEM[x1][y1][x2][y2];
   if( x1==x2 && y1==y2  )return 0;

   long long sol = inf,d1;
   for( int i = x1 ; i<x2 ;i++){
       d1 = rek( x1 , y1 , i , y2 ) + rek( i+1,y1, x2,y2 ) + Get_Reckt(x1,y1,i,y2) + Get_Reckt(i+1,y1,x2,y2);
       if( d1 < sol ) sol = d1;
   }
   for( int i = y1 ; i<y2 ; i++ ){
      d1 = rek( x1 , y1 , x2 , i ) + rek( x1 , i+1 , x2,y2 ) + Get_Reckt( x1,y1,x2,i) + Get_Reckt(x1,i+1,x2,y2);
      if( d1 < sol ) sol = d1;
   }
   return (  MEM[x1][y1][x2][y2] = sol );

}

int main(){
 //  freopen("Ulaz.txt","r",stdin);
   memset(MEM,-1,sizeof(MEM));
   int N,M,i,j;
   scanf("%d%d",&N,&M);
   for(i=1;i<=N;i++)
      for(j=1;j<=M;j++)
         scanf("%d",&cok[i][j]);
   int sumNew;
   for(i=1;i<=N;i++){
      sumNew =0;
      for(j=1;j<=M;j++){
         DP[i][j] += DP[i-1][j] + cok[i][j]+sumNew;
         sumNew += cok[i][j];
      }
   }
   cout<<rek( 1,1,M,N)<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<math.h>
#include<queue>
#include<cstdlib>
#include<algorithm>
using namespace std;

#define f first
#define s second

const short inf = 9999;
int n,m,source,sink;
bool visited[2055];
short cap[2055][2055] , prev[2050];
vector<int>graph[2055];

int find_flow(){
   memset(visited,0,sizeof(visited));
   priority_queue< pair<short,pair<int,int> > >PQ;
   int sz;
   pair<short,pair<int,int> >p;
   PQ.push( make_pair(inf,make_pair(source,-1) ) );
   int min_cap = inf;
   while(!PQ.empty()==true){
      p = PQ.top();PQ.pop();
      prev[ p.s.f ] = p.s.s;
      if( p.s.f == sink ){
         min_cap = p.f;
         break;
      }
      visited[p.s.f] = true;
      sz = graph[p.s.f].size();
      for( int i=0 ; i<sz;i++){
         if( visited[ graph[p.s.f][i] ] == false && cap[p.s.f][ graph[p.s.f][i] ] > 0 )
            PQ.push( make_pair( min(p.f,cap[p.s.f][ graph[p.s.f][i] ])  , make_pair( graph[p.s.f][i] , p.s.f ) ) );
      }
   }
   if( min_cap == inf )return -inf;
   int it = sink;
   while( prev[it] != -1 ){
      cap[ prev[it] ][it] -= min_cap;
      cap[it][ prev[it] ] += min_cap;
      it = prev[it];
   }
   return min_cap;
}

int maxflow(){
   int sol = 0;
   while(true){
      int path = find_flow();
      if( path == -inf )
         return sol;
      else
         sol += path;
   }
}

int main(){
   int i,j,k,b;
   scanf("%d%d",&n,&m);
   source = n+m , sink = n+m+1;
   for(i=0;i<n;i++){
      graph[source].push_back(i); cap[source][i] = 1;
      scanf("%d",&k);
      for(j=0;j<k;j++){
         scanf("%d",&b);
         graph[i].push_back(n+b-1); cap[i][n+b-1] = 1;
         graph[n+b-1].push_back(i); cap[n+b-1][i] = 0;
      }
   }
   for(i=0;i<m;i++){
      graph[n+i].push_back(sink);
      cap[n+i][sink] = 1;
   }
   printf("%d\n",maxflow());
   return 0;
}

#include<cstdio>
#include<math.h>
int main(){
   int a;
   scanf("%d",&a);
   printf("%d\n",(int)(ceil(a/2.0)+1)*(a/2+1));
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<math.h>
#include<cstdlib>
#include<iomanip>
#include<queue>
#include<algorithm>
using namespace std;

#define f first
#define s second

struct event{
   int top;
   int time;
   bool type;
   event( int a , int b , bool c ):time(a),top(b),type(c){};
   event(){};
   bool operator<( const event &e2 ) const {
      return time < e2.time;
   }
};

int sol[100006];
bool poped[100006];
vector<event>V;

int main(){
   int tests,N,i;
   int a,b,now;
   scanf("%d",&tests);
   for( ; tests ; tests-- ){
      scanf("%d",&N);
      V.clear();
      for( i = 0 ; i < N ; i ++ ){
         scanf("%d%d",&a,&b);
         V.push_back( event(a-1,i,0) );
         V.push_back( event(b,i,1) );
         poped[i] = false , sol [ i ] = 0;
      }
      sort(V.begin(),V.end());
      now = V[0].time;
      priority_queue< int >PQ;
      PQ.push(V[0].top);
 
      for(i=0;i<2*N;i++){                  
         if( PQ.empty()==true ){
            if( V[i].type == 1 )poped[V[i].top]=true;
            else{
               now = V[i].time;
               PQ.push( V[i].top );
            }continue;
         }else if( poped[PQ.top()] ){
            i--;
            PQ.pop();
            continue;
         }
      
         if( V[i].type == 0 ){
            sol[PQ.top()] += V[i].time - now;
            now = V[i].time;
            PQ.push( V[i].top );
         }else{
            poped[ V[i].top ] = true;
            sol[ PQ.top() ] += V[i].time - now;
            now = V[i].time;
         }
      }
      int cnt = 0;
      for(i=0;i<N;i++)
         if( sol[i] > 0 )cnt++;
      printf("%d\n",cnt);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<cstdlib>
#include<math.h>
#include<iomanip>
#include<stack>
using namespace std;

int n,m;
vector<int>graph[5005];
bool visited[5005];
int low_id[5005];
int id[5005];
bool in_stack[5005];
stack<int>S;

int newn = 0;
int in_group[5005];
vector<int>groups[5005];
bool not_valid[5005];

int scc_counter;
void SCC( int node ){
   visited[node] = low_id[node] = id[node] = scc_counter++;
   S.push(node);
   in_stack[node] = true;
   for( int i=0;i<graph[node].size();i++){
      if( visited[ graph[node][i] ] == false ){
         SCC( graph[node][i] );
         low_id[node] = min( low_id[node],low_id[graph[node][i]] );
      }else if( in_stack[ graph[node][i] ]==true && id[ graph[node][i] ]<id[node] ){
         low_id[node] = min( low_id[node],id[graph[node][i]] );
      }
   }
   if( low_id[node] == id[node] ){
      while( S.empty() == false && id[ S.top() ]>= id[node] ){
         in_stack[S.top()]= false;
         in_group[S.top()] = newn;
         groups[newn].push_back(S.top());
         S.pop();
      }
      newn++;
   }
   
}

void tarjan(){
   for( int i=1;i<=n;i++){
      if( visited[i] == false ) 
         SCC(i);
   }
}

int main(){
   int i,j,k,a,b;
   while(true){
      scanf("%d",&n);
      if(!n)break;
      scc_counter = 1 , newn = 0;
      for(i=0;i<=n;i++){
         graph[i].clear();
         groups[i].clear();
         visited[i] = false;
         low_id[i] = id[i] = in_stack[i] = not_valid[i] = in_group[i] =  0;
      }
      scanf("%d",&m);
      for(i=0;i<m;i++){
         scanf("%d%d",&a,&b);
         graph[a].push_back(b);
      }
      tarjan();
      
      for(i=0;i<newn;i++)
         if( not_valid[ i ] == false )
            for(j=0;j<groups[i].size() && !not_valid[i] ;j++)
               for(k=0;k<graph[ groups[i][j] ].size() && !not_valid[i];k++)
                  if( in_group[ graph[groups[i][j]][k] ] != i )
                     not_valid[i] = true;
      for(i=1;i<=n;i++)
         if( not_valid[ in_group[i] ] == false)
            printf("%d ",i);
      printf("\n");
      
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<math.h>
#include<vector>
#include<cstdlib>
#include <cassert>
using namespace std;

const long long MOD = 1000000007 ;
char str[100005];
int idx[28];

int main(){
   int tests,i,j,k;
   scanf("%d",&tests);
   for( ; tests; tests-- ){
      scanf("%s",str);
      for(i=0;i<27;i++)idx[i] = 1;
      int len = strlen(str);
      long long ans(1);
      for( i = len-1 ; i>=0 ;i-- ){
         k = str[i] - 'A';
         ans = (ans+idx[k])%MOD;
         int tmp = idx[k];
         for( j=0;j<27;j++ )
           idx[j] = (idx[j]+tmp)%MOD;
         idx[ k ] = tmp;
      }
      cout<<ans<<endl;
   }
   return 0;
}

#include<cstdio>
#include<cstring>
int N;
const int MOD = 10000;
const int PRIME = 4919;

inline int get_key( char *str ){
   int len = strlen(str);
   int ret = 0 ;
   for( int i = 0 ; i < len ; i++ )
      ret = ( ret*PRIME + str[i] ) % MOD; 
   return ret;
}

int path[10005];
int kg[500];
bool hasIN[10005];
bool hasOUT[10005];
char str[1000][10000];
int hash[MOD+5];

int main(){
   int tests,i,j,a,b,ka,kb,cnt = 1;;
   scanf("%d",&tests);
   for( int t=1 ; t<=tests ; t++ ){
      scanf("%d",&N);
      for( i=0;i<=MOD;i++)hasIN[i] = hasOUT[i] = 0,path[i]=-1;
      
      for( i=1;i<=N*2-2;i++){
         scanf("%s",str[i]);
         if( i%2==0 ){
            ka = get_key(str[i-1]) , kb = get_key(str[i]);
            hash[ka] = i-1 , hash[kb] = i;
            kg[i-1] = ka , kg[i] = kb;
            path[ka] = kb;
            hasIN[kb] = true;
            hasOUT[ka] = true;
         }
      }
      int start = 0;
      for( i=1;i<=N*2-2 && !start;i+=2 )
         if( hasIN[ kg[i] ] == false )start = i;
      printf("Scenario #%d:\n",t);
      while( start != -1 ){
         printf("%s\n",str[start]);
         if( hasOUT[ kg[start] ] == false )break;
         start = hash[path[kg[start]]];
      }
      printf("\n");
   }
   return 0;
}

#include<cstdio>
#include<iostream>
using namespace std;

int N,H;
char mx[21][21];
long long sol,DP[1048580][2],gotMel;

int main(){
   int i,j,k;
   scanf("%d%d",&N,&H);
   for(i=0;i<N;i++)scanf("%s",mx[i]);
   memset(DP,-1,sizeof(DP));
   for(i=0;i<N;i++)if(mx[0][i]=='1')gotMel |=1<<i, sol++;
   for(i=0;i<H-1;i++){
      int new_melon = 0;
      for(j=0;j<N;j++)
         for(k=0;k<N;k++)
             if( mx[j][k] == '1' ){
                 if( gotMel&(1<<j) ){new_melon^=(1<<k) , sol++; }
                 else {sol+=2; }
             }
      gotMel = new_melon;
      if( DP[gotMel][0] != -1 ){
         long long diff = sol-DP[gotMel][1] , dist = i-DP[gotMel][0];
         int div = (H-i-2)/dist;
         sol += diff*div , i += dist*div;
      }else
         DP[gotMel][0] = i , DP[gotMel][1] = sol;
   }
   cout<<sol<<endl;
   return 0;
}

// 0  = LASSER IDE VERTIKALNO
// 1  = LASER IDE HORIZONTALNO

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<queue>
#include<iomanip>
using namespace std;

#define f first
#define s second

struct trio{
   int type,x,y;
   trio( int p1,int p2,int p3):type(p1),x(p2),y(p3){};
   trio(){};
};

struct duo{
   int x,y;
   duo( int p1,int p2):x(p1),y(p2){};
   duo(){};
};

int H,W;
const int inf = 999999;
char mx[105][105];
int dist[4][105][105];
vector<duo>cows;

int main(){
   // FILE *in = fopen("Ulaz.txt","r");
   int i,j;
   scanf("%d%d",&W,&H);
   for(i=0;i<H;i++){
      scanf("%s",&mx[i]);
      for(j=0;j<W;j++){
         dist[0][i][j] = dist[1][i][j] = inf;
         if( mx[i][j] == 'C' )cows.push_back( duo(j,i) );
      }
   }
   memset(dist,-1,sizeof(dist));
   trio u;
   queue<trio>Q;
   int nx,ny,nmp;
   
   
   bool ok = true ,ok1 = true;
   dist[0][cows[0].y][cows[0].x] = dist[1][cows[0].y][cows[0].x] = inf;

   for(i=1;i<=W && (ok || ok1);i++){
      if( cows[0].x+i<W && ok && mx[cows[0].y][cows[0].x+i]!='*' ){
         Q.push( trio(0,cows[0].x+i,cows[0].y) );
         dist[0][cows[0].y][cows[0].x+i] = 1;
      }else ok = false;
      
      if( cows[0].x-i>=0 && ok1 && mx[cows[0].y][cows[0].x-i]!='*' ){
         Q.push( trio(0,cows[0].x-i,cows[0].y) );
         dist[0][cows[0].y][cows[0].x-i] = 1;
      }else ok1 = false;
   }
   
   
   ok = ok1 = true;
   for(i=1;i<=H && (ok || ok1);i++){
      if( cows[0].y+i<H && ok && mx[cows[0].y+i][cows[0].x]!='*' ){
         Q.push( trio(1,cows[0].x,cows[0].y+i) );
         dist[1][cows[0].y+i][cows[0].x] = 1;
      }else ok = false;
      
      if( cows[0].y-i>=0 && ok1 && mx[cows[0].y-i][cows[0].x]!='*' ){
         Q.push( trio(1,cows[0].x,cows[0].y-i) );
         dist[1][cows[0].y-i][cows[0].x] = 1;
      }else ok1 = false;
   }
   
   while(!Q.empty()){
      u = Q.front();Q.pop();
    //  cout<<"NODE: "<<u.x<<" "<<u.y<<" = "<<dist[u.type][u.y][u.x]<<" "<<u.type<<endl;
      if( u.type == 0 ){
         ok = ok1 = true;
         for(i=1;i<=H && (ok || ok1);i++){
            if(u.y+i<H && ok && dist[1][u.y+i][u.x]==-1 && mx[u.y+i][u.x]!='*' ){
               Q.push( trio(1,u.x,u.y+i) );
               dist[1][u.y+i][u.x] = dist[0][u.y][u.x] + 1;
            }else ok = false;
            
            if( u.y-i>=0 && ok1 && dist[1][u.y-i][u.x]==-1 && mx[u.y-i][u.x]!='*' ){
               Q.push( trio(1,u.x,u.y-i) );
               dist[1][u.y-i][u.x] = dist[0][u.y][u.x] + 1;
            }else ok1 = false;
         }
      }else{
         ok = ok1 = true;
         for(i=1;i<=W && (ok || ok1);i++){
            if( u.x+i < W && ok && dist[0][u.y][u.x+i]==-1 && mx[u.y][u.x+i]!='*' ){
               Q.push( trio(0,u.x+i,u.y) );
               dist[0][u.y][u.x+i] = dist[1][u.y][u.x] + 1;
            }else ok = false;
            
            if( u.x-i>=0 && ok1 && dist[0][u.y][u.x-i]==-1 && mx[u.y][u.x-i]!='*' ){
               Q.push( trio(0,u.x-i,u.y) );
               dist[0][u.y][u.x-i] = dist[1][u.y][u.x] + 1;
            }else ok1 = false;
         }
      }
   }
   if( dist[0][cows[1].y][cows[1].x]!=-1 && dist[1][cows[1].y][cows[1].x]!=-1 )printf("%d\n",min(dist[0][cows[1].y][cows[1].x],dist[1][cows[1].y][cows[1].x])-1 );
   else printf("%d\n",max(dist[0][cows[1].y][cows[1].x],dist[1][cows[1].y][cows[1].x])-1 );
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<string.h>
#include<math.h>
#include<iomanip>
#include<set>
using namespace std;

#define f first
#define s second


int N,a,b,sol(0);
vector< pair<int,int> > V;
set< int >S;
set< int >::iterator it;

int main(){
   int tests;
   scanf("%d",&tests);
   for( ; tests ; tests-- ){
      scanf("%d",&N);
      sol = 0;
      V.clear();
      S.clear();
      for( int i=0; i<N; ++i ){
         scanf("%d%d",&a,&b);
         V.push_back( make_pair(a,b) );
      }
      sort(V.begin(),V.end());
      S.insert(-1);
      for( int i=0; i<N; ++i ){
         it = S.lower_bound( V[i].s );
         if( it == S.end() || *it != V[i].s )it--;
         if( *it == -1){
            S.insert( V[i].s );
            sol++;
         }else{
            S.erase(it);
            S.insert(V[i].s);
         }
      }
      printf("%d\n",sol);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<vector>
#include<iomanip>
#include<set>
#include<algorithm>
using namespace std;

#define f first
#define s second
#define mk make_pair

int N;
vector<int>tmp;
vector<pair<int,int> >V;
multiset<int>S1;
multiset<int>::iterator it;

int main(){
   int tests,a,b;
   scanf("%d",&tests);
   for( ; tests ; tests-- ){
      scanf("%d",&N);
      V.clear();
      for( int i=0; i<N; ++i ){
         scanf("%d%d",&a,&b);
         V.push_back( mk(a,b) );
      }
      sort(V.begin(),V.end());
      tmp.clear();
      S1.clear();
      S1.insert(-1);
      int sol = 0;
      for( int i=0; i<N; ++i ){
        
         if( i>0 && V[i].f != V[i-1].f ){
             for( int j=0; j<tmp.size(); ++j )
                S1.insert( tmp[j] );
             tmp.clear();
         }
         
         it = S1.lower_bound( V[i].s );
         it--;
         if( *it == -1 ){
            sol++;
            tmp.push_back( V[i].s );
         }else{
            S1.erase(it);
            tmp.push_back( V[i].s );
         }
      }
      printf("%d\n",sol);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<iomanip>
#include<queue>
using namespace std;

#define f first
#define s second

const int inf = 999999;
int n,a,b,c;
char mx[55][55];
int DP[55][55][55];

inline pair<int,pair<int,int> > make_trio( int a , int b , int c ){
   return make_pair( a ,make_pair(b,c) );
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
   int i,j,k,l,m;
   while(true){
      scanf("%d",&n);
      if( n==0 )break;
      scanf("%d%d%d",&a,&b,&c);
      for(i=0;i<n;i++)for(int j=0;j<n;j++)cin>>mx[i][j];
      memset(DP,-1,sizeof(DP));
      queue< pair<int, pair<int,int> > >Q;
      pair<int, pair<int,int> > u;
      DP[a-1][b-1][c-1] = 0;
      Q.push( make_trio(a-1,b-1,c-1) );
      int p1,p2,p3;
      bool ok = false;
      while(!Q.empty()==true ){
         u = Q.front();Q.pop();
         p1 = u.f , p2 = u.s.f , p3 = u.s.s;
         if( p1 == p2 && p2 == p3 ){
            ok = true;
            break;
         }
         for(i=0;i<n;i++)if( DP[i][p2][p3] == -1 && mx[p1][i] == mx[p2][p3] ){
            DP[i][p2][p3] = DP[p1][p2][p3]+1;
            Q.push( make_trio(i,p2,p3) );
         }
         for(i=0;i<n;i++)if( DP[p1][i][p3] == -1 && mx[p2][i] == mx[p1][p3] ){
            DP[p1][i][p3] = DP[p1][p2][p3]+1;
            Q.push( make_trio(p1,i,p3) );
         }
         for(i=0;i<n;i++)if( DP[p1][p2][i] == -1 && mx[p3][i] == mx[p1][p2] ){
            DP[p1][p2][i] = DP[p1][p2][p3]+1;
            Q.push( make_trio(p1,p2,i) );
         }
      }
      if( ok )printf("%d\n",DP[p1][p2][p3] );
      else printf("impossible\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<cstdlib>
#include<math.h>
using namespace std;

int N,sol,vs;
vector<short>V;
char mx[9][9];

int in_queue;
int visited;

int DP[300][300];

int solve(){
   if( DP[visited][in_queue] != -1 )return DP[visited][in_queue];
   bool ok;
   int node = -1 , i ,j , visi=0;
   for( i=0;i<N;i++ ){
     if( node==-1 && in_queue&(1<<i) ){
        node = i;
        break;
     }
     visi += bool(visited & (1<<i) );
   }
   int sl = 0;
   if( node!=-1 ){
      in_queue ^= 1<<node;
      for( i=0;i<vs;i++){
         ok = true;
         for(j=0;j<N && ok;j++){
            if( V[i]&(1<<j) && (visited&(1<<j) || mx[node][j]=='0') )
               ok = false;
         }
         if( ok ){
            for(j=0;j<N;j++)if(V[i]&(1<<j) )visited |=1<<j , in_queue |=1<<j;
            int g = solve();
            sl += g;
            DP[visited][in_queue] = g;
            for(j=0;j<N;j++)if(V[i]&(1<<j) )visited ^=1<<j , in_queue ^=1<<j;
         }
      }
      in_queue |= 1<<node;
   }else if(visi==N){
      return 1;
   }
   return (DP[visited][in_queue] = sl);
}



int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
   int i,j;
   while(true){
      scanf("%d",&N);
      if(N==0)break;
      V.clear();
      V.push_back(0);
      for(i=0;i<N;i++){
         vs = V.size();
         for(j=0;j<vs;j++)
            V.push_back( V[j] | (1<<i) );
      }
      vs = V.size();
      for(i=0;i<N;i++)scanf("%s",mx[i]);
      sol = 0;
      visited = 0, in_queue = 0;
      memset(DP,-1,sizeof(DP));
      for(i=0;i<N;i++){
         in_queue|= 1<<i;
         visited |= 1<<i;
         sol += solve();
         in_queue^= 1<<i;
         visited ^= 1<<i;
      }
      cout<<sol<<endl;
   }
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<string>
#include<iomanip>
#include<vector>
#include<queue>
#include<stack>
#include<set>
#include<map>
using namespace std;

map< pair<string,int>,int>M;
set<string>teams[27];
int AC[27];
int AVR[27];


int main(){        
   int N,tests;
   int time;string team,task,sol;
   scanf("%d",&tests);
   for( ; tests ; tests-- ){
       memset(AC,0,sizeof(AC));
       memset(AVR,0,sizeof(AVR));
       M.clear();
       for( int i = 0; i<27 ; ++i)teams[i].clear();
                      
       scanf("%d",&N);
       for( int i =0 ; i < N ; i ++ ){
          cin>>time>>team>>task>>sol;
          if( teams[task[0]-'A'].count( team ) )continue;
          M[ make_pair(team,task[0]-'A') ]++;
          if( sol[0] == 'A' ){
             AVR[task[0]-'A']+=time;
             teams[task[0]-'A'].insert(team);
             AC[task[0]-'A']++;
          }
       }
       set<string>::iterator it;
       for( int i = 0;i<='I'-'A';i++){
          int cnt = AC[i];
          int subs = 0;
          for( it = teams[i].begin() ; it!=teams[i].end();it++ ){
             subs += M[ make_pair(*it,i) ];
          }
          if( AC[i]!=0 )
             printf("%c %d %.2f %.2f\n",'A'+i,cnt,((double)(subs))/cnt,((double)(AVR[i]))/cnt );
          else
             printf("%c 0\n",'A'+i);
       }
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<string>
#include<iomanip>
#include<vector>
#include<queue>
#include<stack>
#include<set>
#include<map>
#include<string.h>
using namespace std;

#define f first
#define s second

int n;
char buff[250005];
set< pair<int,int> >H[500095];
set< pair<int,int> >W[500095];
pair<int,int>now(250008,250008);
int lens=9999998 , idxs , idxe; char d;

inline void isGood(int len , int s , int e , char w ){
   if( lens > len ){
      lens = len , idxs = s , idxe = e , d = w;
      return;
   }
   if( lens == len && s<idxs ){
      lens = len , idxs = s , idxe = e , d = w;
      return;
   }
   if( lens == len && s==idxs && e>idxe ){
      lens = len , idxs = s , idxe = e , d = w;
      return;
   }
}

int main(){
   int tests;
   scanf("%d",&tests);
   while(tests--){
       now = make_pair(250008,250008);
       lens = 9999998;
       for( int i=0;i<=500050;i++){H[i].clear();W[i].clear();}
       scanf("%d%s",&n,buff);
       int len = strlen(buff) , diff;
       set< pair<int,int> >::iterator lo, hi;
       for(int i=0;i<=len;i++){
          H[ now.s ].insert( make_pair(now.f,i) );
          W[ now.f ].insert( make_pair(now.s,i) );
          if( i>0 ){
             lo = H[now.s].lower_bound( now );lo--;lo--;
             hi = H[now.s].upper_bound( now );

             if( lo != H[now.s].end() && lo->f < now.f && buff[i-1]!='E'){
                diff = lo->f-now.f; diff = abs(diff);
                isGood( diff , lo->s , i , 'E');
             }
             if( hi != H[now.s].end() && hi->f > now.f && buff[i-1]!='W' ){
                diff = hi->f-now.f; diff = abs(diff);
                isGood( diff , hi->s , i , 'W');  
             }
             lo = W[now.f].lower_bound( make_pair(now.s,now.f) );lo--;lo--;
             hi = W[now.f].lower_bound( make_pair(now.s,now.f) );
         
             if( lo!= W[now.f].end() && lo->f < now.s && buff[i-1]!='N'){
                diff = lo->f-now.s; diff = abs(diff);
                isGood( diff , lo->s , i , 'N' );
             } 
             if( hi!= W[now.f].end() && hi->f > now.s && buff[i-1]!='S'){
                diff = hi->f-now.s; diff = abs(diff);
                isGood( diff , hi->s , i , 'S' );
             } 
          }
        // cout<<i<<": "<<lens<<" "<<idxs<<" "<<idxe<<" "<<d<<endl;
        if( i==len)break;
        if( buff[i] == 'N' ) now.s++;
        else if( buff[i] == 'S' ) now.s--;
        else if( buff[i] == 'E' ) now.f++;
        else now.f--;
        //cout<<endl;
      } 
      cout<<lens<<" "<<idxs<<" "<<idxe<<" "<<d<<endl;
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<string>
#include<iomanip>
#include<vector>
#include<queue>
#include<stack>
#include<set>
#include<map>
using namespace std;

map< pair<string,int>,int>M;
set<string>teams[27];
int AC[27];
int AVR[27];


int main(){
   int N;
   int time;string team,task,sol;
   scanf("%d",&N);
   for( int i =0 ; i < N ; i ++ ){
      cin>>time>>team>>task>>sol;
      if( teams[task[0]-'A'].count( team ) )continue;
      M[ make_pair(team,task[0]-'A') ]++;
      if( sol[0] == 'A' ){
         AVR[task[0]-'A']+=time;
         teams[task[0]-'A'].insert(team);
         AC[task[0]-'A']++;
      }
   }
   set<string>::iterator it;
   for( int i = 0;i<='I'-'A';i++){
      int cnt = AC[i];
      int subs = 0;
      for( it = teams[i].begin() ; it!=teams[i].end();it++ ){
         subs += M[ make_pair(*it,i) ];
      }
      if( AC[i]!=0 )
         printf("%c %d %.2f %.2f\n",'A'+i,cnt,((double)(subs))/cnt,((double)(AVR[i]))/cnt );
      else
         printf("%c 0\n",'A'+i);
   }

   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<string>
#include<iomanip>
#include<vector>
#include<queue>
#include<stack>
#include<set>
#include<map>
#include<string.h>
using namespace std;

#define f first
#define s second

int n;
char buff[250005];
vector<  set< pair<int,int> >  >H;
vector<  set< pair<int,int> >  >W;
pair<int,int>now(250008,250008);
int lens=9999998 , idxs , idxe; char d;

map<int,int>hashH , hashW;

inline void isGood(int len , int s , int e , char w ){
   if( lens > len ){
      lens = len , idxs = s , idxe = e , d = w;
      return;
   }
   if( lens == len && s<idxs ){
      lens = len , idxs = s , idxe = e , d = w;
      return;
   }
   if( lens == len && s==idxs && e>idxe ){
      lens = len , idxs = s , idxe = e , d = w;
      return;
   }
}

short cntH[500005],cntW[500005];

int main(){
   // FILE *in = fopen("Ulaz.txt","r");
   //freopen("Ulaz.txt","r",stdin);
   //freopen("Izlaz.txt","w",stdout);
       now = make_pair(250008,250008);

       scanf("%d%s",&n,buff);
       int len = strlen(buff) , diff;
       set< pair<int,int> >::iterator lo, hi;
       int cntX = 1 , cntY = 1 , XN, YN;
       H.clear();W.clear();
       H.push_back( set< pair<int,int> >() ); W.push_back( set< pair<int,int> >() );
       
       for(int i=0;i<=len;i++){
          cntH[ now.s]++;
          cntW[ now.f]++;
        if( i==len)break;
        if( buff[i] == 'N' ) now.s++;
        else if( buff[i] == 'S' ) now.s--;
        else if( buff[i] == 'E' ) now.f++;
        else now.f--;
      } 
      now = make_pair(250008,250008);
      
       
       for(int i=0;i<=len;i++){
            //   cout<<now.s<<","<<now.f<<" = "<<cntH[now.s]<<" "<<cntW[now.f]<<endl;
          if( cntH[now.s]>1 &&  hashH[ now.s ] == 0 ){
             hashH[ now.s ] = cntY++;
             H.push_back( set< pair<int,int> >() );
          }
          if( cntW[now.f]>1 && hashW[ now.f ] == 0 ){
             hashW[ now.f ] = cntX++;
             W.push_back( set< pair<int,int> >() );
          }
          XN = hashW[ now.f ] , YN = hashH[ now.s ];
          if( cntH[now.s]>1 )H[ YN ].insert( make_pair(now.f,i) );
          if( cntW[now.f]>1 )W[ XN ].insert( make_pair(now.s,i) );
          if( i>0 ){
             if( cntH[now.s] > 1 ){
                lo = H[YN].lower_bound( now );lo--;lo--;
                hi = H[YN].upper_bound( now );
                if( lo != H[YN].end() && lo->f < now.f && buff[i-1]!='E'){
                   diff = lo->f-now.f; diff = abs(diff);
                   isGood( diff , lo->s , i , 'E');
                }
                if( hi != H[YN].end() && hi->f > now.f && buff[i-1]!='W' ){
                   diff = hi->f-now.f; diff = abs(diff);
                   isGood( diff , hi->s , i , 'W');  
                }
             }
             
             if( cntW[now.f] > 1 ){
                lo = W[XN].lower_bound( make_pair(now.s,now.f) );lo--;lo--;
                hi = W[XN].lower_bound( make_pair(now.s,now.f) );
                if( lo!= W[XN].end() && lo->f < now.s && buff[i-1]!='N'){
                   diff = lo->f-now.s; diff = abs(diff);
                   isGood( diff , lo->s , i , 'N' );
                } 
                if( hi!= W[XN].end() && hi->f > now.s && buff[i-1]!='S'){
                   diff = hi->f-now.s; diff = abs(diff);
                   isGood( diff , hi->s , i , 'S' );
                } 
             }
          }
        // cout<<i<<": "<<lens<<" "<<idxs<<" "<<idxe<<" "<<d<<endl;
        if( i==len)break;
        if( buff[i] == 'N' ) now.s++;
        else if( buff[i] == 'S' ) now.s--;
        else if( buff[i] == 'E' ) now.f++;
        else now.f--;
        //cout<<endl;
      } 
      cout<<lens<<" "<<idxs<<" "<<idxe<<" "<<d<<endl;
      //system("Pause");
     
   return 0;
}

#include<iostream>
#include<vector>
#include<cstdio>
#include<algorithm>
#include<math.h>
#include<cstdlib>
#include<string>
using namespace std;

int chars,words,tests;
char W[5005][30];
char str[10000000];
bool has[50][200];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
   int i,j,k,g;
   scanf("%d%d%d",&chars,&words,&tests);
   for(i=0;i<words;i++)scanf("%s",W[i]);

   for(i=0;i<tests;i++){
      memset(has,0,sizeof(has));
      scanf("%s",str);
      g=0;
      for(j=0;j<strlen(str);j++){
         if( str[j]=='(' ){
            j++;
            while( str[j]!=')' )has[g][ str[j]-'a' ] = true,j++;
            g++;
         }else{
            has[g++][ str[j]-'a' ] = true;
         }
      }

      int sol = 0;
      for(j=0;j<words;j++){
         int len = strlen(W[j]);
         bool ok = true;
         for(k=0;k<len && ok;k++)ok = has[k][ W[j][k]-'a' ];
         sol += ok;
      }
      
      printf("Case #%d: %d\n",i+1,sol);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<math.h>
#include<cstdlib>
#include<iomanip>
#include<queue>
#include<stack>
#include<string>
using namespace std;
#define f first
#define s second

char num[255];
bool used[300];
int digits[300];

long long mypow( long long base , long long stp ){
   long long ret = 1;
   for( int i = 0 ; i < stp ; i ++ ){
      ret *= base;
   }
   return ret;
}

int main(){
   cout<<pow( (long long)(5) , (long long)(7) )<<endl;
   int tests;
   scanf("%d",&tests);

   for( int t = 1 ; t <= tests ; t++ ){      
      memset( digits, -1,sizeof(digits));
      memset(used,false,sizeof(used));
   
      scanf("%s",num);
      int i,j;
      long long cnt=1;
      bool ok;
      digits[ num[0] ] = 1; used['1'] = true;
      for(i=1;i<strlen(num);i++){
         ok = false;
         if( digits[ num[i] ] == -1 ){
            cnt++;
            for(j='0';j<='9' && ok == false;j++){
               if( used[j] == false ){
                  used[j] = true;
                  digits[ num[i] ] = j-'0';
                  ok = true;
               }
            }
            if( ok == false ){
               for(j='a';j<='z' && ok == false;j++){
                  if( used[j] == false ){
                     used[j] = true;
                     digits[ num[i] ] = (j-'a')+10;
                     ok = true;
                  }
               }
            }  
         }
      }
      if( cnt == 1 )cnt = 2;
      long long sol = 0;
      long long stp = mypow(cnt,strlen(num)-1);
      for(i=0;i<strlen(num);i++){
         sol += digits[ num[i] ]*stp;
         stp /= cnt;
      }
      cout<<"Case #"<<t<<": ";
      cout<<sol<<endl; 
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<math.h>
using namespace std;

int N;
double P[55][2];

inline double get_Sol(double A , double B , double C, double D){
   double ret = 0;
   for( int i=0; i<N; ++i ){
      double w = P[i][0]*P[i][0]*P[i][0]*A + P[i][0]*P[i][0]*B + P[i][0]*C + D;
      ret += (P[i][1] - w )*(P[i][1] - w );
   }
   return ret;
}

const int inf = 55555555;
const double lo_ = -100 , hi_ = +100;
double GetA(),GetB( double ),GetC( double,double ),GetD(double,double,double);
double solA,solB,solC,solD,solM=inf;

double sol1A,sol1B,sol1C,sol1D,sol1M=inf;
double sol2A,sol2B,sol2C,sol2D,sol2M=inf;
double sol3A,sol3B,sol3C,sol3D,sol3M=inf;

double xyz = 0.00001;
double adder = 0.00001;

double GetA(){
   double lo = lo_ , hi = hi_,v1,v2,mid,ret=inf;
   while( hi-lo>xyz ){
      mid = (lo+hi)/2;
      v1 = GetB( mid );
      
      sol1M = inf;
      v2 = get_Sol(mid+adder,sol1B,sol1C,sol1D);
    //  v2 = GetB( mid+xyz );
      ret = min( ret , v1 );
      if( v1 < v2 )
         hi = mid-xyz;
      else
         lo = mid+xyz;
   }
   return ret;
}
double GetB( double A ){
   double lo = lo_ , hi = hi_,v1,v2,mid,ret=inf;
   while( hi-lo>xyz ){
      mid = (lo+hi)/2;
      v1 = GetC( A, mid );
      
      sol2M = inf;
      v2 = get_Sol(sol2A,mid+adder,sol2C,sol2D);
      ret = min( ret , v1 );
      if( v1 < v2 )
         hi = mid-xyz;
      else
         lo = mid+xyz;
   }
   return ret;
}
double GetC( double A , double B ){
   double lo = lo_ , hi = hi_,v1,v2,mid,ret=inf;
   while( hi-lo>xyz ){
      mid = (lo+hi)/2;
      
      sol3M = inf;
      v1 = GetD( A, B , mid );
      
      sol3M = inf;
      v2 = get_Sol(sol3A,sol3B,mid+adder,sol3D);
      
      ret = min( v1,ret);
      if( v1 < v2 )
         hi = mid-xyz;
      else
         lo = mid+xyz;
   }
   return ret;
}
double GetD( double A , double B , double C ){
   double lo = lo_ , hi = hi_,v1,v2,mid,ret=inf;
   while( hi-lo>xyz ){
      mid = (lo+hi)/2;
      v1 = get_Sol( A, B , C , mid );
      v2 = get_Sol( A, B , C , mid+adder );
      ret = min( v1 , ret );
      if( v1 < solM ){
         solM = v1;
         solA = A , solB = B, solC = C, solD = mid;
      }
      if( v1 < sol3M )
         sol3M = v1 , sol3A = A , sol3B = B , sol3C = C , sol3D = mid;
      if( v1 < sol2M )
         sol2M = v1 , sol2A = A , sol2B = B , sol2C = C , sol2D = mid;
      if( v1 < sol1M )
         sol1M = v1 , sol1A = A , sol1B = B , sol1C = C , sol1D = mid;
         
      if( v1 < v2 )
         hi = mid-xyz;
      else
         lo = mid+xyz;
   }
   return ret;
}

int main(){
// FILE *in = fopen("Ulaz.txt","r");
   scanf("%d",&N);
   for( int i=0; i<N; ++i )scanf("%lf %lf",&P[i][0],&P[i][1]);
   double sol = GetA();
  // cout<<solA<<" "<<solB<<" "<<solC<<" "<<solD<<" = "<<solM<<endl;
   printf("%.2lf %.2lf %.2lf %.2lf\n",solA,solB,solC,solD);
//system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<fstream>
using namespace std;

const double PI = 2*acos(0);
int d1,d2,x,h;

inline double sqr( double v ){
   return v*v;
}

int main(){
   scanf("%d%d%d%d",&d1,&d2,&x,&h);
   
   double sol = 10000 , mid;
   for( double alfa = 0.01 ; alfa <= 89.99 ; alfa+=0.01 ){  
      mid = alfa * (2*PI)/360;
      double sinM = sin(mid);
      double cosM = cos(mid);
      double z =  ( d1 / cosM );
      double v = sqrt( sqr(z) - sqr(d1) );
      
      double v2 = x - v;;
      double z2 = sqrt( sqr(d2) + sqr(v2) );
      
      sol = min( z2 + h + z , sol );
   }
   printf("%.2lf\n",sol);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<math.h>
#include<cstdlib>
#include<iomanip>
#include<queue>
#include<algorithm>
using namespace std;

#define f first
#define s second


struct event{
   int top;
   float time;
   bool type;
   event( float a , int b , bool c ):time(a),top(b),type(c){};
   event(){};
   bool operator<( const event &e2 ) const {
      return time < e2.time;
   }
};

float sol[100006];
bool poped[100006];
vector<event>V;

int main(){
   int N,i;
   float a,b;
   scanf("%d",&N);
   for( i = 0 ; i < N ; i ++ ){
      scanf("%f%f",&a,&b);
      V.push_back( event(a,i,0) );
      V.push_back( event(b,i,1) );
   }
   sort(V.begin(),V.end());
   float now = V[0].time;
   priority_queue< int >PQ;
   PQ.push(V[0].top);

   for(i=0;i<2*N;i++){
                      
      if( PQ.empty()==true ){
         if( V[i].type == 1 )poped[V[i].top]=true;
         else{
            now = V[i].time;
            PQ.push( V[i].top );
         }
         continue;
      }else if( poped[PQ.top()] ){
         i--;
         PQ.pop();
         continue;
      }
      
      if( V[i].type == 0 ){
         sol[PQ.top()] += V[i].time - now;
         now = V[i].time;
         PQ.push( V[i].top );
      }else{
         poped[ V[i].top ] = true;
         sol[ PQ.top() ] += V[i].time - now;
         now = V[i].time;
      }
   }
   for(i=0;i<N;i++)
      printf("%.3f ",sol[i]);
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;

short niz[5];

int main()
{
   int i,j;
   for(i=0;i<5;i++)scanf("%d",&niz[i]);
   bool dalje = true;
   while(dalje)
   {
      dalje = false;
      for(i=0;i<4;i++)
         if( niz[i]>niz[i+1] ){
            swap(niz[i],niz[i+1]);
            for(j=0;j<5;j++)
               printf("%d ",niz[j]);printf("\n");
               dalje = true;
         }
   }
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<vector>
#include<math.h>
#include<string.h>
#include<algorithm>
using namespace std;

#define f first
#define s second

void rek();
void rek2(int);
void rek3(int);

int N;
string str[5];
int maxP = 0;

int loH = 0 , hiH , loW , hiW;

void rek( ){
   for( int i = 1; i<str[0].size()-1 ; ++i ){
      for( int j = 1; j<str[1].size()-1 ; ++j ){
         if( str[0][i] == str[1][j] ){
            loH = j;
            hiW = i;
            rek2( j );
         }
      }
   }
}

void rek2(int start){
    for( int i = start+1; i<str[1].size()-1; ++i ){
       for( int j = 1; j<str[2].size()-1; ++j ){
          if( str[1][i] == str[2][j] ){
             hiH = i;
             rek3( j );
          }
       }
    }
}

void rek3(int end ){
   for( int i = 1; i<end ; ++i ){
      for( int j = 1; j<str[3].size()-1; ++j ){
         if( str[2][i] == str[3][j] ){
            loW =  hiW-(end-i);
            if(  hiW-(end-i) > 0 && j-(hiH-loH) > 0 && hiH-loH<=j && str[0][hiW-(end-i)]==str[3][ j-(hiH-loH) ]  ){
               maxP = max( maxP , (hiW-loW-1)*(hiH-loH-1) );
            }
         }
      }
   }
}


int main(){
   cin>>N>>str[0]>>str[1]>>str[2]>>str[3];
   for( int i = 0 ; i < 2*3*4 ; i++ ){
      rek();
      next_permutation(str,str+4);
   }
   cout<<maxP<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
using namespace std;

int N,K;
int blocks[105][105];
int dp[105][105];

inline int get_reckt( int r1, int c1, int r2, int c2 ){
   return ( dp[r2][c2] - dp[r2][c1-1] - dp[r1-1][c2] + dp[r1-1][c1-1] );
}

int main(){
   scanf("%d%d",&N,&K);
   int sol = 0, r, c;
   for( int i = 0; i < K; ++i ){
      scanf("%d%d",&r,&c);
      if( blocks[r][c] == true )
         sol++;
      else 
         blocks[r][c] = true;
   }
   for( int i = 1; i <= N; ++i ){
      int cnt = 0;
      for( int j = 1; j <= N; ++j ){
         cnt += blocks[i][j];
         dp[i][j] = dp[i-1][j] + cnt;
      }
   }
   int h,w,maxBlcs(-1);
   for( int d = 1; d <= K; ++d ){
      if( K % d )continue;
      h = d , w = K / d;
      if( h > N || w > N )continue;
      for( int i = 1; i + h - 1 <= N; ++i ){
         for( int j = 1; j + w - 1 <= N; ++j ){
            maxBlcs = max( maxBlcs , get_reckt( i, j, i+h-1, j+w-1 )  );
         }
      }
   }
   printf("%d\n",(K-maxBlcs) );
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<vector>
#include<cstdlib>
using namespace std;


const int inf = 1000000005;
int niz[100005] , low[100005] , DP[100005];

int main(){
   int N,i,mid,lo,hi,tmp,sol=0;
   scanf("%d",&N);
   for(i=0;i<N;i++){ scanf("%d",&niz[i]); low[i] = inf; }
   low[N] = inf;
   for(i=0;i<N;i++){
      lo = 1, hi = i+1 , tmp = -inf;
      while(lo<=hi){
         mid = (lo+hi)/2;
         if( low[mid]<=niz[i]){
             tmp = mid+1;
             lo = mid+1;
         }else
             hi = mid-1;
      }
         DP[i] = lo;
         sol = max( sol , lo );
         low[ lo ] = min( low[lo], niz[i] );
   }
   printf("%d\n",sol);
   return 0;
}    

#include<cstdio>
#include<iostream>
#include<string.h>
using namespace std;

char str[50];
int sv[50][50];

int main(){
   scanf("%s",str);
   int i,gp=-1;
   for( i=0;i<strlen(str);i++){
      if( str[i] == '#' )
         gp++;
      else if( str[i] == 'O' )
         sv[gp][0]++;
      else
         sv[gp][1]++;
   }
   gp=-1;
   for( i=0;i<strlen(str);i++){
      if( str[i] == '#' ){
         gp++;
         printf("#");
      }else if( str[i] == 'O' ){
         if( sv[gp][0] > sv[gp][1] )
            printf("O");
      }else{
         if( sv[gp][0] <= sv[gp][1] )
            printf("V");
      }
   }printf("\n");
   return 0;
}

#include<iostream>
#include<vector>
#include<cstdio>
#include<math.h>
#include<fstream>
#include<cstdlib>
#include<set>
#include<queue>
#include<iomanip>
#include<cctype>
#include<string>
#include<stack>
#include<assert.h>
#include<climits>
using namespace std;

int main()
{
   int n,k,j,i;
   vector<bool>field(2000,true);
   vector<int>NotPrimes;
   scanf("%d%d",&n,&k);
   for(i=2;i<=n;i++)
   {
     if( field[i] )
     {
        NotPrimes.push_back(i);
        j=2;
        while(i*j<=n ){
           
           if( field[i*j] )NotPrimes.push_back(i*j);
           field[i*j]=false;
           j++;
        }
     }
   }
   printf("%d\n",NotPrimes.at(k-1));
   return 0;
}

#include<iostream>
#include<cstdio>
using namespace std;

int N;
int arr[100005][2];

bool ok( int kids ){
   long long nxt=0, now=0;
   for( int i=0; i<N; ++i ){
       now = arr[i][1] + nxt;
       nxt = 0;
       if( i == N-1 )break;
       if( now == kids )continue;
       else if( now > kids ){
          if( now-kids > arr[i+1][0]-arr[i][0] )
             nxt = (now-kids) - (arr[i+1][0]-arr[i][0]);
       }else{
          nxt = now-kids-(arr[i+1][0]-arr[i][0]);
       }
   }
   if( now-kids >= 0 )return true;
   else return false;
      
}

int main(){
   scanf("%d",&N);
   for( int i=0; i<N; ++i)scanf("%d%d",&arr[i][0],&arr[i][1]);
   int lo = 0 , hi = 1000000005 , mid , ans=-1;
   while( lo <= hi ){
      mid = (lo+hi)/2;
      if( ok(mid) )
         lo = mid+1 , ans = mid;
      else
         hi = mid-1;
   }
   printf("%d\n",ans);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<string.h>
#include<math.h>
#include<iomanip>
#include<set>
using namespace std;

#define f first
#define s second


int N,a,b,sol(0);
vector< pair<int,int> > V;
set< int >S;
set< int >::iterator it;

int main(){
   int tests;
   scanf("%d",&tests);
   for( ; tests ; tests-- ){
      scanf("%d",&N);
      sol = 0;
      V.clear();
      S.clear();
      for( int i=0; i<N; ++i ){
         scanf("%d%d",&a,&b);
         V.push_back( make_pair(a,b) );
      }
      sort(V.begin(),V.end());
      S.insert(-1);
      for( int i=0; i<N; ++i ){
         it = S.lower_bound( V[i].s );
         if( it == S.end() || *it != V[i].s )it--;
         if( *it == -1){
            S.insert( V[i].s );
            sol++;
         }else{
            S.erase(it);
            S.insert(V[i].s);
         }
      }
      printf("%d\n",sol);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<vector>
#include<math.h>
#include<queue>
using namespace std;

int n;
int niz[1005];
int takes[] = { 5 , 3 , 2 };

int cnt23 , cntB , cntX , cnt6;

inline bool IsX( int v ){
   if( v % 7 <= 1 )return true;
   return false;
}
inline bool Is6( int v ){
   if( v % 7 == 6 )return true;
   return false;
}
inline bool Is23( int v ){
   if( v % 7 == 2 || v % 7 == 3 )return true;
   return false;
}
inline bool IsB( int v ){
   return ( !IsX(v) && !Is23(v) );
}

void take( int val ){
   if( val <= 1 )return;
   if( Is23(val) )cnt23--;
   else if(  IsX(val)   )cntX--;
   else cntB--;
   if( Is6(val) )cnt6--;
}
void add( int val ){
   if( val <= 1 )return;
   if( Is23(val) )cnt23++;
   else if(  IsX(val)  )cntX++;
   else cntB++;
   if( Is6(val) )cnt6++;
}

int main(){
   int tests;
   scanf("%d",&tests);
   for( ; tests ; tests-- ){
      cnt23 = cntB = cntX = cnt6 = 0;
      scanf("%d",&n);
      for( int i=0; i<n; ++i)
         scanf("%d",&niz[i]);
         
      for( int i=0; i<n; ++i ){
         if( niz[i] == 1 )
            continue;
         else if( Is23(niz[i]) )
            cnt23++;
         else if(  IsX(niz[i]) )
            cntX++;
         else
            cntB++;
         if( Is6(niz[i]) )cnt6++;
      }
      int ansTake = -1 , ansIdx = 999999;
      for( int i=0; i<n; ++i ){
         for( int j=0; j<3; ++j ){
            if( niz[i] >= takes[j] ){
               take( niz[i] );
               add( niz[i] - takes[j] );
               bool OK = false;
               if (         
                     (cntB%2 ==0 && cnt6%2==0 && cnt23%2==0) ||
                     (cntB%2 ==0 && cnt6%2==1 && cnt23%2==1) 
                  )
                      OK = true;
               take( niz[i] - takes[j] );
               add( niz[i] );
               
               if( OK ){
                  if( takes[j] > ansTake )
                     ansTake = takes[j] , ansIdx = i;
               }
            }
         }
      }
      if( ansTake != -1 )
         printf("Julia wins.\nTake %d sticks from heap number %d.\n",ansTake,ansIdx+1);
      else
         printf("Robert wins.\n");
      printf("\n");
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<vector>
#include<math.h>
#include<queue>
using namespace std;

string buff,t2;
char solWorst[30];
int digits[30];
int cnt[10] , cntc[10];
int sol[30];

int main(){
   int T,t,d;
   freopen("Ulaz.txt","r",stdin);
  freopen("Izlaz.txt","w",stdout);
   scanf("%d",&T);
   for( int t = 1 ; t<=T; t++){
      memset(sol,0,sizeof(sol));
      memset(cnt,0,sizeof(cnt));
      memset(cntc,0,sizeof(cntc));
      memset(digits,0,sizeof(digits));
      memset(solWorst,0,sizeof(solWorst));
      cin>>buff;
      t2 = buff;
      for(int i=0;i<buff.size();i++)cnt[ buff[i]-'0' ]++ , digits[i] = buff[i]-'0';
      sort(buff.begin(),buff.end() );
      solWorst[0] = buff[0];
      solWorst[1] = '0';
      int di;
      for(int i=0;i<buff.size();i++){
         if( buff[i]!='0' ){ di = i;break;}
      }
      d=2;
      solWorst[0] = buff[di];
      solWorst[1] = '0';
      for(int i=0;i<buff.size();i++){
         if( i==di )continue;
         solWorst[d] = buff[i];d++;
      }                
      vector<string>V;
      string num;
      
      bool ok = false;
      bool solExist = false;
      for(int i=buff.size()-1; i>=0;i--){
           num = "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz";
         for( int j=digits[i]+1;j<10;j++){
            for( int k=0;k<10;k++) cntc[k] = cnt[k];
            cntc[j]--;sol[i] = j;
            num[i] = '0'+j;
            if( cntc[j]<0 )continue;
            bool getG = false;
            solExist = true;
            for( int l=0;l<buff.size() && solExist;l++){
               if( l==i ){getG=true;continue;}
               
               int m;
               if( getG==false)m=digits[l];
               else m = 0;
               for( ;m<10;m++){
                  if( cntc[m]==0 )continue;
                  cntc[m]--;
                  if( m>digits[l] )getG = true;
                  num[l] = '0'+m;
                  sol[l] = m;
                  break;
               }
               if( m==10 )solExist = false;
            }
            if( solExist ){
               V.push_back(num);
               ok  = true;
            }
         }
      }
      if( ok ){
         printf("Case #%d: ",t);
         sort(V.begin(),V.end());
         for(int i=0;i<buff.size();i++)
            cout<<V[0][i];cout<<endl;
      }else{
         printf("Case #%d: ",t);
         printf("%s\n",solWorst); 
      }
        
      
   }
   return 0;
}

#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

const int MOD = 1000000009;
int N;
int DP[10000][10][10][10];
bool isPrime[10][10][10];

bool prime( int v ){
   if( v%2 == 0 && v!=2 )return false;
   for( int i=3; i*i<=v ; i+=2 )
      if( v % i == 0 )return false;
   return true;
}

int solve( int idx, int p2, int p1 ){
   if( idx == N )return 1;
   int sol = 0, tmp;
   for( int i=1; i<=9; ++i ){
      if( isPrime[p2][p1][i] ){
         if( DP[idx][p2][p1][i] != -1 ){sol = (sol+DP[idx][p2][p1][i])%MOD; continue;}
         tmp = solve(idx+1,p1,i);
         DP[idx][p2][p1][i] = tmp;
         sol = (sol+tmp)%MOD;
      }
   }
   return sol;
}

int main(){
   for( int i=100; i<=999; ++i )
      if( prime(i) ){
            isPrime[ (i/100)%10 ][ (i/10)%10 ][ i%10 ] = true;
         }
      
   memset(DP,-1,sizeof(DP));
   scanf("%d",&N);
   int sol = 0;
   for( int i=1; i<=9; ++i ){
      for( int j=1; j<=9; ++j ){
         sol = (sol+solve( 2 , i , j ) )%MOD;
      }
   }
   printf("%d\n",sol);
   system("Pause");
   return 0;
}

#include<iostream>
// North, West, East, South.\
// Up , Left , Right , Down
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
#include<iomanip>
using namespace std;

const char empty = '*';
const int inf = 9999999;
int H,W;
int mx[105][105];
char sol[105][105];

inline int min4( int a , int b , int c , int d ){
   return min( a , min(b , min(c,d) ) );
}

bool add;
char flow( char sym , int x , int y , bool flow_down = true ){
   int mn = min4( x-1>=0?mx[y][x-1]:inf , x+1<W?mx[y][x+1]:inf , y-1>=0?mx[y-1][x]:inf, y+1<H?mx[y+1][x]:inf );
   if( flow_down && mn < mx[y][x] ){
      char ch;
      if( y-1>=0 && mx[y-1][x] == mn )ch = flow( sym , x , y-1 , true );
      else if( x-1>=0 && mx[y][x-1] == mn )ch = flow( sym , x-1 , y , true );
      else if( x+1<W  && mx[y][x+1] == mn )ch = flow( sym , x+1 , y , true );
      else if( y+1<H  && mx[y+1][x] == mn )ch = flow( sym , x , y+1 , true );
      sol[y][x] = ch;
      return ch;
   }else{
      if( sol[y][x] == empty ){sol[y][x] = sym; add = true; }
      else add = false;
      return sol[y][x];
   }
}

int main(){
   freopen("Ulaz.txt","r",stdin);
   freopen("Izlaz.txt","w",stdout);
   int tests,i,j;
   scanf("%d",&tests);
   for( int t = 1 ; t <= tests ; t++ ){
      scanf("%d%d",&H,&W);
      for(i=0;i<H;i++)
         for(j=0;j<W;j++){
            scanf("%d",&mx[i][j]);
            sol[i][j] = empty;
         }
      char c = 'a';
      for(i=0;i<H;i++){
         for(j=0;j<W;j++){
            if( sol[i][j] == empty ){
               flow( c , j , i );
               c+=add;
            }
         }
      }
      printf("Case #%d:\n",t);
      for(i=0;i<H;i++){
         for(j=0;j<W;j++){
            printf("%c ",sol[i][j]);
         }printf("\n");
      }
   }
   return 0;
}

// welcome to code jam
// w e l c o m t d j a 
// a c d e j l m o t w ' '
#include<iostream>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<algorithm>
#include<vector>
#include<iomanip>
#include<math.h>
using namespace std;

string str;
char sfind[] = "welcome to code jam\0";
int DP[600],mDP[600];

int main(){
   int tests,i,j;
   freopen("Ulaz.txt","r",stdin);
   freopen("Izlaz.txt","w",stdout);
   cin>>tests>>ws;
   for( int t = 1 ; t<=tests;t++){
      memset(DP,0,sizeof(DP));
      getline(cin,str);
      int lens = strlen(sfind) , len = str.size();
      int cnt = 0;
      for( i=0 ; i < len ; i++ ){
         if( str[i] == 'w' )cnt++;
         DP[i] = cnt;
      }
      for( i=1 ; i < lens ; i++ ){
         cnt = 0;
         for( j = 0 ; j < len ; j ++ ){
            if( str[j] == sfind[i] )
               cnt = (cnt+DP[j-1])%10000;
            mDP[j] = cnt;
         }
         for( j = 0 ; j < len ; j ++ )DP[j] = mDP[j];
      }
      printf("Case #%d: %.4d\n",t,DP[ len-1] );
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<math.h>
#include<iomanip>
#include<queue>
#include<string.h>
using namespace std;

int k1,k2,k3;
char str[3000];
char sol[3000];
int G1[3000],G2[3000],G3[3000];
int i1,i2,i3;

void rotate( deque<char> &Q , int k ){
   for( int i=0; i<k; ++i ){
      char u = Q.back(); Q.pop_back();
      Q.push_front(u);
   }
}

void set( deque<char>&Q , int *G , int sz ){
   for( int i=0; i<sz; ++i ){
      char u = Q.front(); Q.pop_front();
      sol[ G[i] ] = u;
   }
}

int main(){
   while(true){
      scanf("%d%d%d",&k1,&k2,&k3);
      if( k1 == 0 && k2 == 0 && k3 == 0 )break;
      i1 = i2 = i3 = 0;
      deque<char>Q1,Q2,Q3;
      scanf("%s",str);
      for( int i=0; i<strlen(str) ; ++i ){
         if( str[i]>='a' && str[i]<='i' ){
            G1[i1++] = i;
            Q1.push_back(str[i]);
         }else if( str[i]>='j' && str[i]<='r' ){
            G2[i2++] = i;
            Q2.push_back(str[i]);
         }else{
            G3[i3++] = i;
            Q3.push_back(str[i]);
         }
      }
      rotate( Q1 , k1 );
      rotate( Q2 , k2 );
      rotate( Q3 , k3 );
      
      set( Q1 , G1 , i1 );
      set( Q2 , G2 , i2 );
      set( Q3 , G3 , i3 );
      sol[ strlen(str) ] = '\0';
      printf("%s\n",sol);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdio>
#include<iomanip>
#include<string.h>
using namespace std;

int N,K;
char str[800008];

int main(){
   scanf("%d%d",&N,&K);
   scanf("%s",str);
   int cnt1(0),cnt0(0);
   int A(-1),B(-1);
   int len = strlen(str);
   int j=0;
   for( int i=0; i<len; ++i){
       if( str[i] == '1' )cnt1++;
       else cnt0++;
       
       for( ; j<len ; ++j ){
          if( str[j]=='0' && cnt0-1>=K )cnt0--;
          else if( str[j]=='1' && cnt1-1>=K )cnt1--;
          else break;
       }
       if( cnt0>=K && cnt1>=K && (A==-1 || B-A > i-j)  ){
          A = j , B = i;
       }
   }
   cnt0 = cnt1 = 0;
   if( A != -1 ){
      for( int i=A; i<=B; i++ ){
         if( str[i] == '1'){
            cnt1++;
            if( cnt1<=K )printf("%d ",i);
         }
         if( str[i] == '0' ){
            cnt0++;
            if( cnt0<=K )printf("%d ",i);
         }
      }
      printf("\n");
   }else{
      printf("-1\n"); 
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;

const int MAXN = 2020;
int N,M;
float niz[ MAXN ];
float BIT1[ MAXN ] , BIT2[ MAXN ];

void add( float *arr , int idx ,float v ){
   for( ; idx < MAXN ; idx+=idx&-idx )
      arr[idx] += v;
}

float read( float *arr , int idx ){
   float ret = 0;
   for( ; idx > 1 ; idx-=idx&-idx )
      ret += arr[idx];
   return ret;
}

float readI( float *arr , int a , int b ){
   if( b > N )b = N;
   return read( arr , b ) - read( arr , a-1 );
}

inline float ceil2( float v ){
   int g = (int)v;
   if( fabs( v - g )<0.01 )return v;
   else return ceil(v);
}
inline float floor2( float v ){
   int g = (int)v;
   if( fabs( v - g )<0.01 )return v;
   else return floor(v);
}

float DP[2020][2];

float sol( int idx , bool down ){
   if( idx == N+1 )return 0;
   float retA = 0,retB = 0;
   if( down ){
       if( DP[idx][down] >= 0 )return DP[idx][down];
       retA  = sol(idx+1,down )+  niz[idx]-floor2(niz[idx]);
       retB = sol( idx+M<=N?idx+M:N+1 , !down )   +   readI(BIT2,idx,idx+M-1);
   }else{
       if( DP[idx][down] >= 0 )return DP[idx][down];
       retA  = sol(idx+1,down )+  ceil2(niz[idx]) - niz[idx];
       retB  = sol( idx+M<=N?idx+M:N+1 ,!down)    +   readI(BIT1,idx,idx+M-1);
   }
   DP[idx][down] = max(retA,retB);
   return max(retA,retB);
}

int main(){
   float v;
   scanf("%d%d",&N,&M);
   for( int i=1; i<=N ; ++i ){
      scanf("%f",&niz[i]);
      DP[i][0] = DP[i][1] = -999;
      add( BIT1 , i , niz[i] - floor2(niz[i]) );
      add( BIT2 , i , ceil2(niz[i]) - niz[i]  );
   }
   float lo = sol( M+1 , true ) + readI(BIT1,1,M);
   float hi = sol( M+1 , false) + readI(BIT2,1,M);
   int sol = (int)round(max(lo,hi)*100);
   printf("%d\n", sol );
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<iomanip>
using namespace std;

long long DP[3][500005];

int main(){
   int N,gsb,gs,g,i,j;
   scanf("%d",&N);
   gsb = N/2 , gs = N/4 , g = N/6;
   DP[0][0] = DP[1][0] = 1;
   for( i=1;i<=gsb;i++){
      DP[0][i] = min(gs + 1,i+1);
      DP[1][i] = DP[0][i] + DP[1][i-1];
   }
   long long val = DP[1][gsb] , sol = 0;
   int gs2 = gs , minus = 0, fdelete = gsb;
   for( i=0;i<=g;i++){
      sol += val;
      minus = min(fdelete+1,gs+1) + (gsb-gs2);
      fdelete--,gs--;
      val-=minus;
   }
   cout<<sol<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<cstdlib>
#include<math.h>
#include<algorithm>
#include<vector>
using namespace std;

char cmd[20];
int users;
bool logged[2000005];
unsigned short id[2000005];
short solved[50005][6];
int cnt[606];

void get_medals(){
   int gg = users/6 , sg = users/4, bg = users/2 ,i;
   int g=0,s=0,b=0,count=0;
   for(i=600;i>=1;i--){
      count += cnt[i];
      if( count > gg )break;
      if( cnt[i-1] == 0 )g = count,i--;
      if( count == gg )break;
   }
   count=g;
   for(;i>=1;i--){
      count += cnt[i];
      if( count > sg )break;
      if( cnt[i-1] == 0 )s = count-g,i--;
      if( count == sg )break;
   }
   count=g+s;
   for(;i>=1;i--){
      count += cnt[i];
      if( count > bg )break;
      if( cnt[i-1] == 0 )b = count-g-s;
      if( count == bg )break;
   }
   printf("%d %d %d\n",g,s,b);
   //fflush(stdout);
}

int main(){
    int time_s = clock();
   int a,b,c,o,idc=0,i,j;
   while(true){
      scanf("%s",cmd);
      if( cmd[0] == 'd' )break;
      else if( cmd[0] == 'l' ){
         scanf("%d",&a);
         if( logged[a]==false ){
            cnt[0]++;
            id[a] = idc++;
            users++;
         }
         logged[a] = true;
         get_medals();
      }else if( cmd[0] == 's' ){
         scanf("%d%d%d",&a,&b,&c);
         o = 0;
         for( i=0;i<6;i++)o+=solved[ id[a] ][i];
         cnt[o]--;
         o = o-solved[ id[a] ][b-1] + c;
         solved[id[a]][b-1] = c;
         cnt[o]++;
         get_medals();
      }
      break;
   }
   return 0;
}

//5 1 10 5

//1 2 6
//1 4 8
//4 2 0
//2 3 3
//3 5 5
//4




#include<iostream>
#include<string.h>
#include<fstream>
#include<vector>
#include<math.h>
#include<queue>
#include<iomanip>
using namespace std;

#define mk make_pair
#define f first
#define s second

struct put{
   int B , cost;
   put( int p1 , int p2 ):B(p1),cost(p2){};
   put();
};


int N,D,L,M;
vector< put >G[105];
bool visited[104]; 
bool pumpa[105];

void dijkstra( int S , int E ){
   priority_queue< pair<int,pair<int,int> > , vector< pair<int,pair<int,int> >  > , greater<  pair<int,pair<int,int> >  >  >PQ;
   PQ.push( mk( 0 , mk(0,S) ) );
   pair<int,pair<int,int> > u;
   bool ok = false;
   while(!PQ.empty()){
      u = PQ.top() ; PQ.pop();
      if( visited[u.s.s] )continue;
      else visited[u.s.s] = true;
      
      if( u.s.s == E ){ ok = true; break; }
      if( pumpa[u.s.s] )u.s.f = 0;
      
      for( int i = 0; i < G[u.s.s].size(); ++i ){
         int dist = u.f + G[u.s.s][i].cost;
         if(  u.s.f+G[u.s.s][i].cost  <= L  && visited[G[u.s.s][i].B  ] == false)
            PQ.push( mk( dist , mk( u.s.f+G[u.s.s][i].cost , G[u.s.s][i].B ) ) );
      }
   }
   if( !ok )
      printf("-1\n");
   else
      printf("%d\n",u.f);
}


int main(){
   int a,b,c;
   scanf("%d%d%d%d",&N,&D,&L,&M);
   for( int i = 0; i<M ; ++i ){
      scanf("%d%d%d",&a,&b,&c);
      G[a].push_back( put(b,c) );
      G[b].push_back( put(a,c) );
   }
   for( int i = 0; i<D ; ++i ){
      scanf("%d",&a);
      pumpa[a] = true;
   }
   dijkstra( 1 , N );
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<string.h>
using namespace std;
 
//void print_bits( int v ){for( int i = 1 ; i <=32;i++){cout<<bool(v & (1<<(32-i)) )<<" ";}cout<<endl;}
 
const int CMB = 1<<20;
const int N = 20;
int K;
char buff[21][21];
int R[21],C[21];
int cnt[21];
int hash[CMB];
 
int main(){
    int i,j,left,tmp,sol(0),z=-1;
    scanf("%d",&K);
    for( i=0; i<N; ++i ){
       scanf("%s",buff[i]);
       for( j=0; j<N; ++j)if( buff[i][j]=='1' )C[j] |= 1<<i;
    }
    for( i=0; i<CMB ; ++i )hash[i] = __builtin_popcount(i);
    for( i=0; i<CMB && z<K; ++i){
       z = hash[ i ];
       left = K - z;
       left = left < 20 ? left : 20;
       for( j=0; j<20; ++j)
          cnt[ hash[ i & C[j] ] ]  ++;
       tmp = 0;
       for( j=20; j>=1; --j){
         if( left > 0 ){
            if( cnt[j] )tmp+=j*( left > cnt[j] ? cnt[j] : left );
            left -= cnt[j];
         }
         cnt[j] = 0;
       }
       sol = sol > tmp ? sol : tmp;
    }
    printf("%d\n",sol);
    return 0;
}

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
#include<map>
using namespace std;

#define f first
#define s second

map<int,int>M;
vector< pair<int,int> >V;

int main(){
   int N,i,j,a,b;
   scanf("%d",&N);
   for( i=0;i<N;i++){
      scanf("%d%d",&a,&b);
      V.push_back( make_pair(a,b) );
   }
   sort(V.begin(),V.end());
   int sol = -1,g,z,d;
   for( i=0;i<N;i++){
      z = M[ V[i].s ];
      M[ V[i].s ] = g =(d=M[V[i].f]+V[i].s-V[i].f) > z ?d:z;
      sol = max( sol , g );
   }
   printf("%d\n",sol);
   return 0;
}

//22,25,26,30,31,33,38,43,44,46,47,50,51,52,55,

#include<iostream>
#include<vector>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<cstdio>
using namespace std;

#define mk make_pair
#define E first
#define dist second

const int MOD = 321555123;
const int MAXN = 50002 , MAXM = 102;
int N,M;
vector< pair<int,int> >G[50005];
long long DP[MAXN][MAXM];
int father[MAXN][2];
bool visited[ MAXN ];

long long sol = 0;

void root( int node ){
   DP[ node ][0]++;
   visited[node] = true;
   for( int i = 0; i<G[node].size(); ++i ){
      if( visited[ G[node][i].E ]==false ){
         father[ G[node][i].E ][0] = node;
         father[ G[node][i].E ][1] = G[node][i].dist;
         root( G[node][i].E );
         for( int j=0; j+G[node][i].dist<=M ;j++ ){
            DP[ node ][   j  +  G[node][i].dist   ] = (DP[ node ][   j  +  G[node][i].dist   ] + DP[ G[node][i].E ][j]) % MOD;
         }
      }
   }
}
bool visited2[ MAXN ];

void root2( int FTH , int node , int D ){
   visited2[ node ] = true;
   int tmp = 0;
   for( int i = 100 ; i >= D ; i -- ){
      DP[ node ][ i ] +=  DP[ FTH ][ i-D ];
      if( i-D*2 >=0  && DP[ FTH ][ i-D ])DP[ node ][ i ] -=DP[ node ][ i-D*2 ];
   }
   for( int i = 0 ; i < G[ node ].size() ; i ++ ){
      if( visited2[ G[node][i].E ] == false )
         root2( node , G[node][i].E , father[ G[node][i].E ][1] );
   }
}

int main(){
   int a,b,c;

  

   scanf("%d%d",&N,&M);
   for( int i=0; i<N-1; ++i ){
      scanf("%d%d%d",&a,&b,&c);
      G[a].push_back( mk(b,c) );
      G[b].push_back( mk(a,c) );
   }
   father[1][0] = -1;
   root( 1 );
   
   visited2[1] = true;
   for( int i=0;i<G[1].size() ; i ++ )
      root2( 1 , G[1][i].E , father[ G[1][i].E ][1] );
      
   for( int i=1;i<=N; ++i ){
      sol = ( sol + DP[i][M] );
   }
   printf("%d\n",(sol)/2)%MOD;

   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<string.h>
#include<math.h>
using namespace std;

void print_bits( int v ){for( int i = 30 ; i <=32;i++){cout<<bool(v & (1<<(32-i)) )<<" ";}cout<<endl;}

int minC , maxC , F , W;
int costF[22];
int workerF[22][22] , workerS[22] , workerCnt[22];

double solProf  = -1;
int solCost , solSale , solTookF , solTookW , solF , solW;

int main(){
  // freopen("Ulaz.txt","r",stdin);
  // freopen("Izlaz.txt","w",stdout);
   int tests;
   scanf("%d",&tests);
   for( int te = 1 ; te<=tests ; te++ ){
      scanf("%d%d%d%d",&minC,&maxC,&F,&W);
      for( int i=0; i<F; ++i )scanf("%d",&costF[i]);
      for( int i=0; i<W; ++i ){
         scanf("%d",&workerCnt[i]);
         for( int j=0; j<workerCnt[i]; ++j ){
            scanf("%d",&workerF[i][j]);
            workerF[i][j]--;
         }
         scanf("%d",&workerS[i]);
      }
      
      
      for( int i=0; i<(1<<F); ++i ){
         int cost = 0;
         for( int j=0;j<F; ++j ) if( i&(1<<j) )cost += costF[j];
         if( cost < minC || cost > maxC )continue;
         int sale = 0 , cntW = 0;
         bool ok;
         int tkW = 0;
         for( int j=0;j<W; ++j ){
            ok = true;
            for( int k=0;k<workerCnt[j] && ok; ++k )
               if( (i & (1<<workerF[j][k]) ) == 0 )
                  ok = false;
            if( ok ){
               sale += workerS[j] , cntW++;
               tkW |= 1<<j;
            }
         }
         int cntF = __builtin_popcount(i);
         
         int P;
         if( cost != 0 )P = (int)round(1000.0*( double(sale) / cost) );
         else P = 0;
         
         
         
         if( (solProf < P) ||
          (solProf == P && sale-cost > solSale-solCost) ||
          (solProf == P && sale-cost ==solSale-solCost && cntF < solF) ||
          (solProf == P && sale-cost ==solSale-solCost && cntF ==solF && cntW > solW)   )
             solProf = P , solSale = sale , solCost = cost , solTookF = i , solTookW = tkW , solW = cntW , solF = cntF;
         
      }
      
      
      printf("Feature Set %d\n",te);
      printf("%.3lf\n",solProf/1000.0);
      printf("%d\n%d\n",solSale,solCost);
      for( int i=0; i<F; ++i )
         if( solTookF & (1<<i) )
            printf("%d ",i+1);
            printf("\n");
      for( int i=0; i<W; ++i )
         if( solTookW & (1<<i) )
            printf("%d ",i+1);
            printf("\n");
      solCost = solSale = solTookF = solTookW = solF = solW = 0;
   }

   return 0;
}

#include<iostream>
#include<cstdio>
#include<vector>
#include<math.h>
#include<cstdlib>
#include<iomanip>
#include<queue>
#include<stack>
#include<string>
using namespace std;
#define f first
#define s second

struct firefly{
   int x,y,z,xv,yv,zv;
   double xt,yt,zt;
   firefly( int p1 , int p2 , int p3 , int p4 , int p5, int p6 ):x(p1),y(p2),z(p3),xv(p4),yv(p5),zv(p6){};
   firefly(){};
   void Move( double time ){
      xt = x + xv*time;
      yt = y + yv*time;
      zt = z + zv*time;
   }
};

int N;
vector<firefly>V;

double sqr( double v ){
   return v*v;
}

double GetDist( double T){
   double xm(0),ym(0),zm(0);
   for(int i=0;i<N;i++)V[i].Move(T);
   for(int i=0;i<N;i++){
      xm += V[i].xt;
      ym += V[i].yt;
      zm += V[i].zt;
   }
   xm /= N , ym /= N , zm /= N;
   double D = sqrt( sqr(xm) + sqr(ym) + sqr(zm) );
   return D;
}

int main(){
freopen("Ulaz.txt","r",stdin);
     freopen("Izlaz.txt","w",stdout);
   int tests,i,j,a,b,c,d,e,f;
   scanf("%d",&tests);
   for (int t = 1 ; t <= tests ; t ++ ){
      V.clear();
      scanf("%d",&N);
      for(i=0;i<N;i++){
         scanf("%d%d%d%d%d%d",&a,&b,&c,&d,&e,&f);
         V.push_back( firefly(a,b,c,d,e,f) );
      }
      double v1,v2,v3;
      double lo = 0 , hi = 9999999999LL , mid;
      double add = 50000;
      double q;
      for( q = 0 ; q < 500000000 && add>0.00000000001 ;  ){
         v1 = GetDist(q) , v2 = GetDist(q+add) , v3 = GetDist(q-add);
         if( v3<v1 && q-add>=0 )
            q -=add;
         else if( v1 > v2 )
            q+=add;
         else
            add /= 2;
      }
      printf("Case #%d: %.8lf %.8lf\n",t,GetDist(q),q);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<vector>
using namespace std;

const int inf = 9999999;
int arr[100005][7];

int N,K;

bool ok ( int mid ){
   int costUk = 0,needs,ret,cost,to,left;
   for( int j=0; j<N; ++j ){
      needs = mid * arr[j][0] - arr[j][1];
      if( needs < 0 )continue;
      ret = inf , cost , left , to = (needs/arr[j][4])+2;
      for( int i = 0; i <= to; ++i ){
         cost = i * arr[j][5];
         left = needs - (i*arr[j][4]);
         if( left > 0 ){
            cost += (left/arr[j][2]) * arr[j][3];
            left -= (left/arr[j][2]) * arr[j][2];
            if( left > 0 )cost += arr[j][3];
         }
         ret = ret < cost ? ret : cost;
      }
      costUk += ret;
   }
   return (costUk <= K);
}

int main(){
   int a,b,c,d,e,f;
   scanf("%d%d",&N,&K);
   for( int i = 0; i < N; ++i ){
      scanf("%d%d%d%d%d%d",&arr[i][0],&arr[i][1],&arr[i][2],&arr[i][3],&arr[i][4],&arr[i][5]);
   }
   int ans = 0 , lo = 0 , hi , mid;
   for( hi = 1 ; ok(hi) ; hi*=2 );
   while( lo <= hi ){
      mid = (lo+hi)/2;
      if( ok(mid) ){
         ans = mid;
         lo = mid+1;
      }else hi = mid-1;
   }
   printf("%d\n",ans );
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<cstdio>
#include<cstdlib>
using namespace std;

const int MAXC = 10000001;

int bsearch( int lo , int hi , long long val ){
   while ( lo<= hi ){
      int mid = (lo+hi)/2;
      long long SUM = mid*(mid+1ll)/2;
      long long SUMprev = mid*(mid-1ll)/2;
      if( SUMprev < val && SUM >= val )return mid;
      else if( SUM > val )hi = mid-1;
      else lo = mid+1;
   }
   return -1;
}

int main(){
   int n,a,idx;
   scanf("%d",&n);
   for(int i=0;i<n;i++){
      scanf("%d",&a);
      idx = bsearch( 0 , MAXC , a );
      long long PASSED = idx*(idx-1ll)/2;
      if( idx % 2 == 1 ){
         cout<<idx-(a-PASSED)+1<<"/"<<a-PASSED<<endl;
      }else{
         cout<<a-PASSED<<"/"<<idx-(a-PASSED)+1<<endl;
      }
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<math.h>
#include<cstdlib>
#include<algorithm>
#include<fstream>
#include<vector>
using namespace std;

string emp = "jfahfjkahsjkdfghasjgfbjahsgfuyaegwfjagjfhdk";

struct node{
   double p;
   string S;
   node *left,*right;
   node(){
       left = NULL;
       right = NULL;
       S = emp;
   }
};

int lines;
node tree;

int ln = 0;

void construct( node *pok ){
   double p;
   string c;char ch;
   ln++;
   while( ch=getchar())if(ch=='(' )break;
   if( ch=='(' ){
       cin>>p;
       pok->p = p;
       ch = getchar();
       if( ch==' '){
          cin>>c;
          if(c[0]!=')' ){
             pok->S = c;
             pok->left = new node();
             pok->right = new node();
             construct(pok->left);
             construct(pok->right);
          }
       }
   }
}

void traverse( node *pok ){
   cout<<pok->S<<" "<<pok->p<<endl;
   cout<<"HAS LEFT CHILD: "<<(pok->left!=NULL)<<endl;
   cout<<"HAS RIGHT CHILD: "<<(pok->right!=NULL)<<endl;
   if( pok->left != NULL ){
      traverse( pok->left );
      cout<<"RET"<<endl;
   }
   if( pok->right != NULL ){
      traverse( pok->right );
      cout<<"RET"<<endl;
   }
}

double now;
int n;
vector<string>opis;

bool hasIT( string &v ){
   int lo = 0 , hi = opis.size()-1,mid;
   while(lo<=hi ){
      mid = (lo+hi)/2;
      if( opis[mid] == v )return true;
      else if (opis[mid] < v )lo = mid+1;
      else hi = mid-1;
   }
   return false;
}

void GetProb( node *pok ){
   now *= pok->p;
   bool b = hasIT( pok->S);
   if( b  ){
      if( pok->left != NULL )GetProb( pok->left );
   }else{
      if( pok->right != NULL )GetProb( pok->right);
   }
}


int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
   char c;
   int tests,i,j;
   scanf("%d",&tests);
   for( int t = 1; t <= tests ; t++ ){
      tree = node();
      node *pok = &tree;
      cin>>lines>>ws;
      construct( pok );
      //traverse(&tree);
      pok = &tree;
      int commands;
      while( c=getchar() )if( c>='0' && c<='9' )break;
      commands = c-'0';
      while( c=getchar() )if( c>='0' && c<='9' )commands = (commands*10)+(c-'0');
         else break;
      string g;
      printf("Case #%d:\n",t);
      for( i=0;i<commands;i++){
         cin>>g>>n;
         opis.clear();
         for(j=0;j<n;j++){
            cin>>g;
            opis.push_back(g);
         }
         sort(opis.begin(),opis.end());
         now = 1;
         GetProb(&tree);
         printf("%.7lf\n",now);
      }
   }
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<set>
#include<ctime>
using namespace std;

inline void read_int( int &v ){
   char c;
   while( (c=getchar())<'0' || c>'9' );
   v = c-'0';
   while( (c=getchar())>='0' && c<='9' ) v = (v*10) + (c-'0');
}

const int MAXN = 1000000000;
vector<int>V;
vector<int>::iterator it;

int main(){
  // double S = clock();
   int z;
   for( int i=0; i<=999; ++i )
      for( int j=0; (z= i*i*i + j*j*j*j )<= MAXN ; ++j )
         V.push_back( z );
   sort(V.begin(),V.end());
   
       
    for(int i = 0; i < 5; i++ )
    cout<<V[i]<<endl;

   int tests,N;
   scanf("%d",&tests);
   for( ; tests ; tests-- ){
      read_int(N);
      long long sol = 0;
      it = V.end();
      for( int i =0 ; i*i<=N ; ++i ){
         it = upper_bound( V.begin() , V.end() , N-i*i );
         it--;
         sol += it - V.begin()+1;
      }
      printf("%lld\n",sol);
   }
   
  // cout<<"ENDING TIME: "<<( clock()-S )/CLOCKS_PER_SEC<<endl;
  // system("pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<string.h>
using namespace std;

int days;
int config[20];
int map[23][23];
int nxt_map[23][23];

int main(){
  //  freopen("Ulaz.txt","r",stdin);
  //  freopen("Izlaz.txt","w",stdout);
   scanf("%d",&days);
   for( int i=0; i<16; ++i )scanf("%d",&config[i]);
   for( int i=1; i<=20; ++i ){
      for( int j=1; j<=20; ++j ){
         scanf("%d",&map[i][j]);
      }
   }
   for( ; days ; days-- ){
      for( int i=1; i<=20; ++i ){
         for( int j=1; j<=20; ++j ){
            nxt_map[i][j] = map[i][j] + config[ map[i][j] + map[i-1][j] + map[i][j-1] + map[i+1][j] + map[i][j+1] ];
            if( nxt_map[i][j] > 3 )nxt_map[i][j] = 3;
            if( nxt_map[i][j] < 0 )nxt_map[i][j] = 0;
         }
      }
      
      memcpy( map , nxt_map , 22*22*4 );
      memset( nxt_map , 0 , sizeof(nxt_map) );
   }
   for( int i=1; i<=20; ++i ){
      for( int j=1; j<=20; ++j ){
         int z = abs(map[i][j]);
         if( z == 0 )
            printf(".");
         else if( z == 1 )
            printf("!");
         else if( z == 2 )
            printf("X");
         else
            printf("#");
      }
      printf("\n");
   }
   return 0;
}

#include<cstdio>
#include<iostream>
#include<algorithm>
#include<vector>
#include<math.h>
#include<set>
using namespace std;

vector<string>search;
vector< vector<string> >docs;

inline bool IsTermChar( char c ){
   return (  (c>='0' && c<='9') || (c>='a' && c<='z') || (c>='A' && c<='Z')  );
}

inline char ToLower( char c ){
   if( c <'A' || c>'Z' )return c;
   else return ('a' + ( c - 'A' ) );
}

vector<string> GetTerms( string line ){
   string parse;
   vector<string>ret;
   for( int i=0; i<line.length(); ++i ){
      if( line[i] == ' ' ){
         if( parse.length() > 0 )
            ret.push_back(parse);
         parse = "";
         continue;
      }else if( IsTermChar( line[i] ) ){
         parse = parse + ToLower( line[i] );
      }
   }
   if( parse.length() > 0 )
      ret.push_back(parse);
   
   return ret;
}

bool IsBreaker( string s ){
   if( s.size() != 10 )return false;
   for( int i=0; i<10; ++i )
      if( s[i] != '-' )return false;
   return true;
}

multiset<string>SSE;

int main(){
   int cntDocs = 0;
   string tmp;
   bool PrevBreaker = false;
   multiset<string>T;
   set<string>T2;
   while(1){
      getline( cin , tmp );
      if( IsBreaker(tmp ) ){
         if( PrevBreaker == true )break;
         PrevBreaker = true;
         cntDocs++;
         
         double ans = 0;
         if( cntDocs == 1 ){
            SSE = T;
         }else{
            set<string>::iterator it;
            for( it = T2.begin(); it!=T2.end(); ++it ){
               ans += sqrt( T.count(*it) * SSE.count(*it) );
            }
            printf("%.2lf\n",ans);
         }
      
         T2.clear();
         T.clear();
         continue;
      }PrevBreaker = false;
      
      vector<string> terms = GetTerms( tmp );
      for( int i=0; i<terms.size(); ++i ){
         T.insert(terms[i]);
         T2.insert(terms[i]);
      }
      
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<limits.h>
#include<cfloat>
#include<math.h>
using namespace std;

int n;
double k;
double pos[100005];

inline bool chk( double t ){
   double  nxt_pos = pos[0]+t , domet;
   for( int i = 0; i < n-1 ; ++i ){
      domet = nxt_pos + k;
      if( domet < pos[i+1]-t )return false;
      nxt_pos = min(domet,pos[i+1]+t);
   }
   return true;
}

int main(){
   scanf("%lf%d",&k,&n);
   for( int i = 0; i < n; ++i )
      scanf("%lf",&pos[i]);
   double lo = 0.0f , hi = 10000005.0f , mid , ans = 9999999.0f;
   for( int i = 0 ; i < 100 ; ++i ){
      mid = (lo+hi)/2.0f;
      if( chk(mid) )
         hi = mid;
      else
         lo = mid;
   }
   printf("%.3lf\n",lo);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<math.h>
using namespace std;

int main(){
   double v;
   int i;
   while(1){
      cin>>v;
      if(v<0.001)break;
      double temp = 0;
      for( i=2; temp<v ; i++ )
         temp += 1.00/i;
      printf("%d card(s)\n",i-2);
   }
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
using namespace std;

int N;
int val[100005];
vector<int>G[100005];
int DP[100005][2];
bool visited[100005];

void root( int node ){
   visited[ node ] = true;
   DP[node][0] = val[node];
   if( G[ node ].size() == 0 )return;
   int w;
   for( int i=0; i<G[ node ].size() ; ++i ){
      w = G[ node ][ i ];
      if( visited[ w ] == false ){
         root( w );
         DP[ node ][ 0 ] += DP[ w ][ 1 ];
         DP[ node ][ 1 ] += max( DP[ w ][ 0 ],DP[ w ][ 1 ] );
      }
   }
}

int main(){
   int v,f;
   scanf("%d",&N);
   scanf("%d",&v);
   val[0] = v;
   for( int i = 1; i <= N-1 ; ++i ){
      scanf("%d%d",&f,&v);
       val[i] = v;
       G[f].push_back(i);
   }
   root( 0 );
   printf("%d\n",max( DP[0][0] , DP[0][1] ) );
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<math.h>
using namespace std;

const int MOD = 500000000;
const int MAXN = 10005 , MAXK = 55;
int N,K;
int arr[MAXN];
int BIT[MAXK][MAXN];

void lower(){
   vector<int>V;
   for(int i=0; i<N; ++i )V.push_back( arr[i] );
   sort(V.begin(),V.end());
   for(int i=0; i<N; ++i )
      arr[i] = lower_bound(V.begin(),V.end(),arr[i]) - V.begin() + 1;
}

void update( int r , int idx , int val ){
   for( ; idx<MAXN; idx+=idx&-idx )
      BIT[r][idx] = (BIT[r][idx]+val)%MOD;
}
int read( int r , int idx ){
   int ret = 0;
   for( ; idx>0; idx-=idx&-idx )
      ret = (ret+BIT[r][idx])%MOD;
   return ret;
}
int read(int row , int l, int r ){
   return read(row,r) - read(row,l-1);
}

int main(){
   scanf("%d%d",&N,&K);
   for( int i=0; i<N; ++i )
      scanf("%d",&arr[i]);
   lower();
   for( int i=0; i<N; ++i ){
      for( int j=1; j<=49; ++j ){
         int v = read( j, 1 , arr[i]-1 );
         if( v > 0 )update( j+1, arr[i] , v );
      }
      update( 1 , arr[i] , 1 );
   }
   printf("%d\n",read( K , 1 , 10001 ) );
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<math.h>
using namespace std;

const double PI = 2*acos(0);
double H,A;

int main(){
   scanf("%lf%lf",&A,&H);
   double koefA = A/H;
   double K = sqrt( A*A/4 + H*H );
   double koefK = K/H;
   double P = 0;
   
   double HO = H , HA = A , R;
   double add = 0;
   do{
      K = sqrt( A*A/4 + H*H );
      double s = (H+A+K)/2;
      double r = sqrt( (s-H)*(s-A)*(s-K) / s );

      R = 2*r;
      P += R*PI;
      
      add += R;
      H = koefA*( HO - add );
      A = koefK*( HO - add );
      printf("  %.6lf\n",P);
   }while( R>0.000001 );
   P -= R*PI;
   printf("%.6lf\n",P);
   system("Pause");
   return 0;
}

#include<string.h>
#include<cstdio>

char str[5][500];
bool used[255];
inline bool IsUsed( char c ){
   if( c >='A' && c<='Z' ) c = 'a' +(c-'A');
   return used[c];
}
inline void TakePos( char c ){
   if( c >='A' && c<='Z' ) c = 'a' +(c-'A');
   used[c] = true;
}

bool EOL;
void get_word( char *buff ){
   EOL = false;
   char c;
   int idx = 0;
   while( c=getchar() )
      if( c == ' ' )break;
      else if( c == '\n'){
         EOL = true; 
         break;
      }else
         buff[idx++] = c;
   buff[idx] = '\0';
}

int main(){
   char tmp;
   int n,cnt;
   scanf("%d%c",&n,&tmp);
   for( int i = 0 ; i < n ; ++i ){
      cnt = 0 , EOL = false;
      while( !EOL )
         get_word( str[cnt++] );
      bool OK = false;
      for( int i = 0; i < cnt ; ++i)
         if( IsUsed( str[i][0] ) == false )OK = true;
      if( OK ){
         OK = false;
         for( int i = 0; i < cnt; ++i ){
            int j = 0;
            if( i )printf(" ");
            if( OK == false && IsUsed( str[i][0] ) == false )
                TakePos( str[i][0] ),
                OK = true,
                printf("[%c]",str[i][0]),
                j = 1;
            for( ; j < strlen( str[i] ) ; ++j )
               printf("%c",str[i][j]);
         }
         printf("\n");
      }else{
          OK = false;
         for( int i = 0; i < cnt; ++i ){
            if( i )printf(" ");
            for( int j = 0; j < strlen( str[i] ) ; ++j ){
               if( OK == false && IsUsed( str[i][j] ) == false )
                   TakePos( str[i][j] ),
                   OK = true,
                   printf("[%c]",str[i][j]);
               else
                   printf("%c",str[i][j]);
            }
         }
         printf("\n");
      }
      
   }
   return 0;
}

#include<iostream>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<set>
#include<vector>
using namespace std;

int main()
{
   long long green,red;
   long long limit;
   bool DoWhile=true;
   cin>>red>>green;
   int i = 2 , r = red;
   multiset<int>divs;
   multiset<int>::iterator it;
   set<int>S;
   divs.insert(1);
   S.insert(1);
   while( i<=sqrt(red) ){
      if( red % i == 0 ){
         red /= i;

            vector<int>ToInsert;
            
            for( it = divs.begin(); it != divs.end(); ++it )
               ToInsert.push_back( i*(*it) );

            for( int j=0;j<ToInsert.size(); ++j ){
               divs.insert( ToInsert[j] );
               S.insert( ToInsert[j] );
            }
      }else
         i++;
   }
   S.insert(r);
   for( it = S.begin() ; it != S.end() ; ++it ){
      if( green % (*it) == 0 ){ 
         printf("%d %d %d\n",*it,r/(*it),green/(*it) );
      }
   }
   return 0;
}

#include<cstdio>
#include<fstream>
#include<iostream>
#include<string.h>
#include<cctype>
#include<math.h>
using namespace std;
string vowels="aeiou";

bool IsVowel(char c)
{
   return vowels.find(c,0)!=string::npos;
}

string transform(string s)
{
   int i;
   for(i=0;i<s.size()-1;i++)
   {
      if( tolower(s[i])=='p' && IsVowel( s[i-1] ) && s[i-1]==s[i+1] )
             s.replace(i-1,3,s.substr(i-1,1));
   }
   return s;
}

int main()
{
    int n;
    string s,ss;
    getline(cin,s);
    ss = transform(s);
    cout<<ss<<endl;
    return 0;
}

#include<cstdio>
#include<iostream>
using namespace std;

int main(){
   double v,uk;
   for( int i = 0; i < 12 ; i ++ ){
      cin>>v;
      uk += v;
   }
      
   printf("$%.2lf\n",uk/12);
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<algorithm>
#include<cstdlib>
#include<fstream>
#include<string.h>
using namespace std;


int N,MOD;
char str[1000005];
int DP[5][5][5];
int cDP[5][5][5];
int test[1000005][3];
bool testIT[1000005];

int main(){
    int S = clock();
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
   int i,j,k,l;
   scanf("%d%d%s",&N,&MOD,str);
   int hi=0,lo=0,diff=0,sol=0,nlo,nhi,dx,mx,lx;
   for(i=0;i<N;i++){
      if( str[i]=='P' ){
         diff--;
         nlo = min(lo,diff) , nhi = max(hi,diff);
         if( !( abs(diff) > 2 || nhi>2 || nlo<-2 || nhi-nlo>2) ){
            test[i+1][0]=diff+2, test[i+1][1]=nlo+2, test[i+1][2] = nhi+2;
            testIT[i+1] = true;
         }
         diff++;
      }
      if( str[i]=='P' )diff++;
      else diff--;
      hi = max(diff,hi) , lo = min(diff,lo); 
   }
   for( j=-2;j<=2;j++)
      for( k = -2 ; k <= 0 ; k ++ )
         for( l = k;l<=2;l++)
             DP[j+2][k+2][l+2] = 1;
   for(i=N;i>0;i--){
      if(testIT[i]!=0)sol = (sol+DP[ test[i][0] ][ test[i][1] ][ test[i][2] ])%MOD;
      for(j=-2;j<=2;j++){
         for(k=-2;k<=0;k++){
            for(l=k;l-k<=2;l++){
                  cDP[j+2][k+2][l+2] = 0;
                  dx = j+1; // diff+1
                  mx = l>dx?l:dx , lx = k<dx?k:dx;
                  if( abs(dx)<=2 && mx-lx <= 2  ){
                     cDP[j+2][k+2][l+2] = (DP[dx+2][lx+2][mx+2]+cDP[j+2][k+2][l+2])%MOD;
                  }
                  
                  
                  dx = j-1; // diff-1
                  mx = l>dx?l:dx , lx = k<dx?k:dx;
                  if( abs(dx)<=2 && mx-lx <= 2  ){
                     cDP[j+2][k+2][l+2] = (DP[dx+2][lx+2][mx+2]+cDP[j+2][k+2][l+2])%MOD;
                  }
            }
         }
      }
      memcpy(DP,cDP,sizeof(int)*5*5*5);
   }
   printf("%d\n",(sol+1)%MOD);
   cout<<"TIME: "<<double(clock()-S)/CLOCKS_PER_SEC<<endl;
   return 0;
}

#include<iostream>
using namespace std;
typedef long long ll;main(){ll a,t,s;cin>>t;for(;t;--t){s=10e9;cin >> a;
       for(ll i=a+1;i<=a+a;++i)  if(!((1+i*a)%(i-a)))s=min(s,((1+i*a)/(i-a))+i);
       cout<<s<<endl;
}}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <iomanip>
using namespace std;

#define ok(r,c) (r>=0&&r<n&&c>=0&&c<10&&mx[r][c])

int n;
bool mx[15][15];
bool visi[15][15];

void mark( int r, int c, int w ){
    for( int i = c; i < c + w; ++i )
        mx[r][i] = true;
}


int dfs( int r, int c ){
    if( !ok(r,c) ) return 0;
    if( visi[r][c] ) return 0;

    int sol = 0;
    visi[r][c] = true;
    for( int i = -1; i <= 1; i+=2 ){
        for( int j = -1; j <= 1; j+=2 ){
            sol = max( sol , dfs( r + i*2 , c + j ) );
            sol = max( sol , dfs( r + i , c + j*2 ) );
        }
    }
    visi[r][c] = false;
    return sol + 1;
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");

    int T = 1;
    while( fscanf(in,"%d",&n) == 1 ){
        if( n == 0 )break;

        int s,w;

        memset(mx,false,sizeof(mx));
        memset(visi,false,sizeof(visi));

        for( int i = 0; i < n; ++i ){
             fscanf(in,"%d%d",&s,&w);
             mark(i,s,w);
        }
        int sol = dfs(0,0);

        int c = 0;
        for( int i = 0; i < n; ++i )
           for( int j = 0; j < 10; ++j )
               c += mx[i][j];

        if( c - sol != 1 ) printf("Case %d, %d squares can not be reached.\n",T++,c-sol);
        else printf("Case %d, %d square can not be reached.\n",T++,c-sol);
    }

    return 0;
}

#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
using namespace std;

const int maxn = 25;
const int maxw = 1050;
const int inf  = 1<<30;

int n;
int acost , sal , sev;
int w[maxn];

void input( FILE *in ){
    fscanf(in,"%d%d%d",&acost,&sal,&sev);
    for( int i = 0; i < n; ++i )
        fscanf(in,"%d",&w[i]);
}

int dp[maxn][maxw];

int solve( int day , int workers ){
    if( day == n ) return 0;
    if( dp[day][workers] != -1 ) return dp[day][workers];

    int sol = inf;
    for( int i = w[day]; i <= max(workers,w[day]); ++i ){
        int _sal = i * sal;
        int _emp = workers < i ? (i-workers)*acost : 0;
        int _sev = i < workers ? (workers-i)*sev : 0;
        sol = min( sol , solve(day+1,i) + _sal + _emp + _sev );
    }
    return dp[day][workers] = sol;
}

int main(){
    FILE *in = fopen("Ulaz.txt","r");

    int ccnt = 1;
    while( fscanf(in,"%d",&n) == 1 ){
        if( n == 0 )break;

        input(in);

        memset( dp , -1, sizeof(dp));
        printf("Case %d, cost = $%d\n",ccnt++,solve(0,0) );
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

#define ok(x,y) (x>=0&&x<w&&y>=0&&y<h&&mx[y][x]!='#')

struct trio{
    int x,y,mask;
    trio( int p1, int p2, int p3 ):x(p1),y(p2),mask(p3){};
    trio(){};
};

const int inf = 16843009;
pii s;

int h,w;
char mx[105][105];
int dp[105][105][1<<4];

int d[][2] = {1,0 , -1,0 , 0,1, 0,-1 };


void change( int &v , char c ){
    if( c == 'b' ) v |= 1<<0;
    if( c == 'y' ) v |= 1<<1;
    if( c == 'r' ) v |= 1<<2;
    if( c == 'g' ) v |= 1<<3;
}

bool CanPass( int v , char door ){
    if( door != 'B' && door != 'Y' && door != 'R' && door != 'G' ) return true;
    if( door == 'B' && (v&(1<<0)) ) return true;
    if( door == 'Y' && (v&(1<<1)) ) return true;
    if( door == 'R' && (v&(1<<2)) ) return true;
    if( door == 'G' && (v&(1<<3)) ) return true;
    return false;
}

vector< pii > v;

void init(){
    v.clear();
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    while( fscanf(in,"%d%d",&h,&w) == 2 ){
        if( h == 0 && w == 0 )break;
        
        init();
        
        for( int i = 0; i < h; ++i ){
            fscanf(in,"%s",mx[i]);
            for( int j = 0; j < w; ++j ){
                if( mx[i][j] == '*' ) s = mk(j,i);
                else if( mx[i][j] =='X' )v.push_back( mk(j,i) );
            }
        }
        
        
        memset( dp , 1 , sizeof(dp));
        dp[s.s][s.f][0] = 0;
        
        queue< trio > Q;
        Q.push( trio(s.f,s.s,0) );

        while( !Q.empty() ){
            trio u = Q.front(); Q.pop();
            
            for( int i = 0; i < 4; ++i ){
                int xn  = u.x + d[i][0];
                int yn  = u.y + d[i][1];
                int dst = dp[u.y][u.x][u.mask] + 1;
                
                if( ok(xn,yn) == false ) continue;
                
                int mask = u.mask;
                change( mask , mx[yn][xn] );
                
                if( CanPass( mask , mx[yn][xn] ) == false ) continue;
                
                
                if( dp[yn][xn][mask] == inf ){
                    dp[yn][xn][mask] = dst;
                    Q.push( trio(xn,yn,mask) );
                }
                
            }   
        }
        int sol = inf;
        for( int k = 0; k < v.size(); ++k ){
            for( int i = 0; i < 16; ++i )
                sol = min( sol , dp[ v[k].s ][ v[k].f ][i] );
        }
        if( sol != inf )
            printf("Escape possible in %d steps.\n",sol);
        else
            printf("The poor student is trapped!\n");
        
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <cstdlib>
using namespace std;

#define GREEN 1
#define RED 2
#define BLUE 3

char buff[200005];
vector< int > G[200005];
bool visited[200005];
const int inf = 1<<30;
int cnt = 1, len = 0 , g = 0;

void make( int node , int deep = 0 ){
    visited[node] = true;
    if( node < len && buff[g] != '0'){
        G[node].push_back( cnt );
        G[cnt].push_back( node ); cnt ++;
    }
    
    if( node < len && buff[g] == '2' ){
        G[node].push_back( cnt );
        G[cnt].push_back( node ); cnt ++;
    }g++;

    for( int i = 0; i < G[node].size(); ++i ){
        if( visited[ G[node][i] ] == false ){
            make( G[node][i] , deep + 1 );
        }
    }
}

void init( ){
    cnt = 1;
    g  = 0;
    memset( visited, 0 , sizeof(visited) );
    for( int i = 0 ; i <= 70000; ++i ) G[i].clear();
}

int maxx( int a , int b ){ if( a > b ) return a; return b; }
int minn( int a , int b ){ if( a > b ) return b; return a; }


int mode = -1;
int dp[50000][5];

int solmax ( int node, int now  , int cmp(int,int) ){
   if( dp[node][now] != -1 ) return dp[node][now];
   
   int sol = mode * inf;

   if( G[node].size() == 1 ){
       
        if( now == GREEN ) sol = 1;
        else sol = 0;
        
   }else if( G[node].size() == 2 ){
         
        if( now == BLUE ) sol =   cmp(   solmax(G[node][1] , RED , cmp) , solmax(G[node][1], GREEN , cmp)     );
        if( now == RED  ) sol =   cmp(   solmax(G[node][1] , BLUE, cmp) , solmax(G[node][1], GREEN , cmp)     );
        if( now == GREEN) sol =   cmp(   solmax(G[node][1] , BLUE, cmp) , solmax(G[node][1], RED   , cmp)     ) + 1;
        
   }else{
         

        if( now == BLUE ) sol = cmp(   solmax(G[node][1],RED  , cmp) + solmax(G[node][2],GREEN, cmp) ,      solmax(G[node][1],GREEN, cmp) + solmax(G[node][2],RED  , cmp)    );                
        if( now == RED )  sol = cmp(   solmax(G[node][1],BLUE , cmp) + solmax(G[node][2],GREEN, cmp) ,      solmax(G[node][1],GREEN, cmp) + solmax(G[node][2],BLUE , cmp)    );                       
        if( now == GREEN )sol = solmax(G[node][1],RED, cmp) + solmax(G[node][2],BLUE, cmp) + 1;
        
        
   }
   return dp[node][now] = sol;
}    



int main(){
    FILE *in =stdin;// fopen("Ulaz.txt","r");
    int tests;
    fscanf(in,"%d",&tests);
    
    for( ; tests ; -- tests ){
        init();
        fscanf(in,"%s",buff);
        len = strlen(buff);
        
        G[0].push_back(0);
        make(0);
        
        int mx = 0 , mn = inf , mode = -1; 
        
        memset( dp , -1 , sizeof(dp));
        mx = max (  mx , solmax( 0 , 1 , maxx)   );
        mx = max (  mx , solmax( 0 , 2 , maxx)   );
        mx = max (  mx , solmax( 0 , 3 , maxx)   );
        
        mode = 1;
        memset( dp , -1 , sizeof(dp));
        mn = min (  solmax( 0 , 1 , minn) , mn );
        mn = min (  solmax( 0 , 2 , minn) , mn );
        mn = min (  solmax( 0 , 3 , minn) , mn );
        
        cout<<mx<<" "<<mn<<endl;
       
    }
    
    //system("Pause");
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
using namespace std;

const int maxn = 505;

int wchoise[maxn];
int mchoise[maxn];

int n;
int w[maxn][maxn];
int m[maxn][maxn];
bool done[maxn][maxn];

void init();
void input( FILE );
int geti( int* , int , int );
void solve();
void output();

void init(){
    memset( wchoise , -1, sizeof(wchoise));
    memset( mchoise , -1, sizeof(mchoise));
    memset( done , false , sizeof(done));
}


void input( FILE *in ){
    fscanf(in,"%d",&n);
    int k,d;
    for( int i = 0; i < n; ++i ){
        fscanf(in,"%d",&k);
        for( int j = 0; j < n; ++j ){
            fscanf(in,"%d",&d);
            w[k][j] = d;
        }
    }

    for( int i = 0; i < n; ++i ){
        fscanf(in,"%d",&k);
        for( int j = 0; j < n; ++j ){
            fscanf(in,"%d",&d);
            m[k][j] = d;
        }
    }
}

int geti( int *arr , int n , int val ){
    for( int i = 0; i < n; ++i )
         if( arr[i] == val ) return i;
    return 0;
}

void solve(){
    int paired = 0;
    while( paired < n ){

        int um = -1;
        for( int i = 1; i <= n && um; ++i ) if ( mchoise[i] == -1 ) um = i;

        int cw = -1;
        for( int i = 0; i < n && cw == -1; ++i )
            if( done[um][i] == false ) cw = m[um][i] , done[um][i] = true;

        if( wchoise[ cw ] == -1 )
            wchoise[cw] = um , mchoise[um] = cw , paired ++;
        else{
            int w1 = geti( w[cw] , n , um );
            int w2 = geti( w[cw] , n , wchoise[cw] );
            if( w1 < w2 )
                mchoise[ wchoise[cw] ] = -1, wchoise[cw] = um , mchoise[um] = cw;
        }
    }
}

void output(){
    for( int i = 1; i <= n; ++i )
        printf("%d %d\n",i,mchoise[i]);
}


int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    int tests;
    fscanf(in,"%d",&tests);
    for( ; tests; --tests ){
        init();
        input(in);
        solve();
        output();
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <string.h>
#include <math.h>
using namespace std;

int n,m;
multiset< string > ms;
set< string > s;
char buff[100];

int cnt[20005];

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    while( fscanf(in,"%d%d",&n,&m) == 2 ){
        if( n == 0 && m == 0 ) break;
        
        memset( cnt , 0 , sizeof(cnt));
        ms.clear();
        s.clear();
        string str;
        
        for( int i = 0; i < n; ++i ){
             fscanf(in,"%s",buff);
             str = string(buff);
             
             ms.insert(str);
             s.insert(str);
        }
        
        set< string >::iterator it;
        
        for( it = s.begin(); it != s.end(); ++it )
            cnt[ ms.count(*it) ]++;
        
        for( int i = 1; i <= n; ++i )
             printf("%d\n",cnt[i]);
        
    }
    return 0;
}

#include<cstdio>
#include<vector>
#include<iostream>
#include<algorithm>
using namespace std;


int t;
int a;
string b;

int gcd( int a, int b ){
    if( b == 0 ) 
         return a;
    else
         return gcd(b,a%b);
}

int main(){
     scanf("%d",&t);
     for( ; t; --t ){
             cin >> a >> b;
             
             if( a == 0 ){
                  cout << b << endl;
                  continue;
             }
         
             int bi = 0;
             for( int i = 0; i < b.size(); ++i )
                 bi = ((bi*10) + b[i]-'0') % a;
             printf("%d\n",gcd(a,bi) );
         
     }
     return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <string.h>
using namespace std;

#define mk make_pair
#define f first
#define s second
#define pii pair<int,int>

struct edge{
    int d,l,c;
    edge( int p1, int p2, int p3 ):d(p1),l(p2),c(p3){};
    edge(){}
};

struct data{
    int node, dist , cost;
    data(){};
    data( int p1, int p2 , int p3 ):node(p1),dist(p2),cost(p3){};
    bool operator<( const data &d2 ) const {
        return dist > d2.dist;
    }
};



int K,N,M;
vector< edge > G[200];
int dst[200][200];
int cst[200][200];
const int inf = 1<<30;


void init(){
    for( int i = 0; i < 150; ++i )
        G[i].clear();
    for( int i = 0; i < 150; ++i )
        for( int j = 0; j < 150; ++j ){
            dst[i][j] = inf;
            cst[i][j] = inf;
        }
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    int tests;
    
    fscanf(in,"%d",&tests);
    
    for( ; tests ; --tests ){       init();
       fscanf(in,"%d%d%d",&K,&N,&M);
       
       int s,d,l,c;
       for( int i = 0; i < M; ++i ){
           fscanf(in,"%d%d%d%d",&s,&d,&l,&c);
           G[s].push_back( edge(d,l,c) );
       }
       
       data u;
       priority_queue< data > PQ;
       PQ.push( data( 1,0,0 ) );
       
       while( !PQ.empty() ){
           u = PQ.top(); PQ.pop();
           
           if( u.node == N ) break;
           
           for( int i = 0; i < G[u.node].size(); ++i ){
               int d = u.dist + G[u.node][i].l;
               int c = u.cost + G[u.node][i].c;
               if( c > K ) continue;
               PQ.push( data( G[u.node][i].d , d , c )  );
           }
       }
       
       if( u.node == N ) 
           printf("%d\n",u.dist );
       else
           printf("-1\n");
       
    }
    
    //system("Pause");
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:frac1
*/
#include <iostream>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <cstdio>
#include <algorithm>
#include <string.h>
#include <set>
using namespace std;

#define f first
#define s second

int n;

set< pair<float, pair<int,int> > >s;

int main(){
    freopen("frac1.in","r",stdin);
    freopen("frac1.out","w",stdout);
    
    cin >> n;
    for( int i = 0; i <= n; ++i ){
        for( int j = i; j <= n; ++j ){
             if( j == 0 ) continue;
             int u = i , d = j;
             int g = __gcd(u,d);
             u /= g;
             d /= g;
             s.insert( make_pair(u/(double)d, make_pair(u,d)  )   );
        }
    }
    
    set< pair<float, pair<int,int> > >::iterator it;
    for( it = s.begin(); it != s.end(); ++it )
         cout<<(*it).s.f<<"/"<<(*it).s.s<<endl;
        // system("Pause");
    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<cstdlib>
#include<vector>
#include<cctype>
using namespace std;

#define ogradaC  9
#define vukC     2
#define ovcaC    1
#define prosaoC  5

struct bice{  
    int x,y;
    bice(int x1,int y1):x(x1),y(y1){}
};

FILE *in,*out;
int h,w;
int matrica[300][300];
int ResVuk=0;
int ResOvca=0;
vector<bice*>vuk_ovca[2];

void input()
{
    in = stdin;//fopen("Ulaz.txt","r");
    int i,j;
    char C;
    fscanf(in,"%d%d%d",&h,&w);
    for(i=0;i<h;i++)
    {
       for(j=0;j<w;j++)
       {
          fscanf(in,"%c",&C);
          if( C == '#' )
             matrica[i][j]=ogradaC;
          else if( C=='o' ){
             matrica[i][j]=ovcaC;
             vuk_ovca[0].push_back( new bice(j,i) );
          }else if( C=='v' ){
             matrica[i][j]=vukC;
             vuk_ovca[1].push_back( new bice(j,i) );
          }
       }
       fscanf(in,"%d");
    }
    fclose(in);
}

int ovcaCounter,vukCounter;
void flood(int x,int y)
{
   if( x>=0 && x<w && y>=0 && y<h && 
      (matrica[y][x] ==  ovcaC || matrica[y][x] == vukC || matrica[y][x] == 0 )  )
   {
      if( matrica[y][x]     == vukC ) vukCounter++;
      else if(matrica[y][x] ==ovcaC ) ovcaCounter++;
      matrica[y][x] = prosaoC;
      flood( x-1,y);
      flood( x+1,y);
      flood( x,y+1);
      flood( x,y-1);
   }
}

void proces()
{
    int *Len = new int[2];
    Len[0]= vuk_ovca[0].size();
    Len[1]= vuk_ovca[1].size();
    int x,y;
    int i,j;
    for(j=0;j<2;j++)
    {
       for(i=0;i<Len[j];i++)
       {
          if( matrica[ (y=vuk_ovca[j].at(i)->y) ][ x=vuk_ovca[j].at(i)->x ] != prosaoC )
          {
             vukCounter=0;
             ovcaCounter=0;
             flood(x,y);
             if( vukCounter>=ovcaCounter)
                ResVuk += vukCounter;
             else
                ResOvca+= ovcaCounter;
          }
       }
    }
    cout<<ResOvca<<" "<<ResVuk<<endl;
}

int main()
{
    input();
    proces();
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <math.h>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
using namespace std;

char buff[1005];

int main(){

    scanf("%s",buff);

    int len = strlen(buff);
    int hlf = (len>>1);

    int pos = len-1;

    for( int i = 0; i < len; ++i ){

        bool ok = true;
        for( int k = 0; i + k <= len - k-1 && ok; ++k )
            if( buff[i+k] != buff[len-k-1] )
                ok = false;

        if( ok ){ pos = i; break; }
    }

    printf("%s",buff);
    for( int i = pos-1; i >= 0; --i )
        putchar(buff[i]);
    putchar('\n');
    return 0;
}

#include <iostream>
#include <cstdio>
#include <string.h>
using namespace std;

int main(){
    int a,b;
    int s1 = 0 , s2 = 0;
    for( int i = 0; i < 5; ++i ){
        scanf("%d%d",&a,&b);
        s1 += a;
        s2 += b;
    }
    if( s1 < s2 )
        printf("Slavko\n");
    else
        printf("Dario\n");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <set>
#include <string.h>
using namespace std;

int n;
float f[100];

int main(){
    while( scanf("%d",&n) ){
        if( n == 0 )break;
        
        for( int i = 0; i < n; ++i )
            scanf("%f",&f[i]);
        
        sort( f , f + n );
        
        bool ok = false;
        float s = 0;
        for( int i = 0; i < n-1 && !ok; ++i ){
            s += f[i];
            if( s >= f[i+1] )
                ok = true;
        }
        
        if( !ok )
            printf("NO\n");
        else
            printf("YES\n");
    }
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:checker
*/
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
using namespace std;


#define REP(i,a,b,c) for(i=a;i<b;i+=v)

int n,z =0;
int cnt =  0;
int col[15];
int idx[15];
int dg[100] , df[100];
int hlf;

void solve( int r , int g ){
    if( r == n ){
        cnt++;
        if (n > 6 && idx[0] < hlf) cnt++;
   
        if( z < 3 ){
             z++;
             for( int i = 0; i < n-1; ++i )
                 printf("%d ",idx[i]+1);
             printf("%d",idx[n-1]+1);
             putchar('\n');
        }
        return;
    }
    
    for( int i = 0; i < g; ++i ){
        if( !col[i] && !dg[i-r+n] && !df[i+r] ){
           idx[r] = i;
           col[i] = df[i+r] = dg[i-r+n] = true;
           solve( r + 1 , n );
           col[i] = df[i+r] = dg[i-r+n] = false;
        }
    }
    
}

int main(){
    freopen("checker.in","r",stdin);
    freopen("checker.out","w",stdout);        
    scanf("%d",&n);
    
    int v = n;
    if( n > 6 ) v = (n+1)>>1;
    hlf = n>>1;
    solve( 0 , v );
    printf("%d\n",cnt);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <iomanip>
#include <cassert>
using namespace std;

int N,M;
int val[1005];
vector< int >G[1005];

int sol = 0;
int scc_cnt = 1;

stack<int>stk;
bool instk[1005];
bool visi[1005];
int lowid[1005];
int idx[1005];


void scc( int node ){
    
    visi[node] = true;
    stk.push( node );
    instk[ node ] = true;
    lowid[node] = idx[node] = scc_cnt++;
    
    for( int i = 0; i < G[node].size(); ++i ){
        if( visi[ G[node][i] ] == false ){
             scc( G[node][i] );
             lowid[node] = min( lowid[node] , lowid[ G[node][i] ] );
        }else if( instk[ G[node][i] ] ){
             lowid[node] = min( lowid[node] , idx[ G[node][i] ] );
        }
    }
    
    if( lowid[node] == idx[node] ){
         int sum = 0;
         while( stk.top() != node ){
             sum += val[ stk.top()-1 ];
             instk[ stk.top() ] = false;
             stk.pop();
         }
         sum += val[ stk.top()-1 ];
         instk[ stk.top() ] = false;
         stk.pop();
         sol = max( sol , sum );
    }
    
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d",&N);
    
    for( int i = 0; i < N; ++i )
        fscanf(in,"%d",&val[i]);
    
    int a,b;
    fscanf(in,"%d",&M);
    
    for( int i = 0; i < M; ++i ){
        fscanf(in,"%d%d",&a,&b);
        G[a].push_back(b);
    }
    
    for( int i = 1; i <= N; ++i ){
        if( visi[i] )continue;
        scc( i );
    }
    
    printf("%d\n",sol);
    
    //system("Pause");
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

const int maxn = 100005;
int N;
int bit[maxn+10];
int cnt[maxn+10];

void update( int idx , int val ){
    for( ; idx <= maxn; idx += idx & -idx )
        bit[idx] += val;
}
int query( int idx ){
    int ss = 0;
    for( ; idx >= 1; idx -= idx & -idx )
        ss += bit[idx];
    return ss;
}

int main(){
    scanf("%d",&N);
    
    int l,r;
    int sol = 0;
    
    for( int i = 0; i < N; ++i ){
        scanf("%d%d",&l,&r);
        int ql = query( l );
        int qr = query( r );
        
        ql = ql - cnt[l];
        qr = qr - cnt[r];

        
        cnt[l] += ql;
        cnt[r] += qr;
        
        
        update( l+1 , 1 );
        update( r , -1 );
        
        
        printf("%d\n", ql + qr);
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <stack>
#include <set>
using namespace std;

int n,m;
vector< int > G[10005];
int ow[10005];

bool visited[10005];

double sum , cnt;
void dfs( int node ){
    visited[node] = true;
    cnt ++;
    sum += ow[node];
    
    for( int i = 0; i < G[node].size(); ++i ){
        if( visited[ G[node][i] ] ) continue;
        dfs( G[node][i] );
    }
}


int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d%d",&n,&m);
    
    for( int i = 0; i < n; ++i )
        fscanf(in,"%d",&ow[i]);
    
    int a,b;
    for( int i = 0; i < m; ++i ){
        fscanf(in,"%d%d",&a,&b);
        G[a].push_back(b);
        G[b].push_back(a);
    }
    
    vector< double > V;
    
    for( int i = 0; i < n; ++i ){
         if( visited[i] ) continue;
         sum = cnt = 0;
         dfs( i );
         V.push_back( sum / cnt );
    }
    bool ok = true;
    double S = V[0];
    for( int i = 1; i < V.size() && ok; ++i ){
         if( fabs( V[0] - V[i] ) > 0.00001 )
               ok = false;
    }
    if( ok )
        printf("POSSIBLE\n");
    else
        printf("IMPOSSIBLE\n");
    
    //system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <set>
#include <string.h>
using namespace std;

typedef long long ll;

const int maxn = 50050;
const int maxv = 1000005;

int n,k;
int arr[maxn];

int c[maxv];
int f[maxn];


int main(){
    int tests;
    scanf("%d",&tests);
    
    for( ; tests; --tests ){
        scanf("%d%d",&k,&n);
        
        for( int i = 1; i <= n; ++i ){
            scanf("%d",&arr[i]);
            arr[i] %= k;
        }
        
        memset( c , 0 , sizeof(c));
        memset( f , 0 , sizeof(f));
        
        for( int i = 1; i <= n; ++i ){
            f[i] = (f[i-1] + arr[i])%k;
            c[ f[i] ] ++;
        }
        
        
        ll sol = 0;
        int now = 0;
        
        for( int i = 1; i <= n; ++i ){
            sol += c[ now ];
            
            now = (now+arr[i])%k;
            c[ f[i] ] --;
        }
        
        printf("%lld\n",sol);
        
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
using namespace std;


int N;
int mx[20][20];
char buff[100];

int G;


bool FAIL;
bool visited[20][20];
int dfs( int x, int y ){
    if( x < 0 || y < 0 || x > G || y > G ) return 0;
    if( visited[y][x] ) return 1;
    visited[y][x] = true;
    
    if( y % 2 == 0 ){
        
        int d = 0;
        if( mx[y+1][x+1] == 1 ) d += dfs( x+1,y+1 );
        if( mx[y-1][x-1] == 1 ) d += dfs( x-1,y-1 );
        if( mx[y-1][x+1] == 2 ) d += dfs( x+1,y-1 );
        if( mx[y+1][x-1] == 2 ) d += dfs( x-1,y+1 );
        
        
        if(d > 1)FAIL = true;
    }else if( mx[y][x] == 1 ){
        
        int d = dfs( x-1 , y-1 ) + dfs( x+1 , y+1 );
        if(d > 1)FAIL = true;
    }else if( mx[y][x] == 2 ){
          
        int d = dfs( x+1 , y-1 ) + dfs( x-1 , y+1 );
        if(d > 1)FAIL = true;
    }
    return 0;
}

bool solve( int r, int c ){
    if( c > G )
        c = 1 , r += 2;
    
    if( r > G ){
        for( int i = 0; i <= G; i += 2 )
            for( int j = 0; j <= G; j += 2 ){
                if( mx[i][j] > 40 ) continue;
                if( mx[i][j] != 0 ) return false;
            }
        FAIL = false;
        memset( visited , false , sizeof(visited) );
        for( int i = 0; i <= G; ++i )
            for( int j = 0; j <= G; ++j ){
                if( visited[i][j] ) continue;
                dfs( j , i );
                if( FAIL ) return false;
            }
        
        return true;
    }
    
    
    if( mx[r-1][c-1] > 0 && mx[r+1][c+1] > 0 ){
        mx[r-1][c-1] --;
        mx[r+1][c+1] --;
        
        
        mx[r][c] = 1;
        
        if( !(mx[r-1][c-1] < 50 && mx[r-1][c-1] != 0) )
           if( solve( r , c + 2 ) )
              return true;
        
        mx[r][c] = 0;
        
        mx[r-1][c-1] ++;
        mx[r+1][c+1] ++;
    }
    
    if( mx[r-1][c+1] > 0 && mx[r+1][c-1] > 0 ){
        mx[r-1][c+1] --;
        mx[r+1][c-1] --;
        
        mx[r][c] = 2;
       
       if( !(mx[r-1][c-1] < 50 && mx[r-1][c-1] != 0) )
           if( solve( r , c + 2 ) )
            return true;
        
        mx[r][c] = 0;
        
        mx[r-1][c+1] ++;
        mx[r+1][c-1] ++;
    }
    
    return false;
    
}


int main(){

    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d",&N);
    
    G = 2*N;
    
    for( int i = 0; i < N+1; ++i ){
        fscanf(in,"%s",buff);
        
        for( int j = 0; j < N+1; ++j )
            if( buff[j] != '.' )
                mx[i*2][j*2] = buff[j] - '0';
            else
                mx[i*2][j*2] = 99;
    }
    
    if( solve( 1 , 1 ) == false )
        printf("ERROR\n");
    else{
    
        for( int i = 1; i < G; i += 2 ){
             for( int j = 1; j < G; j +=2 ){
                 if( mx[i][j] == 1 )
                     printf("\\");
                 else
                     printf("/");
             }
             putchar('\n');
        }
    }
    
    
    
    //system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;

const int maxn = 1000005;

int N,M;
vector< int > G[maxn];

bool visi[maxn];

int dp[maxn][21];
int lvl[maxn];

void dfs( int node , int deep ){
    visi[node] = true;
    lvl[node] = deep;
    
    for( int i = 0; i < G[node].size(); ++i )
         if( !visi[ G[node][i] ] ){
              dp[ G[node][i] ][0] = node;
              dfs( G[node][i] , deep + 1);
         }
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    fscanf(in,"%d%d",&N,&M);
    
    int a,b;
    for( int i = 1; i < N; ++i ){
        fscanf(in,"%d%d",&a,&b);
        G[a].push_back(b);
        G[b].push_back(a);
    }
    
    dp[1][0] = 0;
    dfs( 1 , 0 );
    
    for( int i = 1; i <= 20; ++i )
        for( int j = 1; j <= N; ++j )
            dp[j][i] = dp[  dp[j][i-1]  ][ i - 1 ];
    
    
    for( int i = 0; i < M; ++i ){
        scanf("%d%d",&a,&b);
        
        if( a == b ){
            printf("%d\n",a);
            continue;
        }
        
        for( int i = 19; i >= 0; --i ){
            if( lvl[a] < lvl[b] && lvl[a] < lvl[ dp[b][i] ] ) b = dp[b][i];
            if( lvl[a] > lvl[b] && lvl[ dp[a][i] ] > lvl[b] ) a = dp[a][i];
        }
        if( lvl[a] < lvl[b] ) b = dp[b][0];
        if( lvl[a] > lvl[b] ) a = dp[a][0];
        
        if( a == b ){
            printf("%d\n",a);
            continue;
        }
        
        
        for( int i = 19; i >= 0; --i ){
            if( dp[a][i] == dp[b][i] ) continue;
            a = dp[a][i];
            b = dp[b][i];
        }
        
        printf("%d\n",dp[a][0]);
    }
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:sort3
*/
#include <iostream>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <cstdio>
#include <algorithm>
#include <string.h>
#include <set>
using namespace std;

int n;
int niz[1005];
int cnt[5];

int main(){
    freopen("sort3.in","r",stdin);
    freopen("sort3.out","w",stdout);
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    fscanf(in,"%d",&n);
    
    
    for( int i = 0; i < n; ++i ){
        fscanf(in,"%d",&niz[i]);
        cnt[niz[i]]++;
    }
    
    int sol = 0;
    
    for( int i = 0; i < cnt[1]; ++i ){
        if( niz[i] == 1 ) continue;
        
        int swp = i;
        for( int j = cnt[1]; j < n; ++j ){
            if( niz[j] != 1 ) continue;
            
            if( niz[i] == 2 ){
                 swp = j;
                 break;
            }else
                 swp = j;
        }
        swap( niz[i] , niz[swp] );
        sol ++;
    }
    
    for( int i = cnt[1]; i < cnt[1]+cnt[2]; ++i )
         if( niz[i] == 3 ) sol++;
    
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <math.h>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
using namespace std;

int n;
char txt[1000][2000];
char srt[1000][2000];
vector< int > idx;

bool cmp( int a , int b ){
    return strcmp( srt[a] , srt[b] ) == -1;
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    fscanf(in,"%d",&n);
    for( int i = 0; i < n; ++i ){
        fscanf(in,"%s",txt[i]);
        
        int len = strlen(txt[i]);
        int hlf = len >> 1;
        int cnt = 0;
        
        for( int j = 0; j <= hlf; ++j ){
            srt[i][cnt++] = txt[i][hlf+j];
            if( j ) srt[i][cnt++] = txt[i][hlf-j];
        }
        srt[i][cnt++] = '\0';
        idx.push_back(i);
    }
    
    sort( idx.begin() , idx.end() , cmp );
    
    for( int i = 0; i < n; ++i )
        printf("%s\n",txt[ idx[i] ] );
    
    //system("Pause");
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

#define f first
#define s second
#define mk make_pair

int cnt[255];
int win[255];
int six[255];

vector< pair< pair<int,int> ,char> > v;

class CrossCountry {
    public:
        string scoreMeet(int n, string f)
        {
            v.clear();
            memset( win , 0 , sizeof(win));
            memset( cnt , 0 , sizeof(cnt));
            memset( six , 1 , sizeof(six));
            int l = f.size();
            for( int i = 0; i < l; ++i ){
                
                cnt[ f[i] ] ++;
                if( cnt[ f[i] ] < 6 )
                    win[ f[i] ] += i + 1;
                else if( cnt[ f[i] ] == 6 )
                    six[ f[i] ] = i + 1;
            }
            
            sort( f.begin() , f.end());
            f.erase( unique(f.begin(),f.end()),f.end());

            for( int i = 0; i < f.size(); ++i ){
                if( cnt[ f[i] ] >= 5 )
                v.push_back( mk( mk(win[f[i]],six[f[i]]) , f[i] ) );
            }
            sort( v.begin() , v.end()  );
            
            string sol = "";
            for( int i = 0; i < v.size(); ++i ){
            
                 sol += string(1,v[i].s);
            }
          
            return sol;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const string &Expected, const string &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arg0 = 3; string Arg1 = "ABACBCBABABABA"; string Arg2 = "BA"; verify_case(0, Arg2, scoreMeet(Arg0, Arg1)); }
	void test_case_1() { int Arg0 = 3; string Arg1 = "CCCBBBBBAAACC"; string Arg2 = "BC"; verify_case(1, Arg2, scoreMeet(Arg0, Arg1)); }
	void test_case_2() { int Arg0 = 4; string Arg1 = "ABDCBADBDCCDBCDBCAAAC"; string Arg2 = "BDCA"; verify_case(2, Arg2, scoreMeet(Arg0, Arg1)); }
	void test_case_3() { int Arg0 = 10; string Arg1 = "BDHCEAJBIDBCCHGCBDJEBAAHEGAGGADHGIECJEHAEBDADJCDHG"; string Arg2 = "BCDAHEG"; verify_case(3, Arg2, scoreMeet(Arg0, Arg1)); }
	void test_case_4() { int Arg0 = 3; string Arg1 = "BABCAABABAB"; string Arg2 = "AB"; verify_case(4, Arg2, scoreMeet(Arg0, Arg1)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    CrossCountry c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

#define f first
#define s second
#define mk make_pair

double p( double a, double b ){
    return a + b;
}
double s( double a, double b ){
    return  ( (a*b) / (a+b));
}

double t;
vector< pair<double,short> >r;

bool differ( short a, short b ){
    for( int i = 0; i < 7; ++i ){
         int d1 = (a&(1<<i));
         int d2 = (b&(1<<i));
         if( d1 == 0 && d2 == 0) continue;
         if( d1 == d2 ) return false;
    }
    return true;
}

class ResistorCombinations {
    public:
        double closestValue(vector <string> z, double t)
        {
            ::t = t;
            r.clear();
            for( int i = 0; i < z.size(); ++i ){
                double d;
                sscanf(z[i].c_str(),"%lf",&d);
                r.push_back( mk(d,1<<i)  );
            }
            
            double sol = 1e10;
            double ret = 0;
            vector< pair<double,short> >g;
            for( int i = 0; i < 6; ++i ){
                g.clear();
                
                for( int j = 0; j < r.size(); ++j ){
                    if( fabs( t - r[j].f ) < sol ){
                        sol = fabs( t - r[j].f );
                        ret = r[j].f;
                    }
                    for( int k = j; k < r.size(); ++k ){
    
                        if( differ( r[j].s , r[k].s ) == false ) continue;
                        short nw = r[j].s | r[k].s;
                        double par = p( r[j].f , r[k].f );
                        double ser = s( r[j].f , r[k].f );
                        g.push_back( mk( par , nw ) );
                        g.push_back( mk( ser , nw ) );
                    }
                    
                    g.push_back( r[j] );
                }
               // system("Pause");
                r = g;
                sort( r.begin() , r.end());
                r.erase(unique(r.begin(),r.end()),r.end());
            }
            
            return ret;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const double &Expected, const double &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { string Arr0[] = {"2","3","5"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); double Arg1 = 2.5; double Arg2 = 2.5; verify_case(0, Arg2, closestValue(Arg0, Arg1)); }
	void test_case_1() { string Arr0[] = {"2","3","5"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); double Arg1 = 1; double Arg2 = 0.967741935483871; verify_case(1, Arg2, closestValue(Arg0, Arg1)); }
	void test_case_2() { string Arr0[] = {"10.25","13.31","6.777","12.2"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); double Arg1 = 10.5; double Arg2 = 10.510805181371511; verify_case(2, Arg2, closestValue(Arg0, Arg1)); }
	void test_case_3() { string Arr0[] = {"10000","2000","300","40","5"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); double Arg1 = 20000; double Arg2 = 12345.0; verify_case(3, Arg2, closestValue(Arg0, Arg1)); }
	void test_case_4() { string Arr0[] = {"125.10000","00270.9","000625.55","90.100000","0015.60000"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); double Arg1 = 153; double Arg2 = 152.75975812465552; verify_case(4, Arg2, closestValue(Arg0, Arg1)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    ResistorCombinations c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

bool prime( int v ){
    if( v != 2 && (v&1) == 0 )return false;
    for( int i = 3; i*i <= v; i+=2 )
        if( v % i == 0 ) return false;
    return true;
}

typedef long long ll;

int z;
vector< int > p;

int GetLo( int idx , int product ){
    if( p[idx]*(ll)product > z ) return 0;
    
    int sol  = z / (product*p[idx]);
        sol += GetLo( idx + 1 , product );
        sol -= GetLo( idx + 1 , product * p[idx] );
    
    return sol;
}

int SQF( int k ){
   z = k;
   return z - GetLo( 0 , 1 );
}

class SquareFree {
    public:
        int getNumber(int n)
        {
            
            for( int i = 2; i*i <= 2000000000; ++i )
                if( prime(i) )
                    p.push_back(i*i);
            
            ll lo = 0 , hi = n*2;
            
            while( lo < hi ){
                ll mid = (lo+hi)>>1;
                int v = SQF( mid );
                if( v >= n ) hi = mid;
                else lo = mid + 1;
            }
            
            
            
            return hi;
            
            
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arg0 = 652494863; int Arg1 = 1073311086; verify_case(0, Arg1, getNumber(Arg0)); }
	void test_case_1() { int Arg0 = 13; int Arg1 = 19; verify_case(1, Arg1, getNumber(Arg0)); }
	void test_case_2() { int Arg0 = 100; int Arg1 = 163; verify_case(2, Arg1, getNumber(Arg0)); }
	void test_case_3() { int Arg0 = 1234567; int Arg1 = 2030745; verify_case(3, Arg1, getNumber(Arg0)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    SquareFree c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

typedef long long ll;

int n,k;

int G[][7] = {
    0,1,1,1,1,1,1,
    1,0,1,0,0,0,1,
    1,1,0,1,0,0,0,
    1,0,1,0,1,0,0,
    1,0,0,1,0,1,0,
    1,0,0,0,1,0,1,
    1,1,0,0,0,1,0
};


int arr[10];
bool visi[10];
int cnt[305];

bool ok( int node ){
    visi[node] = true;
    for( int i = 0; i < 7; ++i ){
        if( G[node][i] == 0 )continue;
        if( arr[node] == arr[i] ) return false;
        if( visi[i] ) continue;
        
        if ( !ok(i)   ) return false;
    }
    return true;
}

ll solve( int idx ){
    
    if( idx == 7 ){
        memset ( visi , 0 , sizeof(visi));
        
        if( !ok(0) )return 0; 
        
        ll sol = 1;
        for( int i = 0; i < 7; ++i ){
            sol *= cnt[ arr[i] ];
            cnt[ arr[i] ] --;
        }
        for( int i = 0; i < 7; ++i )
            cnt[ arr[i] ] ++;
        
        return sol;
    }
    
    ll sol = 0;
    for( arr[idx] = 0; arr[idx] < k; ++arr[idx] )
        sol += solve( idx + 1 );
    return sol;
}

class TheHexagonsDivTwo {
    public:
        long long count(int n, int k)
        {
            ::k = k;
            ::n = n;
            
            memset( cnt , 0 , sizeof(cnt));
            
            for( int i = 1; i <= n; ++i )
                 cnt[ i % k ] ++;

            ll sol = solve( 0 );

            return sol/6;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const long long &Expected, const long long &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arg0 = 7; int Arg1 = 3; long long Arg2 = 0LL; verify_case(0, Arg2, count(Arg0, Arg1)); }
	void test_case_1() { int Arg0 = 8; int Arg1 = 3; long long Arg2 = 24LL; verify_case(1, Arg2, count(Arg0, Arg1)); }
	void test_case_2() { int Arg0 = 8; int Arg1 = 4; long long Arg2 = 256LL; verify_case(2, Arg2, count(Arg0, Arg1)); }
	void test_case_3() { int Arg0 = 20; int Arg1 = 5; long long Arg2 = 4692480LL; verify_case(3, Arg2, count(Arg0, Arg1)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    TheHexagonsDivTwo c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

int R[1000];
int over = 0;


class TheSquareDivTwo {
    public:
        vector <string> solve(vector <string> b)
        {
            int N = b.size();
            memset( R , 0 , sizeof(R) );
            
            for( int i = 0; i < N; ++i ){
                 for( int j = 0; j < N; ++j )
                      if( b[i][j] == 'C' )
                           R[i] ++ , b[i][j] = '.';
            }
            
            
            for( int i = 0; i < N; ++i ){
                 for( int j = 0; j < R[i]; ++j )
                      b[N-j-1][i] = 'C';     
            }
            
            
            return b;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); if ((Case == -1) || (Case == 5)) test_case_5(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const vector <string> &Expected, const vector <string> &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: " << print_array(Expected) << endl; cerr << "\tReceived: " << print_array(Received) << endl; } }
	void test_case_0() { string Arr0[] = {"..",
 "C."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arr1[] = {"..", ".C" }; vector <string> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); verify_case(0, Arg1, solve(Arg0)); }
	void test_case_1() { string Arr0[] = {"CC",
 ".C"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arr1[] = {"C.", "CC" }; vector <string> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); verify_case(1, Arg1, solve(Arg0)); }
	void test_case_2() { string Arr0[] = {".C..",
 "CC.C",
 "..C.",
 "CCCC"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arr1[] = {"...C", ".C.C", ".C.C", "CCCC" }; vector <string> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); verify_case(2, Arg1, solve(Arg0)); }
	void test_case_3() { string Arr0[] = {"...CCC",
 "...CCC",
 "...CCC",
 "CCC...",
 "CCC...",
 "CCC..."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arr1[] = {"......", "......", "......", "CCCCCC", "CCCCCC", "CCCCCC" }; vector <string> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); verify_case(3, Arg1, solve(Arg0)); }
	void test_case_4() { string Arr0[] = {".....C",
 "....CC",
 "...CCC",
 "..CCCC",
 ".CCCCC",
 "CCCCCC"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arr1[] = {".....C", "....CC", "...CCC", "..CCCC", ".CCCCC", "CCCCCC" }; vector <string> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); verify_case(4, Arg1, solve(Arg0)); }
	void test_case_5() { string Arr0[] = {"C.C..C.C..C..C.",
 "CCC...C..CCC.C.",
 "......CC...CCCC",
 ".C..CC.C.C.C.C.",
 "C....C.C......C",
 ".....C..CCCCC.C",
 "CCC.......CCCCC",
 "..C.C..C.C...C.",
 "CCC....CCC.CC..",
 "CC.CCCC.CCCC...",
 ".C..C.CC.C.CC.C",
 "C.CCCC..CC..C.C",
 ".CCCC.CCCCCC...",
 "..C...C.CCC.CC.",
 "CCCC..CCC.C...."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arr1[] = {"...............", "...............", "...............", "...............", "...............", ".........C..C..", ".........C.CC..", ".C....C.CCCCC.C", ".C.C.CC.CCCCCCC", "CCCC.CC.CCCCCCC", "CCCC.CCCCCCCCCC", "CCCCCCCCCCCCCCC", "CCCCCCCCCCCCCCC", "CCCCCCCCCCCCCCC", "CCCCCCCCCCCCCCC" }; vector <string> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); verify_case(5, Arg1, solve(Arg0)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    TheSquareDivTwo c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

#define h first
#define m second
#define pii pair<int,int>
#define mk make_pair

pii GetTime( string time ){
    int h,m,g;
    sscanf(time.c_str(),"%d:%d GMT%d",&h,&m,&g);
    
    
    h -= g;
    if( h < 0 ) h += 24;
    if( h >= 24 ) h -= 24;
    
    return mk(h,m);
}

string ToStr( int val ){
     string r = "";
     while( val ){
         r += string(1 , val%10 + '0');
         val /= 10;       
     }
     reverse( r.begin() , r.end() );
     if( r.size() == 0 ) r = "00";
     if( r.size() == 1 ) r = "0" + r;
     
     return r;
}


int H = 99, M = 99;


class TheTriangleBothDivs {
    public:
        string fix(string t)
        {
            H = 99 , M = 99;
            
            string prv = t;
            
            int from1 = '0' , to1 = '2';
            if( t[0] != '?' ) from1 = to1 = t[0];
            
            for( char i = from1; i <= to1; ++i ){
                 
                 int from2 = '0' , to2 = '9';
                 if( t[1] != '?' ) from2 = to2 = t[1];
                 else if( i == '2' ) from2 = '0' , to2 = '4';
                 
                 for( char j = from2; j <= to2; ++j ){
                      
                      int from3 = '0' , to3 = '6';
                      if( t[3] != '?' ) from3 = to3 = t[3];
                      
                      if( i == '2' && j > '3' ) continue;
                      
                      for( char k = from3; k <= to3; ++k ){
                          
                          int from4 = '0' , to4 = '9';
                          if( t[4] != '?' ) from4 = to4 = t[4];
                          else if( k == 6 ) from4 = to4 = '0';
                          
                          for( char l = from4; l <= to4; ++l ){
                              
                              int from5 = '0' , to5 = '9';
                              if( t[10] != '?' ) from5 = to5 = t[10];
                              
                              if( k == '6' && l > '0' ) continue;
                              
                              for( char m = from5; m <= to5; ++m ){
                                   
                                   t[0] = i , t[1] = j;
                                   t[3] = k , t[4] = l;
                                   t[10] = m;
                                   
                                   if( t[9] == '?' ){
                                       
                                       if( m != '0' ){
                                          t[9] = '-';
                                          pii z = GetTime( t );
                                          if( H > z.h ) H = z.h , M = z.m;
                                          else if( H == z.h && M > z.m ) H = z.h , M = z.m;;
                                       }
                                      

                                       t[9] = '+';
                                       pii z = GetTime( t );
                                       if( H > z.h ) H = z.h , M = z.m;
                                       else if( H == z.h && M > z.m ) H = z.h , M = z.m;;
                                       
                                   }else{
                                       if( m == '0' && t[9] == '-' ) continue;
                                       pii z = GetTime( t );
                                       if( H > z.h ) H = z.h , M = z.m;
                                       else if( H == z.h && M > z.m ) H = z.h , M = z.m;;
                                   }
                                   t = prv;
                              }
                              
                              
                          }
                          
                          
                      }
                 }
                 
            }
            

            return ToStr(H) + ":" + ToStr(M);
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const string &Expected, const string &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { string Arg0 = "?4:00 GMT?1"; string Arg1 = "03:00"; verify_case(0, Arg1, fix(Arg0)); }
	void test_case_1() { string Arg0 = "16:?? GMT??"; string Arg1 = "00:00"; verify_case(1, Arg1, fix(Arg0)); }
	void test_case_2() { string Arg0 = "?1:34 GMT-9"; string Arg1 = "06:34"; verify_case(2, Arg1, fix(Arg0)); }
	void test_case_3() { string Arg0 = "?2:22 GMT+0"; string Arg1 = "00:00"; verify_case(3, Arg1, fix(Arg0)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    TheTriangleBothDivs c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

#define ok(x,y) (x>=0&&x<w&&y>=0&&y<h)

#define pii pair<int,int>
#define x first
#define y second
#define mk make_pair

int ds[20][20];
int d[][2] = { 0,1 , 0,-1 , 1,0, -1,0 };

class Desertification {
    public:
        int t,i,jl;
        struct pa{
            int q,w,e;
        };
        int desertArea(vector <string> s, int t)
        {
             memset( ds , -1 , sizeof(ds) );
             int h = s.size();
             int w = s[0].length();
             
             queue< pii > q;
             
             for( int i = 0; i < h; ++i )
                 for( int j = 0; j < w; ++j ){
                      if( s[i][j] =='D' ){
                          ds[i][j] = 0;
                          q.push( mk(j,i) );
                      }
                 }
             
             while( !q.empty() ){
                 pii u = q.front(); q.pop();
                 
                 for( int i = 0; i < 4; ++i ){
                      int xn = u.x + d[i][0];
                      int yn = u.y + d[i][1];
                      
                      if( ok(xn,yn) == false ) continue;
                      if( ds[u.y][u.x] == t ) continue;
                      if( ds[yn][xn] != -1 ) continue;
                      
                      ds[yn][xn] = ds[u.y][u.x] + 1;
                      q.push( mk(xn,yn));
                 }
             }
             int sol = 0;
             for( int i = 0; i < h; ++i )
                 for( int j = 0; j < w; ++j )
                      sol += ds[i][j] != -1;
             return sol;
                      
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); if ((Case == -1) || (Case == 5)) test_case_5(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { string Arr0[] = {"FFFD"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 5; int Arg2 = 5; verify_case(0, Arg2, desertArea(Arg0, Arg1)); }
	void test_case_1() { string Arr0[] = {"FFF",
 "FDF",
 "FFF"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 2; int Arg2 = 9; verify_case(1, Arg2, desertArea(Arg0, Arg1)); }
	void test_case_2() { string Arr0[] = {"FFFFF",
 "FFDFF",
 "FFFFD",
 "FFFFF",
 "FFFFF"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 2; int Arg2 = 17; verify_case(2, Arg2, desertArea(Arg0, Arg1)); }
	void test_case_3() { string Arr0[] = {"FFFFFF",
 "FFFFFF",
 "FFFFFF",
 "FFFFFF"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 1000000000; int Arg2 = 0; verify_case(3, Arg2, desertArea(Arg0, Arg1)); }
	void test_case_4() { string Arr0[] = {"FFFFFDFFFF",
 "FDFDFFFFFF",
 "FFFFFFFFFD",
 "FFFFFFFFFF",
 "DDFFFFFFFF", 
 "FFFFFFFFFD",
 "FFFFFFFFFF",
 "FFFFFFFDFF",
 "FFFFFFFDFF",
 "FFFFDDFFFF"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 3; int Arg2 = 90; verify_case(4, Arg2, desertArea(Arg0, Arg1)); }
	void test_case_5() { string Arr0[] = {"FFFFFDFFFF",
 "FDFDFFFFFF",
 "FFFFFFFFFD",
 "FFFFFFFFFF",
 "DDFFFFFFFF", 
 "FFFFFFFFFD",
 "FFFFFFFFFF",
 "FFFFFFFDFF",
 "FFFFFFFDFF",
 "FFFFDDFFFF"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 98765432; int Arg2 = 100; verify_case(5, Arg2, desertArea(Arg0, Arg1)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    Desertification c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

const double PI = acos(0) * 2;

class RecursiveFigures {
    public:
        double getArea(int s, int K)
        {
            double sol = 0;
            double a = s;
            
            for( int i = 0; i < K; ++i ){
                 
                sol += a*a;
                a /= 2;
                
                sol -= a*a*PI;
                
                a = a*sqrt(2);

            }
            return s*s-sol;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const double &Expected, const double &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arg0 = 10; int Arg1 = 1; double Arg2 = 78.53981633974483; verify_case(0, Arg2, getArea(Arg0, Arg1)); }
	void test_case_1() { int Arg0 = 10; int Arg1 = 2; double Arg2 = 67.80972450961724; verify_case(1, Arg2, getArea(Arg0, Arg1)); }
	void test_case_2() { int Arg0 = 10; int Arg1 = 3; double Arg2 = 62.444678594553444; verify_case(2, Arg2, getArea(Arg0, Arg1)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    RecursiveFigures c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <vector>
#include <iostream>
#include <sstream>
using namespace std;


class Inequalities {
    public:
        int maximumSubset(vector <string> in)
        {
            string eq;
            int r , sol = 0;
            
            for( double v = -1000; v <= 1005; v+=0.5 ){
                
                int cnt = 0;
                
                for( int i = 0; i < in.size(); ++i ){
                     stringstream ss (stringstream::in | stringstream::out);
                     ss << in[i];
                     ss >> eq >> eq >> r;
                     
                     if( eq[0] == '=' ){
                         if( v == r ) cnt++;
                     }else if( eq.size() > 1 ){
                         if( eq[0] == '<' ) cnt += v <= r;
                         else cnt += v >= r;
                     }else{
                         if( eq[0] == '<' ) cnt += v < r;
                         else cnt += v > r;
                     }
                }
                sol = max( sol , cnt );
            }
            return sol;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { string Arr0[] = {"X <= 12" , "X = 13" , "X > 9" , "X < 10", "X >= 14"  }; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 1; verify_case(0, Arg1, maximumSubset(Arg0)); }
	void test_case_1() { string Arr0[] = {"X < 0","X <= 0"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 2; verify_case(1, Arg1, maximumSubset(Arg0)); }
	void test_case_2() { string Arr0[] = {"X = 1","X = 2","X = 3","X > 0"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 2; verify_case(2, Arg1, maximumSubset(Arg0)); }
	void test_case_3() { string Arr0[] = {"X <= 521","X >= 521","X = 521","X > 902","X > 12","X <= 1000"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 5; verify_case(3, Arg1, maximumSubset(Arg0)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    Inequalities c;
    c.__test();
    system("Pause");
}
// END CUT HERE

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <math.h>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
using namespace std;

int a,b;
int sz[2];
int nums[2][105];
int dp[15][105][2][2];

void transfer( int v , int niz[100]  ){
    int g = 0;
    while( v ){
        niz[g++] = v % 10;
        v /= 10;
    }
}

int limit;


int solve( int idx , int ss , bool iznad , bool ispod ){
    if( idx == -1 ) return ss == limit;
    
    int &ref = dp[idx][ss][iznad][ispod];
    if( ref != -1 ) return ref;
    
    int sol = 0;
    
    for( int i = 0; i <= 9; ++i ){
        if( !iznad && nums[0][idx] > i ) continue;
        if( !ispod && nums[1][idx] < i ) continue;
        
        sol += solve( idx - 1 , ss + i , iznad | ( nums[0][idx] < i ) , ispod | ( nums[1][idx] > i )   );
    }
    
    return ref = sol;    
}


int main(){
    cin >> a >> b;
    
    transfer( a , nums[0] );
    transfer( b , nums[1] );
    
    int sol = 0;
    int sum = 0;
    
    for( int i = 1; i < 9*10; ++i ){
        
        limit = i;
        
        memset( dp , -1 , sizeof(dp));
        int cnt = solve( 10 , 0 , false , false );
        
        if( cnt >= sum )
            sum = cnt , sol = i;
        
    }
    
    printf("%d\n",sol);
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:sprime
*/
#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int n;

bool prime( int v ){
     if( v == 1 ) return false;
     if( v != 2 && !(v&1) ) return false;
     for( int i = 3; i*i <= v; i += 2 )
         if( v % i == 0 )return false;
     return true;
}

void solve( int d , int v ){
    if( d == n ){
        printf("%d\n",v);
        return;
    }
    
    for( int i = 1; i <= 9; ++i ){
         int z = v * 10 + i;
         if( prime(z) )
              solve( d + 1 , z );
    }
    
}

int main(){
    freopen("sprime.in","r",stdin);
    freopen("sprime.out","w",stdout);
    scanf("%d",&n);
    
    solve(0,0);
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:castle
*/
#include <iostream>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <cstdio>
#include <algorithm>
#include <string.h>
using namespace std;

int w,h;
int mx[55][55];

// 1234
// down  == 4th bit
// right == 3th bit
// up    == 2th bit
// left  == 1th bit

#define ok(x,y) (x>=0&&x<w&&y>=0&&y<h)

bool visi[77][77];


int cnt = 0;

void dfs( int x, int y ){
    if( ok(x,y) == false ) return;
    if( visi[y][x] ) return;
    
    visi[y][x] = true;
    cnt++;
    
    int &ref = mx[y][x];
    if( ~ref&1 )dfs(x-1,y);
    if( ~ref&(1<<1) )dfs(x,y-1);
    if( ~ref&(1<<2) )dfs(x+1,y);
    if( ~ref&(1<<3) )dfs(x,y+1);
}

int main(){
    freopen("castle.in","r",stdin);
    freopen("castle.out","w",stdout);
    
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d%d",&w,&h);
    
    for( int i = 0; i < h; ++i )
        for( int j = 0; j < w; ++j )
            fscanf(in,"%d",&mx[i][j]);
    
    int cntR = 0;
    int cntX = 0;
    for( int i = 0; i < h; ++i ){
         for( int j = 0; j < w; ++j ){
             if( visi[i][j] ) continue;
             cnt = 0 , cntR++;
             dfs(j,i);
             cntX = max( cntX , cnt );
         }
    }
    
    int MAXX = -1;
    int rx,cx;
    char d;
    for( int c = 0; c < w; ++c ){
        for( int r = h-1; r >= 0; --r ){
            for( int j = 0; j < 4; ++j ){
                int &ref = mx[r][c];
                if( ~ref&(1<<j) ) continue;
                
                memset( visi , 0 , sizeof(visi));
                ref ^= 1<<j;
                
                cnt = 0;
                dfs(c,r);
                if( MAXX < cnt ){
                    MAXX = cnt;
                    rx = r;
                    cx = c;
                    if( j == 0 ) d ='W';
                    if( j == 1 ) d ='N';
                    if( j == 2 ) d ='E';
                    if( j == 3 ) d ='S';
                }
                
                ref ^= 1<<j;
                
            }
        }
    }
    
    cout<<cntR<<endl;
    cout<<cntX<<endl;
    cout<<MAXX<<endl;
    cout<<rx+1<<" "<<cx+1<<" "<<d<<endl;
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <math.h>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
using namespace std;


int n,k;

int dx = 1<<30 , sol = 0;
int cnt = 0;
int v[20];

void solve( int pos , int sum ){
    if( pos == cnt ){
        int df = abs(sum - k );
        if( dx > df ) dx = df , sol = sum;
        return;
    }
    
    int y = 0;
    for( int i = pos; i < cnt; ++i ){
        y = y * 10 + v[i];
        solve( i + 1 , sum + y );
    }
}

int main(){
    scanf("%d%d",&n,&k);
    
    while( n ){
        v[ cnt ++ ] = n % 10;
        n /= 10;
    }
    
    reverse( v , v + cnt );
    solve( 0 , 0 );
    
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <cstdio>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int n,h;
int arr[100];



int main(){
    scanf("%d",&n);
    
    int ss = 0;
    
    for( int i = 0; i < n; ++i )
        scanf("%d",&arr[i]) , ss += arr[i];
    
    int h = ss / 2;
    int sol = 0;
    
    for( int i = 0; i < (1<<n); ++i ){
        int g = 0;
        for( int j = 0; j < n; ++j )
            if( i & ( 1 << j ) )
                g += arr[j];
        if( g > h )
            sol ++;
    }
    
    cout<<sol<<endl;
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
using namespace std;

#define pq priority_queue
#define mk make_pair
#define x first
#define y second
#define f first
#define s second
#define pii pair<int,int>
#define piii pair< int , pair<int,int> >
#define mt(x,y,z) make_pair(x,make_pair(y,z))

#define ok(x,y) (x>=0&&x<M&&y>=0&&y<N&&mx[y][x]!='#')

pii S , E;
int N,M,H,V;
char mx[200][200];

int d[][2] = { 0,1 , 0,-1 , 1,0,  -1,0 };

void input( FILE *in ){
    fscanf(in,"%d%d%d%d",&N,&M,&H,&V);
    
    for( int i = 0; i < N; ++i ){
        fscanf(in,"%s",mx[i]);
        for( int j = 0; j < M; ++j )
             if( mx[i][j] == 'S' ){
                 mx[i][j] = '0';
                 S = mk(j,i);
             }else if ( mx[i][j] == 'E' ){
                 mx[i][j] = '0';
                 E = mk(j,i);
             }
    }
}

int D[105][105];

void process(){
    memset( D , 1 , sizeof(D));
    pq< piii , vector< piii  > , greater< piii >  > PQ;
    
    piii u;
    PQ.push( mt(0, S.x,S.y  )   );
   
    while( !PQ.empty() ){
        u = PQ.top();
        PQ.pop();
        
        if( u.s.x == E.x && u.s.y == E.y ) break;
        
        for( int i = 0; i < 4; ++i ){
            int xn  = u.s.x + d[i][0];
            int yn  = u.s.y + d[i][1];
            if( ok(xn,yn) == false ) continue;
            
            int dst = u.f + mx[yn][xn] - '0';
            if( u.s.x != xn ) dst += H;
            else dst += V;
            
            if( D[xn][yn] > dst ){
                D[xn][yn] = dst;
                PQ.push( mt( dst , xn , yn) );
            }
            
            
        }
    }
    
    if( u.s.x == E.x && u.s.y == E.y )
        printf("%d\n",u.f );
    else
        printf("-1\n");
    
    
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    input(in);
    process();
    
    
    //system("Pause");
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
using namespace std;

const int maxn = 3000000;
int rev[maxn + 5];

typedef long long ll;

ll val[1000][2] = {
9000,10010001,9900,1010001,18000,10020001,18900,10109001,19800,1020001,19890,11009901,19989,10009990,20790,1100801,20889,1000890,27000,10030001,27900,10108001,28890,11008901,28989,10008990,29700,1030001,30690,1100701,30789,1000790,36000,10040001,36900,10107001,37890,11007901,37989,10007990,39600,1040001,40590,1100601,40689,1000690,45000,10050001,45900,10106001,46890,11006901,46989,10006990,49500,1050001,50490,1100501,50589,1000590,54000,10060001,54900,10105001,55890,11005901,55989,10005990,59400,1060001,60390,1100401,60489,1000490,63000,10070001,63900,10104001,64890,11004901,64989,10004990,69300,1070001,70290,1100301,70389,1000390,72000,10080001,72900,10103001,73890,11003901,73989,10003990,79200,1080001,80190,1100201,80289,1000290,81000,10090001,81900,10102001,82890,11002901,82989,10002990,89100,1090001,90000,1000100001,90090,1100101,90189,1000190,90900,10101001,91890,11001901,91989,10001990,99000,100100001,99900,10100001,99990,1100001,100089,1000090,100890,11000901,100989,10000990,108900,10110001,109890,1110001,110880,1200901,110979,1000980,117900,10120001,118800,10209001,118890,11020901,118989,10020990,119790,1120001,119889,1020090,120780,1200801,126900,10130001,127800,10208001,127890,11030901,127989,10030990,128790,11008801,128889,10008890,129690,1130001,129789,1030090,130680,1200701,130779,1000780,135900,10140001,136800,10207001,136890,11040901,136989,10040990,137790,11007801,137889,10007890,139590,1140001,139689,1040090,140580,1200601,140679,1000680,144900,10150001,145800,10206001,145890,11050901,145989,10050990,146790,11006801,146889,10006890,149490,1150001,149589,1050090,150480,1200501,150579,1000580,153900,10160001,154800,10205001,154890,11060901,154989,10060990,155790,11005801,155889,10005890,159390,1160001,159489,1060090,160380,1200401,160479,1000480,162900,10170001,163800,10204001,163890,11070901,163989,10070990,164790,11004801,164889,10004890,169290,1170001,169389,1070090,170280,1200301,170379,1000380,171900,10180001,172800,10203001,172890,11080901,172989,10080990,173790,11003801,173889,10003890,179190,1180001,179289,1080090,180000,1000200001,180180,1200201,180279,1000280,180900,10190001,181800,10202001,181890,11090901,181989,10090990,182790,11002801,182889,10002890,189000,1001090001,189090,1190001,189189,1090090,190080,1200101,190179,1000180,190800,10201001,191790,11001801,191889,10001890,198000,100200001,198900,1010099001,199800,10200001,199890,1100099901,199980,1200001,199989,1000099990,200079,1000080,200790,11000801,200889,10000890,207900,101008001,208800,10210001,208890,110008901,208989,100008990,209790,11010801,209880,1210001,209889,10010890,209979,1010080,210870,1300901,210969,1000970,217800,10220001,218700,10309001,218790,11020801,218889,10020890,219690,11009701,219780,1220001,219789,10009790,219879,1020080,220770,1300801,220869,1000870,226800,10230001,227700,10308001,227790,11030801,227889,10030890,228690,11008701,228789,10008790,229680,1230001,229779,1030080,230670,1300701,230769,1000770,235800,10240001,236700,10307001,236790,11040801,236889,10040890,237690,11007701,237789,10007790,239580,1240001,239679,1040080,240570,1300601,240669,1000670,244800,10250001,245700,10306001,245790,11050801,245889,10050890,246690,11006701,246789,10006790,249480,1250001,249579,1050080,250470,1300501,250569,1000570,253800,10260001,254700,10305001,254790,11060801,254889,10060890,255690,11005701,255789,10005790,259380,1260001,259479,1060080,260370,1300401,260469,1000470,262800,10270001,263700,10304001,263790,11070801,263889,10070890,264690,11004701,264789,10004790,269280,1270001,269379,1070080,270000,1000300001,270270,1300301,270369,1000370,271800,10280001,272700,10303001,272790,11080801,272889,10080890,273690,11003701,273789,10003790,279000,1001080001,279180,1280001,279279,1080080,280170,1300201,280269,1000270,280800,10290001,281700,10302001,281790,11090801,281889,10090890,282690,11002701,282789,10002790,288900,1010089001,289080,1290001,289179,1090080,289890,1100089901,289989,1000089990,290070,1300101,290169,1000170,290700,10301001,291690,11001701,291789,10001790,297000,100300001,299700,10300001,299970,1300001,300069,1000070,300690,11000701,300789,10000790,306900,101007001,307890,110007901,307989,100007990,308700,10310001,309690,11010701,309789,10010790,309870,1310001,309969,1010070,310860,1400901,310959,1000960,317700,10320001,318600,10409001,318690,11020701,318789,10020790,319590,11009601,319689,10009690,319770,1320001,319869,1020070,320760,1400801,320859,1000860,326700,10330001,327600,10408001,327690,11030701,327789,10030790,328590,11008601,328689,10008690,329670,1330001,329769,1030070,330660,1400701,330759,1000760,335700,10340001,336600,10407001,336690,11040701,336789,10040790,337590,11007601,337689,10007690,339570,1340001,339669,1040070,340560,1400601,340659,1000660,344700,10350001,345600,10406001,345690,11050701,345789,10050790,346590,11006601,346689,10006690,349470,1350001,349569,1050070,350460,1400501,350559,1000560,353700,10360001,354600,10405001,354690,11060701,354789,10060790,355590,11005601,355689,10005690,359370,1360001,359469,1060070,360000,1000400001,360360,1400401,360459,1000460,362700,10370001,363600,10404001,363690,11070701,363789,10070790,364590,11004601,364689,10004690,369000,1001070001,369270,1370001,369369,1070070,370260,1400301,370359,1000360,371700,10380001,372600,10403001,372690,11080701,372789,10080790,373590,11003601,373689,10003690,378900,1010079001,379170,1380001,379269,1080070,379890,1100079901,379989,1000079990,380160,1400201,380259,1000260,380700,10390001,381600,10402001,381690,11090701,381789,10090790,382590,11002601,382689,10002690,389070,1390001,389169,1090070,390060,1400101,390159,1000160,390600,10401001,391590,11001601,391689,10001690,396000,100400001,399600,10400001,399960,1400001,400059,1000060,400590,11000601,400689,10000690,405900,101006001,406890,110006901,406989,100006990,408600,10410001,409590,11010601,409689,10010690,409860,1410001,409959,1010060,410850,1500901,410949,1000950,417600,10420001,418500,10509001,418590,11020601,418689,10020690,419490,11009501,419589,10009590,419760,1420001,419859,1020060,420750,1500801,420849,1000850,426600,10430001,427500,10508001,427590,11030601,427689,10030690,428490,11008501,428589,10008590,429660,1430001,429759,1030060,430650,1500701,430749,1000750,435600,10440001,436500,10507001,436590,11040601,436689,10040690,437490,11007501,437589,10007590,439560,1440001,439659,1040060,440550,1500601,440649,1000650,444600,10450001,445500,10506001,445590,11050601,445689,10050690,446490,11006501,446589,10006590,449460,1450001,449559,1050060,450000,1000500001,450450,1500501,450549,1000550,453600,10460001,454500,10505001,454590,11060601,454689,10060690,455490,11005501,455589,10005590,459000,1001060001,459360,1460001,459459,1060060,460350,1500401,460449,1000450,462600,10470001,463500,10504001,463590,11070601,463689,10070690,464490,11004501,464589,10004590,468900,1010069001,469260,1470001,469359,1070060,469890,1100069901,469989,1000069990,470250,1500301,470349,1000350,471600,10480001,472500,10503001,472590,11080601,472689,10080690,473490,11003501,473589,10003590,479160,1480001,479259,1080060,480150,1500201,480249,1000250,480600,10490001,481500,10502001,481590,11090601,481689,10090690,482490,11002501,482589,10002590,489060,1490001,489159,1090060,490050,1500101,490149,1000150,490500,10501001,491490,11001501,491589,10001590,495000,100500001,499500,10500001,499950,1500001,500049,1000050,500490,11000501,500589,10000590,504900,101005001,505890,110005901,505989,100005990,508500,10510001,509490,11010501,509589,10010590,509850,1510001,509949,1010050,510840,1600901,510939,1000940,517500,10520001,518400,10609001,518490,11020501,518589,10020590,519390,11009401,519489,10009490,519750,1520001,519849,1020050,520740,1600801,520839,1000840,526500,10530001,527400,10608001,527490,11030501,527589,10030590,528390,11008401,528489,10008490,529650,1530001,529749,1030050,530640,1600701,530739,1000740,535500,10540001,536400,10607001,536490,11040501,536589,10040590,537390,11007401,537489,10007490,539550,1540001,539649,1040050,540000,1000600001,540540,1600601,540639,1000640,544500,10550001,545400,10606001,545490,11050501,545589,10050590,546390,11006401,546489,10006490,549000,1001050001,549450,1550001,549549,1050050,550440,1600501,550539,1000540,553500,10560001,554400,10605001,554490,11060501,554589,10060590,555390,11005401,555489,10005490,558900,1010059001,559350,1560001,559449,1060050,559890,1100059901,559989,1000059990,560340,1600401,560439,1000440,562500,10570001,563400,10604001,563490,11070501,563589,10070590,564390,11004401,564489,10004490,569250,1570001,569349,1070050,570240,1600301,570339,1000340,571500,10580001,572400,10603001,572490,11080501,572589,10080590,573390,11003401,573489,10003490,579150,1580001,579249,1080050,580140,1600201,580239,1000240,580500,10590001,581400,10602001,581490,11090501,581589,10090590,582390,11002401,582489,10002490,589050,1590001,589149,1090050,590040,1600101,590139,1000140,590400,10601001,591390,11001401,591489,10001490,594000,100600001,599400,10600001,599940,1600001,600039,1000040,600390,11000401,600489,10000490,603900,101004001,604890,110004901,604989,100004990,608400,10610001,609390,11010401,609489,10010490,609840,1610001,609939,1010040,610830,1700901,610929,1000930,617400,10620001,618300,10709001,618390,11020401,618489,10020490,619290,11009301,619389,10009390,619740,1620001,619839,1020040,620730,1700801,620829,1000830,626400,10630001,627300,10708001,627390,11030401,627489,10030490,628290,11008301,628389,10008390,629640,1630001,629739,1030040,630000,1000700001,630630,1700701,630729,1000730,635400,10640001,636300,10707001,636390,11040401,636489,10040490,637290,11007301,637389,10007390,639000,1001040001,639540,1640001,639639,1040040,640530,1700601,640629,1000630,644400,10650001,645300,10706001,645390,11050401,645489,10050490,646290,11006301,646389,10006390,648900,1010049001,649440,1650001,649539,1050040,649890,1100049901,649989,1000049990,650430,1700501,650529,1000530,653400,10660001,654300,10705001,654390,11060401,654489,10060490,655290,11005301,655389,10005390,659340,1660001,659439,1060040,660330,1700401,660429,1000430,662400,10670001,663300,10704001,663390,11070401,663489,10070490,664290,11004301,664389,10004390,669240,1670001,669339,1070040,670230,1700301,670329,1000330,671400,10680001,672300,10703001,672390,11080401,672489,10080490,673290,11003301,673389,10003390,679140,1680001,679239,1080040,680130,1700201,680229,1000230,680400,10690001,681300,10702001,681390,11090401,681489,10090490,682290,11002301,682389,10002390,689040,1690001,689139,1090040,690030,1700101,690129,1000130,690300,10701001,691290,11001301,691389,10001390,693000,100700001,699300,10700001,699930,1700001,700029,1000030,700290,11000301,700389,10000390,702900,101003001,703890,110003901,703989,100003990,708300,10710001,709290,11010301,709389,10010390,709830,1710001,709929,1010030,710820,1800901,710919,1000920,717300,10720001,718200,10809001,718290,11020301,718389,10020390,719190,11009201,719289,10009290,719730,1720001,719829,1020030,720000,1000800001,720720,1800801,720819,1000820,726300,10730001,727200,10808001,727290,11030301,727389,10030390,728190,11008201,728289,10008290,729000,1001030001,729630,1730001,729729,1030030,730620,1800701,730719,1000720,735300,10740001,736200,10807001,736290,11040301,736389,10040390,737190,11007201,737289,10007290,738900,1010039001,739530,1740001,739629,1040030,739890,1100039901,739989,1000039990,740520,1800601,740619,1000620,744300,10750001,745200,10806001,745290,11050301,745389,10050390,746190,11006201,746289,10006290,749430,1750001,749529,1050030,750420,1800501,750519,1000520,753300,10760001,754200,10805001,754290,11060301,754389,10060390,755190,11005201,755289,10005290,759330,1760001,759429,1060030,760320,1800401,760419,1000420,762300,10770001,763200,10804001,763290,11070301,763389,10070390,764190,11004201,764289,10004290,769230,1770001,769329,1070030,770220,1800301,770319,1000320,771300,10780001,772200,10803001,772290,11080301,772389,10080390,773190,11003201,773289,10003290,779130,1780001,779229,1080030,780120,1800201,780219,1000220,780300,10790001,781200,10802001,781290,11090301,781389,10090390,782190,11002201,782289,10002290,789030,1790001,789129,1090030,790020,1800101,790119,1000120,790200,10801001,791190,11001201,791289,10001290,792000,100800001,799200,10800001,799920,1800001,800019,1000020,800190,11000201,800289,10000290,801900,101002001,802890,110002901,802989,100002990,808200,10810001,809190,11010201,809289,10010290,809820,1810001,809919,1010020,810000,1000900001,810810,1900901,810909,1000910,817200,10820001,818100,10909001,818190,11020201,818289,10020290,819000,1001020001,819090,11009101,819189,10009190,819720,1820001,819819,1020020,820710,1900801,820809,1000810,826200,10830001,827100,10908001,827190,11030201,827289,10030290,828090,11008101,828189,10008190,828900,1010029001,829620,1830001,829719,1030020,829890,1100029901,829989,1000029990,830610,1900701,830709,1000710,835200,10840001,836100,10907001,836190,11040201,836289,10040290,837090,11007101,837189,10007190,839520,1840001,839619,1040020,840510,1900601,840609,1000610,844200,10850001,845100,10906001,845190,11050201,845289,10050290,846090,11006101,846189,10006190,849420,1850001,849519,1050020,850410,1900501,850509,1000510,853200,10860001,854100,10905001,854190,11060201,854289,10060290,855090,11005101,855189,10005190,859320,1860001,859419,1060020,860310,1900401,860409,1000410,862200,10870001,863100,10904001,863190,11070201,863289,10070290,864090,11004101,864189,10004190,869220,1870001,869319,1070020,870210,1900301,870309,1000310,871200,10880001,872100,10903001,872190,11080201,872289,10080290,873090,11003101,873189,10003190,879120,1880001,879219,1080020,880110,1900201,880200,10890001,880209,1000210,881100,10902001,881190,11090201,881289,10090290,882090,11002101,882189,10002190,889020,1890001,889119,1090020,890010,1900101,890100,10901001,890109,1000110,891000,100900001,891090,11001101,891189,10001190,899100,10900001,899910,1900001,900009,1000010,900090,11000101,900189,10000190,900900,101001001,901890,110001901,901989,100001990,908100,10910001,909000,1001010001,909090,11010101,909189,10010190,909810,1910001,909909,1010010,910899,1000900,917100,10920001,918090,11020101,918189,10020190,918900,1010019001,918990,11009001,919089,10009090,919710,1920001,919809,1020010,919890,1100019901,919989,1000019990,920799,1000800,926100,10930001,927090,11030101,927189,10030190,927990,11008001,928089,10008090,929610,1930001,929709,1030010,930699,1000700,935100,10940001,936090,11040101,936189,10040190,936990,11007001,937089,10007090,939510,1940001,939609,1040010,940599,1000600,944100,10950001,945090,11050101,945189,10050190,945990,11006001,946089,10006090,949410,1950001,949509,1050010,950499,1000500,953100,10960001,954090,11060101,954189,10060190,954990,11005001,955089,10005090,959310,1960001,959409,1060010,960399,1000400,962100,10970001,963090,11070101,963189,10070190,963990,11004001,964089,10004090,969210,1970001,969309,1070010,970299,1000300,971100,10980001,972090,11080101,972189,10080190,972990,11003001,973089,10003090,979110,1980001,979209,1080010,980100,10990001,980199,1000200,981090,11090101,981189,10090190,981990,11002001,982089,10002090,989010,1990001,989109,1090010,990099,1000100,990990,11001001,991089,10001090,999000,1001000001,999900,101000001,999990,11000001,999999,1000000
};


ll bs( ll n ){
    ll sol = -1;
    int lo = 0 , hi = 973;
    while( lo <= hi ){
        int mid = ( lo + hi ) >> 1;
        
        if( val[mid][0] == n ){
            sol = val[mid][1];
            break;
        }
        
        if( val[mid][0] > n ) hi = mid - 1;
        else lo = mid + 1;
    }
    return sol;

}




int main(){
    int z;
    for( int i = 0; i <= maxn; ++i ){
        z = i;
        while( z ){
            rev[i] = rev[i] * 10 + z % 10;
            z /= 10;
        }
        
    }
    
    bool ok = false;
    int n;
    scanf("%d",&n);
    
    for( int i = n; i <= maxn; ++i ){
        if( i - n == rev[i] ){
            printf("%d\n",i);
            ok = true;
            break;
        }
    }
    
    ll v = bs( n );
    
    
    if( n == 990000 )
        printf("10001000001\n");
    else if( n == 900000 )
        printf("100001000001\n");
    else if( !ok && v == -1 ) 
        printf("-1\n");
    else  if( !ok ) 
        cout << v <<endl;
 
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:numtri
*/

#include <iostream>
#include <cstdio>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
using namespace std;

int n;
int mx[2][2002];

int main(){
    freopen("numtri.in","r",stdin);
    freopen("numtri.out","w",stdout);
    scanf("%d",&n);
    
    int sol = 0;
    for( int i = 1; i <= n; ++i ){
        int G = n - i;
        for( int j = G , z = 0; z < i; j += 2 , z++ ){
            scanf("%d",&mx[i%2][j] );
            if( i ) mx[i%2][j] = max( mx[(i+1)%2][j-1] + mx[i%2][j] , mx[(i+1)%2][j+1] + mx[i%2][j] );
            sol = max( sol , mx[i%2][j] );
        }
    }
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
using namespace std;

int main(){
    int e,f,c;
    cin >> e >> f >> c;
    int v = e+f;
    
    int sol = 0;
    while( v >= c ){
         int buy = v / c;
         sol += buy;
         v -= buy * c;
         v += buy;
    }
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <cstdlib>
using namespace std;



int main(){
    int tests;
    scanf("%d",&tests);
    for( ; tests; --tests ){
        int n;
        scanf("%d",&n);
        
        int cnt = 0 , v;
        for( int i = 1; i <= n; ++i ){
            scanf("%d",&v);
            if( i == v ) cnt ++;
        }
        if(cnt&1)printf("ALICE\n");
        else printf("BOB\n");
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
using namespace std;

int A;
long long B;
char buff[1005];

int fastpw( int a , long long b ){
    if( b == 0 ) return 1;
    else if( b & 1 ){
         return ( fastpw( a , b - 1 ) * a)%10;;
    }else{
         int z = fastpw( a , b >> 1 );
         return ( z * z )%10;
    }
}

int main(){
    int tests;
    scanf("%d",&tests);
    for( ; tests ; --tests ){
        scanf("%s%lld",buff,&B);
        
        
        
        A = buff[strlen(buff)-1] - '0';
        
        printf("%d\n",fastpw( A , B ) );
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <fstream>
#include <string.h>
using namespace std;

const int maxn = 20000;
int n,k;
int niz[20005];

int cnt[32];

inline void add( int val ){ //cout<<"ADD: "<<val<<endl;
    for( int i = 0; i < 31; ++i ){
        if( !(val&(1<<i)) )
            cnt[i] ++;
    }
}
inline void take( int val ){// cout<<"TAKE: "<<val<<endl;
    for( int i = 0; i < 31; ++i ){
        if( !(val&(1<<i)) )
            cnt[i] --;
    }
}
inline int make( ){
    int sol = 0;
    for( int i = 0; i < 31; ++i )
       if( cnt[i] == 0 )
            sol |= (1<<i);
    return sol;
}


int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");

    int tests;
    fscanf(in,"%d",&tests);

    for( ; tests; --tests ){
        memset( cnt , 0 , sizeof(cnt));
        fscanf(in,"%d%d",&n,&k);

        for( int i = 1; i <= n; ++i )
            fscanf(in,"%d",&niz[i]);

        if( k > n ) k = (k%n) + n;

        int l = 1 , r = 1;
        add( niz[1] );

        for( int j = 0; j < k; ++j ){
            l -- , r ++;
            if( l <= 0 )l = n + l;
            if( r > n  )r = r - n;

            add(niz[l]);
            add(niz[r]);

            if( l == r  ){
                take(niz[r]);
                r--;
                break;
            }else if( r + 1 == l ) break;

        }

        for( int i = 1; i <= n; ++i ){
             printf("%d ",make());

             take( niz[l] );
             l++,r++;
             if( l > n ) l -= n;
             if( r > n ) r -= n;
             add( niz[r] );

        }
        printf("\n");
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int n,k;
int arr[1000];
int mem[1000];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    int tests,a,b,c;
    fscanf(in,"%d",&tests);
    
    for( ; tests; --tests ){
         memset( mem, 0 , sizeof(mem));
        fscanf(in,"%d%d",&n,&k);
        for( int i = 0; i < n; ++i )
            fscanf(in,"%d",&arr[i]);
        
        
        for( int i = 0; i < k; ++i ){
            
            for( int j = 0; j < n; ++j ){
                a  = j > 0 ? arr[j-1] : arr[n-1];
                b = arr[j];
                c = j < n-1 ? arr[j+1] : arr[0];
                mem[j] = a & b & c;
            }
            
            memcpy( arr , mem , sizeof mem );
        }
            for( int i = 0; i < n; ++i )
            cout<<arr[i]<<" ";cout<<endl;
        
    }    
    
    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <fstream>
#include <string.h>
using namespace std;

int n = 5;
int T = 50;

int main(){
    srand( (unsigned) time (0) );
    ofstream out("Ulaz.txt");
    
    out<<T<<endl;
    
    for( int i = 0; i < T; ++i ){
         out<<n<<" "<<100<<endl;
         
         for( int j = 0; j < n
         ; ++j )
             out<< ( rand()%1000000000 ) <<" ";
         out<<endl;
         
    }
    
    return 0;
}

#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <stack>
using namespace std;

const int maxn = 505;
int n , k , arr[maxn];
int ma[maxn][maxn] , zx[maxn][maxn];
int mx[maxn] , rs[maxn] , sol[maxn];

inline void popuni( int val[maxn] , int mx[maxn][maxn] ){
    for( int i = 0; i < n; ++i ) for( int j = 0; j < n; ++j ) mx[i][j] = val[ i-j >= 0 ? i-j : i-j+n ];
}

inline void mul( int val[maxn] , int mx[maxn][maxn] ){
    for( int i = 0; i < n; ++i )rs[i] = 0;
    for( int i = 0; i < n; ++i )
        for( int j = 0; j < n; ++j )
            rs[i] = ( rs[i] + val[j] * mx[i][j] );
    
    for( int i = 0; i < n; ++i )val[i] = rs[i];
}

int main(){
    FILE *in = fopen("Ulaz.txt","r");
    
    int tests;
    fscanf(in,"%d",&tests);
    
    for( ; tests; --tests ){
        fscanf(in,"%d%d",&n,&k);// k--;
        
        for( int i = 0; i <= n; ++i )
            mx[i] = rs[i] = sol[i] = 0;
        
        for( int j = 0; j < n; ++j )
            fscanf(in,"%d",&arr[j]);
        
        mx[0] = mx[1] = mx[n-1] = 1;
        for( int i = 0; i < n; ++i ) for( int j = 0; j < n; ++j ) ma[i][j] = mx[ i-j >= 0 ? i-j : i-j+n ];
        memcpy( zx , ma , sizeof zx );
        
        stack< int > stp;
        int v = k;
        while( k ){
            if( k == 1 )break;
            else if( k & 1 ) stp.push( 1 ) , k --;
            else stp.push( 2 ) , k >>= 1;
        }
        
        int mem = 0;
        while( !stp.empty() ){
            int u = stp.top(); stp.pop();
            if( u == 1 ) mul( mx , zx ) , mem ++ ;
            else mul( mx , ma ) , mem *= 2;
            for( int i = 0; i < n; ++i ) for( int j = 0; j < n; ++j ) ma[i][j] = mx[ i-j >= 0 ? i-j : i-j+n ];
        }
        
        for( int i = 0; i < n; ++i ) mx[i] = mx[i]&1;
        
        for( int i = 0; i < n; ++i ){
            int v = arr[i];
            for( int j = 1; j < n; ++j ){
                int k = (i+j);
                if( k >= n ) k -= n;
                if( mx[j] ) v ^= arr[k];
            }
            sol[i] = v;
        }
        
        
        for( int i = 0; i < n; ++i )
             printf("%d ",sol[i]);
        putchar('\n');
         
    }
    system("Pause");
    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int n,k;
int arr[1000];
int mem[1000];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    int tests,a,b,c;
    fscanf(in,"%d",&tests);
    
    for( ; tests; --tests ){
        fscanf(in,"%d%d",&n,&k);
        for( int i = 0; i < n; ++i )
            fscanf(in,"%d",&arr[i]);
        
        
        for( int i = 0; i < k; ++i ){
            
            for( int j = 0; j < n; ++j ){
                a  = j > 0 ? arr[j-1] : arr[n-1];
                b = arr[j];
                c = j < n-1 ? arr[j+1] : arr[0];
                mem[j] = a ^ b ^ c;
            }
            
            memcpy( arr , mem , sizeof mem );
        }
            for( int i = 0; i < n; ++i )
            cout<<arr[i]<<" ";cout<<endl;
        
    }    
    
    return 0;
}

#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#include <math.h>
#include <fstream>
#include <map>
#include <iomanip>
using namespace std;

int n,k;
int a[100][100], b[100][100];
int c[100][100];

void mul() {
    memset( c , 0 , sizeof(c) );
    
    for( int i = 0; i < n; ++i )
        for( int j = 0; j < n; ++j )
            for( int k = 0; k < n; ++k )
                 c[i][j] = ( c[i][j] + a[i][k] * b[k][j] );
    
    for( int i = 0; i < n; ++i )
        for( int j = 0; j < n; ++j )
            a[i][j] = c[i][j];
}

int main(){
    ifstream cin("Ulaz2.txt");
    cin >> n >> k;
    for( int i = 0; i < n; ++i )
        for( int j = 0; j < n; ++j )
            cin >> a[i][j];
    
    memcpy( b , a , sizeof a );
    
    for( int i = 0; i < k; ++i ){
        mul();
        
        
    }
    for( int j = 0; j < n; ++j ){
            for( int k = 0; k < n; ++k ){
                cout<<(a[j][k]&1)<<" ";
            }cout<<endl;
        }
    
    system("pause");
    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <fstream>
#include <string.h>
using namespace std;

int n = 10;
int T = 50;

int main(){
    cout<<( 4^4^4)<<endl;
    srand( (unsigned) time (0) );
    ofstream out("Ulaz.txt");
    
    out<<T<<endl;
    
    for( int i = 0; i < T; ++i ){
         out<<n<<" "<<5894<<endl;
         
         for( int j = 0; j < n
         ; ++j )
             out<< ( rand()%1000000000 ) <<" ";
         out<<endl;
         
    }
    
    system("Pause");
    return 0;
}

#include <iostream>
#include <fstream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <cstdlib>
#include <cstdio>
#include <set>
#include <queue>
#include <stack>
using namespace std;

const int maxn = 55;

int n,m,tests;
int mx[maxn][maxn];

char c;
inline void read( int &v ){
    while( (c = getchar()) < '0' || c > '9' );
    v = c - '0';
    while( (c = getchar()) >= '0' && c <= '9' )v = v*10 + c - '0';
}

int main(){
    read(tests);
    for( ; tests; --tests ){

        read(n); read(m);

        for( int i = 0; i < n; ++i )
            for( int j = 0; j < m; ++j )
                read(mx[i][j]);

        int sol = 0 , lst;

        for( int i = 0; i < n; ++i ){

            lst = 0;
            for( int j = m-1; j >= 0; --j )
                if( mx[i][j] > lst ) lst = mx[i][j];
                else lst = mx[i][j] - 1;

            sol ^= lst;

        }
        if( sol )printf("FIRST\n");
        else printf("SECOND\n");

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <fstream>
#include <set>
#include <queue>
#include <stack>
#include <iomanip>
using namespace std;

int n,m;
int dp[105][1205];
int mm[105][1205];
int p[105];

const int inf = 999999999;

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    int tests;
    fscanf(in,"%d",&tests);
    
    for( ; tests; --tests) {
        fscanf(in,"%d%d",&n,&m);
        for( int i = 1; i <= n; ++i )
            fscanf(in,"%d",&p[i]);
        
        sort( p , p + n + 1 );
        

        int sol = inf , mem = inf;
        
        for( int i = 1; i <= n; ++i ){
            for( int j = 0; j <= 1000; ++j ){
                 
                 dp[i][j] = inf;
                 mm[i][j] = inf;

                 int w = abs(p[i]-j);
                 
                 for( int k = 0; k <= m; ++k ){
                      dp[i][j] = min( dp[i][j] , (j-k>=0 ? dp[i-1][j-k]:dp[i][0]) + w );
                      
                      mm[i][j] = min( mm[i][j] , max(w,(j-k>=0 ? mm[i-1][j-k]:mm[i-1][0]))  );

                      
                      if( i == n )sol = min( sol , dp[i][j] ) , mem = min( mem , mm[i][j]);
                 }
                 
            }
        }
        
        printf("%d %d\n",mem,sol);
    }
    //system("Pause");
    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<math.h>
#include<iomanip>
#include<queue>
#include<string.h>
using namespace std;

int k1,k2,k3;
char str[20000];
char sol[20000];
int G1[20000],G2[20000],G3[2000];
int i1,i2,i3;

void rotate( deque<char> &Q , int k ){
   if( Q.empty() == true )return;
   for( int i=0; i<k; ++i ){
      char u = Q.back(); Q.pop_back();
      Q.push_front(u);
   }
}

void set( deque<char>&Q , int *G , int sz ){
   if( Q.empty() == true ) return;
   for( int i=0; i<sz; ++i ){
      char u = Q.front(); Q.pop_front();
      sol[ G[i] ] = u;
   }
}

int main(){
   while(true){
      scanf("%d%d%d",&k1,&k2,&k3);
      if( k1 == 0 && k2 == 0 && k3 == 0 )break;
      i1 = i2 = i3 = 0;
      deque<char>Q1,Q2,Q3;
      scanf("%s",str);
      for( int i=0; i<strlen(str) ; ++i ){
         if( str[i]>='a' && str[i]<='i' ){
            G1[i1++] = i;
            Q1.push_back(str[i]);
         }else if( str[i]>='j' && str[i]<='r' ){
            G2[i2++] = i;
            Q2.push_back(str[i]);
         }else{
            G3[i3++] = i;
            Q3.push_back(str[i]);
         }
      }
      rotate( Q1 , k1 );
      rotate( Q2 , k2 );
      rotate( Q3 , k3 );
      
      set( Q1 , G1 , i1 );
      set( Q2 , G2 , i2 );
      set( Q3 , G3 , i3 );
      
      sol[ strlen(str) ] = '\0';
      printf("%s\n",sol);
   }
   return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <iomanip>
#include <string.h>
using namespace std;

#define ok(x,y) (x>=0&&x<W&&y>=0&&y<H)

int H,W;
char mx[55][55];
char mm[55][55];

inline void change( int r, int c ){
     if( !ok(c,r) )return;
     if( mx[r][c] == 'R' ) mx[r][c] = 'G';
     else if( mx[r][c] == 'G' ) mx[r][c] = 'B';
     else mx[r][c] = 'R';
}
inline int away( char c ){
    if( c == 'G' ) return 2;
    if( c == 'B' ) return 1;
    return 0;
}

int mxm;
int mov[55][55];

bool solve( int r, int c , int cnt ){
     if( cnt > mxm )return false;
     if( c == W ) c = 0 , r ++;
     
     if( r == H ) return mx[H-1][W-1] == 'R';

     
     for( int i = 0; i < 3; ++i ){
    
         if( r-1 < 0 || mx[r-1][c] == 'R' )
         if( r != H-1 || c - 1 < 0 || mx[r][c-1] == 'R' )
        // if( r == H-1 || c == 0 || away( mx[r+1][c-1]) == away( mx[r][c-1] )  );
         if( solve( r , c + 1 , cnt + i) )
         return true;
         
         
         mov[r][c] ++;
         change( r-1, c );
         change( r+1, c );
         change( r ,  c );
         change( r , c+1);
         change( r , c-1);
     }
     mov[r][c] = 0;
     return false;
}


struct data{
    int a,b,c;
    data( int p1, int p2, int p3 ):a(p1),b(p2),c(p3){};
    data(){};
};


bool EXIST = false;
int sol1 = 0;
int sol2 = 0;
vector< data >sol3;



void take(){
    EXIST = true;
    sol3.clear();
    sol2 = 0;
    sol1 = mxm;
    for( int i = 0; i  < H; ++i ){
        for( int j = 0; j < W; ++j ){
            sol2 += mov[i][j] != 0;
            if( mov[i][j] != 0 )
                sol3.push_back( data( i , j , mov[i][j] )  );
        }
    }
}


void init(){
    sol1 = sol2 = 0;
    sol3.clear();
    EXIST = false;
}


int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    int tests;
    fscanf(in,"%d",&tests);
    
    for( int T = 1; T <= tests; ++T ){
        init();
        fscanf(in,"%d%d",&H,&W);
        
        
        for( int i = 0; i < H; ++i )
             fscanf(in,"%s",mx[i]);
             
        memcpy( mm , mx , sizeof mx );
        
        
        if( H*W >= 30 ){
            printf("Case %d: N\n",T);
            continue;
        }
        
        int lo = 0, hi = 3*H*W;
        while( lo <= hi ){
            mxm = (lo+hi) >> 1;
            
            memcpy( mx , mm , sizeof mx );
            memset( mov , 0 , sizeof(mov));
            bool ok = solve( 0 , 0 , 0 );
            //cout<<mxm<<" = "<<ok<<endl;

            if( ok ) take() , hi = mxm - 1;
            else lo = mxm+1;
        }
        
        if( !EXIST )
             printf("Case %d: N\n",T);
        else{
             printf("Case %d: Y\n",T);
             printf("%d %d\n",sol1,sol2);
             for( int i = 0; i < sol3.size(); ++i )
                 printf("%d %d %d\n", sol3[i].a,sol3[i].b,sol3[i].c );
        }
        
    }
    
    system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
using namespace std;

typedef long long ll;

int szv,szc;
int cv,cc;

int len;
char str[100];


inline bool isVowel( char c ){ if( c == 'a' || c == 'e' || c =='i' || c=='o' || c=='u' ) return true; return false; }
inline bool isCons( char c ){ return !isVowel(c); }


ll dp[20][6][6][3][40];

ll solve( int idx , int same, int group , bool vowel , char prev ){
    
    int z = prev - 'a';
    if( dp[idx][same][group][vowel][z] != -1 ) return dp[idx][same][group][vowel][z];
    
    if( vowel ){
        if( same  > cv  ) return 0;
        if( group > szv ) return 0;
    }else{
        if( same >  cc  ) return 0;
        if( group>  szc ) return 0;
    }
    
    if( idx == len )
        return 1;
    
    
    ll sol = 0;
    int from = 'a' , to = 'z';
    
    if( str[idx] != '*' )
        from = str[idx] , to = str[idx];
    
    for( int i = from; i <= to; ++i ){
        if( vowel ){
            if( i == prev )      sol += solve( idx + 1, same + 1, group + 1, true, i );
            else if( isVowel(i) )sol += solve( idx + 1, 1       , group + 1, true, i );
            else                 sol += solve( idx + 1, 1       , 1        , false,i);
        }else{
            if( i == prev )      sol += solve( idx + 1, same + 1, group + 1, false,i);
            else if( isCons(i) ) sol += solve( idx + 1, 1       , group + 1, false,i);
            else                 sol += solve( idx + 1, 1       , 1        , true ,i);
        }
    }

    return dp[idx][same][group][vowel][z] = sol;
    
}

int main(){
    scanf("%d%d%d%d",&cv,&szv,&cc,&szc);
    scanf("%s",str);
    
    len = strlen(str);
    
    memset( dp, -1, sizeof(dp));
    
    
    cout<< solve ( 0 , 0 , 0 , 0 , 'a' + 30 ) << endl;
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
using namespace std;

int N,K;
int arr[305];
int dp[305][305];

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    fscanf(in,"%d%d",&N,&K);
    
    for( int i = 0; i < N; ++i )
        fscanf(in,"%d",&arr[i]);
    
    memset( dp , 1, sizeof(dp));
    
    for( int i = 0; i <= N; ++i ) dp[i][i] = 1;
    
    for( int i = 2; i <= N; ++i ){
        for( int j = 0; j < N-i+1; ++j ){
            int L = j , R = L + i - 1;
            int r = 999999;
            int s = arr[L] == arr[R];
            
            for( int k = L; k < R; ++k )
                r = min( r , dp[L][k] + dp[k+1][R] - s );
            dp[L][R] = r;
        }
    }
    
    
    printf("%d\n",dp[0][N-1] );
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <math.h>
#include <string.h>
using namespace std;

int n;

int main(){
    scanf("%d",&n);
    
    long long sol = 0;
    
    for( int i = 9 , j = 1; n ; i *= 10 , j++ ){
        sol += j*min(i,n);
        n -= min( i , n );
    }
    printf("%lld\n",sol);
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#include <math.h>
#include <cstdlib>
#include <string.h>
using namespace std;

bool allow[100];

int getp( char c ){
    if( c >= '0' && c <= '9' ) return c - '0';
    else if( c == '*' ) return 10;
    else if( c == '/' ) return 11;
    else if( c == '+' ) return 12;
    else if( c == '-' ) return 13;
    return 20;
}

int ok ( int val ){
    int L = 0;
    while( val ){
        if( allow[ getp( val % 10 + '0' ) ] == false ) return 0;
        val /= 10;
        L++;
    }
    return L;
}


int dp[1005];
char buff[100];
const int inf = 1<<30;
int m;

int main(){
    FILE *in = fopen("Ulaz.txt","r");
    fscanf(in,"%s",buff);
    fscanf(in,"%d",&m);
    
    for( int i = 0; i < strlen(buff); ++i ){
        allow[ getp( buff[i] ) ] = true;
    }
    
    for( int i = 1; i <= 1000; ++i )
        dp[i] = inf;
    
    int z;
    dp[0] = 1;
    
    for( int i = 1; i <= 1000; ++i )
        if( z = ok(i) ) dp[i] = z;
    
    for( int i = 0; i <= 5; ++i ){
        for( int j = 1; j <= 1000; ++j ){
            if( dp[j] == inf) continue;
            for( int k = 1; k <= 1000; ++k ){
                 if( dp[k] == inf ) continue;
                 
                 int v = j/k;
                 int f = j*k <= 1000 ? j*k : 1000;
                 
                 if( allow[10] )dp[f] = min( dp[f] , dp[j] + dp[k] + 1 );
                 if( allow[11] ) dp[v] = min( dp[v] , dp[j] + dp[k] + 1 );
            }
        }
    }
    
    for( int i = 0; i <= 5; ++i ){
        //if( dp[m] != inf ) break;
        for( int j = 0; j <= 1000; ++j ){
            if( dp[j] == inf) continue;
            for( int k = 0; k <= 1000; ++k ){
                 if( dp[k] == inf ) continue;
                 
                 int f = j+k <= 1000 ? j+k : 1000;
                 
                 if( allow[12] )dp[f] = min( dp[f] , dp[j] + dp[k] + 1 );
                 if( allow[13] && j >= k ) dp[j-k] = min( dp[j-k] , dp[j] + dp[k] + 1 );
            }
        }
    }
    if( dp[m] != inf )
        printf("%d\n",dp[m]);
    else
        printf("0\n");
    system("Pause");
    return 0;
}

#include <iostream>
#include <vector>
#include <iomanip>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <string.h>
using namespace std;

int N,M;
int arr[50];

vector< int >v1;
vector< int >v2;

map< int , int > MP;

int main(){
    FILE *in = fopen("Ulaz.txt","r");
    fscanf(in,"%d%d",&M,&N);
    
    int z = N >> 1;
    
    for( int i = 0; i < N; ++i ){
        fscanf(in,"%d",&arr[i]);
        if( i < z ) v1.push_back( arr[i] );
        else  v2.push_back( arr[i] );
    }
    
    int sz1 = v1.size();
    int sz2 = v2.size();
    int ss;
    
    MP[0] = 1;
    for( int i = 1; i < (1<<sz1); ++i ){
        ss = 0;
        for( int j = 0; j < sz1; ++j )
            if( i & ( 1 << j ) )
                ss += v1[j];
        if( ss <= M )
            MP[ ss ] ++;
    }
    
   
    
    long long sol = 0;
    for( int i = 0; i < (1<<sz2); ++i ){
        ss = 0;
        for( int j = 0; j < sz2; ++j )
            if( i & ( 1 << j ) )
                ss += v2[j];
        if( ss <= M )
        sol += MP[ M - ss ];
    }
    cout<< sol % 1000000000 <<endl;
    system("Pause");
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

const int inf = 2000000010;

struct node{
    int idx , val;
    int cntL;
    int minL;
    node *L , *R;
    
    node(){ L = R = NULL; }
    node( int p0 , int p2 ):idx(p0),val(p2){
          L = R = NULL;
          minL = inf;
          cntL = 0;
    };
    
    void insert( int, int , int );
    int query( int , int);
}tree;


void node::insert( int dx, int vv , int add ){

    if( dx <= idx+cntL+add ){
 
        if( L != NULL ) L->insert( dx , vv , add );
        else L = new node( dx-add-cntL , vv );
        cntL++;

        minL = min( minL , vv );
    }else{
          
        if( R != NULL )R->insert( dx , vv , add + cntL );
        else R = new node( dx-add-cntL , vv );
    }
}

int node::query( int dx , int add ){
    if( idx+cntL+add <= dx )
        return min( minL , min( val , R != NULL ? R->query(dx , add + cntL) : inf  )   );
    else if( L != NULL )
        return L->query( dx , add);
    return inf;
}


int N;

int main(){   
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    tree.val = inf;
    fscanf(in,"%d",&N);
    
    int added = 0;
    int a,b,c;
    for( int i = 0; i < N; ++i ){
         fscanf(in,"%d%d",&a,&b);
         
         if( a == 1 ){
             fscanf(in,"%d",&c);
             
             if( !added )tree = node( b,c );
             else tree.insert( b , c , 0 );
             
             added++;
         }else{
             if( added )
                 printf("%d\n",tree.query(b,0) );
             else
                 printf("%d\n",inf);
         }
    }
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <math.h>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
using namespace std;

int N,M,P = 1;
char txt[10][100];
char *pok[10];
char text[1000];

char Q[100][100];
int val[100];

int dp[1000];
int nw[1000];

bool ok( char *pok1, char *pok2 , int sz ){
    for( int i = 0; i < sz; ++i )
        if( *(pok1-i) != *(pok2-i) )
            return false;
    return true;
}


int get( int l ,int r, int msk ){
    if( l > r  ) return 0;
    int ret = 0;
    for( int i = 0; i < M; ++i ){
       if( msk&(1<<i) ) continue;
       
       int ln = strlen(Q[i]);
       int z = msk|(1<<i);
       
       for( int j = l; j <= r; ++j ){
           if( j - ln + 1 < l )continue;
           if( ok( &text[j] , &Q[i][ln-1] , ln ) == false )continue;
           
           
           ret = max( ret , get( j+1 , r , z ) + val[i]   );
           
       }
    }
    return ret;
}

int main(){

    FILE *in =stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d",&N);
    
    for( int i = 0; i < N; ++i ){
        fscanf(in,"%s",txt[i]);
        pok[i] = txt[i];
        P *= (i+1);
    }
    
    fscanf(in,"%d",&M);
    for( int i = 0; i < M ; ++i )
        fscanf(in,"%s%d",Q[i],&val[i]);
    
    int sol = 0;
    for( int i = 0; i < P; ++i ){
        
        int cnt = 0;
        for( int j = 0; j < N; ++j )
            for( int k = 0; k < strlen( pok[j] ); ++k )
                text[cnt++] = pok[j][k];

        memset( dp , 0 , sizeof(dp));
        memset( nw , 0 , sizeof(nw));
        
        
        sol = max( sol , get( 0 , cnt-1 , 0 ) );
        
       // cout<<text<<" = "<<get( 0 , cnt - 1 , 0 )<<endl;
        

        next_permutation( pok , pok + N );
    }
    printf("%d\n",sol);
   // system("Pause");
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
using namespace std;

int n,d,k;
vector< int > rad;
const int inf = 9999999;


void input( FILE *in ){
   fscanf(in,"%d%d%d",&n,&d,&k);
   
   int v;
   for( int i = 0; i < n; ++i ){
       fscanf(in,"%d",&v);
       rad.push_back(v);
   }
   sort( rad.begin() , rad.end() );
}

int dp[105][105];

int solve( int idx , int dst , int range ){
    if( idx == n ){
        if( d-dst <= range ) return 0;
        else return inf;
    }
    
    if( dp[idx][dst] != -1 ) return dp[idx][dst];
    
    int sol = inf;
    for( int i = dst; i <= d; ++i ){
        if( i - dst > range ) continue;
        sol = min( sol , solve( idx + 1 , i , range ) + abs(i-rad[idx])  );
    }
    return dp[idx][dst] = sol;
}


void process(){
    int lo = 0 , hi = 105;
    int sol = inf;
    while( lo <= hi ){    
        int mid = (lo+hi)>>1;
        
        memset( dp , -1 , sizeof(dp));
        int cost = solve( 0 , 0 , mid);

        if( cost <= k ){
             sol = mid;
             hi = mid - 1;
        }else
             lo = mid + 1; 
    }
    printf("%d\n",sol);
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    input( in );
    process();
    
    //system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#include <math.h>
#include <cstdlib>
#include <string.h>
using namespace std;

#define x first
#define y second
#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

#define ok(x,y) (x>=0&&x<W&&y>=0&&y<H&&mx[y][x]!='#')

int H,W;
pii P,B,E;

const int inf = 16843009;

char mx[100][100];
int dp[31][31][31][31];

int d[][2] = { 0,1, 0,-1, 1,0 , -1,0 };

int main(){
    FILE *in = fopen("Ulaz.txt","r");
    
    fscanf(in,"%d%d",&H,&W);
    
    for( int i = 0; i < H; ++i ){
        fscanf(in,"%s",mx[i]);
        for( int j = 0; j < W; ++j ){
            if( mx[i][j] == 'P' ) P = mk(j,i);
            else if( mx[i][j] == 'B' ) B = mk(j,i);
            else if( mx[i][j] == 'F' ) E = mk(j,i);
            
            if( mx[i][j] == 'P' || mx[i][j] == 'B' || mx[i][j] == 'F' ) mx[i][j] = '.';
        }
    }
    
    memset( dp , 1 , sizeof(dp));
    dp[ P.x ][ P.y ][ B.x ][ B.y ] = 0;
    
    queue< pair<pii,pii> > Q;
    Q.push( mk(P , B) );
    
    pair<pii,pii> u;

    while( !Q.empty() ){
        u = Q.front(); Q.pop();

        
        for( int i = 0; i < 4; ++i ){
            int xn = u.f.x + d[i][0];
            int yn = u.f.y + d[i][1];
            
            if( ok(xn,yn) == false ) continue;
            
            int xb = u.s.x;
            int yb = u.s.y;
            
            if( mk(xn,yn) == u.s ){
                xb += d[i][0];
                yb += d[i][1];
            }
            
            if( ok(xb,yb) == false ) continue;
            
            if( dp[xn][yn][xb][yb] == inf ){
                dp[xn][yn][xb][yb] = dp[ u.f.x ][ u.f.y ][ u.s.x ][ u.s.y ] + 1;
                
                Q.push( mk( mk(xn,yn) , mk(xb,yb) ) );
            }
        }
    }
    
    int sol = inf;
    for( int i = 0; i <= 30; ++i )
        for( int j = 0; j <= 30; ++j )
            sol = min( sol , dp[i][j][ E.x ][ E.y ] );
    
    if( sol != inf )
        printf("%d\n",sol);
    else
        printf("-1\n");
    system("Pause");
    return 0;
}

#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
using namespace std;

typedef long long ll;

const ll maxn = 20000000000LL;
const int maxsq = (int)sqrt( maxn )*2;

ll n;
bool prime[300005];
int  moebius[300005];
int  _sqrt[300005];

int main(){
    
    for( int i = 1; i <= maxsq; ++i ){
        moebius[i] = -1;
        prime[i] = true;
        _sqrt[i] = (int)sqrt(i);
    }
    
    for( int i = 2; i <= maxsq; i++ ){
         if( prime[i] )for( int j = i*2; j <= maxsq; j+=i )prime[j] = false;
         
         
         if( _sqrt[i]*_sqrt[i] == i )
             for( int j = i; j <= maxsq; j+=i )
                  moebius[j] = 0;
                  
         else if( prime[i] )
             for( int j = i; j <= maxsq; j+=i )
                  moebius[j] *= -1;
    }
    
      cin >> n;
        
        ll sq = (ll)sqrt(n);
        ll lo = 0 ,hi = 4*n ;
        while ( lo < hi ){         
            ll mid = (lo + hi) >> 1;
            
            ll cnt = mid;
            ll sq = (ll)sqrt(mid);
           // cout<<sq<<" "<<mid<<endl;
            for( ll i = 2; i <= sq; ++i )
                cnt -= moebius[i] * (mid/(i*i));
            
            //cout<<mid<<" "<<cnt<<endl;
            
            if( cnt >= n ) hi = mid;
            else lo = mid + 1;
        }
        cout<<hi<<endl;
      //  }
        //system("Pause");
    return 0;
}

#include <iostream>
#include <math.h>
#include <vector>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
using namespace std;

typedef long long ll;

ll A,B;


int main(){
    cin >> A >> B;
    
    ll sol = 0;
    ll sub = 1 , pw = 2;
    
    for( int i = 0; i < 60; ++i ){
        
        ll ca = (ll)ceil( (A-sub) / (double)pw );
        ll cb = (ll)floor( (B-sub) / (double)pw );
        
        if( cb >= ca && ca*pw + sub >= A && cb*pw + sub <= B )
            sol += (cb-ca+1) * sub;
        
        sub <<= 1;
        pw  <<= 1;
        
    } 
    cout << sol <<endl;
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int n;
int mx[100][100];
int bx[100];
int sol[100];

void input( FILE *in ){
    fscanf(in,"%d",&n);

    for( int i = 0; i < n; ++i ){
         for( int j = 0; j < n; ++j )
             fscanf(in,"%d",&mx[i][j]);
         fscanf(in,"%d",&bx[i]);
    }

}

template <class type>
void div( double v , type *arr, int n ){
    for( int i = 0; i < n; ++i )
       arr[i] /= v;
}

double b[100];
double m[100][100];

void chkmx(){
    for( int i = 0; i < n; ++i ){
       for( int j = 0; j < n; ++j ){
            printf("%lf ",m[i][j]);
       }
       printf(" = %lf\n",b[i]);
       printf("\n");
    }
}

void gausian(){

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < n; ++j )
            m[i][j] = mx[i][j];
        b[i] = (double)bx[i];
    }


    for( int i = 0; i < n; ++i ){
        b[i] /= m[i][i];
        div( m[i][i] , m[i] , n );

        for( int j = i+1; j < n; ++j ){
            double z = m[j][i];
            for( int k = 0; k < n; ++k )
                m[j][k] = m[j][k] - z * m[i][k];
            b[j] -= z * b[i];
        }
    }


    for( int i = n-1; i >= 0; --i ){
        double sum = 0;
        for( int j = i+1; j < n; ++j )
            sum += sol[j] * m[i][j];
        sum = -sum + b[i];
        sol[i] = sum / m[i][i];
    }

}

void output(){
    for( int i = 0; i < n; ++i )
        cout<<sol[i]<<endl;
}

int main(){
    FILE *in = fopen("Ulaz.txt","r");

    input(in);

    gausian();

    output();


    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:hamming
*/
#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <vector>
#include <set>
#include <map>
using namespace std;

int n,b,d;
int maxv;
int hd[257][257];
int mem[100];

int dst( int a, int b ){
     int cnt = 0;
     
     for( int i = 0; i < 10; ++i ){
         bool b1 = a & (1<<i);
         bool b2 = b & (1<<i);
         
         cnt += b1 != b2;
     }
     return cnt;
}

bool solve( int idx , int nxt){
    if( idx == n )
        return true;
    
    for( int i = nxt; i <= maxv; ++i ){
        
        bool ok = true;
        for( int j = 0; j < idx && ok; ++j )
            if( hd[i][ mem[j] ] < d ) ok = false;
        
        if( !ok ) continue;
        
        mem[idx] = i;
        if( solve( idx + 1 , i + 1) ) return true;
        else mem[idx] = 0;
    }
    return false;
}

int main(){
    freopen("hamming.in","r",stdin);
    freopen("hamming.out","w",stdout);
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    
    fscanf(in,"%d%d%d",&n,&b,&d);
    maxv = (1<<b) -1;
    
    for( int i = 0; i <= maxv; ++i )
        for( int j = 0; j <= maxv; ++j )
            hd[i][j] = dst(i,j);
    
    
    mem[0] = 0;
    solve( 1 , 1);
    
    for( int i = 1; i <= n; ++i ){
         cout<<mem[i-1];
         if( i==n || i % 10 == 0 ) cout<<endl;
         else if( i % 10 != 0 ) cout<<" "; 
    }
    
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:holstein
*/
#include <iostream>
#include <vector>
#include <cstdio>
#include <math.h>
#include <set>
#include <queue>
#include <stack>
#include <cstdlib>
#include <string.h>
using namespace std;

int v,n;
int arr[1005];
int vim[20][30];
int cnt[30];

int main(){
    freopen("holstein.in","r",stdin);
    freopen("holstein.out","w",stdout);
    
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d",&v);
    
    for( int i = 0; i < v; ++i )
        fscanf(in,"%d",&arr[i]);
    
    fscanf(in,"%d",&n);
    
    for( int i = 0; i < n; ++i )
        for( int j = 0; j < v; ++j )
            fscanf(in,"%d",&vim[i][j]);
    
    
    int cntx = 9999;
    vector< int > sol;
    
    for( int i = 0; i < (1<<n); ++i ){
         
         vector<int>vc;
         memset(cnt,0,sizeof(cnt));
         
         for( int j = 0; j < n; ++j ){
             if( ~i&(1<<j) )continue;
             
             for( int k = 0; k < v; ++k )
                 cnt[k] += vim[j][k];
             
             vc.push_back(j);
         }
         
         bool ok = true;
         for( int j = 0; j < v && ok; ++j )
             if( cnt[j] < arr[j] ) ok = false;
         
         if( !ok ) continue;
         
         if( vc.size() < cntx || ( vc.size() == cntx && vc < sol) )
             cntx = vc.size() , sol = vc;
         
    }
    
    printf("%d ",cntx);
    for( int j = 0; j < sol.size()-1; ++j )
        printf("%d ",sol[j]+1);
    printf("%d",sol[sol.size()-1]+1 );
    putchar('\n');
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <cstdlib>
using namespace std;


int main(){
    int N,K;
    scanf("%d",&N);
    
    for( int i = 0; i < N; ++i ){
       scanf("%d",&K);
       int ss = 1 , v;
       for( int j = 0; j < K; ++j ){
           scanf("%d",&v);
           ss += v - 1;
       }
       printf("%d\n",ss);
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
using namespace std;

typedef long long ll;

int n;
ll k;
int niz[50005];


ll getlo( int val ){
    int j  = n-1;
    ll sol = 0;
    for( int i = 0; i < n; ++i ){
        for( ; j >= 0 && niz[i] + niz[j] > val ; --j );
        sol += j + 1;
    }
    return sol;
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d%lld",&n,&k);
    for( int i = 0; i < n; ++i )
        fscanf(in,"%d",&niz[i]);
    
    sort( niz , niz + n );
    
    
    
    int lo = 0 , hi = niz[n-1] * 2;
    while( lo < hi ){
        int mid = (lo+hi) >> 1;
        
        ll cnt = getlo( mid );
        
        if( cnt >= k ) 
             hi = mid;
        else
             lo = mid + 1;
        
    }
    printf("%d\n",hi);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <math.h>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
using namespace std;

typedef long long ll;

const ll inf = 999999999999999999LL;
int n,k;
int niz[850005];
ll  sums[850005];

void input( FILE *in ){
    fscanf(in,"%d%d",&n,&k);
    for( int i = 0; i < n; ++i )
        fscanf(in,"%d",&niz[i]);
    sort( niz , niz + n );
}

void preprocess(){
    for( int i = 0; i < n; ++i ){
         sums[i] = niz[i];
         if( i ) sums[i] += sums[i-1];
    }
}

ll GetSub( int l ,int r ){
    ll ret = sums[r];
    if( l-1 >= 0 ) ret -= sums[l-1];
    return ret;
}

ll sf1 = inf, sf2 = -1;

void check( ll diff , int l , int r ){
    ll sum = GetSub(l,r);
    
    if( sf1 > diff || ( sf1 == diff && sf2 < sum )  )
        sf1 = diff , sf2 = sum; 
}

void solve(){
     ll v = 0;
     for( int i = 0; i < k; ++i ){
        int z = k-i-1;
        v += -z*(ll)niz[i] + i*(ll)niz[i];
     }
     
     check( v , 0 , k - 1 );
     
     for( int i = k; i < n; ++i ){
         
         v += niz[i-k]*(ll)(k-1);
         v -= GetSub(i-k+1 , i-1)*2;
         v += niz[i]*(ll)(k-1);
         
         check( v , i-k+1 , i );  
     }
}

void write(){
    cout<<sf1<<" "<<sf2<<endl;
}

int main(){
    FILE *in = stdin;
    
    input( in );
    preprocess();
    solve();
    write();
    return 0;
}

#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <iomanip>
using namespace std;

#define f first
#define s second
#define mk make_pair

struct masina{
    int key;
    int idx , pwr , rad , s;
    masina(){};
    masina( int p1, int p2, int p3, int p4, int p5 ):idx(p1),pwr(p2),rad(p3),s(p4),key(p5){};
    bool operator < ( const masina &m2 ) const {
        return idx < m2.idx;
    }
};

struct event{
    int key;
    int idx, pwr, mode;
    event(){};
    event( int p1, int p2, int p3 , int p4 ):idx(p1),pwr(p2),mode(p3),key(p4){};
    bool operator < ( const event &e2 ) const {
         return idx < e2.idx || ( idx == e2.idx && mode < e2.mode );
    }
};

int N;
masina m[100055];
vector< event > V;
const int inf = 1<<31 - 1;
bool inq[100055];

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d",&N);

    for( int i = 0; i < N; ++i ){
        m[i].key = i;
        fscanf(in,"%d%d%d%d",&m[i].idx,&m[i].pwr,&m[i].rad,&m[i].s);
        V.push_back( event( m[i].idx - m[i].rad , m[i].pwr , -3 , i )   );
        V.push_back( event( m[i].idx + m[i].rad , m[i].pwr , 3, i )   );
        V.push_back( event( m[i].idx , m[i].s , 0 , i ) );
    }
    sort( V.begin() , V.end());
    
    priority_queue< pair<int,int> >PQ;
    
    int sol = 0;
    for( int i = 0; i < V.size(); ++i ){
        
        if( V[i].mode == -3 ){
            inq[ V[i].key ] = true;
            PQ.push( mk( V[i].pwr , V[i].key )  );
        }
        
        while( !PQ.empty() && inq[ PQ.top().s ] == false ) PQ.pop();
        
        if( V[i].mode == 0 )
            if( !PQ.empty() && V[i].pwr < PQ.top().f )
                sol++;
        
        if( V[i].mode == 3)
            inq[ V[i].key ] = false;
        
    }
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <vector>
#include <set>
#include <stack>
#include <queue>
#include <string.h>
using namespace std;

int n;
char buff[100006];

int mem[4][4][4][4];
int prv[4][4][4][4]; // [4] = NOTHING-0 , M-1 , F-2 , B-3


inline char Idx( char c ){
    if( c == 'M' ) return 1;
    if( c == 'F' ) return 2;
    if( c == 'B' ) return 3;
    return 0;
}

inline int Val( int a, int b , int c ){
    int take = a == 0 || b == 0 || c == 0;
    if( a != b && a != c && b != c ) return 3-take;
    else if( a == b && b == c ) return 1-take;
    else return 2-take;
    
}


int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d",&n);
    fscanf(in,"%s",buff);
    
    int sol = 0;
    memset( prv , -32 , sizeof( prv ) );
    prv[0][0][0][0] = 0;
    
    for( int i = 0; i < n; ++i ){
        
        int vp = Idx( i-1 >= 0 ? buff[i-1] : 0 );
        int vn = Idx( buff[i] );
        memset( mem, -32 , sizeof(mem) );

        for( int i = 0; i <= 3; ++i ){
            for( int j = 0; j <= 3; ++j ){
                for( int k = 0; k <= 3; ++k ){
                    
                    int a1 = prv[i][j][k][vp] + Val( k , vp , vn );
                    int a2 = prv[i][vp][j][k] + Val( i , vp , vn );
                    int a3 = prv[i][vp][j][k] + Val( j , k ,  vn );
                    int a4 = prv[i][j][k][vp] + Val( i , j , vn );
                    
                    mem[i][j][vp][vn] = max( mem[i][j][vp][vn] , a1 );
                    mem[vp][vn][j][k] = max( mem[vp][vn][j][k] , a2 );
                    
                    mem[i][vp][k][vn] = max( mem[i][vp][k][vn] , a3 );
                    mem[j][vn][k][vp] = max( mem[j][vn][k][vp] , a4 );
                    
                    sol = max( sol , max( a1 , a2 ) );
                }
            }
        }
        memcpy( prv , mem , sizeof mem );
    }
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <math.h>
using namespace std;

typedef long long ll;

ll h,w;

ll f( ll z ){
    ll ret = 1;
    for( int i = 1; i <= z; ++i )
        ret *= i;
    return ret;
}

int main(){
    cin >> h >> w;
    
    h-- , w--;
    cout<< f(h+w) / ( f(h)*f(w) ) <<endl;
    
    system("Pause");
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <math.h>
using namespace std;

int dp[1000][1000];

int main(){
   int h,w;
   scanf("%d%d",&h,&w);
   
   dp[1][0] = 1;
   
   for( int i = 1; i <= h; ++i )
       for( int j = 1; j <= w; ++j )
           dp[i][j] = dp[i-1][j] + dp[i][j-1];
   cout<<dp[h][w]<<endl;
    
   system("Pause");
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <vector>
#include <map>
#include <cstdlib>
#include <math.h>
#include <queue>
#include <stack>
#include <string.h>
using namespace std;

#define d first
#define w second
#define mk make_pair
#define pii pair<int,int>

int N;
vector< pii >G[2005];

const int inf = 999999999;
bool visited[2005];
int dp[2005][2]; 
int sol = 0;

int dfs( int node , bool used){
    
    if( dp[node][used] != -1 ) return dp[node][used];
    
    visited[ node ] = true;
    
    int sol = 0;
    priority_queue< int > PQ;
    
    for( int i = 0; i < G[ node ].size(); ++i ){
        if( visited[ G[node][i].d ] )
             continue;
        int v1 = dfs( G[node][i].d  , false );
        int v2 = dfs( G[node][i].d  , true ) + G[node][i].w ;
        
        sol += v1;
        PQ.push( v2 - v1 );
    }
    int m1 = 0 , m2 = -inf;
    if( PQ.empty() == false ){ m1 = PQ.top(); PQ.pop(); };
    if( PQ.empty() == false )  m2 = PQ.top();
    
    int mx  =  sol + m1;
    if( used == false ) mx = max( mx , sol + m1 + m2 );
    else mx = max( sol , mx );
    
    visited[node] = false;
    
    if( used == false && mx == 0 )return dp[node][used] = -inf;
    return dp[node][used] = mx;
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d",&N);
    
    int a,b,c;
    for( int i = 1; i < N; ++i ){
        fscanf(in,"%d%d%d",&a,&b,&c);
        G[a].push_back( mk(b,c) );
        G[b].push_back( mk(a,c) );
    }
    
    memset( dp, -1, sizeof(dp));
    printf("%d\n", dfs( 1 , 0 ) );
    
    //system("Pause");
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <cstdio>
#include <set>
#include <queue>
#include <fstream>
#include <stack>
using namespace std;

int n;
int tests;
char buff[50006];

int main(){
   scanf("%d",&tests);
   
   for( ; tests; --tests ){
       scanf("%d",&n);
       scanf("%s",buff);
       printf("%c\n",buff[strlen(buff)-1] );
   }
   
   return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

const int maxn = 100005;
int N;
int bit[maxn+10];
int cnt[maxn+10];

void update( int idx , int val ){
    for( ; idx <= maxn; idx += idx & -idx )
        bit[idx] += val;
}
int query( int idx ){
    int ss = 0;
    for( ; idx >= 1; idx -= idx & -idx )
        ss += bit[idx];
    return ss;
}

int main(){
    scanf("%d",&N);
    
    int l,r;
    int sol = 0;
    
    for( int i = 0; i < N; ++i ){
        scanf("%d%d",&l,&r);
        int ql = query( l );
        int qr = query( r );
        
        ql = ql - cnt[l];
        qr = qr - cnt[r];

        
        cnt[l] += ql;
        cnt[r] += qr;
        
        
        update( l+1 , 1 );
        update( r , -1 );
        
        
        printf("%d\n", ql + qr);
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <stack>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <string.h>
#include <assert.h>
using namespace std;

int dp[55][55][2];

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    int tests;
    scanf("%d",&tests);
    
    for( ; tests; --tests) {
        int n;
        scanf("%d",&n);
        
        memset( dp , 0 , sizeof(dp));
        
        dp[25][25][1] = 1;
        bool mode = true;
        
        for( int i = 0; i < n; ++i ){
             
            for( int j = 0; j < 50; ++j )
                for( int k = 0; k < 50; ++k )
                        dp[j][k][!mode] = false;
            
            for( int j = 2; j < 50; ++j ){
                for( int k = 2; k < 50; ++k ){
                    
                    dp[j+1][k+1][!mode] += dp[j][k][mode];
                    dp[j-1][k-1][!mode] += dp[j][k][mode];
                    dp[j-1][k+1][!mode] += dp[j][k][mode];
                    dp[j+1][k-1][!mode] += dp[j][k][mode];
                    
                    dp[j][k+2][!mode] += dp[j][k][mode];
                    dp[j][k-2][!mode] += dp[j][k][mode];
                    
                }
            }
            mode = !mode;
        }
        printf("%d\n",dp[25][25][mode]);
        
    }
    return 0;
}

#include <iostream>
#include <cstdlib>
#include <math.h>
#include <cstdio>
#include <vector>
#include <fstream>
#include <set>
#include <map>
#include <queue>
using namespace std;

string a,b;
int add;

int dp[2005][2005];

int solve( int idx , int last ){
    if( idx == a.size() )    
            return (b.size()-last)*add;
    
    if( dp[idx][last] != 0 ) return dp[idx][last];    
    
    int sol = solve( idx + 1 , last) + add;
    
    for( int i = last; i < last + 27; ++i ){
        if( i >= b.size() ) break;
        sol = min( sol , solve(idx+1,i+1) + abs(a[idx]-b[i]) + (i-last)*add  );
    }
    
    return dp[idx][last] = sol;
}

int solve2(){
     dp[0][0] = 0;
     for( int i = 0; i <= a.size(); ++i ){
          for( int j = 0; j <= b.size(); ++j ){
              int &ref = dp[i][j];
              if( i > 0 && j > 0 )dp[i][j] = min( dp[i][j] , dp[i-1][j-1] + abs(a[i-1]-b[j-1])  );
              if( i > 0 )dp[i][j] = min( dp[i][j] , dp[i-1][j] + add );
              if( j > 0 )dp[i][j] = min( dp[i][j] , dp[i][j-1] + add );
          }   
     }
     return dp[a.size()][b.size()];
}

int main(){
    memset( dp , 1, sizeof(dp));    
 
    cin >> a >> b >> add;
    
    cout<<solve2()<<endl;
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

struct edge{
    int flow , cap , node , rev;
    edge( int p1, int p2, int p3 ):node(p1),cap(p2),flow(p3){};
    edge(){};
};

typedef long long ll;

const int MAXN = 5005;
const int MAXM = 30005;
const int inf  = 1000000005;

int n,m;
vector< edge >g[MAXN];
int dist[MAXN];
vector< edge > :: iterator work[MAXN];
vector< edge > :: iterator end[MAXN];

bool bfs(){
    memset( dist , -1 , sizeof(dist));

    queue< int >Q;
    dist[0] = 0;
    Q.push(0);
    while( !Q.empty() ){
        int u = Q.front(); Q.pop();
        for( int i = 0; i <g[u].size(); ++i ){
            if( dist[g[u][i].node] < 0 && g[u][i].flow < g[u][i].cap ){
                dist[g[u][i].node] = dist[u] + 1;
                Q.push( g[u][i].node );
            }
        }
    }
    return ( dist[n-1] >= 0 );
}

int flow( int x, int mn ){
    if( x == n-1 ) return mn;

    for( ; work[x]!=end[x]; ++work[x] ){
        int y = work[x]->node;
        if( dist[x] + 1 != dist[ y ] || work[x]->flow >= work[x]->cap ) continue;

        int f = flow( y , min( mn , work[x]->cap - work[x]->flow ) );
        if( f == 0 )continue;

        work[x]->flow += f;
        g[ y ] [ work[x]->rev ].flow -= f;
        return f;
    }
    return 0;
}

ll dinic(){
    ll ret = 0;
    while( bfs() ){
        for( int i = 0; i < n; ++i )
            work[i] = g[i].begin();

        while( true ){
            int f = flow( 0 , inf );
            if( f == 0 )break;
            ret += f;
        }
    }
    return ret;
}


int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");

    fscanf(in,"%d%d",&n,&m);

    int a,b,c;
    for( int i = 0; i < m; ++i ){
        fscanf(in,"%d%d%d",&a,&b,&c);
        a--, b--;

        g[a].push_back( edge(b,c,0) );
        g[b].push_back( edge(a,c,0) );

        int sz1 = g[a].size() , sz2 = g[b].size();

        g[a][sz1-1].rev = sz2-1;
        g[b][sz2-1].rev = sz1-1;

    }

    for( int i = 0; i < n; ++i )
        end[i] = g[i].end();


    cout<< dinic () <<endl;
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
using namespace std;

struct snow{
    int arr[6];
    snow () {};
    bool operator<( const snow &s2 ) const {
        for( int i = 0; i < 6; ++i )
            if( arr[i] < s2.arr[i] ) return true;
            else if( arr[i] > s2.arr[i] ) return false;
        return false;
    }
    bool operator==( const snow &s2 ) const {
        for( int i = 0; i < 6; ++i )
            if( arr[i] < s2.arr[i] ) return false;
            else if( arr[i] > s2.arr[i] ) return false;
        return true;
    }
}w[1000000];

int main(){
    int n;
    scanf("%d",&n);
    
    for( int i = 0; i < n; ++i ){
        scanf("%d%d%d%d%d%d",&w[i].arr[0],&w[i].arr[1],&w[i].arr[2],&w[i].arr[3],&w[i].arr[4],&w[i].arr[5]);
        sort( w[i].arr , w[i].arr + 6 );
    }
    sort( w , w + n );
    
    bool ok = false;
    for( int i = 1; i < n && !ok; ++i )
        if( w[i] == w[i-1] ) ok = true;
    
    if( ok ) printf("Twin snowflakes found.\n");
    else printf("No two snowflakes are alike.\n");
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <string.h>
#include <math.h>
using namespace std;

const double pi = acos(0) * 2;
int l;

int main(){
    while( cin >> l ){
        if( l == 0 )break;
        double r = l / (2.0*pi);
        double A = r*r * pi;
        
        printf("%.2f\n", A*2 );
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <math.h>
#include <iomanip>
#include <cstdlib>
using namespace std;

typedef long long ll;

ll fac( int v ){
   ll ret = 1;
   for( int i = 2; i <= v; ++i ) ret *= i;
   return ret;
}

int main(){
    int a,b;
    while( scanf("%d%d",&a,&b) == 2 ){
        if( a == -1 ) break;
        ll p = fac(a+b) / (fac(a)*fac(b));
        
        if( p == a + b )
            printf("%d+%d=%d\n",a,b,a+b);
        else
            printf("%d+%d!=%d\n",a,b,a+b);
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <math.h>
#include <vector>
#include <set>
#include <queue>
#include <stack>
#include <fstream>
using namespace std;

typedef long long ll;

ll start[30005];

void calc(){
    start[1] = 1;
    start[2] = -1;
    start[3] = 4;
    start[4] = 9;
    for( int i = 5; i <= 30003; ++i )
        start[i] = start[i-1] + (start[i-1]-start[i-2]) + 2;
}

int N;
char buff[255];

int main(){
    calc();
    
    for( ; ; ){
        scanf("%d%s",&N,buff);
        if( N == 0 )break;
        
        if( N == 2 ){
            printf("0\n");
            continue;
        }
        
        ll sol = 0;
        for( int i = 0; i < strlen(buff); ++i )
             sol = (sol * 10 + (buff[i] - '0'))%start[N];
        if( sol == 0 )
             printf("Yes\n");
        else
             printf("No\n");
    }
    
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <math.h>
#include <vector>
#include <set>
#include <queue>
#include <stack>
using namespace std;

multiset< string >ms;

int main(){
    int n;
    scanf("%d",&n);
    
    string str;
    int sol = 0;
    
    for( int i = 0; i < n; ++i ){
        cin >> str;
        int all = ms.size();
        int taker = ms.count( str );
        
        int o = all - taker;
        
        if( o < taker )
           sol ++;
        
        ms.insert( str );
    }
    
    printf("%d\n",sol);
    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:pprime
*/
#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <vector>
#include <string.h>
#include <set>
#include <queue>
#include <algorithm>
#include <stack>
using namespace std;

inline bool prime( int v ){
    if( v % 2 == 0 && v != 2 ) return false;
    for( int i = 3; i*i <= v; i += 2 )
        if( v % i == 0 ) return false;
    return true;
}

int main(){
    freopen("pprime.in","r",stdin);
    freopen("pprime.out","w",stdout);
    int a,b;
    cin >> a >> b;
    
    vector<int>pls;
    for( int i = 0; i <= 9; i ++ ){
        if( i != 0 ){
           if( i%2 == 0 && i != 0 )continue;
           if( i%5 == 0 )continue;
        }
        for( int j = 0; j <= 9; ++j ){
            for( int k = 0; k <= 9; ++k ){
                for( int l = 0; l <= 9; ++l ){
                     for( int z = 0; z <= 9; ++z ){
                         if( (i|j|k|l|z) == 0 )continue;
                         int stp = 10;
                         if( l != 0 ) stp = 100;
                         if( k != 0 ) stp = 1000;
                         if( j != 0 ) stp = 10000;
                         if( i != 0 ) stp = 100000;
                         
                         int num = -1,num1 = -1;
                         if( i == 0 ){
                            num = i*10000 + j*1000 + k*100 + l*10 + z;
                            num *= stp;
                            num += z*stp/10 + l*stp/100 + k*stp/1000 + j*stp/10000 + i*stp/100000;
                         }
                         
                         num1 = i*10000 + j*1000 + k*100 + l*10 + z;
                         num1 *= stp/10;
                         num1 += l*stp/100 + k*stp/1000 + j*stp/10000 + i*stp/100000;
                         
                         //cout<<num<<" "<<num1<<endl;
                         //system("pause");
                         if( num != -1 && a <= num && num <= b && num%5 != 0 ) pls.push_back( num );
                         if( num1!= -1 && a <= num1 && num1 <= b && num1%5 != 0) pls.push_back( num1 );
                     }
                }
            }
        }
    }
    vector< int > ok;

    for( int i = 0; i < pls.size(); ++i ){
        if(  prime( pls[i] ) )
            ok.push_back( pls[i] );
    }
    ok.push_back(2);
    ok.push_back(3);
    ok.push_back(5);
    sort( ok.begin() , ok.end() );
    
    for( int i = 0; i < ok.size(); ++i ){
        if( ok[i] >= a && ok[i] <= b )
            printf("%d\n",ok[i]);
    }
    //system("Pause");

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <stack>
#include <iomanip>
#include <map>
#include <algorithm>
#include <string.h>
using namespace std;

char buff[100];

int main(){
    scanf("%s",buff);
    sort( buff , buff + strlen(buff));
    cout<<buff<<endl;
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <cstdio>
#include <set>
#include <queue>
#include <stack>
using namespace std;

const double g = 9.80665;
double A,M,S,F;

int main(){
    while( scanf("%lf%lf%lf%lf",&A,&M,&S,&F)  ){
         if ( A == 0 ) break;
         double G = M*g;
         double fx = F*G;
         double move = S * fx;
         
         int times = (int)(S/A);
         double W = M*g*(sqrt(A*A+A*A)-A)/2.0;
         double rot = times * W;
         
         if( rot > move )
             printf("2\n");
         else
             printf("1\n");
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <math.h>
using namespace std;

int main(){
    int n;
    scanf("%d",&n);
    
    int sol = 0;
    
    for( int m = 4; m <= n; ++m ){
        for( int i = 2; i < m-1; ++i ){
           int L = i - 1;
           int R = m - i - 1;
        
           sol += L * R;
        }
    }
    
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <string.h>
#include <algorithm>
using namespace std;

const int MOD = 1000000007;

int n,m;
int arr[100005];
int stp2[100005];

int main(){
    scanf("%d%d",&n,&m);
    
    for( int i = 0; i < n; ++i )
        scanf("%d",&arr[i]);
    
    sort( arr , arr + n );

    stp2[0] = 1;
    for( int i = 1 ;i <= n; ++i )
        stp2[i] = ( stp2[i-1] << 1 ) % MOD;
    
    int sol = 0;
    int j = 0;
    for( int i = n-1; i >= 0; --i ){
        for( ; j <= i && arr[j] + arr[i] <= m; ++j ); --j;
        if( j < 0 ) ++j;
        
        
        if( arr[i] + arr[j] == m ){
            if( i == j ) sol++;
            else sol = (sol + stp2[i - j-1]) % MOD;
        }
 
    }
    printf("%d\n",sol);
    

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 50000 + 55;

struct event{
    int f,s,c;
    event(){};
    event( int p1, int p2, int p3 ):f(p1),s(p2),c(p3){};

    const bool operator < ( const event &e ) const {
        return s < e.s;
    }
};

struct segment_tree{
    int begin;
    vector<int>sum;
    vector<int>add;

    void init( int n ){
        n += 10;
        int sz = 1;
        while( sz < n ) sz <<= 1;
        begin = sz;
        sz <<= 1;
        sum.resize(sz);
        add.resize(sz);
    }

    segment_tree(){};
    segment_tree( int n ){ init(n); }

    void forward( int dad, int kid , int range ){
        int hlf = range >> 1;

        if( add[dad] ){
            int R = min( add[dad] , hlf - sum[kid]);
            add[kid] += R;
            sum[kid] += R;
            add[dad] -= R;
        }
    }

    int l,r,c;

    int _query( int node, int lo, int hi ){
        int range = hi - lo + 1;
        if( l <= lo && hi <= r ) return sum[node];
        if( node >= begin || lo > r || hi < l ) return 0;

        int x = node*2, y = node*2+1;
        forward(node,y,range);
        forward(node,x,range);

        int mid = (lo+hi)>>1;
        return  _query( y, mid+1, hi ) + _query( x, lo, mid );
    }

    void _update( int node, int lo, int hi ){
        int range = hi - lo + 1;
        if( l <= lo && hi <= r ){
            int w = min( c , range - sum[node] );
            add[node] += w;
            sum[node] += w;
            c -= w;
            return;
        }
        if( node >= begin || lo > r || hi < l ) return;

        int x = node*2, y = node*2+1;
        forward(node,y,range);
        forward(node,x,range);


        int mid = (lo+hi)>>1;
        if( c ) _update( y, mid+1, hi );
        if( c ) _update( x, lo, mid );

        sum[node] = sum[x] + sum[y];
    }

    int query( int lo, int hi ){
        l = lo + begin;
        r = hi + begin;
        return _query( 1, begin, begin*2-1 );
    }

    void update( int lo, int hi, int cnt ){
        l = lo + begin;
        r = hi + begin;
        c = cnt;
        _update( 1, begin, begin*2-1 );
    }
};

int n;
vector< event > w;

int main(){
   // freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        w.clear();
        scanf("%d",&n);
        segment_tree t(50050);

        for( int i = 0; i < n; ++i ){
            int a,b,c; scanf("%d%d%d",&a,&b,&c);
            w.push_back( event(a,b,c) );
        }

        int sol = 0;
        sort( w.begin() , w.end() );

        for( int i = 0; i < n; ++i ){
            int sum = t.query(w[i].f,w[i].s);
            int add = w[i].c - sum;
            if( add <= 0 ) continue;
            sol += add;
            t.update( w[i].f, w[i].s , add );
            //for( int i = 1; i <= 11; ++i )
            //    cout<<t.query(i,i)<<" ";cout<<endl;
        }
        printf("%d\n",sol);

    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 50000 + 55;

struct event{
    int f,s,c;
    event(){};
    event( int p1, int p2, int p3 ):f(p1),s(p2),c(p3){};

    const bool operator < ( const event &e ) const {
        return s < e.s;
    }
};

struct segment_tree{
    int begin;
    vector<int>sum;

    void init( int n ){
        n += 10;
        sum.resize(n);
    }

    segment_tree(){};
    segment_tree( int n ){ init(n); }


    int query( int lo, int hi ){
        int sol = 0;
        for( int i = lo; i <= hi; ++i ) sol += sum[i];
        return sol;
    }

    void update( int lo, int hi, int cnt ){
        for( int i = hi; i >= lo && cnt; --i ){
            if( sum[i] == 0 ) sum[i] = 1, cnt--;
        }
    }
};

int n;
vector< event > w;

int main(){
    freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        w.clear();
        scanf("%d",&n);
        segment_tree t(n+50000);

        for( int i = 0; i < n; ++i ){
            int a,b,c; scanf("%d%d%d",&a,&b,&c);
            w.push_back( event(a,b,c) );
        }

        int sol = 0;
        sort( w.begin() , w.end() );

        for( int i = 0; i < n; ++i ){
            int sum = t.query(w[i].f,w[i].s);
            int add = w[i].c - sum;
            cout<<sum<<" "<<add<<" , "<<w[i].f<<" "<<w[i].s<<endl;
            if( add <= 0 ) continue;
            sol += add;
            t.update( w[i].f, w[i].s , add );
        }
        printf("%d\n",sol);

    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

int main(){
    srand((unsigned)time(0));
    freopen("Ulaz.txt","w",stdout);

    int t = 1;

    cout<<t<<endl;

    for( int i = 0; i < t; ++i ){
        int n = 100;
        cout<<n<<endl;
        for( int j = 0; j < n; ++j ){
            int f = rand()%1000, s;
            while(1){
                s = rand()%1000;
                if( s >= f ) break;
            }
            int c = 1+rand()%(s-f+1);
            cout<<f<<" "<<s<<" "<<c<<endl;
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <stack>
#include <string>
#include <string.h>
#include <map>
#include <set>
using namespace std;

const int maxn = 100000 + 55;
const int inf = 100000000;

int n,k,m;
int tests;

int e[maxn];
int s[maxn];

multiset<int>skup;
multiset<int>::iterator it;

int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d%d",&n,&k,&m);
        skup.clear();
        s[0] = 0;

        for( int i = 0; i < n; ++i ) scanf("%d",&e[i]);

        for( int i = 0; i < n; ++i ){
            if( i ) s[i] = s[i-1];
            s[i] = (s[i]+e[i])%m;
            skup.insert( s[i] );
        }

        int sol = inf;
        for( int i = 0; i < n; ++i ){
            int behind = 0;
            if( i ){
                behind = s[i-1];
                skup.erase( skup.lower_bound(s[i-1]) );
            }
            int search,case1;

            // case A - B >= k
            case1 = inf;
            search = k + behind;

            it = skup.lower_bound( search );
            if( it != skup.end() )case1 = *it;

            if( case1 < search ) case1 = inf;
            if( case1 != inf )sol = min( sol , case1 - behind );


            // case A - B < 0 => (A+m) - B > k
            case1 = inf;
            search = k + behind - m;

            it = skup.lower_bound( search );
            if( it != skup.end() )case1 = *it;

            if( case1 < search || case1 >= behind ) case1 = inf;
            if( case1 != inf )sol = min( sol , case1 - behind + m );
        }

        printf("%d\n",sol);


    }

    return 0;
}

#include <iostream>
#include <fstream>
#include <string>
#include <string>
#include <string.h>
using namespace std;

const int inf = 100000000;
const int maxn = 100000 + 55;

int n,k,m;
int e[maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d%d",&n,&k,&m);

        for( int i = 0; i < n; ++i ) scanf("%d",&e[i]);

        int sol = inf;

        for( int i = 0; i < n; ++i ){
            int sum = 0;
            for( int j = i; j < n; ++j ){
                sum = (sum+e[j])%m;
                if( sum >= k )
                    sol = min( sol , sum );
            }
        }

        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <fstream>
#include <algorithm>
#include <stack>
#include <string>
#include <string.h>
using namespace std;

int main(){
    srand((unsigned)time(0));
    freopen("Ulaz.txt","w",stdout);

    int t = 5;
    cout<<t<<endl;
    while( t-- ){
        int n = 300;//+rand()%10;
        int m = 1+rand()%1000;
        int k = 1+rand()%m;

        printf("%d %d %d\n",n,k,m);

        for( int i = 0; i < n; ++i )
            printf("%d ",1+rand()%1000);
        printf("\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <fstream>
#include <algorithm>
#include <stack>
#include <string>
#include <string.h>
using namespace std;

int main(){
    for( int t = 1; ; t++ ){
        system("PARTSUM_MAKER.exe");
        system("PARTSUM_BRUTE.exe");
        system("PARTSUM.exe");

        if( system("diff -qb Izlaz.txt Izlaz2.txt") ){
            printf("WA on %d\n",t);
            while(1);
        }else{
            printf("AC on %d\n",t);
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <stack>
#include <map>
#include <queue>
#include <set>
#include <iomanip>
#include <string.h>
using namespace std;

const int maxn = 1000000 + 555;

int n,l,mod;

char bit[maxn];

int dp[maxn][2];

int solve( int dx, int carry ){
    if( dx == n ) return carry == 0;

    int A = carry;
    if( dx < l ) A += bit[dx] - '0';

    int &sol = dp[dx][carry];
    if( sol != -1 ) return sol;

    sol = 0;

    if( A == 0 ) sol += solve( dx + 1, 0 );
    else if( A == 1 ) sol += solve( dx + 1, 0 ) + solve( dx + 1, 1 );
    else sol += solve( dx + 1, 1 );

    sol %= mod;

    return sol;

}

int main(){
  //  freopen("Ulaz.txt","r",stdin);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d%d",&n,&l,&mod);
        scanf("%s",bit);

        reverse( bit , bit + strlen(bit));
        while( (l = strlen(bit)) && l > 0 ){
            if( bit[l-1] == '1' ) break;
            else bit[l-1] = bit[l];
        }


        for( int i = 0; i <= n; ++i )
            dp[i][0] = dp[i][1] = -1;

        int sol = solve( 0 , 0 );
        printf("%d\n",sol);

    }
    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <stack>
#include <map>
#include <queue>
#include <set>
#include <iomanip>
using namespace std;

int s2[20];

vector< int > mov;

int solve( int w, int dx ){
    if( dx == -1 ){
        if( w == 0 ){
            for( int i = 0; i < mov.size(); ++i )
                cout<<mov[i]<<" ";cout<<endl;
        }
         return w == 0;
    }

    int sol = 0;

    mov.push_back( -s2[dx] );  sol += solve( w - s2[dx] , dx - 1 );  mov.pop_back();
    mov.push_back( s2[dx]  );  sol += solve( w + s2[dx] , dx - 1 );  mov.pop_back();
    sol += solve( w , dx - 1 );

    return sol;
}

int main(){

    s2[0] = 1;
    for( int i = 1; i < 20; ++i ) s2[i] = s2[i-1] * 2;

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        int n,w;
        cin >> n >> w;

        cout<< solve( w , n - 1 ) << endl;
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <set>
#include <iomanip>
#include <fstream>
using namespace std;

const int maxn = 100000 + 55;

int n;
int L[maxn],R[maxn],lvl[maxn];
int lo[maxn],hi[maxn];

int cnt;
bool ok;

int dfs( int node , int dad ){

   // cout<<node<<" "<<dad<<endl;
    //for( int i = 0; i < 10000000; ++i );

    int lvl_dad = 0;
    if( dad != -1 ) lvl_dad = lvl[dad];

    if( node == -2 ) return lvl_dad + 1;
    lvl[node] = lvl_dad + 1;

    int a,b;

    a = dfs( L[node] , node );
    b = dfs( R[node] , node );

    int lhi,llo, rhi, rlo;

    if( L[node] == -2 ) lhi = llo = a;
    else lhi = hi[ L[node] ], llo = lo[ L[node] ];

    if( R[node] == -2 )rhi = rlo = b;
    else rhi = hi[ R[node] ], rlo = lo[ R[node] ];

    if( llo-1 != rhi && llo != rhi  ) swap( llo , rlo ) , swap( lhi, rhi ) , cnt++;
    if( llo-1 != rhi && llo != rhi  ) ok = 0;
    if( llo + 1 < lhi || rlo + 1 < rhi ) ok = 0;

    lo[ node ] = rlo;
    hi[ node ] = lhi;

   // cout<<ok<<" = "<<llo<<" "<<lhi<<" | "<<rlo<<" "<<rhi<<" [ "<<node<<" ] "<<" = "<<cnt<<endl;

    return -123;
}

int main(){

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d",&n);

        for( int i = 0; i < n; ++i ){
            int a,b; scanf("%d%d",&a,&b); a--, b--;
            L[i] = a, R[i] = b;
        }

        ok = 1;
        cnt = 0;
        dfs( 0 , -1 );

        if( !ok ) cout << -1 <<endl;
        else cout << cnt << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <map>
#include <vector>
#include <string.h>
#include <string>
#include <set>
using namespace std;

typedef long long ll;

int n,x;

ll pows[25];
ll sums[25];

int main(){
    scanf("%d%d",&n,&x);

    for( int i = 1; i <= 20; ++i )
        pows[i] = round(pow( 3 , i-1 ));

    for( int i = 1; i <= 20; ++i )
        sums[i] = sums[i-1] + pows[i];

    vector< int > a,b;

    for( int r = 50; r >= 0; r -- ){
        for( int i = 1; i <= n; ++i ){
            ll domet = sums[i-1];
            if( pows[i] - domet <= x && x <= pows[i] + domet ){
                a.push_back( i );
                x -= pows[i];
            }
            if( -pows[i] - domet <= x && x <= -pows[i] + domet ){
                b.push_back( i );
                x += pows[i];
            }
        }
    }

    sort( a.begin(), a.end() );
    sort( b.begin(), b.end() );

    if( x ) printf("-1\n");
    else{
        for( int i = 0; i < b.size(); ++i )printf("%d ",b[i]); printf("\n");
        for( int i = 0; i < a.size(); ++i )printf("%d ",a[i]); printf("\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <string.h>
using namespace std;

int n;
int area[100000];
int sum[100000];

int main(){
    area[0] = sum[0] = 1;
    area[1] = 6;
    for( int i = 2; i <= 99999; ++i ) area[i] = area[i-1] + 6;
    for( int i = 1; i <= 99999; ++i ) sum[i] = sum[i-1] + area[i];

    while( scanf("%d",&n) == 1 ){
        int ring;

        for( ring = 0; ; ++ring ) if( sum[ring] >= n ) break;
        //cout<<ring<<endl;

        int move = n;
        if( ring ) move -= sum[ring-1];
        move --;

        int x,y;
        if( ring == 0 ) x = y = 0;
        else if( ring == 1 ) x = 0, y = 1;
        else x = ring - 1 , y = 1;

        if( ring > 1 ){
            while( move ){
                x--, y++, move--;
                if( x == 0 ) break;
            }
        }

        while( move ){
            x--, move--;
            if( -x == y ) break;
        }

        while( move ){
            y--, move--;
            if( y == 0 ) break;
        }
       // cout<<"MID: "<<x<<" "<<y<<endl;
        while( move ){
            x++,y--, move--;
            if( x == 0 ) break;
        }

        while( move ){
            x++, move--;
            if( x == -y ) break;
        }

        while( move ){
            y++, move--;
        }

        printf("%d %d\n",x,y);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <stack>
#include <map>
#include <algorithm>
#include <fstream>
#include <math.h>
#include <cstdio>
#include <iomanip>
using namespace std;

char txt[30];

int poz[30],cnt[30];
bool visi[30];

int main(){
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        memset( cnt, 0, sizeof(cnt));
        memset( visi, 0, sizeof(visi));
        scanf("%s",txt);

        for( int k = 0; k < strlen(txt); ++k )
            poz[ txt[k] - 'A' ] = k;

        for( int i = 0; i < strlen(txt); ++i ){
            int dx = txt[i] - 'A', len = 1;
            if( visi[dx] ) continue;
            visi[dx] = 1;

            while(1){
                dx = poz[dx];
                visi[dx] = 1;
                if( dx == txt[i] - 'A' ) break;
                len ++;
            }

            cnt[len] ++;
        }

        bool ok = true;
        for( int i = 0; i <= strlen(txt); i += 2 )
            if( cnt[i] % 2 ) ok = false;

        if( ok ) printf("Yes\n");
        else printf("No\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <string.h>
#include <string>
#include <iomanip>
using namespace std;

#define pii pair<ui,ui>
#define f first
#define s second
#define mk make_pair

typedef unsigned int ui;

const int maxn = 1048576 + 55;

int n,l,r;
ui arr[ maxn ];
pii srt[ maxn ];
int dx[ maxn ];

int cntlo[ maxn ];
int cnt[ maxn ];

ui w;


const int MaxBuff = 500000;

char buff[ MaxBuff ];
int pos = MaxBuff;

inline char readch () {
if ( pos == MaxBuff ) {
fread( buff, 1, MaxBuff, stdin );
pos = 0;
}
return buff[pos++];
}

inline ui readi () {
char c;
ui ret;
while ( !isdigit( c = readch() ) );
ret = c - '0';
while ( isdigit( c = readch() ) ) {
ret *= 10;
ret += c - '0';
}
return ret;
}


int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
    n = readi();
    l = readi();
    r = readi();


    for( int i = 0; i < n; ++i ){
        arr[i] = readi();
        srt[i] = mk(arr[i],i);
    }
    sort( srt , srt + n );
    int now = 0;
    for( int i = 0; i < n; ++i ){
        if( i && srt[i].f != srt[i-1].f ) now ++;
        dx[ srt[i].s ] = now;
    }

    int lo = -1 , hi = -1;
    int c = 0 , clo;
    long long sol = 0;
    for( int i = 0; i < n; ++i ){
        if( cnt[ dx[i] ] == 0 ) c ++;
        cnt[ dx[i] ] ++;

        if( c < l ) cntlo[dx[i]]++;

        if( c >= l ){
            if( lo == -1 ){
                lo = i , clo = c;
                cntlo[ dx[i] ] ++;
            }
            if( c <= r ) hi = i;
            else break;
        }
    }
    dx[n] = n+1;
    cnt[ dx[hi+1] ] --;

    if( lo < 0 ){
        printf("%d\n",0);
        return 0;
    }

    if( c > r )c --;
    sol += (hi-lo+1);

    for( int i = 1; i < n; ++i ){
        cnt[ dx[i-1] ] --;
        cntlo[ dx[i-1] ] --;

        if( cnt[ dx[i-1] ] == 0 ){
            c --;
            while( hi+1 < n ){
                if( cnt[ dx[hi+1] ] == 0 ){
                    if( c + 1 > r ) break;
                    c ++;
                }
                hi++;
                cnt[ dx[hi] ] ++;
            }
        }

        if( cntlo[ dx[i-1] ] == 0 ){
            clo --;
            while( lo+1 < n ){
                lo++;
                cntlo[ dx[lo] ] ++;
                if( cntlo[ dx[lo] ] == 1 ){ clo++; break; }
            }
        }

        if( lo <= hi && l <= c && c <= r ) sol += hi - lo + 1;
        else break;

    }
    printf("%lld\n",sol);


    return 0;
}

#include <iostream>
#include <vector>
#include <map>
using namespace std;

const int maxn = 1000;

int n,l,r;
int e[maxn];
map<int,int>m;

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
    scanf("%d%d%d",&n,&l,&r);

    for( int i = 0; i < n; ++i ) scanf("%d",&e[i]);

    int sol = 0;

    for( int i = 0; i < n; ++i ){
        int c = 0;
        m.clear();
        for( int j = i; j < n; ++j ){
            if( m[ e[j] ] == 0 ) c ++;
            m[ e[j] ] ++;
            if( c >= l && c <= r ) sol ++;
        }
    }
    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int n =  1000000 , l = 1 , r = 2;

int main(){
    srand((unsigned)time(0));
    freopen("Ulaz.txt","w",stdout);

   // n = 1+rand()%50;
    l = 1;

    while(1){
        r = 1+rand()%n;
        if( r >= l ) break;
    }

    printf("%d %d %d\n",n,l,r);

    for( int i = 0; i < n; ++i ){
        printf("%d\n",1+rand()%6000);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <stack>
#include <cstdio>
using namespace std;

typedef unsigned long long ll;

const ll mod = 1000000000LL + 7;

ll GetInversion( ll v ){
   ll stp = mod-2;
   stack<ll>S;
   while(stp!=1 ){
      if( stp&1) stp--, S.push(1);
      else stp/=2, S.push(2);
   }
   ll tmp = v;
   while(S.empty()==false ){
      if( S.top()==1 ) v  = (v*tmp)%mod;
      else v =  (v*v)%mod;
      S.pop();
   }
   return v;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);

    ll h,w,k;
    cin >> h >> w >> k;

    if( k > h || k > w ){
        printf("0\n");
        return 0;
    }

    ll sol = 1;

    for( ll i = 0; i < k; ++i ){
        sol = (sol * (w-i))%mod;
        sol = (sol * (h-i))%mod;
    }

    ll fac = 1;
    for( ll i = 1; i <= k; ++i )
        fac = (fac*i)%mod;

    sol = ( sol * GetInversion(fac) ) % mod;

    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <stack>
using namespace std;

typedef unsigned long long ll;

const ll mod = 1000000000 + 7;

int h,w,k;
int sol = 0;

bool col[1000];

void track( int r, int c, int cnt ){
    if( c == w ) r ++ , c = 0;
    if( r == h ){ sol += cnt == 0; return; }

    track( r, c+1, cnt );
    if( !col[c] ){
        col[c] = 1;
        track( r+1, 0, cnt-1 );
        col[c] = 0;
    }
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
    scanf("%d%d%d",&h,&w,&k);

    track( 0, 0, k );

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <stack>
#include <fstream>
using namespace std;

int main(){
    for( int i = 1; i <= 10; ++i ){
        for( int j = 1; j <= 10; ++j ){
            for( int k = 1; k <= i*j; ++k ){
                ofstream out("Ulaz.txt");
                out<<i<<" "<<j<<" "<<k<<endl;

                system("BIO1.exe");
                system("BIO1_BRUTE.exe");

                printf("%d %d %d\n",i,j,k);

                if( system("diff -qb Izlaz.txt Izlaz2.txt") ){
                    printf("WA\n");
                    while(1);
                }else{
                    printf("AC\n");
                }
            }
        }
    }
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <iomanip>
#include <string>
#include <string.h>
#include <vector>
using namespace std;

typedef long long ll;

const int maxn = 105;

struct data{
    ll time;
    int r,c;

    data(){};
    data( ll p1, int p2, int p3 ):time(p1),r(p2),c(p3){};

    const bool operator<( const data &d2 ) const {
        return time > d2.time;
    }
};

int d[][2] = { {1,0} , {-1,0} , {0,1} , {0,-1} };

int n;
ll m,threshold;
ll mat[maxn][maxn];
ll done[maxn][maxn];
ll start[maxn][maxn];

ll cnt_bac( ll passed ){
    ll ret = 0;
    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < n; ++j ){
            ret += mat[i][j];
            ll s = start[i][j];
            if( s < passed ) ret += passed - s;
        }
    }
    return ret;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%lld%lld",&n,&threshold,&m);

        for( int i = 0; i < n; ++i )
            for( int j = 0; j < n; ++j )
                done[i][j] = -1;

        priority_queue< data > pq;

        ll cnt = 0;
        bool ok = 0;

        for( int i = 0; i < n; ++i ){
            for( int j = 0; j < n; ++j ){
                scanf("%lld",&mat[i][j]);
                cnt += mat[i][j];

                if( mat[i][j] >= threshold ){
                    ok = 1;
                    start[i][j] = done[i][j] = 0;
                    pq.push( data( 0, i, j ) );
                }
            }
        }

        if( cnt >= m ){
            printf("0\n");
            continue;
        }

        if( !ok ){
            printf("Not possible\n");
            continue;
        }

        while( !pq.empty() ){
            data u = pq.top(); pq.pop();

            for( int i = 0; i < 4; ++i ){
                int r = u.r + d[i][0];
                int c = u.c + d[i][1];

                if( r < 0 || c < 0 || r >= n || c >= n || done[r][c] != -1 ) continue;

                done[r][c] = u.time + threshold - mat[r][c];
                start[r][c] = u.time;
                pq.push( data( done[r][c], r, c ) );
            }
        }


        ll lo = 0, hi = m;
        while( lo < hi ){
            ll mid = (lo+hi)/2;

            ll B = cnt_bac( mid );
            if( B >= m ) hi = mid;
            else lo = mid + 1;
        }

        printf("%lld\n",hi);
    }


    return 0;
}

#include <stdio.h>
#include <math.h>
#include <time.h>
#include <string.h>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <string>
#include <vector>
#include <set>
#include <map>
#pragma comment(linker, "/STACK:16777216")
using namespace std;

typedef vector<int> VI;
typedef pair<int,int> PII;
#ifndef ONLINE_JUDGE
typedef __int64 LL;
#else
typedef long long LL;
#endif

#define bit(n) (1<<(n))
#define inf 1000000000
#define eps 1e-9
#define PI 3.1415926535897932385
#define pb push_back
#define sz size()
#define mp make_pair
#define cl clear()
#define all(a) a.begin(),a.end()
#define fill(ar,val) memset(ar,val,sizeof ar)
#define MIN(a,b) if(a>(b)) a=(b)
#define MAX(a,b) if(a<(b)) a=(b)
#define sqr(x) ((x)*(x))
#define min(a,b) ((a)<(b)?(a):(b))
#define max(a,b) ((a)>(b)?(a):(b))

//clock_t start=clock();
//fprintf(stderr,"time=%.3lfsec\n",0.001*(clock()-start));

#define N 111
int n;
LL k,m;
LL a[N][N];
int mark[N][N];
set< pair<LL,PII> > live;
int dx[4]={1,-1,0,0};
int dy[4]={0,0,1,-1};

int main()
{
	#ifndef ONLINE_JUDGE
	freopen("Ulaz.txt","r",stdin);
	#endif
	int T;
	for(cin>>T;T--;)
	{
		cin >> n >> k >> m;
		live.cl;
		int cnt=0;
		fill(mark,0);
		int i,j,h;
		for(i=0;i<n;i++)
			for(j=0;j<n;j++)
			{
				cin >> a[i][j];
				m-=a[i][j];
				if(a[i][j]>=k)
				{
					mark[i][j]=1;
					cnt++;
				}
			}
		for(i=0;i<n;i++)
			for(j=0;j<n;j++)
				if(a[i][j]<k)
				{
					for(h=0;h<4;h++)
					{
						int x=i+dx[h];
						int y=j+dy[h];
						if(0<=x && x<n && 0<=y && y<n && a[x][y]>=k) break;
					}
					if(h<4)
					{
						mark[i][j]=1;
						cnt++;
						live.insert(mp(-a[i][j],mp(i,j)));
					}
				};
		if(m<=0){puts("0");continue;}
		if(cnt==0){puts("Not possible");continue;}
		LL ans=0;
		LL dif=0;
		for(;;)
		{
			if(live.empty())
			{
				ans+=(m+cnt-1)/cnt;
				break;
			}
			pair<LL,PII> p=*live.begin();
			LL val=-p.first+dif;
			int i=p.second.first;
			int j=p.second.second;
			LL d=k-val;
			if(m<=d*cnt)
			{
				ans+=(m+cnt-1)/cnt;
				break;
			}
			ans+=d;
			m-=cnt*d;
			dif+=d;
			live.erase(live.begin());
			for(h=0;h<4;h++)
			{
				int x=i+dx[h];
				int y=j+dy[h];
				if(0<=x && x<n && 0<=y && y<n && !mark[x][y])
				{
					mark[x][y]=1;
					cnt++;
					live.insert(mp(-a[x][y]+dif,mp(x,y)));
				}
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <iomanip>
#include <assert.h>
#include <time.h>
#include <math.h>
#include <fstream>
using namespace std;

const int maxn = 100000 + 55;

int n;
int niz[maxn];
int R[maxn];

int sum = 0;

int main(){
    int tests;
    scanf("%d",&tests);
    while( tests -- ){ sum = 0;

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%d",&niz[i]);
        sum += niz[i];
    }

    int now = 0;
    R[n] = 0;

    for( int i = n-1; i >= 0; --i ){
        now += -2*niz[i];
        R[i] = max( R[i+1] , now );
    }

    int sol = max( sum , sum + R[0] );
    for( int i = 0; i < n; ++i ){
        sum += -2*niz[i];
        sol = max( sol , sum + R[i+1] );
    }

    printf("%d\n",sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <set>
#include <iomanip>
#include <queue>
#include <math.h>
using namespace std;

typedef long long ll;

const int mod = 1000000000 + 7;

int s[30],sz=0;

int mypow( int a, int e ){

    int sol = 1;
    for( int i = sz-1; i >= 0; --i ){
        int u = s[i];
        if( u == 0 ) sol = (sol*(ll)sol)%mod;
        else sol = (sol*(ll)a)%mod;
    }
    return sol;
}

int main(){
    //double t = clock();
  //  freopen("Ulaz.txt","r",stdin);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        int a,b,stp,sol=0;
        scanf("%d%d%d",&a,&b,&stp);

        int e = stp;
        sz = 0;
        while( e > 0 ){
            if( e % 2 == 0 ) s[sz++] = 0, e >>= 1;
            else s[sz++] = 1, e --;
        }

        int lo = a-1;
        int hi = b;

        for( int i = 1; i <= b; ++i ){
            int lo = (a-1) / i;
            int hi = b / i;

           // while( lo * i > a-1 ) lo --;
           // while( hi * i > b   ) hi --;

            int cnt = hi - lo;
            sol = (sol + cnt * (ll)mypow(i,stp))%mod;
        }

        printf("%d\n",sol);

    }

   // printf("%.10lf\n",(clock()-t)/CLOCKS_PER_SEC);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <set>
#include <iomanip>
#include <queue>
#include <math.h>
using namespace std;

int mypow( int base, int exp ){
    int sol = 1;
    for( int i = 1; i <= exp; ++i )
        sol *= base;
    return sol;
}

int main(){
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        int a,b,stp,sol=0;
        scanf("%d%d%d",&a,&b,&stp);

        for( int i = a; i <= b; ++i ){
            for( int k = 1; k <= i; ++k ){
                if( i % k == 0 ){
                    sol += mypow(k,stp);
                }
            }
        }
        printf("%d\n",sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <iomanip>
using namespace std;

const int prime = 5441;

int n;
char txt[1005];

int mem[1005][1005];

int main(){
    scanf("%s",txt);
    n = strlen(txt);

    for( int i = 0; i < n; ++i ){
        int s = 0;
        for( int j = i; j < n; ++j ){
            s = s * prime + txt[j];
            mem[i][j] = s;
        }
    }

    int sol = 0;

    for( int i = n-1; i >= 0; --i ){
        int s = 0;
        for( int j = i; j >= 0; --j ){
            s = s * prime + txt[j];
            int L = i - j;
            if( i + L == n ) break;

            if( i+L   < n && mem[i][i+L] == s  ) sol ++;
            if( i+L+1 < n && mem[i+1][i+L+1] == s ) sol ++;
        }
    }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
using namespace std;

int k,n,m;

int readi(){
    char c;
    while( (c=getchar()) < '0' || c > '9' );
    int v = c - '0';
    while( (c=getchar())>='0' && c <= '9' )
        v = v * 10 + c - '0';
    return v;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz2.txt","w",stdout);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        k = readi();
        n = readi();
        m = readi();

        if( n > m ){
            int t = n;
            n = m;
            m = t;
        }

        int w = n / (k+1);

        if( n % (k+1) == 0 ) printf("+\n");
        else if( w % 2 == 0 || k == 1 ){
            if( (m-n) % 2 == 0 ) printf("-\n");
            else printf("+\n");
        }else{
            if( (m-n) % 2 == 0 ) printf("+\n");
            else printf("-\n");
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
using namespace std;

int k,n,m;

int dp[101][101];

int solve( int n, int m ){
   if( n == 1 && m == 1 ) return 0;

   int &sol = dp[n][m];
   if( sol != -1 ) return sol;

   int a = 1 , b = 1,  c = 1;

   if( n > 1 ) a = solve( n-1 , m );
   if( m > 1 ) b = solve( n , m-1 );
   if( n-1>=k && m-1>=k ) c = solve( n-k , m-k );

   if( !a || !b || !c ) return sol = 1;
   return sol = 0;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);

    int t; cin >> t;

    while( cin >> k >> n >> m ){
      //  for( int i = n; i <= 60; ++i ){
             memset( dp, -1, sizeof(dp));
            cout<< ( solve( n , m ) ? "+" : "-" ) << endl;;
      //  }cout<<endl;

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string.h>
#include <string>
using namespace std;

const int maxn = 23;
const int maxw = 100000 + 55;
const int mod = 1000000007;

int n,w;
int r[maxn];

int dp[maxn][maxw];
int ss[maxn][maxw];


inline int readi(){
    char c;
    while( (c=getchar()) < '0' || c > '9' );
    int v = c - '0';
    while( (c=getchar())>='0' && c <= '9' )
        v = v * 10 + c - '0';
    return v;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests;
    tests = readi();

    for( ; tests; --tests ){
        n = readi() , w = readi();


        int sl = w;
        int range = 0;

        for( int i = 0; i < n; ++i ){
            int a,b;
            a = readi(), r[i] = readi();
            sl -= a;
            w -= a;
            r[i] -= a;
            range += r[i];
        }

        if( sl < 0 || range < w){
            printf("0\n");
            continue;
        }

        dp[n][w] = ss[n][w] = 1;
        ss[n][w+1] = 0;

        for( int i = w; i >= 0; --i ){
            if( i < w ) ss[n][i] = ss[n][i+1];
            for( int j = n-1; j >= 0; --j ){
                dp[j][i] = 0;
                ss[j][i] = ss[j][i+1];

                int to = i + r[j];
                if( to > w ) to = w;

                dp[j][i] = ss[j+1][i] - ss[j+1][to+1];

                if( dp[j][i] < 0 ) dp[j][i] += mod;

                ss[j][i] += dp[j][i];
                if( ss[j][i] >= mod ) ss[j][i] -= mod;
            }
        }

        printf("%d\n",dp[0][0]);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <string.h>
#include <map>
#include <queue>
using namespace std;

const int maxe = 300000 + 555;
const int maxn = 200000 + 55;
const int source = 2*50003;
const int sink   = 2*50004;
const int inf = 999999;

int n,m,w;
int cnte = 1;
int head[maxn] , nxt[maxe] , point[maxe] , cap[maxe];

inline void add_edge( int a, int b, int c ){
    cap[cnte] = c, point[cnte] = b, nxt[cnte] = head[a], head[a] = cnte++;
}

int dst[maxn];

bool bfs(){
    queue< int > q;
    q.push( source );

    memset( dst , -1 , sizeof(dst));
    dst[source] = 0;

    while( !q.empty() ){
        int u = q.front(); q.pop();

        for( int i = head[u]; i >= 1; i = nxt[i] ){
            if( dst[ point[i] ] != -1 || cap[i] == 0 ) continue;
            dst[ point[i] ] =  dst[u] + 1;
            if( point[i] !=  sink )q.push( point[i] );
        }
    }

    if( dst[ sink ] == -1 ) return 0;
    return 1;
}

int flow( int node , int min_cap ){
    if( min_cap <= 0 ) return 0;
    if( node == sink ) return min_cap;

    int ret = 0;

    for( int i = head[node]; i >= 1; i = nxt[i] ){
        if( dst[ point[i] ] != dst[node] + 1 ) continue;
        int f = flow( point[i] , min( cap[i] , min_cap - ret ) );

        int x = i+1;
        if( (i&1) == 0 ) x = i-1;

        cap[i] -= f;
        cap[x] += f;
        ret += f;
    }
    return ret;
}

int match(){
    int ret = 0;
    while( bfs() ) ret += flow( source , inf );
    return ret;
}

inline int readi(){
    char c;
    while( (c=getchar())<'0' || c > '9' ) ;
    int v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v*10 + c - '0';
    return v;
}


int main(){
    freopen("Ulaz.txt","r",stdin);
    n = readi();
    m = readi();
    w = readi();

    for( int i = 0; i < w; ++i ){
        int a,b;
        a = readi();
        b = readi();
        a-- , b--;
        b += n;

        add_edge( a , b , 1 );
        add_edge( b , a , 0 );
    }

    for( int i = 0; i < n; ++i ) add_edge( source, i, 1 ), add_edge( i, source, 0 );
    for( int i = 0; i < m; ++i ) add_edge( i+n, sink, 1 ), add_edge( sink, i+n, 0 );

    printf("%d\n",match());

    return 0;
}


#include <queue>
#include <vector>
#include <cstdio>
#include <cstring>

using namespace std;

const int S = 100004;
const int T = 100003;
const int inf = 1000000000;

#define MAX 100005
#define f( x ) ( ( x ) << ( 1 ) )
#define g( x ) ( f( x ) | ( 1 ) )

struct edge {
	int n, ok, cap, rev;
	edge( int _n, int _cap ) : n( _n ), ok( 0 ), cap( _cap ) {}
};

int N, M, P;
int a, b;

int bio[ MAX ];
int cookie;

queue< int > Q;

vector< edge > G[ MAX ];

inline int bfs()
{
	while( !Q.empty() ) Q.pop();

	Q.push( S );
	bio[ S ] = ++cookie;

	while( !Q.empty() ) {
		int c = Q.front(); Q.pop();
		for( int i = 0; i < G[c].size(); ++i ) {
			if( G[c][i].cap == 0 ) continue;
			if( bio[ G[c][i].n ] == cookie && G[c][i].n != T ) continue;

			bio[ G[c][i].n ] = cookie;
			G[c][i].ok = cookie;

			if( G[c][i].n != T ) Q.push( G[c][i].n );
		}
	}

	return ( bio[ T ] == cookie );
}

int augment( int c, int p )
{
	if( p <= 0 ) return 0;
	if( c == T ) return p;

	int sent = 0;

	for( int i = 0; i < G[c].size(); ++i ) {
		if( G[c][i].ok != cookie ) continue;
		int flow = augment( G[c][i].n, min( G[c][i].cap, p - sent ) );

		G[ c ][ i ].cap -= flow;
		G[ G[c][i].n ][ G[c][i].rev ].cap += flow;

		sent += flow;
	}

	return sent;
}

inline int Dinic() {
	int maxflow = 0;
	for( ; bfs(); maxflow += augment( S, inf ) );
	return maxflow;
}

int main( void )
{
    freopen("Ulaz.txt","r",stdin);

	scanf( "%d%d%d", &N, &M, &P );
	for( int i = 0; i < P; ++i ) {
		scanf( "%d%d", &a, &b );
		G[ f( a ) ].push_back( edge( g( b ), 1 ) );
		G[ g( b ) ].push_back( edge( f( a ), 0 ) );
		G[ f( a ) ].back().rev = G[ g( b ) ].size()-1;
		G[ g( b ) ].back().rev = G[ f( a ) ].size()-1;
	}

	for( int i = 1; i <= N; ++i ) {
		G[ S ].push_back( edge( f( i ), 1 ) );
		G[ f( i ) ].push_back( edge( S, 0 ) );
		G[ S ].back().rev = G[ f( i ) ].size()-1;
		G[ f( i ) ].back().rev = G[ S ].size()-1;
	}

	for( int i = 1; i <= M; ++i ) {
		G[ g( i ) ].push_back( edge( T, 1 ) );
		G[ T ].push_back( edge( g( i ), 0 ) );
		G[ g( i ) ].back().rev = G[ T ].size()-1;
		G[ T ].back().rev = G[ g( i ) ].size()-1;
	}

	printf( "%d\n", Dinic() );

	return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <string.h>
#include <map>
#include <queue>
using namespace std;

const int maxe = 300000 + 555;
const int maxn = 200000 + 55;
const int nil = 50000*2 + 6;
const int inf = 999999;

int n,m,w;
int cnte = 1;
int head[maxn] , nxt[maxe] , point[maxe];

inline void add_edge( int a, int b ){
    point[cnte] = b, nxt[cnte] = head[a], head[a] = cnte++;
}

int dst[maxn];
int par[maxn];

bool bfs(){

    queue<int>q;
    dst[nil] = -1;

    for( int i = 0; i < n; ++i ){
        if( par[i] == nil ){
            dst[i] = 0;
            q.push(i);
        }else dst[i] = -1;
    }

   // cout<<"A"<<endl;
    while( !q.empty() ){
        int u = q.front(); q.pop();
       // cout<<u<<endl;
        for( int i = head[u]; i >= 1; i = nxt[i] ){
            int w = point[i];
            if( dst[ par[w] ] == -1 ){
                dst[ par[w] ] = dst[u] + 1;
                q.push( par[w] );
            }
        }
    }
    //cout<<"B"<<endl;
    return dst[nil] != -1;
}

bool dfs( int node ){
    if( node == nil ) return 1;
  //  cout<<node<<endl;

    for( int i = head[node]; i >= 1; i = nxt[i] ){
        int w = point[i];

        if( dst[ par[w] ] != dst[node] + 1 ) continue;
        bool f = dfs( par[w] );

        if( f ){
            par[node] = w;
            par[w] = node;
            return 1;
        }
    }
    return 0;
}

int match(){
    for( int i = 0; i < n+m; ++i ) par[i] = nil;

    int ret = 0;
    while( bfs() ){
        for( int i = 0; i < n; ++i )
            if( par[i] == nil ) ret += dfs( i );
    }
    return ret;
}

inline int readi(){
    char c;
    while( (c=getchar())<'0' || c > '9' ) ;
    int v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v*10 + c - '0';
    return v;
}


int main(){
    //freopen("Ulaz.txt","r",stdin);
    n = readi();
    m = readi();
    w = readi();

    for( int i = 0; i < w; ++i ){
        int a,b;
        a = readi();
        b = readi();
        a-- , b--;
        b += n;

        add_edge( a , b );
    }


    printf("%d\n",match());

    return 0;
}


#include <cstdio>
#include <math.h>
#include <vector>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <stack>
#include <iostream>
using namespace std;

const int maxn = 1000 + 55;

int n;
vector< int > g[maxn];

bool visi[maxn];

int scc_counter = 1;
int low[maxn];
int id[maxn];
bool instack[maxn];

stack<int>stk;
int cnt = 0;

int color[maxn];
int ccnt[maxn];

void scc( int node ){
    low[node] = id[node] = scc_counter++;
    visi[node] = 1;

    instack[node] = 1;
    stk.push( node );

    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( visi[nxt] == false ){
            scc( nxt );
            low[node] = min( low[node], low[nxt] );
        }else if( instack[nxt] && id[nxt] < id[node]  ){
            low[node] = min( low[node], id[nxt] );
        }
    }

    if( id[node] == low[node] ){
        //cout<<"COMPONENT: "<<endl;
        while( stk.empty() == false && id[stk.top()] >= id[node] ){
            int u = stk.top(); stk.pop();
            instack[u] = 0;
            //cout<<" "<<u+1<<endl;
            color[u] = cnt;
            ccnt[ cnt ] ++;
        }
        cnt ++;
    }
}

vector< int > cg[maxn];
vector< int > crg[maxn];
int out[maxn];

int main(){
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d",&n);

        cnt = 0 ;
        scc_counter = 1;
        for( int i = 0; i < n; ++i ){
            g[i].clear();
            crg[i].clear();
            cg[i].clear();
            out[i] = 0;
            ccnt[i] = color[i] = instack[i] = id[i] = low[i] = visi[i] = 0;
        }

        for( int i = 0; i < n; ++i ){
            int m; scanf("%d",&m);
            for( int j = 0; j < m; ++j ){
                int a; scanf("%d",&a);
                g[a-1].push_back( i );
            }
        }

        for( int i = 0; i < n; ++i ){
            if( visi[i] == false ) scc(i);

            for( int j = 0; j < g[i].size(); ++j ){
                int nxt = g[i][j];
                if( color[i] != color[nxt] ){
                    cg[ color[i] ].push_back( color[nxt] );
                    crg[ color[nxt] ].push_back( color[i] );
                }
            }
        }

        int sol = -1;
        int dom = -1;
        queue< int > q;

        for( int i = 0; i < cnt; ++i ){
            out[i] = cg[i].size();
            if( out[i] == 0 )
                q.push( i );
        }

        while( !q.empty() ){
            int u = q.front(); q.pop();
            if( crg[u].size() == 0 ){
                if( dom == -1 ) dom = u;
                else dom = -2;
            }

            for( int i = 0; i < crg[u].size(); ++i ){
                int nxt = crg[u][i];

                out[nxt] --;
                if( out[nxt] == 0 ) q.push( nxt );
            }
        }

        if( dom == -2 ) printf("0\n");
        else printf("%d\n",ccnt[dom]);
    }

    return 0;
}

#include <cstdio>
#include <math.h>
#include <vector>
#include <string.h>
#include <string>
#include <set>
#include <queue>
using namespace std;

const int maxn = 1000 + 55;

int n;
vector< int > g[maxn];
vector< int > rg[maxn];

bool visi[maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d",&n);
        for( int i = 0; i < n; ++i )
            g[i].clear(), rg[i].clear();

        for( int i = 0; i < n; ++i ){
            int m; scanf("%d",&m);
            for( int j = 0; j < m; ++j ){
                int a; scanf("%d",&a);
                g[i].push_back( a - 1 );
                rg[a-1].push_back(i);
            }
        }

        int sol = 0;

        for( int i = 0; i < n; ++i ){
            memset( visi, 0, sizeof(visi));

            queue< int > q;
            q.push( i );
            visi[i] = 1;

            while( !q.empty() ){
                int u = q.front(); q.pop();
                for( int j = 0; j < g[u].size(); ++j ){
                    int nxt = g[u][j];
                    if( visi[nxt] ) continue;
                    q.push( nxt );
                    visi[nxt] = 1;
                }
            }

            bool ok = 1;
            for( int j = 0; j < rg[i].size(); ++j ){
                int nxt = rg[i][j];
                if( visi[nxt] == false ) ok = 0;
            }

            for( int j = 0; j < n; ++j ) if( visi[j] == 0 ) ok = 0;

            sol += ok;
        }

        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <fstream>
using namespace std;

int main(){
    srand((unsigned)time(0));
    ofstream out("Ulaz.txt");

    int tests = 1000;
    out<<tests<<endl;

    while( tests -- ){

    int n = 1 + rand()%50;
    out<<n<<endl;

    for( int i = 0; i < n; ++i ){
        int m = 1 + rand()%n;
        out<<m<<" ";
        for( int j = 0; j < m; ++j ){
            out<<1+rand()%n<<" ";
        }out<<endl;
    }

    }

    out.close();

    system("TOUR.exe");
    system("TOUR_BRUTE.exe");
    system("diff -qb Izlaz.txt Izlaz2.txt");

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <string.h>
using namespace std;

const int maxn = 1005;
const int maxp = 10000;

char a[maxn],b[maxn];

char a_plus_b[maxn];
char a_lcm_b[maxn];
char final[maxn];

bool ok[maxp];
int ps[maxp];
int sz = 0;

void calc_primes(){
    for( int i = 2; i < maxp; ++i ){
        if( ok[i] ) continue;
        ps[sz++] = i;
        for( int k = i+i; k < maxp; k += i )
            ok[k] = 1;
    }
}

void _plus( char *a, char *b, char *sol ){
    int ln1,ln2;
    ln1 = strlen(a);
    ln2 = strlen(b);

    int fin = 0;

    for( int i = 0; i < 1000; ++i ){
        int mod = ps[i];
        int v1 = 1, v2 = 1;

        if( i < ln1 && i < ln2 && a[i] == b[i] && a[i] == '1' ){
            v1 = 0 , v2 = 0;
        }else{
            for( int k = 0; k < ln1; ++k ){
                if( a[k] == '0' ) continue;
                v1 = (v1*ps[k])%mod;
            }

            for( int k = 0; k < ln2; ++k ){
                if( b[k] == '0' ) continue;
                v2 = (v2*ps[k])%mod;
            }
        }

        int v = (v1+v2)%mod;
        if( v == 0 ) sol[i] = '1' , fin = i+1;
        else sol[i] = '0';
    }
    sol[fin] = '\0';
}

void lcm( char *a, char *b, char *sol ){
    int ln1 = strlen(a);
    int ln2 = strlen(b);
    int mx = max(ln1,ln2);

    for( int i = 0; i < mx; ++i ){
        char c1 = '0', c2 = '0';
        if( i < ln1 ) c1 = a[i];
        if( i < ln2 ) c2 = b[i];

        if( c1 == '1' || c2 == '1' ) sol[i] = '1';
        else sol[i] = '0';
    }
    sol[mx] = '\0';
}

void gcd( char *a, char *b, char *sol ){
    int ln1 = strlen(a);
    int ln2 = strlen(b);
    int mx = max(ln1,ln2);

    int fin = 0;

    for( int i = 0; i < mx; ++i ){
        char c1 = '0', c2 = '0';
        if( i < ln1 ) c1 = a[i];
        if( i < ln2 ) c2 = b[i];

        if( c1 == '1' && c2 == '1' ) sol[i] = '1', fin = i+1;
        else sol[i] = '0';
    }
    sol[fin] = '\0';
}

int main(){
   // freopen("Ulaz.txt","r",stdin);

    calc_primes();

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%s%s",a,b);

        int ln1 = strlen(a);
        int ln2 = strlen(b);
        int mx = max(ln1,ln2);

        int cm = 0;
        for( int i = 0; i < mx; ++i ){
            char c1 = '0', c2 = '0';
            if( i < ln1 ) c1 = a[i];
            if( i < ln2 ) c2 = b[i];

            if( c1 == '1' && c2 == '1' ) cm = i + 1;
        }

        if( cm == 0 ) printf("relatively prime\n");
        else{
            for( int i = 0; i < cm; ++i ){
                char c1 = '0', c2 = '0';
                if( i < ln1 ) c1 = a[i];
                if( i < ln2 ) c2 = b[i];

                if( c1 == '1' && c2 == '1' ) printf("1");
                else printf("0");
            }
            printf("\n");
        }

        continue;

        _plus(a,b,a_plus_b);
        lcm (a,b,a_lcm_b );


        gcd( a_plus_b , a_lcm_b , final );

        if( strlen(final) == 0 ) printf("relatively prime\n");
        else printf("%s\n",final);
    }


    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <cstdio>
#include <string>
#include <string.h>
#include <map>
#include <set>
#include <algorithm>
#include <queue>
using namespace std;

const int maxn = 10005;

int n;
int x[maxn],y[maxn],w[maxn];


int main(){
    //freopen("Ulaz.txt","r",stdin);

    while( scanf("%d",&n) ){
        if( n == -1 ) break;

        for( int i = 0; i < n; ++i ) scanf("%d",&x[i]);
        for( int i = 0; i < n; ++i ) scanf("%d",&y[i]);

        sort( y , y + n );
        sort( x , x + n );

        w[0] = x[1] - x[0];
        for( int i = 1; i < n-1; ++i )
            w[i] = x[i+1] - x[i-1];
        w[n-1] = x[n-1] - x[n-2];

        sort( w , w + n );

        double sol = 0;
        for( int i = 0; i < n; ++i )
            sol += w[i] * y[i];

        sol /= 2;
        printf("%.1lf\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <string>
#include <string.h>
#include <iomanip>
using namespace std;

struct segment_tree{
    int begin;
    vector< int > L,R,tree,on;
    vector< bool > rot;

    void init( int n ){
        int sz = 1;
        while( sz < n ) sz <<= 1;
        begin = sz;
        sz <<= 1;
        rot.resize(sz);
        on.resize(sz);
        L.resize(sz);
        R.resize(sz);

        for( int i = begin; i < begin*2-1; ++i ) L[i] = R[i] = i;
        for( int i = begin-1; i >= 1; --i ) L[i] = L[i*2] , R[i] = R[i*2+1];
    }

    segment_tree(){}
    segment_tree( int n ){ init(n); }

    int l,r;

    void _update( int node , int lo, int hi ){
        int range = hi-lo+1;

        if( lo >= l && hi <= r ){
            on[node] = range - on[node];
            rot[node] = !rot[node];
            return;
        }
        if( node >= begin || lo > r || hi < l ) return;

        if( rot[node] ){
            int w = range >> 1;
            rot[node] = 0;
            on[node*2] = w - on[node*2];
            on[node*2+1] = w - on[node*2+1];
            rot[node*2] = !rot[node*2];
            rot[node*2+1] = !rot[node*2+1];
        }

        int mid = (hi+lo) >> 1;
        _update( node*2, lo, mid );
        _update( node*2+1, mid+1, hi );

        on[node] = on[node*2] + on[node*2+1];
    }

    int _query( int node, int lo, int hi ){
        int range = hi-lo+1;

        if( lo >= l && hi <= r ) return on[node];
        if( node >= begin || lo > r || hi < l ) return 0;

        if( rot[node] ){
            int w = range >> 1;
            rot[node] = 0;
            on[node*2] = w - on[node*2];
            on[node*2+1] = w - on[node*2+1];
            rot[node*2] = !rot[node*2];
            rot[node*2+1] = !rot[node*2+1];
        }

        int mid = (hi+lo) >> 1;
        int sol = _query( node*2, lo, mid ) + _query( node*2+1, mid+1, hi );

        on[node] = on[node*2] + on[node*2+1];

        return sol;
    }

    void update( int lo, int hi ){
        l = lo + begin;
        r = hi + begin;
        _update( 1 , begin , begin*2-1);
    }

    int query( int lo, int hi ){
        l = lo + begin;
        r = hi + begin;
        return _query( 1 , begin , begin*2-1);
    }
};

int n,m;
segment_tree t;

int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    scanf("%d%d",&n,&m);
    t.init(n);

    for( int i = 0; i < m; ++i ){
        int c,a,b;
        scanf("%d%d%d",&c,&a,&b);

        if( c == 0 ) t.update( a-1, b-1 );
        else printf("%d\n",t.query(a-1,b-1) );
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <string>
#include <string.h>
#include <iomanip>
using namespace std;

struct segment_tree{
    int begin;
    vector< bool > tree;

    void init( int n ){
        tree.resize(n+50);
    }

    segment_tree(){}
    segment_tree( int n ){ init(n); }

    void update( int l, int r ){
        for( int i  = l; i <= r; ++i ) tree[i] = !tree[i];
    }

    int query( int l , int r ){
        int sol = 0;
        for( int i  = l; i <= r; ++i ) sol += tree[i];
        return sol;
    }
};

int n,m;
segment_tree t;

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
    scanf("%d%d",&n,&m);
    t.init(n);

    for( int i = 0; i < m; ++i ){
        int c,a,b;
        scanf("%d%d%d",&c,&a,&b);

        if( c == 0 ){
            t.update( a-1, b-1 );
        }else{
            printf("%d\n",t.query(a-1,b-1) );
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <string>
#include <string.h>
#include <iomanip>
using namespace std;

int main(){
    freopen("Ulaz.txt","w",stdout);
    srand((unsigned)time(0));
    int n = 500 , m = 9000;

    printf("%d %d\n",n,m);

    for( int i = 0; i < m; ++i ){
        int c = rand()%2;
        int f = 1+rand()%n;
        int s;

        while(1){
            s = 1+rand()%n;
            if( s >= f ) break;
        }

        printf("%d %d %d\n",c,f,s);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <cstdlib>
#include <set>
using namespace std;

typedef long long ll;

const int maxn = 20000 + 55;
const int mod = 1000000007;

vector< int > g[maxn];

int n,m;
int C[30][30];
int sub[maxn][30];

int fpow( int b, int e ){
    if( e == 0 ) return 1;
    else if( e&1 ) return (b*(ll)fpow(b,e-1)) % mod;
    else{
        int w = fpow( b, e >> 1 );
        return (w*(ll)w)%mod;
    }
}

void inclevel( int *poly ){
    for( int i = 0; i <= m; ++i ){
        int v = poly[i];
        for( int k = 0; k < i; ++k )
            poly[k] = ( poly[k] + (ll)v * (ll)C[i][k] ) % mod;
    }
}

void dfs( int node, int dad ){
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( nxt == dad ) continue;
        dfs( nxt , node );

        for( int k = 0; k <= m; ++k ) sub[node][k] = ( sub[node][k] + sub[nxt][k] ) % mod;
    }

    inclevel( sub[node] );
    sub[node][m] = ( sub[node][m] + 1 ) % mod;
}

int curr[30];
int mem[maxn][30];
int sols[maxn];
int work[30];

void solve( int node, int dad ){
    inclevel( curr );
    for( int i = 0; i <= m; ++i ){
        sols[node] = ( sols[node] + (curr[i] + sub[node][i])%mod ) % mod;
        mem[node][i] = (curr[i] + sub[node][i])%mod;
    }

    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( nxt == dad ) continue;

        for( int k = 0; k <= m; ++k ) work[k] = sub[nxt][k];
        inclevel( work );

        for( int k = 0; k <= m; ++k ) curr[k] = (mem[node][k] - work[k] + mod ) % mod;

        solve( nxt , node );
    }

}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    for( int i = 0; i < 30; ++i ){
        C[i][0] = 1;
        for( int j = 1; j <= i; ++j ) C[i][j] = ( C[i-1][j] + C[i-1][j-1] ) % mod;
    }

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&n,&m);

        for( int i = 0; i <= n; ++i ){
            g[i].clear();
            sols[i] = 0;
            for( int j = 0; j <= m; ++j )
                sub[i][j] = 0;
        }
        for( int i = 0; i < 30; ++i ) curr[i] = 0;


        for( int i = 0; i < n-1; ++i ){
            int a,b; scanf("%d%d",&a,&b);
            g[a].push_back(b);
            g[b].push_back(a);
        }

        dfs( 0 , -1 );
        solve( 0 , -1 );

        for( int i = 0; i < n; ++i )
            printf("%d\n",sols[i]);
        printf("\n");


    }

    return 0;
}

#include <iostream>
#include <vector>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <cstdlib>
#include <set>
using namespace std;

typedef long long ll;

const int maxn = 20000 + 55;
const int mod = 1000000007;

vector< int > g[maxn];

int n,m;
int C[30][30];
int sub[maxn][30];

int fpow( int b, int e ){
    if( e == 0 ) return 1;
    else if( e&1 ) return (b*(ll)fpow(b,e-1)) % mod;
    else{
        int w = fpow( b, e >> 1 );
        return (w*(ll)w)%mod;
    }
}

int sols[maxn];
int lvl[maxn];

int cnt = 0;

void dfs( int node, int dad ){
    cnt = ( cnt + fpow( lvl[node] , m ) ) % mod;
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( nxt == dad ) continue;
        lvl[nxt] = lvl[node] + 1;
        dfs( nxt , node );
    }
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
    for( int i = 0; i < 30; ++i ){
        C[i][0] = 1;
        for( int j = 1; j <= i; ++j ) C[i][j] = (C[i-1][j] + C[i-1][j-1])%mod;
    }

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&n,&m);

        for( int i = 0; i < n; ++i ){
            g[i].clear();
            for( int j = 0; j <= m; ++j )
                sub[i][j] = 0;
        }

        for( int i = 0; i < n-1; ++i ){
            int a,b; scanf("%d%d",&a,&b);
            g[a].push_back(b);
            g[b].push_back(a);
        }

        for( int i = 0; i < n; ++i ){
            cnt = 0;
            lvl[i] = 1;
            dfs( i , -1 );
            sols[i] = cnt;
        }

        for( int i = 0; i < n; ++i )
            printf("%d\n",sols[i]);
        printf("\n");


    }

    return 0;
}

#include <iostream>
#include <vector>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <cstdlib>
#include <fstream>
#include <set>
using namespace std;

typedef long long ll;

struct dis_set{
    vector< int > sz;
    vector< int > id;

    void init( int n ){
        n += 55;
        sz.resize(n);
        id.resize(n);

        for( int i = 0; i < n; ++i ) sz[i] = 1 ,  id[i] = i;
    }

    dis_set(){};
    dis_set( int n ){ init(n); }

    int get_root( int x ){
        if( x == id[x] ) return x;
        return id[x] = get_root( id[x] );
    }

    int subtree_sz( int x ){
        return sz[ get_root(x) ];
    }

    bool merge( int a, int b ){
        int x = get_root( a ) , y = get_root( b );
        if( x == y ) return 1;

        if( sz[x] < sz[y] ) id[x] = y , sz[y] += sz[x];
        else id[y] = x , sz[x] += sz[y];

        return 0;
    }
};



int main(){
    srand((unsigned)time(0));
    ofstream out("Ulaz.txt");

    int tests = 200;
    out<<tests<<endl;

    while( tests -- ){

    int n = 1+rand()%100;
    int m = 1 + rand()%20;

    out<<n<<" "<<m<<endl;

    dis_set f;
    f.init(40000);

    for( int i = 0; i < n-1; ++i ){
        int a,b;
        while(1){
            a = rand()%n;
            b = rand()%n;
            if( f.get_root(a) == f.get_root(b) ) continue;
            break;
        }
        f.merge( a , b);
        out<<a<<" "<<b<<endl;

    }
    }

    system("TREESUM.exe");
    system("TREESUM_BRUTE.exe");
    system("diff -qb Izlaz.txt Izlaz2.txt");


    return 0;
}

#include <iostream>
#include <math.h>
#include <cstdio>
using namespace std;

int main(){
    int a,b;
    while( cin >> a >> b ){
        if( a == -1 && b == -1 ) break;

        printf("%d\n",(int)round(max(ceil(a/(double)(b+1)),ceil(b/(double)(a+1))))  );
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <iomanip>
#include <queue>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>
#define pq priority_queue

const int maxn = 3000 + 15;

struct edge{
    int a,b,c;
    edge(){};
    edge( int p1, int p2, int p3 ):a(p1),b(p2),c(p3){};
    const bool operator<( const edge &e ) const {
        return c < e.c;
    }
};

struct disset{
    vector< int > id, sz;

    void init( int n ){
        id.resize( n + 5 );
        sz.resize( n + 5 );
        for( int i = 0; i <= n; ++i ) id[i] = i , sz[i] = 1;
    }

    disset(){};
    disset( int n ){ init(n); }

    int find( int n ){
        if( n == id[n] ) return n;
        return id[n] = find( id[n] );
    }

    bool merge( int a, int b ){
        int x = find(a) , y = find(b);
        if( x == y ) return 1;

        if( sz[x] < sz[y] ) id[x] = y, sz[y] += sz[x];
        else id[y] = x, sz[x] += sz[y];

        return 0;
    }
};

int n,m,h;
int mat[maxn][maxn];
vector< edge > g[maxn];
vector< int > quest[maxn];

int allow[maxn];
map<int,int>sols[maxn];

void dfs( int node, int dad, int mini ){
    allow[node] = mini;
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i].b;
        if( nxt == dad ) continue;
        dfs( nxt , node , max( mini , g[node][i].c ) );
    }
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    while( (scanf("%d%d%d",&n,&m,&h)) == 3 ){
        if( n == -1 ) break;

        for( int i = 0; i < n; ++i )
            quest[i].clear() , g[i].clear();
        disset d(n);

        vector< edge > w;

        for( int i = 0; i < m; ++i ){
            int a,b,c; scanf("%d%d%d",&a,&b,&c); a-- , b--;
            mat[a][b] = mat[b][a] = c;
            w.push_back( edge(a,b,c) );
        }

        sort( w.begin() , w.end() );

        for( int i = 0; i < w.size(); ++i ){
            int a = w[i].a;
            int b = w[i].b;
            if( d.merge( a , b ) == 0 ){
                g[a].push_back( edge(-1,b,w[i].c) );
                g[b].push_back( edge(-1,a,w[i].c) );
            }
        }

        vector< pii > asks;
        for( int i = 0; i < h; ++i ){
            int a,b; scanf("%d%d",&a,&b); a-- , b--;
            quest[a].push_back(b);
            asks.push_back( mk(a,b) );
        }

        for( int i = 0; i < n; ++i ){
            dfs( i , -1 , 0 );
            for( int k = 0; k < quest[i].size(); ++k ){
                sols[i][ quest[i][k] ] = allow[ quest[i][k] ];
            }
        }

        for( int i = 0; i < h; ++i )
            printf("%d ",sols[ asks[i].f ][ asks[i].s ] );
        printf("\n");

    }


    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <vector>
using namespace std;

typedef long long ll;

int n;
vector< int > lo, hi;

ll dp[20][2][2];
ll cx[20][2][2];
ll cnt = 0;

ll solve( int dx , bool da, bool db ){
    if( dx == n ) return 1;

    ll &sol = dp[dx][da][db];
    if( sol != -1 ){
        cnt += cx[dx][da][db];
        return sol;
    }

    sol = 0;

    ll q = 0;

    for( int i = 0; i <= 9; ++i ){
        bool a = da , b = db;
        if( da && i < lo[dx] ) continue;
        else if( i > lo[dx] ) a = 0;
        if( db && i > hi[dx] ) continue;
        else if( i < hi[dx] ) b = 0;

        ll x;
        sol += x = solve( dx + 1 , a ,b );
        q += x * i;
        cx[dx][da][db] += cx[dx+1][a][b];
    }
    cnt += q;
    cx[dx][da][db] += q;

    return sol;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
    int a,b;

    while( scanf("%d%d",&a,&b) == 2 ){
        if( a == -1 ) break;

        lo.clear() , hi.clear();
        while( a ){
            lo.push_back( a % 10 );
            a /= 10;
        }

        while( b ){
            hi.push_back( b % 10 );
            b /= 10;
        }

        while( lo.size() < hi.size() ) lo.push_back( 0 );

        reverse( lo.begin() , lo.end() );
        reverse( hi.begin() , hi.end() );
        n = lo.size();
        memset( dp , -1 , sizeof(dp));
        memset( cx , 0 , sizeof(cx));

        cnt = 0;
        ll sol = solve( 0 , 1 , 1 );

        cout<<cnt<<endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <vector>
using namespace std;

typedef long long ll;

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
    int a,b;
   while( scanf("%d%d",&a,&b) == 2 ){
        if( a == -1 ) break;

    ll sol = 0;

    for( int i = a; i <= b; ++i ){
        int w = i;
        while( w ){
            sol += w % 10;
            w /= 10;
        }
    }

    cout<< sol << endl;
   }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <vector>
using namespace std;

int main(){
    freopen("Ulaz.txt","w",stdout);
    for( int i = 0; i < 10000; ++i ){
        int a = 1 + rand()%100000;
        int b;
        while(1){
            b = 1 + rand()%100000;
            if( b >= a ) break;

        }
        cout<<a<<" "<<b<<endl;
    }
    cout<<-1<<" "<<-1<<endl;
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <math.h>
#include <string>
#include <string.h>
#include <map>
#include <stack>
#include <queue>
#include <iomanip>
#include <fstream>
using namespace std;

const int maxn = 500 + 55;
const int maxe = 3000 + 55;

const int inf = 999999999;

const int source = 502;
const int sink = 503;

int n,m,h;

int flow[maxn][maxn];
int cap[maxn][maxn];
int mark[maxn];

int edges[maxe][2];
bool know[maxn];

vector< int > g[maxn];
bool visi[maxn];

int _flow( int node , int mincap ){
    if( node == sink ) return mincap;
    visi[node] = 1;
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        int pass = cap[node][nxt] - flow[node][nxt];
        if( pass == 0 || visi[nxt] )continue;
        int w = _flow( nxt , min( mincap, pass ) );
        if( w == 0 ) continue;

        flow[node][nxt] += w;
        flow[nxt][node] -= w;
        return w;

    }
    return 0;
}

void maxflow(){
    while(1){
        for( int i = 0; i <= n; ++i ) visi[i] = 0;
        int s = _flow( source , inf );
        if( s == 0 ) break;
    }
}

void clear(){
    for( int i = 0; i <= n; ++i ){
        visi[i] = know[i] = mark[i] = 0;
        g[i].clear();
    }
    for( int i = source; i <= sink; ++i ){
        visi[i] = know[i] = mark[i] = 0;
        g[i].clear();
        for( int k = 0; k <= n; ++k ){
            cap[k][i] = cap[i][k] = 0;
            flow[k][i] = flow[i][k] = 0;
        }
    }
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&n,&m);

        clear();

        for( int i = 0; i < m; ++i ){
            int a,b; scanf("%d%d",&a,&b); a--,b--;
            g[a].push_back(b);
            g[b].push_back(a);
            cap[a][b] = cap[b][a] = 1;
            edges[i][0] = a, edges[i][1] = b;
        }

        for( int i = 0; i < n; ++i ){
            g[source].push_back(i);
            g[i].push_back(sink);
            cap[source][i] = inf;
            cap[i][sink] = inf;
        }

        scanf("%d",&h);
        for( int i = 0; i < h; ++i ){
            int x,y; scanf("%d%d",&x,&y);
            mark[x-1] = y;
            know[x-1] = true;
        }

        for( int i = 0; i <= 30; ++i ){
            for( int k = 0; k <= n; ++k ){
                flow[source][k] = inf;
                flow[k][sink] = inf;
            }

            for( int k = 0; k < m; ++k ){
                flow[ edges[k][0] ][ edges[k][1] ] = 0;
                flow[ edges[k][1] ][ edges[k][0] ] = 0;
            }

            for( int k = 0; k < n; ++k ){
                if( mark[k]&(1<<i) )
                    flow[source][k] = 0;//, printf("%d -> %d\n",source,k);
                else if( know[k] )
                    flow[k][sink] = 0;//, printf("%d -> %d\n",k,sink);
            }

            maxflow();

            for( int k = 0; k <= n; ++k ) visi[k] = 0;
            queue< int > q;
            q.push( source );
            visi[source] = true;

            while( !q.empty() ){
                int u = q.front(); q.pop();
                if( know[u] == false ) mark[u] += 1 << i;
                for( int k = 0; k < g[u].size(); ++k ){
                    int w = g[u][k];
                    int pass = cap[u][w] - flow[u][w];
                    if( pass > 0 && !visi[w] ){
                        q.push( w );
                        visi[w] = 1;
                    }
                }
            }
        }

        for( int i = 0; i < n; ++i )
            printf("%d\n",mark[i]); printf("\n");
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <string>
#include <string.h>
#include <map>
#include <set>
#include <queue>
#include <iomanip>
#include <vector>
using namespace std;

const int maxn = 4*30000 + 55;
const int maxm = 4*50000 + 55;
const int maxe = maxm * 3;
const int inf  = 99999999;

int source = 30000 + 33;
int sink   = 30000 + 34;

int n,m;

int nedge = 1;
int point[maxe],head[maxn],nxt[maxe];
int c[maxe],rev[maxe];

void add_edge( int a, int b, int c1 ){
    c[nedge] = c1;
    point[nedge] = b, nxt[nedge] = head[a], head[a] = nedge++;
}

bool visi[maxn];
int in[maxn], out[maxn];

int flow( int node, int mincap ){
    if( node == sink ) return 1;
    visi[node] = 1;
    for( int w = head[node]; w > 0; w = nxt[w] ){
        if( visi[ point[w] ] ) continue;
        if( c[w] <= 0 ) continue;

        int f = flow( point[w], min( mincap, c[w] ) );
        if( f <= 0 ) continue;

        c[w] -= f;
        c[ rev[w] ] += f;

        return f;
    }
    return 0;
}

int max_flow(){
    for( int t = 0; t < 2; ++t ){
        for( int i = 0; i <= (n+5)<<1; ++i ) visi[i] = 0;

        int s = flow( source , inf );
        if( s <= 0 ) return 0;
    }
    return 1;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        scanf("%d%d",&n,&m);
        for( int i = 0; i <= ((n+5)<<1); ++i )
            head[i] = 0;

        nedge = 1;

        for( int i = 0; i < n; ++i ){
            in[i] = (i<<1), out[i] = (i<<1)|1;

            int w = 1;
            if( i == 1 ) w = 2;

            rev[nedge] = nedge + 1, rev[nedge+1] = nedge;
            add_edge( in[i], out[i], w );
            add_edge( out[i], in[i], 0 );
        }

        source = n*2;
        sink = n*2+1;

        rev[nedge] = nedge + 1, rev[nedge+1] = nedge;
        add_edge( source, in[1], 2 );
        add_edge( in[1], source, 0 );

        rev[nedge] = nedge + 1, rev[nedge+1] = nedge;
        add_edge( out[0], sink, 1 );
        add_edge( sink, out[0], 0 );

        rev[nedge] = nedge + 1, rev[nedge+1] = nedge;
        add_edge( out[2], sink, 1 );
        add_edge( sink, out[2], 0 );

        for( int i = 0; i < m; ++i ){
            int a,b; scanf("%d%d",&a,&b); a--, b--;
            if( a == b ) continue;
            if( a >= n || b >= n ) continue;

            rev[nedge] = nedge + 1, rev[nedge+1] = nedge;
            add_edge( out[a] , in[b] , 1 );
            add_edge( in[b] , out[a] , 0 );

            rev[nedge] = nedge + 1, rev[nedge+1] = nedge;
            add_edge( out[b] , in[a] , 1 );
            add_edge( in[a], out[b] , 0 );
        }
        if( n <= 2 ){
            printf("NO\n");
            continue;
        }

        if( max_flow() ) printf("YES\n");
        else printf("NO\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <string>
#include <string.h>
#include <map>
#include <set>
#include <queue>
#include <iomanip>
#include <vector>
using namespace std;

bool visi[300];
vector< int > g[300];

bool ok;
int n,m;



void dfs( int node ){
    if( visi[2] && !visi[1] ) return;
    if( visi[1] && visi[2] ){
        ok = 1;
        return;
    }

    for( int i = 0; i < g[node].size() && !ok; ++i ){
        int nxt = g[node][i];
        if( visi[nxt] ) continue;

        visi[nxt] = 1;
        dfs( nxt );
        visi[nxt] = 0;
    }
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        ok = 0;
        for( int i = 0; i < 300; ++i ) g[i].clear();

        scanf("%d%d",&n,&m);
        for( int i = 0; i < m; ++i ){
            int a,b;scanf("%d%d",&a,&b); a--, b--;
            if( a >= n || b >= n ) continue;
            g[a].push_back(b);
            g[b].push_back(a);
        }

        visi[0] = 1;
        dfs( 0 );

        if( ok ) printf("YES\n");
        else printf("NO\n");


    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <string>
#include <string.h>
#include <map>
#include <set>
#include <queue>
#include <iomanip>
#include <vector>
using namespace std;

bool mat[200][200];

int main(){
    freopen("Ulaz.txt","w",stdout);

    srand((unsigned)time(0));
    int tests = 50;

    cout<<tests<<endl;

    while( tests -- ){
        memset( mat , 0 , sizeof(mat));
        int n = 1 + rand()%20;
        int m = 1 + rand()%((n*(n+1))>>1);

        cout<<n<<" "<<m<<endl;

        for( int i = 0; i < m; ++i ){
            int a,b;
            while(1){
                a = 1 + rand()%n;
                b = 1 + rand()%n;

                if( mat[a][b] ) continue;
                break;
            }

            cout<<a<<" "<<b<<endl;
            mat[a][b] = mat[b][a] = 1;

        }

        cout<<endl;
    }


    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <string>
#include <string.h>
#include <map>
#include <set>
#include <queue>
#include <iomanip>
#include <vector>
using namespace std;

int main(){
    for( int t = 1; ; ++t ){
        system("IM_MAKER.exe");
        system("IM_BRUTE.exe");
        system("IM.exe");

        if( system("diff -qb Izlaz.txt Izlaz2.txt") ){
            printf("WA on %d\n",t);
            while(1);
        }else{
            printf("AC on %d\n",t);
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <stack>
#include <string.h>
#include <string>
#include <iomanip>
#include <sstream>
using namespace std;

string line;

int main(){
    //freopen("Ulaz.txt","r",stdin);
  //  freopen("Izlaz.txt","w",stdout);

    while( cin.eof() == false ){
        getline(cin,line);
        if(line.size() == 0 )continue;

        stack<int>stk;
        stringstream in(line);
        bool ok = 1;

        while( in.eof() == false && ok ){
            int a; in >> a;
            if( a < 0 )stk.push( a );
            else{
                int sum = 0;
                while( stk.empty() == false && stk.top() != -a ){
                    sum += stk.top();
                    if( stk.top() < 0 ) ok = 0;
                    stk.pop();
                }
                if( stk.empty() == 1 ){
                    ok = false;
                    break;
                }
                stk.pop();
                stk.push(a);
                if( sum >= a ) ok = 0;
            }
        }
        if( stk.size() != 1 ) ok = 0;
        if( ok ) printf(":-) Matrioshka!\n");
        else printf(":-( Try again.\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <iomanip>
#include <assert.h>
#include <time.h>
#include <math.h>
#include <fstream>
using namespace std;

int n,m,k;
int ok[1000000 + 55];

int main(){
    scanf("%d%d%d",&n,&m,&k);

    int cnt = 0;
    memset( ok , -1, sizeof(ok));

    for( int i = 0; i < n; ++i ){
        int r,c; scanf("%d%d",&r,&c);
        if( ok[r] == -1 ){
            cnt += c;
            ok[r] = c;
        }else{
            cnt = cnt - ok[r] + min( ok[r] , c );
            ok[r] = min( ok[r] , c );
        }
    }

    printf("%d\n",min(cnt,k));

    return 0;
}

#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <string.h>
#include <cstdio>
using namespace std;

const int maxn = 2000 + 5;

int n;
int niz[maxn];

int dp_me[maxn][988];
int dp_he[maxn][988];
int ss[maxn];

int rsum( int l , int r ){
    int ret = ss[r];
    if( l ) ret -= ss[l-1];
    return ret;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ) scanf("%d",&niz[i]);
    for( int i = 0; i < n; ++i ){
        if( i ) ss[i] = ss[i-1];
        ss[i] += niz[i];
    }

    for( int i = n-1; i >= 0; --i ){
        for( int k = 1; k+i <= n && k <= 988; ++k ){
            int nxt = 2*k;
            int left = n - (i+k);
            if( nxt > left ) nxt = left;
            nxt = min( nxt , 988 );

            dp_me[i][k] = max( dp_me[i][k-1] , dp_he[i+k][ nxt ] + rsum( i , i + k - 1 )  );
            if( dp_me[i][k] == dp_me[i][k-1] ) dp_he[i][k] = dp_he[i][k-1];
            else dp_he[i][k] = dp_me[i+k][ nxt ];
        }
    }

    printf("%d\n",max( dp_me[0][1], dp_me[0][2] ) );


    return 0;
}

#include <iostream>
#include <fstream>
using namespace std;

int main(){
    srand((unsigned)time(0));
    freopen("Ulaz.txt","w",stdout);

    int n = 1000;
    cout<<n<<endl;
    for( int i = 0; i < n; ++i )
        cout<< 1 + rand()%1000 <<" "; cout<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <iomanip>
#include <assert.h>
#include <time.h>
#include <math.h>
#include <fstream>
using namespace std;

const int maxn = 100000 + 55;

int n;
char s[maxn] , t[maxn];
char sol[maxn];

int mat[300][300];



int main(){
  //  freopen("Ulaz.txt","r",stdin);
    scanf("%s%s",s,t);
    scanf("%d",&n);

    if( strlen(s) != strlen(t) ){
        printf("-1\n");
        return 0;
    }

    memset( mat, 1, sizeof(mat));
    int inf = mat[0][0];

    for( int i = 0; i < n; ++i ){
        char a,b; int c;
        cin >> a >> b >> c;
        mat[a][b] = min( mat[a][b] , c );
    }


    for( int i = 'a'; i <= 'z'; ++i )
        for( int j = 'a'; j <= 'z'; ++j )
            for( int k = 'a'; k <= 'z'; ++k ){
                if( mat[j][i] == inf || mat[i][k] == inf ) continue;
                mat[j][k] = min( mat[j][k] , mat[j][i] + mat[i][k] );
            }

    for( int i = 0; i < 300; ++i )
        mat[i][i] = 0;

    bool ok = 1;
    int ss = 0;
    memset( sol, -1, sizeof(sol));

    for( int i = 0; i < strlen(s); ++i ){
        char a = s[i];
        char b = t[i];
        if( a == b ){ sol[i] = a; continue; }

        char ch = -1;
        int now = inf;

        for( char k = 'a' ; k <= 'z'; ++k ){
            if( now > mat[a][k] + mat[b][k] ){
                now = mat[a][k] + mat[b][k];
                ch = k;
            }
        }
        ss += now;
        sol[i] = ch;
        if( sol[i] == -1 ) ok = 0;
    }

    sol[ strlen(s) ] = '\0';


    if( ok )printf("%d\n%s\n",ss,sol);
    else printf("-1\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <iomanip>
#include <assert.h>
#include <time.h>
#include <math.h>
#include <fstream>
using namespace std;

const int maxn = 100000 + 55;

int n;
int niz[maxn];
int R[maxn];

int sum = 0;

int main(){
    int tests;
    scanf("%d",&tests);
    while( tests -- ){ sum = 0;

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%d",&niz[i]);
        sum += niz[i];
    }

    int now = 0;
    R[n] = 0;

    for( int i = n-1; i >= 0; --i ){
        now += -2*niz[i];
        R[i] = max( R[i+1] , now );
    }

    int sol = max( sum , sum + R[0] );
    for( int i = 0; i < n; ++i ){
        sum += -2*niz[i];
        sol = max( sol , sum + R[i+1] );
    }

    printf("%d\n",sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <iomanip>
#include <set>
#include <queue>
#include <cstdio>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 1000 + 55;

struct scroll{
    int x;
    int pow,dmg;
    scroll(){};
    scroll( int p1, int p2 ):pow(p1),dmg(p2){};

    const bool operator<( const scroll &s ) const {
        return pow > s.pow;
    }
};

int n,hp,reg;
vector< scroll > w;

bool used[maxn];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d%d%d",&n,&hp,&reg);

    for( int i = 0; i < n; ++i ){
        int p,d; scanf("%d%d",&p,&d);
        w.push_back( scroll(p,d) );
        w[ w.size() - 1 ].x = i;
    }

    sort( w.begin() , w.end() );

    int now = hp;
    int dead = -1;

    vector< pii > mov;

    for( int i = 0; i < 1050000; ++i ){
        double hpp = (now*100) / (double)hp;

        int cx = -1;

        for( int dx = 0; dx < w.size(); ++dx ){
            if( used[dx] ) continue;

            if( hpp <= w[dx].pow ){
                if( cx == -1 ) cx = dx;
                else if( w[dx].dmg > w[cx].dmg ) cx = dx;
            }
        }

        if( cx == -1 && reg >= 0 ){
            printf("NO\n");
            return 0;
        }

        if( cx != -1 ){
            reg -= w[cx].dmg;
            mov.push_back( mk( i , w[cx].x ) );
            used[cx] = 1;
        }

        now = min( hp , now+reg);
        if( now <= 0 ){ dead = i; break; }
    }

    if( now <= 0 ){
        printf("YES\n");
        printf("%d %d\n",dead+1,mov.size());
        for( int i = 0; i < mov.size(); ++i )
            printf("%d %d\n",mov[i].f, mov[i].s+1 );
    }else
        printf("NO\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <string>
#include <string.h>
#include <fstream>
using namespace std;

string txt;
int cnt[500];

int c[100000*3];

int main(){
   // freopen("Ulaz.txt","r",stdin);

    while( cin.eof() == false ){

        memset( cnt , 0 , sizeof(cnt));
        memset( c , 0 , sizeof(c));
        getline(cin,txt);
        if( txt.size() == 0 ) break;

        for( int i = 0; i < txt.size(); ++i ){
            if( txt[i] >= 'A' && txt[i] <= 'Z' ) txt[i] = (txt[i]-'A') + 'a';

            if( txt[i] >= 'a' && txt[i] <= 'z' )
                cnt[ txt[i] ]++;
        }

        bool one = 1;
        bool ok = 1;

        vector< int > w;

        for( int i = 0; i < 255; ++i ){
            if( cnt[i] == 0 ) continue;

            if( one && cnt[i]%2 ) one = 0, cnt[i] --;
            else if( cnt[i]%2 ) ok = 0;

            if( cnt[i] == 0 ) continue;

            w.push_back( cnt[i] / 2 );
        }

        if( !ok ){
            printf("0\n");
            continue;
        }

        if( w.size() == 0 ){
            printf("1\n");
            continue;
        }

        int sum = 0;
        sort( w.rbegin(), w.rend() );
        for( int i = 0; i < w.size(); ++i ) sum += w[i];

        unsigned long long sol = 1;

        vector< int > hi,lo;

        for( int i = 2; i <= sum; ++i ){
            int w = i;
            for( int i = 2; i*i <= w; ++i ){
                while( w % i == 0 ){
                    hi.push_back( i );
                    w /= i;
                }
            }
            if( w > 1 ) hi.push_back( w );
        }

        for( int i = 0; i < w.size(); ++i ){
            for( int k = 1; k <= w[i]; ++k ){
                int m = k;
                for( int i = 2; i*i <= m; ++i ){
                    while( m % i == 0 ){
                        lo.push_back( i );
                        m /= i;
                    }
                }
                if( m > 1 ) lo.push_back( m );
            }
        }

        for( int i = 0; i < hi.size(); ++i ) c[ hi[i] ]++;
        for( int i = 0; i < lo.size(); ++i ) c[ lo[i] ]--;

        sol = 1;
        for( int i = 2; i <= 100000; ++i )
            for( int k = 0; k < c[i]; ++k )
                sol *= i;

        for( int i = 2; i <= 100000; ++i )
            for( int k = 0; k < -c[i]; ++k )
                sol /= i;

        cout<<sol<<endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <string>
#include <string.h>
#include <fstream>
using namespace std;

int letters,alphas;
int terminator;
int freq[26];

void read_input(){
    int c;

    for(c=0;c<26;++c)freq[c]=0;
    letters=alphas=0;
    while(((c=getchar())!='\n')&&(c!=EOF)){
        letters++;
        if(isalpha(c)){
            alphas++;
            freq[toupper(c)-'A']++;
        }
    }
    terminator = c;
}

int gcd( int a,int b){
    if( b>a)return gcd(b,a);
    if(b==0)return a;
    return gcd(b,a%b);
}

long long count_ways(){
    int c,i,ii,j,g;
    int odds,odd;
    int maxfreq,maxoccur;
    int factor[1000],factors;
    long long result;

    for(odds=0,c=0;c<26;c++) if( freq[c]%2 ){ odds++;odd=c; }
    if(odds>1)return 0;
    if(odds){ freq[odd]--; alphas--;}
    if(alphas==0)return 1;
    for(c=0;c<26;c++)freq[c] /= 2;
    alphas /= 2;
    for( maxfreq=0,c=0;c<26;c++) if(freq[c]>maxfreq){ maxfreq=freq[c]; maxoccur=c;}
    for(factors=0,i=maxfreq+1;i<=alphas;++i) factor[factors++] = i;

    freq[maxoccur] = 0;
    for(c=0;c<26;c++){
        for(i=2;i<=freq[c];++i){
            ii=i;
            for(j=0;ii>1;j++)if((g=gcd(factor[j],ii))>1){
                factor[j] /= g;
                ii /= g;
            }
        }
    }
    result = 1;
    for( j = 0; j < factors;++j) result *= factor[j];
    return result;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    do{
        read_input();
        if((letters==0)&&(terminator==EOF))break;
        printf("%lld\n",count_ways());
    }while(terminator!=EOF);
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <queue>
#include <vector>
#include <string>
#include <string.h>
#include <map>
using namespace std;

#define pii pair<int,int>
#define mk make_pair
#define f first
#define s second

const int maxn = 100000*2 + 155;


int n;
int id[maxn];
int x1[maxn], y1[maxn], x2[maxn], y2[maxn];

pii coord[maxn];

vector< int > g[maxn];

int sol;

int visi[maxn];

int v,e;
map<int,int>M[maxn];

void dfs( int node ){
    visi[node] ++;
    v++;
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( M[node][nxt] == 0 ){
            e++;
            M[node][nxt] = M[nxt][node] = 1;
        }
        if( visi[nxt]  ) continue;

        dfs( nxt );
    }
    visi[node] ++;
}

struct dis_set{
    vector< int > sz;
    vector< int > id;

    void init( int n ){
        n += 55;
        sz.resize(n);
        id.resize(n);

        for( int i = 0; i < n; ++i ) sz[i] = 1 ,  id[i] = i;
    }

    dis_set(){};
    dis_set( int n ){ init(n); }

    int get_root( int x ){
        if( x == id[x] ) return x;
        return id[x] = get_root( id[x] );
    }

    int subtree_sz( int x ){
        return sz[ get_root(x) ];
    }

    bool merge( int a, int b ){
        int x = get_root( a ) , y = get_root( b );
        if( x == y ) return 1;

        if( sz[x] < sz[y] ) id[x] = y , sz[y] += sz[x];
        else id[y] = x , sz[x] += sz[y];

        return 0;
    }
};


int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);

    while( scanf("%d",&n) == 1 ){
        if( n == -1 ) break;
        dis_set join(n*2);

        sol = 0;
        for( int i = 0; i <= (n<<1); ++i ) g[i].clear() , visi[i] = 0, M[i].clear();

        vector< pii > srt;

        for( int i = 0; i < n; ++i ){
            scanf("%d%d%d%d",&x1[i],&y1[i],&x2[i],&y2[i]);

            coord[i<<1] = mk( x1[i], y1[i] );
            coord[(i<<1)|1] = mk( x2[i], y2[i] );

            srt.push_back( mk(x1[i], y1[i] ) );
            srt.push_back( mk(x2[i], y2[i] ) );
        }

        sort( srt.begin(), srt.end() );

        for( int i = 0; i < (n<<1); ++i )
            id[i] = lower_bound( srt.begin(), srt.end(), coord[i] ) - srt.begin();

        for( int i = 0; i < n; ++i ){
            int x = i<<1;
            int y = (i<<1)|1;
            x = id[x] , y = id[y];
            //g[ id[x] ].push_back( id[y] );
            //g[ id[y] ].push_back( id[x] );

            sol += join.merge(x,y);
        }

//        for( int i = 0; i < (n<<1); ++i ){
//            if( visi[i] ) continue;
//            v = e = 0;
//            dfs( i );
//            int f = 1 - v + e;
//            sol += f;
//        }

        printf("%d\n",sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <queue>
#include <vector>
#include <string>
#include <string.h>
#include <map>
using namespace std;

#define pii pair<int,int>
#define mk make_pair
#define f first
#define s second

const int maxn = 100000*2 + 155;


int n;
int id[maxn];
int x1[maxn], y1[maxn], x2[maxn], y2[maxn];

pii coord[maxn];

vector< int > g[maxn];

int sol;

int visi[maxn];

int v,e;
map<int,int>M[maxn];

void dfs( int node ){
    visi[node] ++;
    v++;
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( M[node][nxt] == 0 ){
            e++;
            M[node][nxt] = M[nxt][node] = 1;
        }
        if( visi[nxt]  ) continue;

        dfs( nxt );
    }
    visi[node] ++;
}

struct dis_set{
    vector< int > sz;
    vector< int > id;

    void init( int n ){
        n += 55;
        sz.resize(n);
        id.resize(n);

        for( int i = 0; i < n; ++i ) sz[i] = 1 ,  id[i] = i;
    }

    dis_set(){};
    dis_set( int n ){ init(n); }

    int get_root( int x ){
        if( x == id[x] ) return x;
        return id[x] = get_root( id[x] );
    }

    int subtree_sz( int x ){
        return sz[ get_root(x) ];
    }

    bool merge( int a, int b ){
        int x = get_root( a ) , y = get_root( b );
        if( x == y ) return 1;

        if( sz[x] < sz[y] ) id[x] = y , sz[y] += sz[x];
        else id[y] = x , sz[x] += sz[y];

        return 0;
    }
};


int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    while( scanf("%d",&n) == 1 ){
        if( n == -1 ) break;
        dis_set join(n*2);

        sol = 0;
        for( int i = 0; i <= (n<<1); ++i ) g[i].clear() , visi[i] = 0, M[i].clear();

        vector< pii > srt;

        for( int i = 0; i < n; ++i ){
            scanf("%d%d%d%d",&x1[i],&y1[i],&x2[i],&y2[i]);

            coord[i<<1] = mk( x1[i], y1[i] );
            coord[(i<<1)|1] = mk( x2[i], y2[i] );

            srt.push_back( mk(x1[i], y1[i] ) );
            srt.push_back( mk(x2[i], y2[i] ) );
        }

        sort( srt.begin(), srt.end() );

        for( int i = 0; i < (n<<1); ++i )
            id[i] = lower_bound( srt.begin(), srt.end(), coord[i] ) - srt.begin();

        for( int i = 0; i < n; ++i ){
            int x = i<<1;
            int y = (i<<1)|1;
            //x = id[x] , y = id[y];
            g[ id[x] ].push_back( id[y] );
            g[ id[y] ].push_back( id[x] );

          //  sol += join.merge(x,y);
        }

        for( int i = 0; i < (n<<1); ++i ){
            if( visi[i] ) continue;
            v = e = 0;
            dfs( i );
            int f = 1 - v + e;
            sol += f;
        }

        printf("%d\n",sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <iomanip>
using namespace std;

const int range = 10;

struct coord{
    int x,y;
    coord(){};
    coord( int p1, int p2 ):x(p1),y(p2){};

    bool operator==( const coord &c2 ) const {
        return x == c2.x && y == c2.y;
    }
};

coord a,b,c,d;

int cross( coord null, coord a , coord b ){
    return (a.x-null.x)*(b.y-null.y) - (b.x-null.x)*(a.y-null.y);
}

int online( coord a , coord b , coord c ){
    return ( min(a.x,b.x) <= c.x && c.x <= max(a.x,b.x) &&
             min(a.y,b.y) <= c.y && c.y <= max(a.y,b.y) );
}

bool sect( coord a, coord b, coord c, coord d ){
    if( a == c && b == d || a == d && b == c ) return 1;
    if( a == c || a == d || b == c || b == d ) return 0;

    int s1 = cross( a , b , c );
    int s2 = cross( a , b , d );
    int s3 = cross( c , d , a );
    int s4 = cross( c , d , b );

    if( ((s1<0 && s2>0)||(s1>0 && s2<0)) && ((s3<0 && s4>0)||(s3>0 && s4<0)) ) return 1;
    else if( s1 == 0 && online(a,b,c) ) return 1;
    else if( s2 == 0 && online(a,b,d) ) return 1;
    else if( s3 == 0 && online(c,d,a) ) return 1;
    else if( s4 == 0 && online(c,d,b) ) return 1;

    return 0;
}

coord A[100], B[100];

int main(){


    srand((unsigned)time(0));
    freopen("Ulaz.txt","w",stdout);

    int tests = 1;
    int n = 1 + rand()%100;

    cout<<n<<endl;

    for( int i = 0; i < n; ++i ){
        int x1,y1,x2,y2;
        while(1){
            x1 = 1 + rand()%range;
            x2 = 1 + rand()%range;
            y1 = 1 + rand()%range;
            y2 = 1 + rand()%range;

            if( x1 == x2 && y1 == y2 ) continue;

            bool ok = 1;
            for( int k = 0; k < i && ok; ++k ){
                if( sect( A[k], B[k], coord(x1,y1) , coord(x2,y2)) ) ok = 0;
            }
            if( !ok ) continue;
            break;
        }
        A[i] = coord(x1,y1);
        B[i] = coord(x2,y2);

        printf("%d %d %d %d\n",x1,y1,x2,y2);
    }
    cout<<-1<<endl;


    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <iomanip>
using namespace std;

int main(){
    for( int t = 1; ; t ++ ){
        system("JARA_MAKER.exe");
        system("JARA.exe");
        system("JARA_EULER.exe");

        if( system("diff -qb Izlaz.txt Izlaz2.txt") ){
            printf("WA %d\n",t);
            while(1);
        }else{
            printf("AC %d\n",t);
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <string.h>
#include <string>
#include <algorithm>
using namespace std;

typedef long long ll;

int bip[1<<15];
int n,m,k;
char mat[20][20];

ll dp[20][1<<13];

ll solve( int dx, int mask ){
    if( dx == n ) return bip[mask] == k;

    ll &sol = dp[dx][mask];
    if( sol != -1 ) return sol;

    sol = solve( dx + 1 , mask );

    for( int i = 0; i < m; ++i ){
        if( mask&(1<<i) || mat[dx][i] == '0' ) continue;
        sol += solve( dx + 1 , mask | ( 1 << i ) );
    }
    return sol;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    for( int i = 0; i < (1<<14); ++i ) bip[i] = __builtin_popcount(i);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d%d",&n,&m,&k);

        for( int i = 0; i < n; ++i ){
            scanf("%s",mat[i]);
            for( int j = 0; j < (1<<m); ++j )
                dp[i][j] = -1;
        }

        ll sol = solve( 0 , 0 );
        printf("%lld\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <iomanip>
#include <assert.h>
#include <time.h>
#include <math.h>
#include <fstream>
using namespace std;

typedef long long ll;

struct coord{
    ll x,y;
    coord(){};
    coord( ll p1, ll p2 ):x(p1),y(p2){};
};

int n,m,k;
int mat[1005][1005];
coord control[1005];

int r[1005];
coord c[1005];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d%d",&n,&m,&k);

    for( int i = 0; i < n; ++i ){
        int x,y; scanf("%d%d",&x,&y);
        control[i] = coord(x,y);
    }

    for( int i = 0; i < m; ++i ){
        int x,y;
        scanf("%d%d%d",&r[i],&x,&y);
        c[i] = coord(x,y);
    }

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < m; ++j ){
            ll dist = (control[i].x-c[j].x)*(ll)(control[i].x-c[j].x) + (control[i].y-c[j].y)*(ll)(control[i].y-c[j].y);
            ll allow = r[j]* (ll)r[j];
            if( dist <= allow )
                mat[i][j] = 1;
        }
    }

    for( int i = 0; i < k; ++i ){
        int a,b; scanf("%d%d",&a,&b); a--,b--;
        int sol = 0;
        for( int j = 0; j < m; ++j )
            if( mat[a][j] + mat[b][j] == 1 ) sol ++;
        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <stack>
#include <map>
#include <iomanip>
#include <string>
#include <string.h>
#include <cstdio>
#include <sstream>
using namespace std;

string txt;

int main(){
    freopen("fontovi.in","r",stdin);
    freopen("fontovi.out","w",stdout);
    string in1,in2;

    getline( cin , txt );
    getline( cin , in1 );
    getline( cin , in2 );

    vector< int > up,low;

    stringstream s1(in1);
    stringstream s2(in2);

    while( s1.eof() == false ){
        int v;
        s1 >> v;
        up.push_back(v);
    }

    while( s2.eof() == false ){
        int v;
        s2 >> v;
        low.push_back(v);
    }

    int sol = 0;

    for( int i = 0; i < txt.size(); ++i ){
        if( txt[i] >= 'A' && txt[i] <= 'Z' )
            sol += up[ txt[i] - 'A' ];
        if( txt[i] >= 'a' && txt[i] <= 'z' )
            sol += low[ txt[i] - 'a'];
        if( txt[i] == ' ' ) sol += 3;
    }

    cout<<sol + txt.size()-1<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <cstdio>
#include <vector>
#include <set>
#include <iomanip>
#include <math.h>
#include <sstream>
using namespace std;

typedef long long ll;

const int maxn = 100000;

int m,n;
int niz[maxn];
ll ss[maxn];

int main(){
  //  freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&m,&n);

    for( int i = 0; i < n; ++i ) scanf("%d",&niz[i]);
    sort( niz , niz + n );
    reverse( niz , niz + n );

    niz[n] = 0;

    for( int i = 0; i <= n; ++i ){
        if( i ) ss[i] = ss[i-1];
        ss[i] += niz[i];
    }

    int dx;
    for( int i = 0; i <= n; ++i ){
        ll rez = ss[i] - (i+1) * (ll)niz[i];

        if( rez > m ) break;
        else dx = i;
    }

    for( int i = 0; i < dx; ++i ){
        m -= niz[i] - niz[dx];
        niz[i] = niz[dx];
    }

    int w = dx + 1;
    int stp = m / w;

    if( stp ) for( int i = 0; i <= dx; ++i ) niz[i] -= stp;

    m = m % w;
    for( int i = 0; i <= dx && m; ++i ) niz[i] -- , m --;

    ll sol = 0;
    for( int i = 0; i < n; ++i ) sol += niz[i] * (ll)niz[i];

    cout<< sol << endl;

    return 0;
}


















#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <stack>
#include <map>
#include <iomanip>
#include <string>
#include <string.h>
#include <cstdio>
using namespace std;

const int inf = 999999999;
const int maxn = 1000000 + 55;

int n;
int niz[maxn];
int dp[maxn];

int main(){
    freopen("muznja.in","r",stdin);
    freopen("muznja.out","w",stdout);

    scanf("%d",&n);

    int maxx = -1, minn = inf;

    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        niz[a] ++;
        niz[b] --;
        maxx = max( maxx , b );
        minn = min( minn , a );
    }

    int e = -1 , f = -1;
    int empty = 0 , full = 0;

    for( int i = minn; i < maxx; ++i ){
        if( i ) dp[i] = dp[i-1];
        dp[i] += niz[i];

        if( dp[i] == 0 ){
            f = -1;
            if( e == -1 ) e = i;
            empty = max(empty,i-e+1);
        }else if( dp[i] != 0 ){
            e = -1;
            if( f == -1 ) f = i;
            full = max( full , i-f+1 );
        }
    }

    printf("%d %d\n",full,empty);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <iomanip>
#include <set>
#include <queue>
#include <cstdio>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

struct node{
    bool was;
    node *l , *r;
    node(){ l = r = NULL; was = 0; };
};

int n;
vector< pii > word;

node *tree;
bool done;
string ss;

bool nothing[1005];

void insert( node *n , int sz , string mov , bool ok , int stp ){
    if( n->was ) return;

    if( sz == 0 ){
        n->was = 1;
        done = 1; ss = mov;
        return;
    }

    if( n->l == NULL ) n->l = new node();
    if( n->r == NULL ) n->r = new node();

    if( !done ) insert( n->r , sz - 1 , mov + "0", ok , stp + 1);
    if( !done ) insert( n->l , sz - 1 , mov + "1", ok , stp + 1);
}

string sol[1005];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
    tree = new node( );
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        int a; scanf("%d",&a);
        nothing[a] = 1;
        word.push_back( mk(a,i) );
    }

    sort( word.begin() , word.end() );

    for( int i = 0; i < n; ++i ){
        done = 0;
        insert( tree , word[i].f , "" , 0 , 0 );
        sol[ word[i].s ] = ss;
        if( !done ){
            printf("NO\n");
            return 0;
        }
    }

    printf("YES\n");
    for( int i = 0; i < n; ++i )
        cout<<sol[i]<<endl;

    return 0;
}

#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <math.h>
#include <vector>
#include <string.h>
#include <string>
#include <cstdio>
using namespace std;

vector< int > pages;

int main(){
   // freopen("Ulaz.txt","r",stdin);
    char c;
    int w = 0;
    while( (c=getchar()) != EOF ){
        if( c >= '0' && c <= '9' )
            w = w*10 + c - '0';
        else{
            if( w != 0 ) pages.push_back( w );
            w = 0;
        }
    }
    if( w != 0 ) pages.push_back( w );

    sort( pages.begin() , pages.end() );
    pages.erase( unique(pages.begin(),pages.end()),pages.end());

    int n = pages.size();

    for( int i = 0; i < n; ++i ){
        int k = i+1;
        while( k < n && pages[k-1] == pages[k] - 1 ) k ++;
        if( i != k-1 )printf("%d-%d",pages[i],pages[k-1]);
        else printf("%d",pages[i]);
        if( k != n )printf(",");
        i = k-1;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <stack>
#include <map>
#include <iomanip>
#include <string>
#include <string.h>
#include <cstdio>
#include <sstream>
#include <set>
using namespace std;

#define pii pair<int,int>
#define x first
#define y second
#define mk make_pair

double eps = 1e-20;

vector< pii > w;

int main(){
    freopen("prava.in","r",stdin);
    freopen("prava.out","w",stdout);
    int n; //scanf("%d",&n);

    n = 1000;

    for( int i = 0; i < n; ++i ){
        int a,b; //scanf("%d%d",&a,&b);
        a =  1+ rand()%1000;
        b = 1 + rand()%1000;
        w.push_back( mk(a,b) );
    }

    int sol = 0;
    double sol_k = -1, sol_m = -1;

    for( int i = 0; i < n; ++i ){
        multiset< double > ks;
        for( int j = i+1; j < n; ++j ){
            if( w[j].x == w[i].x || w[j].y == w[i].y ) continue;
            double k = (w[i].y - w[j].y) / (double)(w[i].x - w[j].x);
            ks.insert( k );
        }

        for( multiset<double>::iterator it = ks.begin(); it != ks.end(); ++it ){
            int cnt = ks.count( *it ) + 1;

            if( sol < cnt ){
                sol = cnt;
                sol_k = *it;
                sol_m = w[i].y - sol_k * w[i].x;
            }else if( sol == cnt ){
                double a = fabs( sol_k );
                double b = fabs( *it );
                double m = w[i].y - (*it) * w[i].x;
                if( b - a > eps ) continue;
                if( fabs(a-b) < eps && fabs(m) > fabs(sol_m) ) continue;

                sol_k = *it;
                sol_m = m;
            }
        }
    }

    printf("%.3lf %.3lf\n",sol_k,sol_m);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <cstdio>
#include <vector>
#include <set>
#include <iomanip>
#include <math.h>
#include <sstream>
using namespace std;

const int maxn = 100000 + 55;

int n;
int a[maxn][2];

int main(){
    scanf("%d",&n);

    for( int i = 0; i < n; ++i )
        scanf("%d%d",&a[i][0],&a[i][1]);


    int grade = 999999;
    int sol = 0;

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < 2; ++j ){
            if( a[i][j] != -1 ){
                int r = i , c = a[i][j];
                while(1){
                    r++;
                    if( a[r][0] != c && a[r][1] != c ) break;

                    if( a[r][0] == c ) a[r][0] = -1;
                    if( a[r][1] == c ) a[r][1] = -1;
                }

                if( sol < r - i ) sol = r - i, grade = c;
                else if( sol == r - i ) grade = min( grade,c);
            }
        }
    }

    printf("%d %d\n",sol,grade);

    return 0;
}

#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <math.h>
using namespace std;

int n;
int niz[105];

int main(){

    cin >> n;
    for( int i = 1; i <= n; ++i ) cin >> niz[i];

    int sol = abs( niz[1] - niz[n]);
    int a = 1 , b = n;

    for( int i = 1; i < n; ++i ){
        int diff = abs(niz[i] - niz[i+1]);
        if( diff < sol ){
            sol = diff;
            a = i , b = i+1;
        }
    }

    cout<<a<<" "<<b<<endl;

    return 0;
}

#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <math.h>
#include <vector>
#include <string.h>
#include <string>
#include <cstdio>
using namespace std;

const int maxn = 5 * 10000 + 555;

int n,r1,r2;
vector< int > g[maxn];
vector< int > order[maxn];

int sols[maxn];

int dfs( int node, int dad ){
    sols[node] = dad;
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( nxt == dad ) continue;
        dfs( nxt , node );
    }
}

int main(){
    scanf("%d%d%d",&n,&r1,&r2);

    for( int i = 1; i <= n; ++i ){
        if( i == r1 ) continue;
        int p; scanf("%d",&p);
        g[p].push_back(i);
        g[i].push_back(p);
    }

    dfs( r2 , -1 );

    for( int i = 1; i <= n; ++i ){
        if( i == r2 ) continue;
        printf("%d ",sols[i]);
    }

    return 0;
}

#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <math.h>
using namespace std;

int n,m;
int niz[1005];


int main(){
    cin >> n >> m;
    for( int i = 0; i < n; ++i ) cin >> niz[i];
    sort( niz , niz + n );

    int cnt = 0, sol = 0;
    for( int i = 0; i < n && cnt < m; ++i ){
        if( niz[i] < 0 ){
            sol += -niz[i];
            cnt++;
        }
    }

    cout<< sol << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <cstdio>
#include <vector>
#include <set>
#include <iomanip>
#include <math.h>
#include <sstream>
using namespace std;

int n;
int niz[100];

int main(){
    scanf("%d",&n);

    int now = 1;
    int cnt = 0;
    int len = 0;
    while( cnt + now <= n ){
        cnt += now;
        now *= 2;
        len ++;
    }

    n -= cnt;
    memset( niz , 0 , sizeof(niz));

    int pos = 0;

    while( n > 0 ){
        pos++;
        if( n % 2 == 0 );
        else niz[len-pos] = 1, n--;
        n /= 2;
    }

    for( int i = 0; i < len; ++i ){
        if( niz[i] == 0 ) printf("4");
        else printf("7");
    } printf("\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <cstdio>
#include <vector>
#include <set>
#include <iomanip>
#include <math.h>
#include <sstream>
using namespace std;

const int maxn = 1000 + 55;
const int inf = 999999;

int n;
int target[maxn];
int begin[maxn];

int sol = 0;

void mov( int lo , int hi , int add ){
    while(1){
        bool ok = 1;
        for( int i = lo; i <= hi; ++i ) if( target[i] != 0 ) ok = 0;
        if( ok ) break;

        for( int i = lo; i <= hi; ++i ){
            if( target[i] == 0 ) continue;
            while( target[i] != 0 && i <= hi ){
                target[i] += add;
                i++;
            }
            sol++;
        }
    }
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ) scanf("%d",&begin[i]);
    for( int i = 0; i < n; ++i ) scanf("%d",&target[i]);

    for( int i = 0; i < n; ++i ) target[i] -= begin[i];

    int state = target[0] > 0;
    int dx = 0;


    for( int i = 1; i < n; ++i ){
        if( target[i] < 0 ){
            if( state == 1 ) mov( dx , i-1 , -1 ) , dx = i;
            state = 0;
        }else{
            if( state == 0 ) mov( dx , i-1 , +1 ) , dx = i;
            state = 1;
        }
    }

    if( state ) mov( dx , n-1 , -1 );
    else mov( dx , n-1, 1 );

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <string>
#include <string.h>
#include <set>
#include <vector>
#include <map>
#include <iomanip>
using namespace std;

const int maxn = 1000 + 55;
const int inf = 999999;

int n;
int begin[maxn];
int target[maxn];

int dp[maxn][180];
int mini[maxn][maxn];

int solve( int dx , int add ){
    if( add < -85 || add > 85 ) return inf;

    if( dx == 0 ){
        if( target[dx] <= begin[dx] + add && begin[dx] <= target[dx] ) return 0;
        if( begin[dx]+add <= target[dx] && begin[dx] >= target[dx] ) return 0;

        if( target[dx] > begin[dx] ) return target[dx] - begin[dx] - max(0,add);
        else return begin[dx] - target[dx] - max(0,-add);
    }

    int &sol = dp[dx][add+80];
    if( sol != -1 ) return sol;

    sol = inf;
    sol = min( solve( dx , add + 1 ) + (add<0?0:1), solve( dx , add - 1 ) + (add>0?0:1) );

    for( int i = 0; i < dx; ++i ){
        bool ok = 1;
        for( int k = i+1; k <= dx && ok; ++k ) if( begin[k] + add != target[k] ) ok = 0;
        if( !ok ) continue;

        sol = min( sol, solve( i , add ) );
    }
    return sol;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz2.txt","w",stdout);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ) scanf("%d",&begin[i]);
    for( int i = 0; i < n; ++i ) scanf("%d",&target[i]);

    for( int i = 0; i < n; ++i ){
        int now = begin[i];
        for( int j = i; j < n; ++j ){
            now = min( now , begin[i] );
            mini[i][j] = now;
        }
    }

    memset( dp, -1, sizeof(dp));
    int sol = solve( n-1 , 0 );

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <cstdio>
#include <vector>
#include <set>
#include <iomanip>
#include <math.h>
#include <sstream>
using namespace std;

int main(){
    int f,m,k;
    cin >> f >> m >> k;

    int teams = min( f / 2 , m );

    int ostalo = f + m - teams * 2 - teams;
    k -= ostalo;

    while( k > 0 ){
        k -= 3;
        teams --;
    }

    printf("%d\n",teams);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <iomanip>
#include <set>
#include <queue>
#include <cstdio>
using namespace std;

int hash[10005];

int main(){
    int n;
    cin >> n;
    int sol = 0;
    int mx = 0;

    for( int i = 0; i < n; ++i ){
        int a; scanf("%d",&a);
        sol += hash[a] == 0;
        hash[a] ++;
        mx = max( mx , hash[a] );
    }

    printf("%d %d\n",mx,sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <algorithm>
#include <map>
#include <iomanip>
#include <queue>
#include <math.h>
using namespace std;

int d[][2] = { {-2,-1} , {-2,1} , {-1,-2} , {-1,2} , {1,-2} , {1,2} , {2,-1} , {2,1} };

string fname( int c, int r ){
    return string(1,'A'+c) + string(1,'1'+r);
}

int n,m;
int cnt = 0;
int tovisit = 0;
bool ok[30][30];

string sol = "";

void solve( int c, int r , string mov ){
    if( cnt == tovisit ){
        sol = mov;
        cout<<sol<<endl;
        return;
    }

    for( int i = 0; i < 8 && sol == ""; ++i ){
        int x = c + d[i][0];
        int y = r + d[i][1];
        if( x >= m || x < 0 || y >= n || y < 0 || ok[x][y] ) continue;
        ok[x][y] = 1, cnt++;
        solve( x , y , mov + fname(x,y) );
        ok[x][y] = 0, cnt--;
    }

}

int main(){
    int tests;
    scanf("%d",&tests);

    while( tests -- ){
        scanf("%d%d",&n,&m);
        tovisit = n*m;
        sol = "";

        for( int i = 0; i < m && sol == ""; ++i )
            for( int j = 0; j < n && sol == ""; ++j ){
                ok[i][j] = 1;
                cnt = 1;
                solve( i , j , fname(i,j) );
                ok[i][j] = 0;
            }
        if( sol == "" ) cout<<"-1"<<endl;

    }
    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <string.h>
#include <queue>
#include <map>
#include <math.h>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 2000000 + 55;
const int prime = 9883;

int n;
int len[maxn];
int stp[maxn];
char *txt[maxn];

int mem[maxn];

const int maxlen = 2000005;

map<int,int> fix [maxlen];

void insert_even(){
    for( int i = 0; i < n; ++i ){
        int len = strlen(txt[i]); mem[len] = 0;
        for( int k = len-1; k >= 0; --k ) mem[k] = mem[k+1]*prime + txt[i][k];

        fix[ len ][ mem[0] ] ++;
        int key1 = txt[i][0], key2 = txt[i][1];
        if( key1 == key2 ) fix[ len - 2 ][ mem[2] ];

        for( int k = 1; 2*k+1 < len; ++k ){
            key1 += txt[i][k]*stp[k];

            key2 -= txt[i][k]*stp[k-1];
            key2 *= prime*prime;
            key2 += txt[i][2*k]*prime;
            key2 += txt[i][2*k+1];

            if( key1 == key2 ) fix[ len - (k+1)*2 ][ mem[2*k+2] ]++;
        }
    }
}

void insert_odd(){
    for( int i = 0; i < n; ++i ){
        int len = strlen(txt[i]); mem[len] = 0;
        for( int k = len-1; k >= 0; --k ) mem[k] = mem[k+1]*prime + txt[i][k];

        int key1 = txt[i][0], key2 = txt[i][0];
        if( key1 == key2 ) fix[ len - 1 ][ mem[1] ]++;

        for( int k = 1; 2*k < len; ++k ){
            key1 += txt[i][k]*stp[k];

            key2 -= txt[i][k-1]*stp[k-1];
            key2 *= prime*prime;
            key2 += txt[i][2*k-1]*prime;
            key2 += txt[i][2*k];

            if( key1 == key2 ) fix[ len - 2*k-1 ][ mem[2*k+1] ]++;
        }
    }
}


int main(){
    freopen("Ulaz.txt","r",stdin);
    stp[0] = 1;
    for( int i = 1; i < maxn; ++i ) stp[i] = stp[i-1] * prime;

    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        scanf("%d",&len[i]);
        txt[i]  = new char[ len[i] ];
        scanf("%s",txt[i]);
    }

    insert_even();
    insert_odd();

    int sol = 0;
    for( int i = 0; i < n; ++i ){
        int key = 0;
        int len = strlen( txt[i] );
        for( int k = 0; k < len; ++k ) key = key * prime + txt[i][k];
        sol += fix[ len ][ key ];
        cout<<txt[i]<<" = "<<sol<<endl;
    }



    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <string.h>
#include <queue>
#include <map>
#include <math.h>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

const int maxn = 2000000 + 55;
const int prime = 1000000007;

int n;
char *txt[maxn];

int mem1[maxn];
int mem2[maxn];
ll sol = 0;

struct node{
    node *nxt[26];
    int visi;
    node(){
        for( int i = 0; i < 26; ++i ) nxt[i] = NULL;
        visi = 0;
    }
};

node *insert( node *n , char *str , int len ){
    for( int i = 0; i < len; ++i ){
        if( n->nxt[ str[i]-'a' ] == NULL ) n->nxt[ str[i]-'a' ] = new node();
        n = n->nxt[ str[i]-'a' ];
    }
    n->visi++;
}

node tree;

void insert_even(){
    for( int i = 0; i < n; ++i ){
        int ln = strlen( txt[i] );
        int mul = prime;
        mem1[0] = mem2[0] = txt[i][0];
        for( int k = 1; k < ln; ++k ){
            mem1[k] = mem1[k-1]*prime + txt[i][k];
            mem2[k] = mem2[k-1] + txt[i][k]*mul , mul *= prime;
        }

        node *now = &tree;
        for( int k = ln-1; k >= 0; --k ){
            if( mem1[k] == mem2[k] ) sol += now->visi;
            now = now->nxt[ txt[i][k]-'a'];
        }
    }
}

void calc_even(){
    for( int i = 0; i < n; ++i ){
        int ln = strlen(txt[i]);
        int mul = 1;
        mem1[ ln ] = mem2[ln] = 0;
        for( int k = ln-1; k >= 0; --k ){
            mem1[k] = mem1[k+1]*prime + txt[i][k];
            mem2[k] = mem2[k+1] + txt[i][k]*mul , mul *= prime;
        }

        node *now = &tree;
        for( int k = 0; k < ln; ++k ){
            if( mem1[k] == mem2[k] ) sol += 2*now->visi;
            now = now->nxt[ txt[i][k]-'a'];
        }
        sol += now->visi;
    }
}

int main(){
  //  freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);

    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        int L;scanf("%d",&L);
        txt[i]  = new char[ L + 5 ];
        scanf("%s",txt[i]);

        insert( &tree , txt[i] , L );
    }

    //insert_even();
    calc_even();
    printf("%lld\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <string.h>
#include <queue>
#include <map>
#include <math.h>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

int n;
int len[500000];
char *txt[500000];

char wstr[100000];

int main(){
    freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        scanf("%d",&len[i]);
        txt[i]  = new char[ len[i] + 5 ];
        scanf("%s",txt[i]);
    }

    int sol = 0;

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < n; ++j ){

            for( int k = 0; k < len[i]; ++k ) wstr[k] = txt[i][k];
            for( int k = 0; k < len[j]; ++k ) wstr[ len[i] + k ] = txt[j][k];

            bool ok = 1;
            int ln = len[i] + len[j];
            for( int k = 0; k < ln && ok; ++k )
                if( wstr[k] != wstr[ln-k-1] ) ok = 0;

            if( ok ){
                cout<<i<<","<<j<<" = "; for( int k = 0; k < len[i]+len[j]; ++k ) cout<<wstr[k];cout<<endl;
                 sol ++;
            }

        }
    }
    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <string.h>
#include <queue>
#include <map>
#include <math.h>
using namespace std;


int main(){
    srand((unsigned)time(0));
    freopen("Ulaz.txt","w",stdout);
    int n = 1 + rand()%500;

    cout<<n<<endl;
    for( int i = 0; i < n; ++i ){
        int ln = 1 + rand()%10;
        string w = "";
        for( int k = 0; k < ln; ++k ) w += char('a'+rand()%3);

        string q = w;
        reverse( q.begin() , q.end() );
        w += q;
        cout<<w.size()<<" "<<w<<endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <cstdlib>
#include <math.h>
#include <string>
#include <string.h>
#include <map>
#include <set>
#include <algorithm>
using namespace std;

const int maxn = 4000 + 55;
const int inf = 999999;

struct coord{
    int x,y,dx;
    coord(){};
    coord( int p1, int p2 ):x(p1),y(p2){};
    coord( int p1, int p2, int p3 ):x(p1),y(p2),dx(p3){};

    int ccw( coord a, coord b ){ return (a.x-x)*(b.y-y) - (b.x-x)*(a.y-y); }
    int dst( coord a ){ return (a.x-x)*(a.x-x) + (a.y-y)*(a.y-y); }

    const bool operator<( const coord &c ) const {
        return x < c.x || ( x == c.x && y < c.y );
    }
};

int n;
vector< coord > dots;
bool kikout[4006];

void convex( vector< coord > s ){
    sort( s.begin() , s.end() );

    vector< coord > lo,hi;

    for( int i = 0; i < s.size(); ++i ){
        int sz = lo.size();
        while( sz >= 2 && lo[sz-2].ccw( lo[sz-1] , s[i] ) < 0 )
            lo.pop_back() , sz --;
        lo.push_back( s[i] );
    }

    for( int i = s.size()-1; i >= 0; --i ){
        int sz = hi.size();
        while( sz >= 2 && hi[sz-2].ccw( hi[sz-1] , s[i] ) < 0 )
            hi.pop_back() , sz --;
        hi.push_back( s[i] );
    }


    for( int i = 0; i < hi.size(); ++i ) kikout[  hi[i].dx ] = 1;
    for( int i = 0; i < lo.size(); ++i ) kikout[  lo[i].dx ] = 1;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        int x,y; scanf("%d%d",&x,&y);
        dots.push_back( coord(x,y,i));
    }

    int sol = 0;
    while( dots.size() > 2 ){
        sol ++;
        convex( dots );

        int k = 0;
        for( int i = 0; i < dots.size(); ++i ){
            if( kikout[dots[i].dx] ){
                swap( dots[i] , dots[ (int)dots.size()-1 ] );
                dots.pop_back();
                k++,--i;
            }
        }
    }
    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <map>
#include <string.h>
#include <cstdlib>
#include <iomanip>
#include <string.h>
#include <string>
#include <queue>
using namespace std;

const int maxn = 105;

int f,n,s,e;

int ex[maxn] , ey[maxn];
bool mat[maxn][maxn];

int r[200];
int q[200][2];

bool exch( int dxa, int dxb ){
    int a = ex[dxa] , b = -ex[dxb];
    int diff = ey[dxb]-ey[dxa];
    int g = __gcd( a, b );

    if( diff % g ) return 0;

    if( a >= b ){
        r[0] = a , q[0][0] = 1, q[0][1] = 0;
        r[1] = b , q[1][1] = 1, q[1][0] = 0;
    }else{
        r[0] = b , q[0][1] = 1, q[0][0] = 0;
        r[1] = a , q[1][0] = 1, q[1][1] = 0;
    }

    int dx = 1;
    do{
        dx++;
        r[dx] = r[dx-2] % r[dx-1];

        q[dx][0] = q[dx-2][0];
        q[dx][1] = q[dx-2][1];

        int d = r[dx-2] / r[dx-1];
        q[dx][0] -= d*q[dx-1][0];
        q[dx][1] -= d*q[dx-1][1];

    }while( r[dx] != 0 ); dx--;

   // cout<<q[dx][0]<<"*"<<a<<" + "<<q[dx][1]<<"*"<<b<<" = "<<r[dx]<<endl;

    if( r[dx] < 0 && diff < 0 ) q[dx][0] *= -1 , q[dx][1] *= -1 , r[dx] *= -1;
    int t = diff / r[dx];
    q[dx][0] *= t;
    q[dx][1] *= t;
    r[dx] *= t;

    int w1 = q[dx][0]*a + ey[dxa];
    int w2 = -q[dx][1]*b + ey[dxb];
    int w = w1;

    int period = abs(a*b / __gcd(a,b));

    if( w > 0 ) w -= period*( w/period);
    if( w < 0 ) w += (period)*( abs(w)/period) + period;

    if( w >= 0 && w < f && w >= ey[dxa] && w >= ey[dxb] ) return 1;

    w += (period)*( (max(ey[dxa],ey[dxb])) / period );
    if( w >= 0 && w < f && w >= ey[dxa] && w >= ey[dxb] ) return 1;

    for( int i = 0; i < 10; ++i ){
        w += period;
        if( w >= 0 && w < f && w >= ey[dxa] && w >= ey[dxb] ) return 1;
    }

    return 0;
}

bool visi[105];
bool end[105];

int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d%d%d",&f,&n,&s,&e);

        for( int i = 0; i < n; ++i ){
            visi[i] = end[i] = 0;
            for( int j = 0; j < n; ++j ) mat[i][j] = 0;
        }


        for( int i = 0; i < n; ++i ) scanf("%d%d",&ex[i],&ey[i]);

        if( s == e ){
            printf("It is possible to move the furniture.\n");
            continue;
        }

        for( int i = 0; i < n; ++i )
            for( int j = 0; j < i; ++j )
                if( exch( i , j ) == true )
                    mat[i][j] = mat[j][i] = 1;// , printf("%d %d\n",i,j);


        queue< int > q;
        for( int i = 0; i < n; ++i ){
            if( (s - ey[i])%ex[i] == 0 && s >= ey[i]){
                q.push( i );
                //printf("GO IN: %d\n",i);
                visi[i] = 1;
            }
            if( (e - ey[i])%ex[i] == 0 && e >= ey[i] ) end[i] = 1;//, printf("GO OUT: %d\n",i);
        }

        bool ok = 0;

        while( q.empty() == false ){
            int u = q.front(); q.pop();
            if( end[u] == 1 ){
                ok = 1;
                break;
            }

            for( int k = 0; k < n; ++k ){
                if( mat[u][k] && visi[k] == false ){
                    q.push( k );
                    visi[k] = 1;
                }
            }
        }

        if( ok ) printf("It is possible to move the furniture.\n");
        else printf("The furniture cannot be moved.\n");

    }

    return 0;
}


#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <math.h>
#include <string>
#include <string.h>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

int stp10[10];
int v,len;

vector<int>sol;

int striked;

void solve( ll a, ll b , int m , int took ){
    if( m == 0 ){
        if( took == 0 && a + b == v )sol.push_back( a );
        return;
    }

    if( a * (ll)stp10[m] + b * (ll)stp10[m+took] > v ) return;
    if( (a+2) * (ll)stp10[m] + (b+2)*(ll)stp10[m+took] - 2 < v ) return;

    for( int i = 0; i <= 9; ++i ){
        if( took == -1 && (a||i!=0) ) striked = m , solve( a*10 + i , b , m-1 , 0 );
        solve( a*10 + i , b*10 + i , m-1 , took );
    }
}

char a[20],b[20];

int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    stp10[0] = 1;
    for( int i = 1; i < 10; ++i ) stp10[i] = stp10[i-1] * 10;
    int tests;  scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d",&v);

        len = 0;
        int tmp = v;
        while( tmp ){
            len ++;
            tmp /= 10;
        }

        sol.clear();
        solve( 0 , 0 , len , -1 );
        sort( sol.begin() , sol.end() );
        sol.erase( unique(sol.begin(),sol.end()),sol.end());

        printf("%d\n",sol.size());
        for( int i = 0; i < sol.size(); ++i ){
            sprintf(a,"%d",sol[i]);
            sprintf(b,"%d",v-sol[i]);
            printf("%d + ",sol[i]);
            for( int k = 0; k < strlen(a)-strlen(b)-1; ++k ) printf("0");
            printf("%d = %d\n",v-sol[i],v);
        }
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <math.h>
#include <string>
#include <string.h>
using namespace std;

void print_solution( int num , int sol ){
    char a[17],b[17];
    int zeros;

    sprintf(a,"%d",sol);
    sprintf(b,"%d",num-sol);
    zeros=strlen(a)-strlen(b)-1;
    printf("%d + ",sol);
    while(zeros--)printf("0");
    printf("%d = %d\n",num-sol,num);
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
    int cases;
    int number;
    int solutions,solution[20];
    long long t;
    int a,b;

    scanf("%d",&cases);
    while(cases--){
        scanf("%d",&number);
        solutions = 0;
        if(number%11<10) solution[solutions++] = 10*(number/11)+number%11;
        if( number%2 == 0 ){
            for( t = 10; t <= number; t *= 10 ){
                a = number / t , b = number % t;
                if(a%11<10) solution[solutions++] = t*(10*(a/11)+a%11)+b/2;
                if((a>1)&&((a-1)%11<10)) solution[solutions++]=t*(10*((a-1)/11)+(a-1)%11)+(t+b)/2;
            }
        }
        if( solutions > 1 ){
            for( a = 0; a < solutions; a++ ) for( b = a+1; b < solutions;b++) if( solution[a]>solution[b] ){
                solution[a] += solution[b];
                solution[b]=solution[a]-solution[b];
                solution[a] -= solution[b];
            }
            for( a = 0, b = 1 ; b < solutions; b++ ) if( solution[b]!=solution[a])solution[++a] = solution[b];
            solutions=a+1;
        }
        printf("%d\n",solutions);
        for( a = 0; a < solutions;++a) print_solution(number,solution[a]);
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <map>
#include <string.h>
#include <string>
#include <iomanip>
using namespace std;

int n;
char mat[70][70];
bool state[70];

const int inf = 99999;

bool possible(){
    for( int i = 0; i < n; ++i ){
        int falsed = 0;
        for( int j = 0; j < n; ++j )
            falsed += state[ j ] != (mat[i][j]=='T');

        if( falsed == 0 && state[i] == 0 ) return false;
        if( falsed != 0 && state[i] == 1 ) return false;
    }
    return true;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);
    int t = 1;

    for( ; tests; --tests ){

        scanf("%d",&n);
        for( int i = 0; i < n; ++i ) scanf("%s",mat[i]);

        int minx = inf, maxx = -1;
        memset( state , 0 , sizeof(state) );

        if( possible() ) minx = maxx = n;

        for( int i = 0; i < n; ++i ){
            int F = 0;
            for( int j = 0; j < n; ++j ){
                state[j] = mat[i][j] == 'T';
                F += mat[i][j] =='L';
            }

            if( possible() ){
                minx = min( minx , F );
                maxx = max( maxx , F );
            }
        }
        if( maxx == -1 ) printf("Class Room#%d is paradoxical\n",t);
        else printf("Class Room#%d contains atleast %d and atmost %d liars\n",t,minx,maxx);

        ++t;
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <math.h>
using namespace std;

int a,b;

int main(){
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&a,&b);
        int g = __gcd(a,b);
        int sol = 1;

        for( int i = 2; i*i <= g; ++i ){
            int cnt = 1;
            while( g % i == 0 ){
                g /= i;
                cnt ++;
            }
            sol *= cnt;
        }

        if( g > 1 ) sol *= 2;

        printf("%d\n",sol);
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <string>
#include <string.h>
#include <map>
#include <set>
#include <queue>
#include <algorithm>
using namespace std;

const int maxn = 1000;
const int maxe = 100000;
const int inf = 999999;
int source,sink;

struct coord{
    int x,y;
    coord(){};
    coord( int p1, int p2 ):x(p1),y(p2){};
    int dst( coord a ){
        return (a.x-x)*(a.x-x) + (a.y-y)*(a.y-y);
    }
};

int w,h,n;
coord dots[maxn];

int cap[maxn][maxn];

bool visited[maxn];

int flow( int node , int min_cap ){
    if( node == sink ) return min_cap;
    visited[ node ] = 1;

    int s = 0;
    for( int i = 0; i <= (n<<1)+1; i++ ){
        if( cap[node][i] == 0 || visited[ i ] == true ) continue;
        int f = flow( i , min( min_cap - s , cap[node][i] ) );
        cap[node][i] -= f;
        cap[i][node] += f;
        s += f;
    }
    return s;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d%d",&w,&h,&n);

    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        dots[i] = coord(a,b);
        cap[i][i+n] = 1;
    }

    source = 2*n;
    sink = 2*n+1;

    for( int i = 0; i < n; ++i ){
        if( dots[i].y <= 100 ) cap[source][i] = 1;
        if( h-dots[i].y <= 100 ) cap[i+n][sink] = 1;
        for( int j = i+1; j < n; ++j ){
            if( dots[i].dst( dots[j] ) <= 40000 ){
                cap[i+n][j] = 1;
                cap[j+n][i] = 1;
            }
        }
    }

    int sol = 0;
    while(1){
        memset( visited , 0 , sizeof(visited));
        int w = flow( source , inf );
        if( w <= 0 ) break;
        sol += w;
    }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <iomanip>
#include <set>
#include <fstream>
#include <assert.h>
using namespace std;

const int maxn = 500;
const int inf = 99999999;
const int mod = 100000000;

int w,n;
int e[maxn][2];

struct interval{
    int f,s;
    int dec,dp;
    interval(){ dec = 0 , dp = 0; };
    interval( int p1, int p2 ):f(p1),s(p2){ dec = 0 , dp = 0; };
    const bool operator<( const interval &i2 ) const {
        return s < i2.s || ( s == i2.s && f < i2.f );
    }
};

int mat[155][155];
bool con[155][155];

int main(){


    while( scanf("%d%d",&w,&n) ){
        if( w == 0 && n == 0 ) break;
        int s1,s2;

        for( int i = 0; i < n; ++i ) scanf("%d%d",&e[i][0],&e[i][1]);

        vector< interval > ve;
        for( int i = 0; i < n; ++i ){
            ve.push_back( interval( e[i][0] , e[i][1] ) );
            if( e[i][0] == 0 ) ve[ ve.size() - 1 ].dp = 1;
        }

        sort( ve.begin() , ve.end() );
        ve.push_back( interval(w,w+1));

        for( int i = 0; i < n+5; ++i )
            for( int j = 0; j < n+5; ++j )
                mat[i][j] = con[i][j] = 0;

        for( int i = 0; i < ve.size(); ++i )
            for( int j = 0; j < i; ++j )
                if( ve[j].s >= ve[i].f && ve[j].f < ve[i].f && ve[j].s != ve[i].s )
                    con[i][j] = 1;


        for( int i = 0; i < ve.size(); ++i ){
            for( int j = 0; j < i; ++j ){
                if( con[i][j] == false ) continue;

                int add = 0;
                for( int k = 0; k < i; ++k ){
                    if( con[j][k] == false ) continue;
                    if( ve[k].s >= ve[i].f ) continue;

                    if( mat[j][k] != 0 ){
                        add += mat[j][k]; if( add >= mod ) add -= mod;
                        continue;
                    }

                    add += ve[k].dp; if( add >= mod ) add -= mod;
                }
                if(  ve[j].f == 0 ) add ++;
                ve[i].dp += add; if( ve[i].dp >= mod ) ve[i].dp -= mod;
                if( add == 0 ) con[i][j] = add;
                mat[i][j] = add;
            }
        }

        printf("%d\n",ve[ve.size()-1].dp%mod);
    }



    return 0;
}

#include <iostream>
using namespace std;
#define w while
typedef long long ll;ll k,a,b,t;
int main(){
    cin>>t;
    w(cin>>k>>a>>b){
        w(a!=b){
            if(a<b)swap(a,b);
            int x=1,s=1;
            while(s<=a) s+=x,x*=k; x/=k, s-=x;
            a = (s-x/k)+(a-s)/k;
        }
        cout<<a<<'\n';
    }
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <map>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <algorithm>
using namespace std;

typedef long long ll;

const int maxn = 100000 + 555;
const int maxc = 100000;
const int inf = 999999;

int n;
int v[maxn];

struct fenwick{

    int maxn;
    vector<int>bit;

    fenwick(){};
    fenwick( int n ){ bit.resize(n+55) , maxn = n + 55; }

    void update( int dx , int v ){
        for( dx += 2; dx < maxn; dx += dx & -dx )
            bit[dx] += v;
    }

    int query( int dx ){
        int ret = 0;
        for( dx += 2; dx >= 1; dx -= dx & -dx )
            ret += bit[dx];
        return ret;
    }
};

int key[maxn];

int main(){
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%d",&v[i]);
        key[ v[i] ] = i+1;
    }

    fenwick f1(n);

    ll now = 0;

    for( int i = 0; i < n; ++i ){
        int cnt = f1.query( n-v[i] );
        now += cnt;
        f1.update( n-v[i] , 1 );
    }

    ll sol = now;

    for( int i = 1; i <= n; ++i ){
        now += (n - key[i]) - ( key[i] - 1 );
        sol = min( sol , now );
    }

    printf("%lld\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <stack>
#include <queue>
using namespace std;

const int maxn = 1005;

struct data{
    int height;
    int sum;
    int dx;
};

int n;
int H[maxn][maxn], W[maxn][maxn];
int hL[maxn][maxn];
int hR[maxn][maxn];
int vU[maxn][maxn];
int vD[maxn][maxn];

char mat[maxn][maxn];

void horizontal_to_left(){
    for( int i = 0; i < n; ++i ){
        stack< data > stk;

        data e;
        e.height = 0;
        e.dx = -1;
        e.sum = 0;
        stk.push( e );

        for( int j = 0; j < n; ++j ){
            while( stk.empty() == false && stk.top().height > H[i][j] ) stk.pop();
            data nw;
            nw.height = H[i][j];
            nw.dx = j;

            nw.sum = stk.top().sum + (stk.top().height>0) + (j-stk.top().dx)*H[i][j] - (H[i][j]>0);

            hL[i][j] = nw.sum;
            stk.push( nw );
        }
    }
}

void horizontal_to_right(){
    for( int i = 0; i < n; ++i ){
        stack< data > stk;

        data e;
        e.height = 0;
        e.dx = n;
        e.sum = 0;
        stk.push( e );

        for( int j = n-1; j >= 0; --j ){
            while( stk.empty() == false && stk.top().height > H[i][j] ) stk.pop();
            data nw;
            nw.height = H[i][j];
            nw.dx = j;

            nw.sum = stk.top().sum + (stk.top().height>0) + (stk.top().dx-j)*H[i][j] - (H[i][j]>0);

            hR[i][j] = nw.sum;
            stk.push( nw );
        }
    }
}

void vertical_to_down(){
    for( int i = 0; i < n; ++i ){
        stack< data > stk;

        data e;
        e.height = 0;
        e.dx = -1;
        e.sum = 0;
        stk.push( e );

        for( int j = 0; j < n; ++j ){
            while( stk.empty() == false && stk.top().height > W[i][j] ) stk.pop();
            data nw;
            nw.height = W[i][j];
            nw.dx = j;

            nw.sum = stk.top().sum + (stk.top().height>0) + (j-stk.top().dx)*W[i][j] - (W[i][j]>0);

            vD[i][j] = nw.sum;
            stk.push( nw );
        }
    }
}

void vertical_to_up(){
    for( int i = 0; i < n; ++i ){
        stack< data > stk;

        data e;
        e.height = 0;
        e.dx = n;
        e.sum = 0;
        stk.push( e );

        for( int j = n-1; j >= 0; --j ){
            while( stk.empty() == false && stk.top().height > W[i][j] ) stk.pop();
            data nw;
            nw.height = W[i][j];
            nw.dx = j;

            nw.sum = stk.top().sum + (stk.top().height>0) + (stk.top().dx-j)*W[i][j] - (W[i][j]>0);

            vU[i][j] = nw.sum;
            stk.push( nw );
        }
    }
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%s",mat[i]);
        for( int j = 0; j < n; ++j ){
            if( mat[i][j] == 'C' ){
                H[i][j] = (i-1>=0?H[i-1][j]:0) + 1;
                //W[i][j] = (j-1>=0?W[i][j-1]:0) + 1;
            }
        }
    }

    for( int i = n-1; i >= 0; --i )
        for( int j = 0; j < n; ++j )
            if( mat[i][j] == 'C' )
                W[i][j] = W[i+1][j] + 1;

    horizontal_to_left();
    horizontal_to_right();
    vertical_to_down();
    vertical_to_up();

    int sol = 0;
        // try to put a vertical line // use hL hR

    for( int i = 0; i < n; ++i ){
        int ss1 = 0;
        int ss2 = 0;
        for( int k = 0; k < n; ++k ){
            ss1 += hL[k][i];
            for( int j = i+1; j < n; ++j )
                ss2 += hR[k][j];
        }
        sol += ss1*ss2;
    }

    // try to put a horizontal line // use vU vD

    for( int i = 0; i < n; ++i ){
        int ss1 = 0;
        int ss2 = 0;
        for( int k = 0; k < n; ++k ){
            ss1 += hL[i][k];
            for( int j = i+1; j < n; ++j ) ss2 += vD[j][k];
        }
       // cout<<i<<" = "<<ss1<<" "<<ss2<<endl;
        sol += ss1*ss2;
    }

    for( int i = 0 ; i < n; ++i ){
        for( int j = 0; j < n; ++j ){
            int ss1 = hL[i][j];
            int ss2 = 0;

            for( int r = i+1; r < n; ++r )
                for( int c = j+1; c < n; ++c )
                    ss2 += vU[r][c];
            sol -= ss1*ss2;
            cout<<ss1*ss2<<" "<<sol<<endl;
        }
    }
     cout<< sol << endl;

    for( int i = 0 ; i < n; ++i ){
        for( int j = 0; j < n; ++j ){
            int ss1 = vD[i][j];
            int ss2 = 0;

            for( int r = i-1; r >= 0; --r )
                for( int c = j+1; c < n; ++c ){
                    ss2 += hR[r][c];
                }
            sol -= ss1*ss2;
        }
    }

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < n; ++j ){
            cout<<hR[i][j]<<" ";
        }cout<<endl;
    }cout<<endl;

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < n; ++j ){
            cout<<vD[i][j]<<" ";
        }cout<<endl;
    }cout<<endl;

    cout<< sol % 10007<< endl;


    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <stack>
#include <queue>
using namespace std;

const int mod = 10007;
const int maxn = 1005;

struct data{
    int height;
    int sum;
    int dx;
};

int n;
int H[maxn][maxn], W[maxn][maxn];
int hL[maxn][maxn];
int hR[maxn][maxn];
int vU[maxn][maxn];
int vD[maxn][maxn];

char mat[maxn][maxn];

void horizontal_to_left(){
    for( int i = 0; i < n; ++i ){
        stack< data > stk;

        data e;
        e.height = 0;
        e.dx = -1;
        e.sum = 0;
        stk.push( e );

        for( int j = 0; j < n; ++j ){
            while( stk.empty() == false && stk.top().height > H[i][j] ) stk.pop();
            data nw;
            nw.height = H[i][j];
            nw.dx = j;

            nw.sum = stk.top().sum + (stk.top().height>0) + (j-stk.top().dx)*H[i][j] - (H[i][j]>0);
            nw.sum %= mod;

            hL[i][j] = nw.sum;
            stk.push( nw );
        }
    }
}

void horizontal_to_right(){
    for( int i = 0; i < n; ++i ){
        stack< data > stk;

        data e;
        e.height = 0;
        e.dx = n;
        e.sum = 0;
        stk.push( e );

        for( int j = n-1; j >= 0; --j ){
            while( stk.empty() == false && stk.top().height > H[i][j] ) stk.pop();
            data nw;
            nw.height = H[i][j];
            nw.dx = j;

            nw.sum = stk.top().sum + (stk.top().height>0) + (stk.top().dx-j)*H[i][j] - (H[i][j]>0);
            nw.sum %= mod;

            hR[i][j] = nw.sum;
            stk.push( nw );
        }
    }
}

void vertical_to_down(){
    for( int i = 0; i < n; ++i ){
        stack< data > stk;

        data e;
        e.height = 0;
        e.dx = -1;
        e.sum = 0;
        stk.push( e );

        for( int j = 0; j < n; ++j ){
            while( stk.empty() == false && stk.top().height > W[i][j] ) stk.pop();
            data nw;
            nw.height = W[i][j];
            nw.dx = j;

            nw.sum = stk.top().sum + (stk.top().height>0) + (j-stk.top().dx)*W[i][j] - (W[i][j]>0);
            nw.sum %= mod;

            vD[i][j] = nw.sum;
            stk.push( nw );
        }
    }
}

void vertical_to_up(){
    for( int i = 0; i < n; ++i ){
        stack< data > stk;

        data e;
        e.height = 0;
        e.dx = n;
        e.sum = 0;
        stk.push( e );

        for( int j = n-1; j >= 0; --j ){
            while( stk.empty() == false && stk.top().height > W[i][j] ) stk.pop();
            data nw;
            nw.height = W[i][j];
            nw.dx = j;

            nw.sum = stk.top().sum + (stk.top().height>0) + (stk.top().dx-j)*W[i][j] - (W[i][j]>0);
            nw.sum %= mod;

            vU[i][j] = nw.sum;
            stk.push( nw );
        }
    }
}

int sumup( int mat[maxn][maxn] ){
    for( int i = 0; i < n; ++i ){
        for( int j = 1; j < n; ++j ){
            mat[i][j] += mat[i][j-1];
            if( mat[i][j] >= mod ) mat[i][j] -= mod;
        }
        if(i)for( int j = 0; j < n; ++j ){
            mat[i][j] += mat[i-1][j];
            if( mat[i][j] >= mod ) mat[i][j] -= mod;
        }
    }
}

int rsum( int mat[maxn][maxn] , int r1 , int r2 , int c1, int c2 ){
    if( r2 < r1 || c2 < c1 ) return 0;
    int s = 0;
    s += mat[r2][c2];
    if( r1 ) s -= mat[r1-1][c2];
    if( c1 ) s -= mat[r2][c1-1];
    if( c1 && r1 ) s += mat[r1-1][c1-1];
    return s;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%s",mat[i]);
        for( int j = 0; j < n; ++j ){
            if( mat[i][j] == 'C' ){
                H[i][j] = (i-1>=0?H[i-1][j]:0) + 1;
                //W[i][j] = (j-1>=0?W[i][j-1]:0) + 1;
            }
        }
    }

    for( int i = n-1; i >= 0; --i )
        for( int j = 0; j < n; ++j )
            if( mat[i][j] == 'C' )
                W[i][j] = W[i+1][j] + 1;

    horizontal_to_left();
    horizontal_to_right();
    vertical_to_down();
    vertical_to_up();

    sumup( hL );
    sumup( hR );
    sumup( vD ); // 2187
    sumup( vU );


    int sol = 0;

    for( int i = 0; i < n; ++i ){
        int ss1 = rsum( hL , 0 , n-1 , i , i );
        int ss2 = rsum( hR , 0 , n-1 , i+1 , n-1 );
        sol += ss1*ss2;
        sol %= mod;
    }

    for( int i = 0; i < n; ++i ){
        int ss1 = rsum( hL , i , i , 0 , n-1 );
        int ss2 = rsum( vD , i+1 , n-1 , 0 , n-1 );
        sol += ss1*ss2;
        sol %= mod;
    }

    for( int i = 0 ; i < n; ++i ){
        for( int j = 0; j < n; ++j ){
            int ss1 = rsum( hL , i , i , j , j );
            int ss2 = rsum( vU , i+1 , n-1 , j+1 , n-1 );
            sol -= ss1*ss2;
            sol %= mod;
            sol += mod;
            sol %= mod;
        }
    }

    for( int i = 0 ; i < n; ++i ){
        for( int j = 0; j < n; ++j ){
            int ss1 = rsum( vD , i , i , j , j );
            int ss2 = rsum( hR , 0 , i-1 , j+1 , n-1 );
            sol -= ss1*ss2;
            sol %= mod;
            sol += mod;
            sol %= mod;
        }
    }

    cout<< sol << endl;


    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <string>
#include <string.h>
#include <set>
#include <map>
#include <queue>
using namespace std;

const int mod = 1000000;

typedef long long ll;

int n;
int pa[2005];
int pd[1005];
bool done[2005];
vector< int > mem[2006];

void factorize( int w , int *mat ){
    if( done[w] ){
        for( int i = 0; i < mem[w].size(); ++i ) mat[ mem[w][i] ] ++;
        return;
    }

    int N = w;

    for( int j = 2; j*j <= w; ++j ){
        while( w % j == 0 ){
            w /= j;
            mat[j] ++;
            mem[N].push_back( j );
        }
    }
    if( w > 1 ) mat[w] ++, mem[N].push_back( w );
    done[N] = 1;
}

int mpow( int b, int e ){
    if( e == 0 ) return 1;
    if( e&1 ){
        int a = mpow( b , e-1 );
        return (a*(ll)b)%mod;
    }else{
        int a = mpow( b , e>>1 );
        return (a*(ll)a)%mod;
    }
}

int main(){
 //   freopen("Ulaz.txt","r",stdin);
    while( scanf("%d",&n) ){
        if( n == 0 ) break;
        for( int i = 0; i <= (n<<1); ++i ) pa[i] = 0;
        for( int i = 0; i <= n+1; ++i ) pd[i] = 0;

        for( int i = 1; i <= (n<<1); ++i ) factorize( i , pa );
        for( int i = 1; i <= n; ++i ) factorize( i , pd );
        for( int i = 1; i <= n+1; ++i ) factorize( i , pd );

        int sol = 1;

        for( int i = 1; i <= (n<<1); ++i ){
            int w = pa[i];
            if( i <= n+1 ) w -= pd[i];
            if( w < 0 ) cout<<"WARNING"<<endl;
            if( w == 0 ) continue;
            sol = (sol*mpow(i,w))%mod;
        }

        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <math.h>
using namespace std;

const double eps = 1e-10;

int n,v;
int a[25];
int b[25];

double tmp;

bool ok( double x ){
    double s = 0;
    for( int i = 0; i < n; ++i ){
        double w = a[i] * x;
        s += w;
        if( w > b[i] ) return false;
    }
    tmp = s;
    return s <= v;
}

int main(){
    scanf("%d%d",&n,&v);
    for( int i = 0; i < n; ++i ) scanf("%d",&a[i]);
    for( int i = 0; i < n; ++i ) scanf("%d",&b[i]);

    double lo = 0 , hi = v , x = 0;
    while( hi-lo > eps ){
        x = (hi+lo)/2;

        if( ok(x) ) lo = x + eps;
        else hi = x - eps;
    }

    printf("%.10lf\n",tmp);

    return 0;
}

#include <cstdio>
#include <string.h>
#include <algorithm>

const short inf = 999;

int m,n;
char bits[105];
int s2[105];

short dp[2][1000000 + 10];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%s",bits); n = strlen(bits);
    std::reverse( bits , bits + n );
    scanf("%d",&m);

    s2[0] = 1;
    for( int i = 1; i < n; ++i ) s2[i] = (s2[i-1]<<1)%m;

    for( int i = 0; i < m; ++i ) dp[0][i] = inf;
    dp[0][0] = 0;

    bool mode = 1;

    for( int i = n-1; i >= 0; --i ){
        bool c = bits[i] - '0';
        int a = c*s2[i];
        int b = (!c)*s2[i];
        int n1,n2;
        short w1,w2;
        for( int k = m-1; k >= 0; --k ){
            n1 = k+a , n2 = k+b;
            if( n1 >= m ) n1 -= m;
            if( n2 >= m ) n2 -= m;

            w1 = dp[!mode][n1];
            w2 = dp[!mode][n2] + 1;

            if( w1 > w2 ) dp[mode][k] = w2;
            else dp[mode][k] = w1;
        }
        mode = !mode;
    }
    printf("%i\n",dp[!mode][0]);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <math.h>
using namespace std;

#define pii pair<int,int>
#define r first
#define c second
#define mk make_pair

string s1,s2,s3,s4;
int king[][2] = { {-1,0} , {+1,0} , {0,-1} , {0,+1} , {1,1} , {-1,-1} , {-1,1} , {1,-1} };

pii rook1,rook2,w,b;

pii format( string a ){
    return mk( a[1] - '0' , a[0] - 'a' + 1 );
}

bool horizontal( pii w  , pii kill ){
    pii block = ::w;
    if( w.r != kill.r ) return 0;
    if( w.r != block.r ) return 1;
    if( min(w.c,kill.c) < block.c && block.c < max(w.c,kill.c) ) return 0;
    return 1;
}

bool vertikal( pii w  , pii kill ){
    pii block = ::w;
    if( w.c != kill.c ) return 0;
    if( w.c != block.c ) return 1;
    if( min(w.r,kill.r) < block.r && block.r < max(w.r,kill.r) ) return 0;
    return 1;
}

int isattacked( pii pos ){
    if( horizontal(rook1,pos) && pos != rook1 || horizontal(rook2,pos) && pos != rook2  ) return 1;
    if( vertikal(rook1,pos) && pos != rook1 || vertikal(rook2,pos) && pos != rook2  ) return 1;


    for( int i = 0; i < 8; ++i ){
        int nr = w.r + king[i][0];
        int nc = w.c + king[i][1];
        if( nr < 1 || nc < 1 || nr > 8 || nc > 8 ) continue;
        if( mk(nr,nc) == pos ) return 1;
    }
    return 0;
}

int main(){
  //  freopen("Ulaz.txt","r",stdin);
    cin >> s1 >> s2 >> s3 >> s4;
    rook1 = format(s1);
    rook2 = format(s2);
    w = format(s3);
    b = format(s4);

  //  cout<<rook1.r<<" "<<rook1.c<<endl;
  //  cout<<rook2.r<<" "<<rook2.c<<endl;


    bool exit = false;
    for( int i = 0; i < 8; ++i ){
        int nr = b.r + king[i][0];
        int nc = b.c + king[i][1];
        pii w = mk(nr,nc);
        if( nr < 1 || nc < 1 || nr > 8 || nc > 8 ) continue;

        if( isattacked( mk(nr,nc) ) == false ) exit = true;
       // cout<<nr<<" "<<nc<<" = "<<isattacked(w)<<endl;
    }


    if( isattacked( b ) && exit == false ) printf("CHECKMATE\n");
    else printf("OTHER\n");


    return 0;
}

#include <iostream>
#include <algorithm>
#include <vector>
#include <cstdio>
#include <string.h>
using namespace std;

const int inf  = 99999999;
const int maxw = 10000000 + 5;

struct pii{
    int f,s;
    pii(){};
    pii( int p1, int p2 ):f(p1),s(p2){};
    const bool operator<( const pii &p ) const { return f > p.f; }
};

int n;
char buff[10000];

vector< pii > inc,decr;

int main(){
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%s",buff);
        int len = strlen(buff);
        int cnt = 0;
        int minx = 0;
        for( int j = 0; j < len; ++j ){
            if( buff[j] == '(' ) cnt ++;
            else cnt --;
            minx = min( minx , cnt );
        }
        if( cnt >= 0 )inc.push_back( pii(minx,cnt) );
        else decr.push_back( pii(minx,cnt) );
    }

    sort( inc.begin() , inc.end() );
    sort( decr.begin() , decr.end()  );

    int now = 0;
    bool ok = 1;

    for( int i = 0; i < inc.size(); ++i ){
        if( now + inc[i].f < 0 ) ok = 0;
        now += inc[i].s;
    }

    int prv = now;
    now = 0;

    for( int i = 0; i < decr.size() && ok; ++i ){
        if( now - decr[i].s + decr[i].f < 0 ) ok = 0;
        now += -decr[i].s;
    }

    if( ok && prv == now ) printf("yes\n");
    else printf("no\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <stack>
#include <algorithm>
#include <string>
#include <string.h>
#include <cstdio>
#include <assert.h>
using namespace std;

const int maxn = 1000000 + 5;
const int inf  = 2000000000;

int n;

const int MaxBuff = 5000000;
char buff[ MaxBuff ];
int pos = MaxBuff;

inline char readch () {
  if ( pos == MaxBuff ) {
    fread( buff, 1, MaxBuff, stdin );
    pos = 0;
  }
  return buff[pos++];
}

char c;
inline int geti () {
  while ( (c = readch())<'0' || c > '9' );
  int ret = c - '0';
  while ( ( c = readch() )>='0' && c <= '9' ) ret = ret * 10 + c - '0';
  return ret;
}

int sz = 0;
int s[maxn], minx[maxn], mindx[maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    n = geti();
    minx[sz] = mindx[sz] = s[sz++] = inf;

    int sol = -1;
    int x;

    for( int i = 0; i < n; ++i ){
        x = geti();

        while( s[sz-1] <= x ){
            sz--;
            if( minx[sz-1] > minx[sz] ) minx[sz-1] = minx[sz] , mindx[sz-1] = mindx[sz];
        }

        int w = mindx[sz-1];
        if( minx[sz-1] <= x && sol < i-w+1 ) sol = i - w + 1;
        s[sz] = x , minx[sz] = x, mindx[sz++] = i;
    }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
#include <assert.h>
#include <iomanip>
#include <stack>
#include <math.h>
#include <fstream>
using namespace std;

const int maxn = 100000 + 55;

int n;
char num[maxn];
bool del[maxn];

struct sel{
    char c;
    int dx;
    sel(){};
    sel( char p1, int p2 ):c(p1),dx(p2){};

    const bool operator<( const sel &s ) const {
        return c < s.c || ( c == s.c && dx > s.dx );
    }
};

int main(){
    scanf("%d",&n);
    scanf("%s",num);

    vector< sel > all;

    for( int i = 0; i < n; ++i ) all.push_back( sel( num[i] , i ) );

    sort( all.begin() , all.end() );

    int mirko = n-1;
    int slavko = 0;

    string mfin = "";
    string sfin = "";

    for( int i = 0; i < n; ++i ){

        if( i%2 == 0 ){
            while( mirko >= 0 && del[mirko] ) mirko --;
            del[mirko] = 1;
            mfin += string(1,num[mirko]);
        }else{
            while( slavko < n && del[ all[slavko].dx ] ) slavko ++;
            del[ all[slavko].dx ] = 1;
            sfin += string(1,all[slavko].c);
        }
    }

    if( sfin < mfin ) printf("DA\n");
    else printf("NE\n");
    cout<<sfin<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
#include <assert.h>
#include <iomanip>
#include <stack>
#include <math.h>
#include <fstream>
using namespace std;

const int maxn = 300000 + 55;

int n,niz[maxn];

int main(){
    scanf("%d",&n);

    for( int i = 0; i < n; ++i )scanf("%d",&niz[i]);

    int now = n , cnt = 0;
    for( int i = n-1; i >= 0; --i ) if( niz[i] == now ){ cnt ++ , now --; }

    cout<<n - cnt<<endl;
    return 0;
}

#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
#include <assert.h>
#include <iomanip>
#include <stack>
#include <math.h>
#include <fstream>
using namespace std;

int h,w;
int mat[1005][1005];

int minr,minc,minx;

void zigzag_left_right(){
    int r = 0 , c = 0;
    int ar = 0 , ac = 1;

    for( int i = 0; i < h*w-1; ++i ){
        int nr = r + ar;
        int nc = c + ac;
        if( nc < 0 || nc >= w ){
            ac *= -1;
            r ++;
            printf("D");
        }else{
            r = nr , c = nc;
            if( ac == 1 ) printf("R");
            else printf("L");
        }
    }
}

void zigzag_up_down(){
    int r = 0 , c = 0;
    int ar = 1 , ac = 0;

    for( int i = 0; i < h*w-1; ++i ){
        int nr = r + ar;
        int nc = c + ac;
        if( nr < 0 || nr >= h ){
            ar *= -1;
            c ++;
            printf("R");
        }else{
            r = nr , c = nc;
            if( ar == 1 ) printf("D");
            else printf("U");
        }
    }
}

int memt = 0;
int vis[1005][1005];
inline void mark( int r, int c ){
    vis[r][c] = 1;
    memt += mat[r][c];
}

#define move_right printf("R"),c++,mark(r,c);
#define move_left printf("L"),c--,mark(r,c);
#define move_up printf("U"),r--,mark(r,c);
#define move_down printf("D"),r++,mark(r,c);

void mode1(){
    int r = 0 , c = 0;
    int ar = 1 , ac = 0;
    mark(r,c);

    bool done = 0;

    while(1){
        int nr = r + ar;
        if( nr == minr && c == minc ) break;

        if( nr < 0 || nr >= h ) ar *= -1 , c ++ , printf("R");
        else if( ar == 1 ) printf("D"), r += ar;
        else printf("U"), r += ar;
        mark(r,c);
    }

    if( c + 1 < w ) move_right
    else done = 1;

    if( r + 1 < h && !done ) move_down
    else done = 1;

    if( r + 1 < h && !done ){
        printf("D"); r++; mark(r,c);
        printf("L"); c--; mark(r,c);
        while( r + 1 < h ){ r ++; printf("D"); mark(r,c); }
        printf("R"); c++; mark(r,c);
    }
    if( c + 1 < w && !done ){c++; printf("R"); mark(r,c);}
    else done = 1;

    while( r - 1 >= 0 && !done ){
        r --; printf("U"); mark(r,c);
        if( vis[r][c-1] == 0 ){
            printf("LUR"); mark(r,c-1) , mark(r-1,c-1), mark(r-1,c);
            r--;
        }
    }

    if( c + 1 < w && !done )printf("R"); c ++; mark(r,c);

    while( !done ){
        int nr = r + ar;
        if( r == h-1 && c == w - 1 ) break;

        if( nr < 0 || nr >= h ) ar *= -1 , c ++ , printf("R");
        else if( ar == 1 ) printf("D"), r += ar;
        else printf("U"), r += ar;
        mark(r,c);
    }

//    printf("\n");
//    for( int i = 0; i < h; ++i ){
//        for( int j = 0; j < w; ++j ){
//            cout<<vis[i][j]<<" ";
//        }cout<<endl;
//    }printf("\n");
//    cout<<memt<<endl;

}

void mode2(){
    int r = 0 , c = 0;
    int ar = 1 , ac = 0;
    mark(r,c);

    while(1){
        int nr = r + ar;
        if( nr == minr && c == minc ) break;

        if( nr < 0 || nr >= h ) ar *= -1 , c ++ , printf("R");
        else if( ar == 1 ) printf("D"), r += ar;
        else printf("U"), r += ar;
        mark(r,c);
    }
    bool done = 0;

    if( c + 1 < w )move_right
    else done = 1;

    if( r - 1 >= 0 && !done ) move_up
    else done = 1;

    if( r - 1 >= 0 && !done ){
        move_up
        move_left
        while( r - 1 >= 0 )move_up
        move_right
    }

    if( c + 1 < w && !done) move_right
    else done = 1;

    while( r + 1 < h && !done ){
        move_down
        if( vis[r][c-1] == 0 ){
            printf("LDR"); mark(r,c-1) , mark(r+1,c-1), mark(r+1,c);
            r++;
        }
    }

    if( c + 1 < w && !done) move_right

    while(1){
        int nr = r + ar;
        if( r == h-1 && c == w - 1 ) break;

        if( nr < 0 || nr >= h ) ar *= -1 , c ++ , printf("R");
        else if( ar == 1 ) printf("D"), r += ar;
        else printf("U"), r += ar;
        mark(r,c);
    }

//    printf("\n");
//    for( int i = 0; i < h; ++i ){
//        for( int j = 0; j < w; ++j ){
//            cout<<vis[i][j]<<" ";
//        }cout<<endl;
//    }printf("\n");
   // cout<<memt<<endl;

}

void spec(){
   // cout<<"SPEC"<<endl;
     w -= 2;
     zigzag_up_down();
     w += 2;
     printf("R");

     int r = 0;
     int c = w - 2;
     int g = 0;

     while( r != h-1 || c != w - 1 ){
        if( g % 2 == 0 ){
            if( (c+1 != minc || r != minr) && c+1<w ) c++ , printf("R");
            else g--;
            if( r+1 < h ) r++ , printf("D");
        }else if( g % 2 == 1  ){
            if( c-1 != minc || r != minr ) c-- , printf("L");
            else g--;
            if( r+1 < h ) r++ , printf("D");
        }
        //cout<<" "<<minc<<" "<<minr<<" , "<<c<<" "<<r<<" ("<<w<<","<<h<<") "<<g<<endl;
        g++;
     }
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&h,&w);

    minx = 999999;

    for( int i = 0; i < h; ++i )
        for( int j = 0; j < w; ++j ){
            scanf("%d",&mat[i][j]);
            if( (i+j)%2 == 1 && minx > mat[i][j] ) minx = mat[i][j] , minr = i, minc = j;
        }
   // cout<<minr<<" "<<minc<<endl;

    if( h % 2 || w % 2 ){
        if( w % 2 ) zigzag_up_down();
        else zigzag_left_right();
    }else{
        vis[minr][minc] = 3;
        if( minc+2 != w && minc % 2 == 0 ) mode1();
        else if( minc+2 != w ) mode2();
        else spec();
    }



    return 0;
}

#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
#include <assert.h>
#include <iomanip>
#include <stack>
#include <math.h>
#include <fstream>
using namespace std;

char buff[105];

string ledzero( string w ){
    string sol = "";
    bool zero = 1;
    for( int i = 0; i < w.size(); ++i ){
        if( w[i] != '0' ) zero = 0;
        if( !zero ) sol = sol + w[i];
    }
    if( sol.size() == 0 ) sol = "0";
    return sol;
}

vector< string > m;

bool cmp( string a , string b ){
    if( a.size() < b.size() ) return 1;
    if( a.size() > b.size() ) return 0;

    int c = lexicographical_compare( a.begin() , a.end() , b.begin() , b.end() );
    return c;
}

int main(){
    int n;
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        scanf("%s",buff);

        string w = "";
        bool num = 0;
        for( int j = 0; j < strlen(buff); ++j ){
            char c = buff[j];
            if( c < '0' || c > '9' ){
                if( num ) m.push_back( ledzero(w) );
                num = 0;
                w = "";
            }else{
                num = 1;
                w += string(1,c);
            }
        }
        if( num ) m.push_back( ledzero(w));
    }

    sort( m.begin() , m.end() , cmp );

    for( int i = 0; i < m.size(); ++i )
        cout<<m[i]<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
#include <assert.h>
#include <iomanip>
#include <stack>
#include <math.h>
using namespace std;

int a,b,v;

int main(){
   // freopen("Ulaz.txt","r",stdin);
  //  freopen("Izlaz.txt","w",stdout);
    cin >> a >> b >> v;
    v -= b;

    int inc = a-b;
    int days = (int)ceil(v / (double)inc);
    cout<<days<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
#include <assert.h>
#include <iomanip>
#include <stack>
#include <math.h>
using namespace std;

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
    int a,b,v; cin >> a >> b >> v;

    int days = 1, now = 0;
    while(1){
        now += a;
        if( now  >= v ){
            cout<<days<<endl;
            break;
        }

        now -= b;
        days++;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
#include <assert.h>
#include <iomanip>
#include <stack>
#include <math.h>
#include <fstream>
using namespace std;

int main(){
    srand((unsigned)time(0));
    int t = 1;
    while(1){
        cout<<"CASE: "<<t++<<" ";

        int a = 1 + rand()%10000;
        int b = 1 + a + rand()%1000;
        int v = b + rand()%10000;

        ofstream out("Ulaz.txt");
        out<<b<<" "<<a<<" "<<v<<endl;
        out.close();

        system("coci_a.exe");
        system("coci_a_brute.exe");

        if( system("diff -qb Izlaz.txt Izlaz2.txt") ){
            cout<<"WA"<<endl;
            while(1);
        }else cout<<"AC"<<endl;
    }

    return 0;
}

#include <iostream>
#include <cstdio>
using namespace std;

int n;
char txt[100];

int main(){
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d",&n);
        scanf("%s",txt);

        string sol = "";

        for( int i = 0; i < (4*n); i += 4 ){
            int w1 = (txt[i]-'0')*10 + (txt[i+2]-'0');
            int w2 = (txt[i+1]-'0')*10 + (txt[i+3]-'0');
            int s = w1 + w2;
            sol += string(1,s);
        }
        cout<< sol << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <string.h>
#include <map>
#include <set>
using namespace std;

int n;
int w[50] , sz = 0;

int dp[45][45][45][45];

vector< string > str;

int solve( int v , int take , int odd , int even ){

    int &m = dp[v][take][odd][even];
    if( m == 0 ) return 0;
    m = 0;

    if( v == 0 ){
        if( odd == even ){
            string add = "";
            for( int i = sz-1; i >= 0; --i ) add += string(1,w[i]);
            str.push_back(add);
            return m = 1;
        }
        return m = 0;
    }

    if( v - take >= 0 ){
        w[sz++] = take;
        m = solve( v - take , take , odd+(take&1) , even+!(take&1) );
        sz--;
    }
    if( take > 1 ) m = m | solve( v  , take - 1 , odd , even );
    return m;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    memset( dp , -1 , sizeof(dp));

    for( ; tests; --tests ){
        scanf("%d",&n);

        str.clear();
        if( solve( n , n , 0 , 0 ) == 0 )
            printf("Impossible\n");
        else{
            sort( str.begin() , str.end() );
            for( int i = 0; i < str.size(); ++i ){
                for( int j = 0; j < str[i].size(); ++j )
                    printf("%d ",str[i][j]); putchar('\n');
            }
          //  cout<<str.size()<<endl;
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <math.h>
using namespace std;

int m,n;
int e[105];

bool ok( int low ){
    int ss = m;

    for( int i = 0; i < n; ++i ){
        int x = low / e[i];
        if( x * e[i] < low ) x++;
        ss -= x;
    }
    return ss >= 0;
}

int main(){
    scanf("%d%d",&m,&n);

    for( int i = 0; i < n; ++i ) scanf("%d",&e[i]);
    sort( e , e + n );

    int lo = 0 , hi = 1000000000 , sol = 0;
    while( lo <= hi ){
        int mid = (lo+hi)>>1;

        if( ok( mid ) ) lo = mid + 1 , sol = mid;
        else hi = mid - 1;
    }

    cout<< sol - m << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
using namespace std;

typedef long long ll;

int h,w,c;

int main(){
    while( scanf("%d%d%d",&h,&w,&c) == 3 ){
        if( h == 0 && w == 0 && c == 0 ) break;
        c = !c;

        int w1,w2;

        int space = w - 8 + 1;
        w1 = (space / 2) + space%2, w2 = (space / 2 );
        if( c ) swap(w1,w2);


        space = h - 8 + 1;

        ll sol = (w1+w2) * (ll)(space/2);
        if( space%2 ) sol += w1;

        cout<<sol<<endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
using namespace std;

int lo,hi;
char s[5];

int main(){
    scanf("%d%d",&lo,&hi);

    while( lo <= hi ){
        int mid = (lo+hi)>>1;
        printf("%d\n",mid); fflush(stdout);
        scanf("%s",s);
        if( s[0] == 'W' )
            break;
        else if( s[0] == 'H' )
            hi = mid - 1;
        else lo = mid + 1;
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <algorithm>
#include <map>
using namespace std;

typedef long long ll;

const int maxn = 1500000 + 55;

int n,m;
int s[maxn],t[maxn],a[maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        cin >> s[0] >> t[0] >> n >> m;

        int f = 0 , ss = m + 1;
        a[0] = m + 1;

        int sol = maxn;

        for( int i = 1; i <= n; ++i ){
            s[i] = (78901 + 31*s[i-1]) % 699037;
            t[i] = (23456 + 64*t[i-1]) % 2097151;
            a[i] = ((s[i]%100)+1) * ((t[i]%100)+1);

           // cout<<a[i]<<endl;

            bool cnt = 0;
            ss += a[i];

            while( f <= i && ss > m ) ss -= a[f++], cnt = i > 1;

            if( cnt ) sol = min( sol , i - f + 1 );
        }
        if( ss <= m ) sol = min( sol , n - f + 1 );

        if( sol != maxn ) printf("%d\n",sol);
        else printf("0\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <map>
#include <stack>
#include <iomanip>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 5005;

int n;
vector< pii > a,b,c;

vector< pii > p[maxn];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        int p1,p2,p3;
        scanf("%d%d%d",&p1,&p2,&p3);
        a.push_back(mk(p1,i));
        b.push_back(mk(p2,i));
        c.push_back(mk(p3,i));
    }

    sort( a.rbegin(), a.rend() );
    sort( b.rbegin(), b.rend() );
    sort( c.rbegin(), c.rend() );

    for( int i = 0; i < n; ++i ){
        int j = 0;
        while( p[ b[i].s ].size() < 2 && j < n ){
            if( c[j].s != b[i].s ) p[ b[i].s ].push_back( c[j] );
            ++j;
        }
    }

    int sol = 0;
    int f,s,t;

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < 3; ++j ){
            for( int k = 0; k < p[ b[j].s ].size(); ++k ){
                if( b[j].s == a[i].s || p[ b[j].s ][k].s == a[i].s ) continue;
                int sm = b[j].f + a[i].f + p[ b[j].s ][k].f;

                if( sol < sm ){
                    sol = sm;
                    f = a[i].s, s = b[j].s , t = p[ b[j].s ][k].s;
                }
            }
        }
    }


    printf("%d\n%d\n%d\n",f,s,t);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <math.h>
#include <iomanip>
using namespace std;

const int maxn = 100 + 5;
const int maxlen = 128 + 5;

int n,m;
char txt[maxn][maxlen];

bool ok[26][26][26][26][26];

bool oksfx( char *txt, char *pat, int dx ){
    int lentxt = strlen(txt);
    int lenpat = strlen(pat);

    int rem = lentxt - dx;
    if( rem >= lenpat ) return 0;

    for( int i = dx; i < lentxt; ++i )
        if( txt[i] != pat[i-dx] )
            return 0;
    return 1;
}

void putx( char a , char b, char c, char d, char e ){
    ok[a-'a'][b-'a'][c-'a'][d-'a'][e-'a'] = 1;
}

void insert( char *txt, int lo, int hi ){
    for( int i = lo; i+m-1 <= hi; ++i ){
        if( m == 5 )putx( txt[i] , txt[i+1] , txt[i+2] , txt[i+3] , txt[i+4] );
        if( m == 4 )putx( txt[i] , txt[i+1] , txt[i+2] , txt[i+3] , 'x' );
        if( m == 3 )putx( txt[i] , txt[i+1] , txt[i+2] , 'x' , 'x' );
        if( m == 2 )putx( txt[i] , txt[i+1] , 'x' , 'x' , 'x' );
        if( m == 1 )putx( txt[i] , 'x' , 'x' , 'x' , 'x' );
    }
}

char tmp[10];
bool done[maxn];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);
    for( int i = 0; i < n; ++i )scanf("%s",txt[i]);

    queue< int > q;
    q.push( 0 );
    done[0] = 1;

    while( !q.empty() ){
        int i = q.front(); q.pop();

        insert( txt[i] , 0 , strlen(txt[i])-1 );
        for( int j = 0; j < n; ++j ){
            for( int k = max((int)strlen(txt[i])-(int)strlen(txt[j]),0); k < strlen(txt[i]); ++k ){
                if( oksfx( txt[i] , txt[j] , k ) ){      if( done[j] == false ){ done[j] = 1 , q.push(j); }
                    strcpy( tmp , "xxxxxxx" );
                    for( int x = -1; x >= -6 && k+x >= 0; --x ){
                        for( int l = 0; l < m; ++l ) if( k+x+l < strlen(txt[i]) ) tmp[l] = txt[i][k+x+l];
                                                     else tmp[l] = txt[j][l+x];
                        putx( tmp[0], tmp[1], tmp[2], tmp[3], tmp[4] );
                    }
                }
            }
        }
    }

    int cnt = 0;
    for( bool *i = &ok[0][0][0][0][0]; i != &ok[25][25][25][25][25]; ++i )
        cnt += (*i != 0 );
    cnt += ok[25][25][25][25][25];

    printf("%d\n",cnt);

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <set>
#include <queue>
#include <map>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

const int maxn = 50000 + 55;

int n;
vector< pii > g[maxn];

void clear(){
    for( int i = 0; i <= n; ++i ) g[i].clear();
}

void input(){
    scanf("%d",&n);

    clear();

    for( int i = 0; i < n-1; ++i ){
        int a,b,c; scanf("%d%d%d",&a,&b,&c); a--, b--;
        g[a].push_back( mk(b,c) );
        g[b].push_back( mk(a,c) );
    }
}

int cost[maxn];

void dfs( int node, int dad ){
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i].f;
        if( nxt == dad ) continue;
        cost[nxt] = cost[node] + g[node][i].s;
        dfs( nxt , node );
    }
}

int mxnode(){
    int dx = 0;
    for( int i = 0; i < n; ++i )
        if( cost[i] > cost[dx] ) dx = i;
    return dx;
}

int main(){
  //  freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        input();

        cost[0] = 0;
        dfs( 0 , - 1 );

        int x = mxnode();
        cost[x] = 0;
        dfs( x , -1 );

        printf("%d\n",cost[mxnode()]);
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
using namespace std;

#define pq priority_queue
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 1050 + 55;
const int inf = 99999999;
int source = 1003 , sink = 1004;

struct edge{
    int a,b,cost,cap;
    int rev;
    edge(){};
    edge( int p1, int p2, int p3, int p4 ):a(p1),b(p2),cost(p3),cap(p4){};
};

int n,m;
int gon[maxn];
int dst[maxn];
vector< edge > e;

void clear(){
    source = n+n+1;
    sink = n+n+2;
    e.clear();

    for( int i = 0; i <= n+n+2; ++i ){
        dst[i] = 0;
    }
}

void add_edge( int a, int b, int c, int d ){
    e.push_back( edge( a, b, c, d ) );
    e.push_back( edge( b, a, -c, 0 ) );
    int sz = e.size();
    e[sz-1].rev = sz-2;
    e[sz-2].rev = sz-1;
}

void input(){
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ) scanf("%d",&gon[i]);
    scanf("%d",&m);

    clear();

    for( int i = 0; i < m; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        add_edge( a, b, 1, inf );
        add_edge( b, a, 1, inf );
    }
}

void getdst(){
    for( int i = 1; i <= n; ++i ){
        add_edge( source, gon[i-1], 0, 1 );
        add_edge( i+n, sink, 0, 1 );
        add_edge( i , i + n , 0 , inf );
    }
}

int cf = 0;
bool visi[maxn];
int prv[maxn];

int path(){
    for( int i = 0; i <= n+n+2; ++i ) prv[i] = -1, dst[i] = inf;

    dst[source] = 0;
    bool ok = 1;

    do{
        ok = 0;
        for( int i = 0; i < e.size(); ++i ){
            if( e[i].cap == 0 ) continue;
            int a = e[i].a , b = e[i].b;
            if( dst[b] > dst[a] + e[i].cost ){
                dst[b] = dst[a] + e[i].cost;
                prv[b] = i;
                ok = 1;
            }
        }
    }while(ok);

    if( dst[sink] == inf ) return 0;

    int node = sink;
    while( prv[node] != -1 ){
        int dx = prv[node];
        e[ dx ].cap --;
        e[e[ dx ].rev].cap ++;
        node = e[ dx ].a;
    }
    cf = dst[sink];
    return 1;
}

int flow(){
    int sol = 0, f;
    while( (f=path()) > 0 ) sol += cf;
    return sol;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        input();

        getdst();

        printf("%d\n",flow());
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
using namespace std;

#define pq priority_queue
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 1050 + 55;
const int inf = 999999999;
int source = 1003 , sink = 1004;

int n,m;
vector< int > exg[maxn];
vector< int > g[maxn];
int gon[maxn];

int dst[maxn];

int C[maxn][maxn];
int cap[maxn][maxn];

void clear(){
    source = n+n+1;
    sink = n+n+2;

    for( int i = 0; i <= n+n+2; ++i ){
        g[i].clear();
        exg[i].clear();
        dst[i] = 0;
        for( int j = 0; j <= n+n+2; ++j )
            cap[i][j] = C[i][j] = 0;
    }
}


void input(){
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ) scanf("%d",&gon[i]);
    scanf("%d",&m);

    clear();

    for( int i = 0; i < m; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        exg[a].push_back(b);
        exg[b].push_back(a);
    }
}

void add_edge( int a, int b, int c, int cp ){
    cap[a][b] += cp;
    C[b][a] = -(C[a][b] = c);
    g[a].push_back(b);
    g[b].push_back(a);
}

void getdst(){
    for( int i = 1; i <= n; ++i ){
        add_edge( source, gon[i-1], 0, 1 );
        add_edge( i+n, sink, 0, 1 );

        queue< int > q; q.push( i );
        for( int k = 0; k <= n; ++k ) dst[k] = 0;
        dst[i] = 1;

        while(!q.empty()){
            int u = q.front(); q.pop();

            for( int k = 0; k < exg[u].size(); ++k ){
                int nxt = exg[u][k];
                if( dst[nxt] == 0 ){
                    dst[nxt] = dst[u] + 1;
                    add_edge( i, nxt+n, dst[nxt] - 1, 1 );
                    q.push( nxt );
                }
            }
        }
    }
}


struct data{
    int node,flow,cost,prv;
    data(){};
    data( int p1, int p2, int p3 ):node(p1),flow(p2),cost(p3){};
    data( int p1, int p2, int p3, int p4 ):node(p1),flow(p2),cost(p3),prv(p4){};

    const inline bool operator<( const data &d2 ) const {
        return cost > d2.cost;
    }
};

int cf = 0;
bool visi[maxn];
int prv[maxn];

int path(){
    for( int i = 0; i <= n+n+2; ++i ) visi[i] = 0, prv[i] = -1, dst[i] = inf;

    data u;
    pq< data > q;
    q.push( data(source,inf,0,-1) );

    while( !q.empty() ){
        u = q.top(); q.pop();

        if( visi[u.node] ) continue;

        visi[ u.node ] = 1;
        prv[u.node] = u.prv;

        if( u.node == sink ) break;

        for( int i = 0; i < g[u.node].size(); ++i ){
            int x = g[u.node][i];
            if( visi[ x ] || cap[u.node][x] == 0 ) continue;

            if( dst[x] > u.cost + C[u.node][x] ){
                int f = min( u.flow , cap[u.node][x] );
                data add = data( g[u.node][i] , f , u.cost + C[u.node][x] );
                add.prv = u.node;

                dst[x] = u.cost + C[u.node][x];
                q.push( add );
            }

        }
    }

    cf = 0;
    if( u.node != sink ) return 0;

    int node = sink;
    while( prv[node] != -1 ){
        cap[ prv[node] ][ node ] -= u.flow;
        cap[ node ][ prv[node] ] += u.flow;
        node = prv[node];
    }
    cf = u.cost;
    return u.flow;
}

int flow(){
    int sol = 0, f;
    while( (f=path()) > 0 ) sol += cf;
    return sol;
}

int main(){
    freopen("Ulaz.txt","r",stdin);

    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        input();

        getdst();

        printf("%d\n",flow());
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
using namespace std;

int caseno;
int cards,card[512],present[512];
int xchange[512][512];

void read_input(){
    int c;
    int pairs,x,y;

    scanf("%d",&cards);
    for(c=1;c<=cards;c++)present[c]=0;
    for(c=1;c<=cards;c++){
        scanf("%d",&card[c]);
        present[card[c]]++;
    }
    scanf("%d",&pairs);
    while(pairs--){
        scanf("%d%d",&x,&y);
        xchange[x][y]=xchange[y][x] = caseno;
    }
}

typedef struct{
    int from,to;
    int cost,residual;
    int backedge;
}t_edge;

int vertices,edges;
t_edge edge[4*512*512];

void make_network(){
    int c1,c2;

    edges = 0;
    for(c1=1;c1<=cards;c1++)if(present[c1]){
        edge[edges]=(t_edge){0,2*c1,0,present[c1],-1}; edges++;
    }
    for(c1=1;c1<=cards;c1++){
        edge[edges++]=(t_edge){2*c1+1,1,0,1,-1};
    }
    for(c1=1;c1<=cards;c1++)for(c2=1;c2<=cards;c2++){
        if( c1 == c2 ){
            edge[edges]=(t_edge){2*c1,2*c2+1,0,cards,-1}; edges++;
            edge[edges]=(t_edge){2*c2+1,2*c1,0,cards,-1}; edges++;
        }else if(xchange[c1][c2]==caseno){
            edge[edges]=(t_edge){2*c1,2*c2+1,1,cards,edges+1};edges++;
            edge[edges]=(t_edge){2*c2+1,2*c1,-1,0,edges-1};edges++;
        }
    }
}

#define INFINITY 1000000000

int find_path(){
    static int mincost[1024],discovered[1024];
    int v,e,c,changed;

    mincost[0] = 0;
    for(v=1;v<2*cards+2;v++) mincost[v]=INFINITY;
    changed = 1;
    do{
        changed = 0;
        for(e=0;e<edges;e++) if( edge[e].residual&&(mincost[edge[e].from]<INFINITY)){
            if((c=mincost[edge[e].from]+edge[e].cost)>=mincost[edge[e].to])continue;
            mincost[edge[e].to]=c;
            discovered[edge[e].to]=e;
            changed=1;
        }
    }while(changed);

    v=1;
    while(v){
        e=discovered[v];
        edge[e].residual--;
        if(edge[e].backedge>=0)edge[edge[e].backedge].residual++;
        v=edge[e].from;
    }
    return mincost[1];
}

int calc_cost(){
    int c,result=0;
    for(c=1;c<=cards;c++)result+=find_path();
    return result;
}




int main(){
    freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz2.txt","w",stdout);
    int cases;
    scanf("%d",&cases);
    for(caseno=1;caseno<=cases;caseno++){
        read_input();
        make_network();
        printf("%d\n",calc_cost());
    }
    return 0;
}











#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <fstream>
#include <set>
#include <queue>
#include <map>
using namespace std;

int n = 500;

int main(){
    srand((unsigned)time(0));
    //while(1){
    ofstream out("Ulaz.txt");

    int t = 1;
    out<<t<<endl;
    while( t -- ){
        int n = 500;
        out<<n<<endl;
        for( int i = 0; i < n; ++i ) out << 1 + rand()%n << " "; out << endl;

        int m = n - 1;
        out<<m<<endl;
        for( int i = 1; i <= m; ++i ){
            out<<i<<" "<<i+1<<endl;
        }
    }
//    out.close();
//    system("GREED.exe");
//    cout<<"  ";
//    system("GREED_AMAROQ.exe");
//
//        if( system("diff -qb Izlaz.txt izlaz2.txt") ){
//            printf("WA\n");
//            while(1);
//        }else{
//            printf("AC\n");
//        }
  //  }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <iomanip>
#include <algorithm>
#include <map>
using namespace std;

const int maxn = 50000 + 55;

int n,m;
int s[maxn];

int bit[maxn];
void addb( int dx ){
    for( dx += 5; dx < n+10; dx += dx & -dx )
        bit[dx] ++;
}

int read( int dx ){
    int ret = 0;
    for( dx += 5; dx >= 1; dx -= dx & -dx ) ret += bit[dx];
    return ret;
}

int main(){
    for( int i = 1; i < maxn; ++i ) s[i] = s[i-1] + i;

    while( scanf("%d%d",&n,&m) == 2 ){
        if( n == -1 && m == -1 ) break;

        int sum = 0;
        for( int i = 0; i < n+10; ++i ) bit[i] = 0;

        for( int i = 0; i < n; ++i ){
            int lo = 0, hi = n-i-1;
            int add = s[n-i-2];
            while( lo < hi ){
                int mid = (lo+hi) >> 1;
                if( sum + add + mid >= m ) hi = mid;
                else lo = mid + 1;
            }
            sum += hi;

            printf("%d ",hi+read(hi)+1);
            addb( hi );
        }
        printf("\n");

    }
    return 0;
}

#include <iostream>
#include <cstdlib>
#include <algorithm>
#include <map>
#include <string.h>
#include <vector>
#include <iomanip>
using namespace std;

typedef long long ll;

const int inf = 999999316;
const int maxx = 2000000000;

bool ok( int x ){
    int p = 1 , n = 0;
    int a = -inf , b = -inf;
    for( int i = 2; i*i <= x || x > 1; ++i ){
        bool done = i*i > x;
        if( done ) i = x;

        if( x % i ) continue; x /= i;
        if( x % i == 0 ) return 0;
        n++;

        if( n == 2 ){
            if( p-1 == 0 || (i-p)%(p-1) ) return 0;
            a = (i - p) / (p-1);
            b = i - p*a;
        }
       // cout<<i<<" "<<a<<" "<<b<<" | "<<n<<" "<<p<<endl;
        if( a != -inf && a*p + b != i ) return 0;
        p = i;

        if( done ) break;
    }

    if( n < 3 ) return 0;
    return 1;
}

const int maxv = 1300;
const int maxt = 45000;
bool vis[maxt];
vector< int > p;

vector< int > valid;

int a,b;
void solve( int x, int dx, int n ){
    if( x == 3*53*1303 ) cout<<"!"<<endl;
    if( n >= 3 ){
       valid.push_back( x );
    }

    for( int i = dx; i < p.size(); ++i ){
        if( x*(ll)p[i] > maxx ) continue;

        if( n == 1 ){
            if( p[dx-1]-1 == 0 || (p[i]-p[dx-1])%(p[dx-1]-1) ) continue;;
            a = (p[i] - p[dx-1]) / (p[dx-1]-1);
            b = p[i] - p[dx-1]*a;
        }

        if( a != -inf && a*p[dx-1] + b != p[i] ) continue;

        solve( x * p[i] , i + 1 , n + 1 );

        if( n == 1 ) a = b = -inf;
    }
}

bool prime( int x ){
    if( x % 2 == 0 && x != 2 ) return 0;
    for( int i = 3; i*i <= x; i += 2 ) if( x % i == 0 ) return 0;
    return 1;
}

int main(){
    p.push_back(1);
    for( int i = 2; i < maxt; ++i ){
        if( vis[i] ) continue;
        p.push_back( i );
        for( int j = i+i; j < maxt; j += i ) vis[j] = 1;
    }
    int sz = p.size();
    for( int i = 1; i < sz; ++i ){
        for( int j = i+1; j < sz; ++j ){
            if( p[i]-1 == 0 || (p[j]-p[i])%(p[i]-1) ) continue;;
            a = (p[j] - p[i]) / (p[i]-1);
            b = p[j] - p[i]*a;

            int x = p[j];
            int w = p[i] * p[j];
            do{
                x = x * a + b;
                if( x * (ll)w > maxx || !prime(x) ) break;
                w *= x;
                valid.push_back( w );
            }while(1);
        }
    }
    sort( valid.begin() , valid.end());
   // for( int i = 0; i < 20; ++i ) cout<<valid[i]<<" ";cout<<endl;

    int tests; scanf("%d",&tests);
    while( tests -- ){
        int lo , hi;
        scanf("%d%d",&lo,&hi);
        int sol = upper_bound( valid.begin() , valid.end() , hi ) - valid.begin();
        sol -= upper_bound( valid.begin() , valid.end() , lo - 1 ) - valid.begin();

        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
using namespace std;

typedef long long ll;

const int maxn = 10000 + 55;
const ll inf = 99999999999999LL;

int n;
int a[maxn];
int p[maxn];
ll dp[2][maxn/2];

inline void readi(int &v){
    char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c-'0';
    while( (c=getchar())>='0' && c <= '9' ) v = v*10 + c-'0';
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int i = 0; i < n; ++i )
        readi( p[i] ), readi( a[i] );

    bool mode = true;
    int c2 = n/2;

    for( int i = 0; i < n; ++i ){
        ll f,s;
        f = s = inf;
        for( int j = 0; j <= c2; ++j ){
            if( j ){
                if( i ) f = dp[!mode][j-1] + a[i];
                else f = a[i];
            }

            if( j < c2 ){
                if( i ) s = dp[!mode][j+1] + p[i];
                else s = p[i];
            }

            dp[mode][j] = f;
            if( dp[mode][j] > s ) dp[mode][j] = s;
        }
        mode = !mode;
    }

    printf("%lld\n",dp[!mode][0]);

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
using namespace std;

typedef long long ll;

const int maxn = 10000 + 55;

int n;
int a[maxn];
int p[maxn];

inline void readi(int &v){
    char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c-'0';
    while( (c=getchar())>='0' && c <= '9' ) v = v*10 + c-'0';
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int i = 0; i < n; ++i )
        readi( p[i] ), readi( a[i] );

    priority_queue< ll > pq;
    ll sol = 0;

    for( int i = 0; i < n; ++i ){
        sol += p[i];
        if( i%2 == 1 )sol -= pq.top(), pq.pop();
        pq.push( p[i] - a[i] );
    }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
using namespace std;

typedef long long ll;

const int maxn = 10000 + 55;

int n;
int nxt[maxn], prv[maxn];
ll dstnxt[maxn], dstprv[maxn];
int L[maxn];

ll f,b;

void input(){
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%d%d",&L[i],&dstnxt[i]);
        nxt[i] = (i+1)%n;
        prv[i] = (i-1+n)%n;
        if( i ) dstprv[i] = dstnxt[i-1];
    }
    dstprv[0] = dstnxt[n-1];
}

int fwrd_wins( int city ){
    ll f = 0;

    ll b = 0;
    for( int i = 0; i < n; ++i ) b += dstnxt[i];

    int sol = city;

    for( int i = nxt[city]; i != city; i = nxt[i] ){
        f += dstprv[i];
        b -= dstprv[i];
        if( f <= b ){
            sol = i;
            ::f = f;
            ::b = b;
        }
    }

    return sol;
}

ll solve(){
    int T = fwrd_wins( 0 );
    ll dst = 0;
    ll costf = 0, costb = 0;
    ll lf = L[0], lb = 0;

    for( int i = 1; i <= T; ++i ){
        dst += dstprv[i];
        costf += dst * L[i];
        lf += L[i];
    }

    dst = 0;
    for( int i = prv[0]; i != T; i = prv[i] ){
        dst += dstnxt[i];
        costb += dst * L[i];
        lb += L[i];
    }

    ll sol = costf + costb;

    for( int i = 1; i < n; ++i ){
        lb += L[ prv[i] ];
        lf -= L[ prv[i] ];

        costf -= dstprv[i] * lf;
        costb += dstprv[i] * lb;

        f -= dstprv[i];
        b += dstprv[i];


        while( f+dstnxt[T] <= b-dstnxt[T] ){
            f += dstnxt[T];
            b -= dstnxt[T];
            T = nxt[T];
            lb -= L[T];
            lf += L[T];
            costf += L[T] * f;
            costb -= L[T] * b;
        }
        sol = min( sol , costf + costb );
        //cout<<i<<" "<<costf<<" , "<<costb<<" || "<<f<<" , "<<b<<" ["<<T<<"]"<<endl;
    }

    return sol;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        input();
        ll sol = solve();

        cout << sol << endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <cstdio>
#include <string.h>
#include <string>
#include <assert.h>
#include <stack>
using namespace std;

const int maxn = 100000 + 5;
const int inf = 10000;

int n;
int v[maxn][3];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int t = 1;

    while( scanf("%d",&n) ){
        if( n == 0 ) break;

        for( int i = 0; i < n; ++i ) scanf("%d%d%d",&v[i][0],&v[i][1],&v[i][2]);

        v[0][2] += v[0][1];
        v[0][0] = inf;

        for( int i = 1; i < n; ++i ){
            for( int k = 0; k < 3; ++k )
                if( k == 1 ) v[i][k] = min(  min(v[i][k-1],v[i-1][k+1]) , min(v[i-1][k-1] , v[i-1][k])  ) + v[i][k];
                else if( k == 0 ) v[i][k] = min(v[i-1][k],v[i-1][k+1]) + v[i][k];
                else v[i][k] = min( v[i-1][k],min(v[i-1][k-1],v[i][k-1]) ) + v[i][k];
        }

        printf("%d. %d\n",t++,v[n-1][1]);
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
using namespace std;

typedef long long ll;

struct segt{
    vector< ll > tree;
    int begin;

    void init(int n){
        int sz = 1;
        while( sz < n ) sz <<= 1;
        begin = sz;
        sz <<= 1;
        tree.resize(sz);
        for( int i = 0; i < sz; ++i ) tree[i] = 0;
    }

    segt(){};
    segt( int n ){ init(n+50); }

    int l,r;
    ll v;

    void _update( int node, int lo, int hi ){
        if( l <= lo && hi <= r ){
            tree[node] += (hi-lo+1)*v;
            return;
        }
        if( node >= begin || hi < l || lo > r ) return;

        ll moje = tree[node] - tree[node*2] - tree[node*2+1];
        tree[node*2] += moje >> 1;
        tree[node*2+1] += moje >> 1;


        int mid = (lo+hi)>>1;
        _update( node * 2 , lo , mid );
        _update( node * 2 + 1 , mid+1, hi );

        tree[node] = tree[node*2] + tree[node*2+1];

    }

    ll _read( int node , int lo, int hi ){
        if( l <= lo && hi <= r ) return tree[node];
        if( node >= begin || hi < l || lo > r ) return 0;

        ll moje = tree[node] - tree[node*2] - tree[node*2+1];
        tree[node*2] += moje >> 1;
        tree[node*2+1] += moje >> 1;

        int mid = (lo+hi)>>1;
        ll sol = _read( node * 2 , lo , mid ) + _read( node * 2 + 1 , mid+1, hi );
        tree[node] = tree[node*2] + tree[node*2+1];
        return sol;
    }

    ll read( int lo, int hi ){
        l = lo + begin;
        r = hi + begin;
        return _read( 1 , begin , begin*2-1);
    }

    void update( int lo, int hi, int val ){
        l = lo + begin;
        r = hi + begin;
        v = val;
        _update( 1 , begin , begin*2-1);
    }

};

segt t(1);

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    while( tests -- ){
        int n,m; scanf("%d%d",&n,&m);

        t.init(n);

        for( int i = 0; i < m; ++i ){
            int c; scanf("%d",&c);
            int a,b,v;
            if( c == 0 ){ scanf("%d%d%d",&a,&b,&v); a-- , b--;
                t.update( a , b , v );
            }else{ scanf("%d%d",&a,&b); a--, b--;
                ll sol = t.read( a , b );
                printf("%lld\n",sol);
            }
        }

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <string.h>
#include <set>
#include <queue>
using namespace std;

const int mod = 1000000007;

int main(){
    int n; scanf("%d",&n);
    int sol = 1;
    for( int i = 1; i < n; ++i ) sol = (sol*(long long)i)%mod;
    printf("%d\n",(sol*(long long)sol)%mod);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
using namespace std;

int n;
char mat[55][55];

int cnt[55];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests ; --tests ){
        scanf("%s",mat[0]);
        n = strlen(mat[0]);
        for( int i = 1; i < n; ++i ) scanf("%s",mat[i]);

        memset( cnt , 0 , sizeof(cnt));

        for( int i = 0; i < n; ++i )
            for( int j = i+1; j < n; ++j )
                if( mat[i][j] == 'N' )
                for( int k = 0; k < n; ++k ){
                    if( k!=i && k!=j && mat[i][k] == 'Y' && mat[k][j] == 'Y' ){
                        cnt[i]++, cnt[j]++;
                        break;
                    }
                }

        int mx = 0 , dx = 0;
        for( int i = 0; i < n; ++i )
            if( cnt[i] > mx ) dx = i , mx = cnt[i];

        printf("%d %d\n",dx,mx);

    }
    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <math.h>
#include <set>
#include <iomanip>
#include <cstdio>
#include <cstdlib>
using namespace std;

typedef long long ll;

const int maxn = 50000 + 55;

int n,m;
ll x[maxn], y[maxn];

ll ss[maxn];

ll range( int x, int y ){
    return ss[y] - ss[x];
}

ll det( int a, int b ){
    return x[a]*y[b] - x[b]*y[a];
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);

    for( int i = 0; i < n; ++i )
        scanf("%lld%lld",&x[i],&y[i]);


    for( int i = 1; i < n; ++i )
        ss[i] = ss[i-1] + det(i-1,i);

    for( int i = 0; i < m; ++i ){
        int a,b; scanf("%d%d",&a,&b);

        int t = a;
        a = min(a,b);
        b = max(t,b);

        ll s1 = range( a , b ) + det(b,a);
        ll s2 = range( b , n-1 ) + det(n-1,0) + range(0,a) + det( a , b );

        double sol = min(abs(s1),abs(s2))/2.00;

      //  printf("[%d,%d] %d %d\n",a,b,s1,s2);
        printf("%.1lf\n",sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <cstdlib>
#include <cstdio>
#include <math.h>
#include <queue>
#include <set>
#include <stack>
using namespace std;

const int maxn = 1000000;

vector< int > p;
bool notprime[maxn];


int main(){
    for( int i = 2; i < maxn; ++i ){
        if( notprime[i] )continue;
        p.push_back(i);
        for( int j = i+i; j < maxn; j += i )
            notprime[j] = 1;
    }

    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        int x; scanf("%d",&x);

        int sol = 1;

        for( int i = 0; p[i]*p[i] <= x; ++i ){
            int cnt = 0;
            while( x % p[i] == 0 ){
                x /= p[i];
                cnt ++;
            }
            sol = max( sol , cnt );
        }

        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <stack>
#include <map>
#include <string.h>
#include <set>
#include <queue>
#include <iomanip>
using namespace std;

int inf = 16843009;

int d[10];

int sz;
int digits[105];

int L;
int dp[105][205][11];

int solve( int dx, int cnt_minus, int sum ){
    if( dx == sz ){
        if( sum == 0 ){
            if( cnt_minus < 0 ) return abs(cnt_minus)-1;
            else return abs(cnt_minus);
        }
        else return inf;
    }

    int &sol = dp[dx][cnt_minus+sz][sum];
    if( sol != inf ) return sol;

    int f = solve( dx + 1, cnt_minus+1, (sum - digits[dx]+11)%11 );
    int s = solve( dx + 1, cnt_minus-1, (sum + digits[dx]+11)%11 );

    return sol = min(f,s);
}


int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        sz = 0;
        for( int i = 1; i <= 9; ++i ){
            scanf("%d",&d[i]);
            for( int x = d[i]; x --; ) digits[sz++] = i;
        }

        L = sz * 9;
        for( int i = 0; i <= sz; ++i )
            for( int j = 0; j <= (sz<<1); ++j )
                for( int k = 0; k <= 11; ++k )
                    dp[i][j][k] = inf;

        int sol = solve( 0 , 0 , 0 );

        if( sol != inf ) printf("%d\n",sol+sz);
        else printf("-1\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <queue>
using namespace std;

#define pii pair<int,int>


typedef long long ll;

const int inf = 999999999;
const int maxn = 300000 + 55;

int n;
int v[maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ) scanf("%d",&v[i]);

    ll sol = 0;

    priority_queue< pii > pqlo;
    priority_queue< pii > pqhi;

    ll curr = 0;

    for( int i = 0; i < n; ++i ){
        ll cnt, ss;

        cnt = 0 , ss = 0;
        while( pqlo.empty() == false ){
            int u = inf-pqlo.top().f , c = pqlo.top().s;
            if( u > v[i] ) break;
            cnt += c;
            ss += u*(ll)c;
            pqlo.pop();
        }

        curr += cnt*(ll)v[i] - ss;
        pqlo.push( mk(inf-v[i],cnt) );

        cnt = 0 , ss = 0;
        while( pqhi.empty() == false ){
            int u = pqhi.top().f , c = pqhi.top().s;
            if( u < v[i] ) break;
            cnt += c;
            ss += u*(ll)c;
            pqhi.pop();
        }

        curr += ss - cnt*v[i];
        pqhi.push( mk(v[i],cnt) );

        sol += curr;

        pqlo.push( mk(inf-v[i],1) );
        pqhi.push( mk(v[i],1) );
    }
    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <set>
#include <queue>
#include <algorithm>
#include <map>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
#include <cstdlib>
#include <stack>
using namespace std;

typedef long long ll;

const int inf = 999999999;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

const int maxn = 300000 + 55;

int v[maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);

    int n; scanf("%d",&n);
    for( int i = 0; i < n; ++i ) scanf("%d",&v[i]);

    ll sol = 0;

    for( int i = 0; i < n; ++i ){
        ll mini = inf , maxi = -inf;

        for( int j = i; j < n; ++j ){
            mini = min( mini , (ll)v[j] );
            maxi = max( maxi , (ll)v[j] );
            sol += maxi - mini;
        }
    }

    cout<< sol << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <set>
#include <queue>
#include <algorithm>
#include <map>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
#include <cstdlib>
#include <stack>
#include <fstream>
using namespace std;

int n = 300000;

int main(){
    ofstream out("Ulaz.txt");

    out<<n<<endl;
    for( int i = 0; i < n; ++i ) out<<i+1<<" ";
    out<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <map>
#include <set>
#include <fstream>
#include <queue>
#include <assert.h>
#include <iomanip>
#include <math.h>
using namespace std;

const int inf = 999999;

int constD = 8;
int d[][2] = {{0,1} , {0,-1} , {1,0} , {-1,0} , {1,1} , {-1,-1} , {1,-1} , {-1,1} };

struct coord{
    int x,y;
    coord(){};
    coord( int p1, int p2 ):x(p1),y(p2){};

    inline int dst( coord b ){ return (int)sqrt( (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y) ); }
    inline double dss( coord b ){ return sqrt( (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y) ); }
    inline int pdst( coord b ){ return (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y); }
};

struct customer{
    int w;
    double val;
    coord p;
    inline int cost( coord u ){ return w * p.dst( u ); }
    inline double dcost( coord u ){ return w*p.dss( u ); }

    customer(){};
    customer( int p1, int p2, int p3 ):w(p3){
        p = coord(p1,p2);
        val = w*sqrt( p1*p1 + p2*p2 );
    }
};

int n,m;
vector< customer > v;
vector< coord > sols;

double inc( coord p ){
    double sol = 0;
    for( int i = 0; i < v.size(); ++i ){
        double q = v[i].val - v[i].cost(p);
        if( q > 0 ) sol += q;
    }
    return sol;
}


void update( coord p ){
    for( int i = 0; i < v.size(); ++i ){
        double x = v[i].dcost( p );
        if( v[i].val - x >= 0 )
            v[i].val = x;
    }
}

double refresh(){
    double ret = 0;
    for( int i = 0; i < n; ++i ){
        int dx = 0;
        for( int j = 1; j < sols.size(); ++j ) if( v[i].p.pdst( sols[j] ) < v[i].p.pdst( sols[dx] ) ) dx = j;

        v[i].val = v[i].dcost( sols[dx] );
        ret += v[i].val;
    }
    return ret;
}

double state(){
    double ret = 0;
    for( int i = 0; i < n; ++i ) ret += v[i].val;
    return ret;
}



int main(){
    //srand((unsigned)time(0));
    freopen("Ulaz.txt","r",stdin);
  //  freopen("Izlaz.txt","w",stdout);

    int tests; scanf("%d",&tests);

    double A = clock();
    for( int t = 1; tests; --tests , t++){
        scanf("%d%d",&n,&m);

        v.clear();
        sols.clear();
        for( int i = 0; i < n; ++i ){
            int a,b,c; scanf("%d%d%d",&a,&b,&c); // x,y,w
            v.push_back( customer(a,b,c) );
        }

        printf("CASE %d Y\n",t);
        sols.clear();


        for( int i = 0; i < m; ++i ){
            coord best = coord(0,0);
            double better = 0;
            for( int j = 0; j < n; ++j ){
                double w = inc( v[j].p );
                if( w > better ){
                    better = w;
                    best = v[j].p;
                }
            }
            update( best );
            sols.push_back( best );
        }
        double curr = refresh();
        int till = 1,ctill = 4;
        if( m > 20 ) till = 1;
        if( m < 5 ) ctill = 8;

        for( int i = 0; i < till; ++i ){
                bool ok = false;

                for( int stp = 16; stp >= 1; stp /= 2 ){
                    for( int k = 0; k < sols.size(); ++k ){
                        int bdx = -1;
                        double now = curr;

                        for( int i = 0; i < ctill; ++i ){
                            coord nxt = sols[k];
                            sols[k].x += stp*d[i][0];
                            sols[k].y += stp*d[i][1];
                            double r = refresh();
                            if( r < now ) ok = true, now = r , bdx = i;
                            sols[k] = nxt;
                        }

                        if( bdx != -1 ){
                            sols[k].x += stp*d[bdx][0];
                            sols[k].y += stp*d[bdx][1];
                            curr = now;
                        }
                    }
                }

              //  printf("%.10lf\n",state());
                if( !ok ) break;
        }

        printf("%.10lf\n",state());
        for( int i =0 ; i < sols.size(); ++i )
            printf("%d %d\n",sols[i].x,sols[i].y);



    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <map>
#include <set>
#include <fstream>
#include <queue>
#include <assert.h>
#include <iomanip>
#include <math.h>
using namespace std;

const int inf = 999999;

int constD = 8;
int d[][2] = {{0,1} , {0,-1} , {1,0} , {-1,0} , {1,1} , {-1,-1} , {1,-1} , {-1,1} };

struct coord{
    int x,y;
    coord(){};
    coord( int p1, int p2 ):x(p1),y(p2){};

    inline int dst( coord b ){ return (int)sqrt( (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y) ); }
    inline double dss( coord b ){ return sqrt( (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y) ); }
    inline int pdst( coord b ){ return (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y); }
};

struct customer{
    int w;
    double val;
    coord p;
    inline int cost( coord u ){ return w * p.dst( u ); }
    inline double dcost( coord u ){ return w*p.dss( u ); }

    customer(){};
    customer( int p1, int p2, int p3 ):w(p3){
        p = coord(p1,p2);
        val = w*sqrt( p1*p1 + p2*p2 );
    }
};

int n,m;
vector< customer > v;
vector< coord > sols;

double inc( coord p ){
    double sol = 0;
    for( int i = 0; i < v.size(); ++i ){
        double q = v[i].val - v[i].cost(p);
        if( q > 0 ) sol += q;
    }
    return sol;
}


void update( coord p ){
    for( int i = 0; i < v.size(); ++i ){
        double x = v[i].dcost( p );
        if( v[i].val - x >= 0 )
            v[i].val = x;
    }
}

double refresh(){
    double ret = 0;
    for( int i = 0; i < n; ++i ){
        int dx = 0;
        for( int j = 1; j < sols.size(); ++j ) if( v[i].p.pdst( sols[j] ) < v[i].p.pdst( sols[dx] ) ) dx = j;

        v[i].val = v[i].dcost( sols[dx] );
        ret += v[i].val;
    }
    return ret;
}

double state(){
    double ret = 0;
    for( int i = 0; i < n; ++i ) ret += v[i].val;
    return ret;
}



int main(){
    //srand((unsigned)time(0));
   // freopen("Ulaz.txt","r",stdin);
  //  freopen("Izlaz.txt","w",stdout);

    int tests; scanf("%d",&tests);

    double A = clock();
    for( int t = 1; tests; --tests , t++){
        scanf("%d%d",&n,&m);

        v.clear();
        sols.clear();
        for( int i = 0; i < n; ++i ){
            int a,b,c; scanf("%d%d%d",&a,&b,&c); // x,y,w
            v.push_back( customer(a,b,c) );
        }

        printf("CASE %d Y\n",t);
        sols.clear();


        for( int i = 0; i < m; ++i ){
            coord best = coord(0,0);
            double better = 0;
            for( int j = 0; j < n; ++j ){
                double w = inc( v[j].p );
                if( w > better ){
                    better = w;
                    best = v[j].p;
                }
            }
            update( best );
            sols.push_back( best );
        }
        double curr = refresh();
        int till = 1,ctill = 4;
        if( m > 20 ) till = 1;
        if( m < 5 ) ctill = 8;

        for( int i = 0; i < till; ++i ){
                bool ok = false;

                for( int stp = 16; stp >= 1; stp /= 2 ){
                    for( int k = 0; k < sols.size(); ++k ){
                        int bdx = -1;
                        double now = curr;

                        for( int i = 0; i < ctill; ++i ){
                            coord nxt = sols[k];
                            sols[k].x += stp*d[i][0];
                            sols[k].y += stp*d[i][1];
                            double r = refresh();
                            if( r < now ) ok = true, now = r , bdx = i;
                            sols[k] = nxt;
                        }

                        if( bdx != -1 ){
                            sols[k].x += stp*d[bdx][0];
                            sols[k].y += stp*d[bdx][1];
                            curr = now;
                        }
                    }
                }

              //  printf("%.10lf\n",state());
                if( !ok ) break;
        }

        //printf("%.10lf\n",state());
        for( int i =0 ; i < sols.size(); ++i )
            printf("%d %d\n",sols[i].x,sols[i].y);



    }
    return 0;
}

#include <cstdio>
#include <math.h>
#include <algorithm>
#include <string.h>
#include <time.h>
using namespace std;

const int maxn = 2000 + 55;
const double eps = 10e-20;
const int inf = 999999999;

int d[][2] = { {0,0} , {0,1} , {0,-1} , {1,0} , {-1,0} , {1,1} , {-1,-1} , {1,-1} , {-1,1} , {1,4} , {-1,4} , {1,-4}, {-1,-4} };

int n,k;
int x[maxn], y[maxn], w[maxn];
double cost[maxn];

int sx[maxn], sy[maxn], sz = 0;

int mdx[maxn], msz = 0;
int bdx[maxn], bsz = 0;

int managed_by[maxn];

double dst( int x1, int y1, int x2, int y2 ){
    return sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );
}

double state(){
    double ret = 0;
    for( int i = 0; i < n; ++i ) ret += cost[i];
    return ret;
}

int main(){
    srand((unsigned)time(0));
   // freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( int t = 1; tests; --tests,++t ){
        scanf("%d%d",&n,&k);
        for( int i = 0; i < n; ++i ){
            scanf("%d%d%d",&x[i],&y[i],&w[i]);
            cost[i] = dst( 0, 0, x[i], y[i] ) * w[i];
            managed_by[i] = 0;
        }

        int hlf = 1500;

        sz = k+1;
        for( int i = 1; i <= k; ++i ){
            double best = -1; bsz = 0;
            int dxs = 0;
            for( int j = 0 , cnt = n-1; cnt >= 0; ++j,--cnt ){
                if( n == 2000 && cnt == hlf) break;
                if( n == 2000 ) j = rand()%n;
                msz = 0;
                double inc = 0;
                for( int k = 0; k < n; ++k ){
                    double a = cost[k] - w[k]*dst( x[j], y[j], x[k], y[k] );
                    if( a > 0 )inc += a;
                    if( a > 0 ) mdx[msz++] = k;
                }
                if( inc > best ){
                    best = inc;
                    bsz = msz;
                    dxs = j;
                    for( int k = 0; k < bsz; ++k ) bdx[k]= mdx[k];
                }
            }
            for( int j = 0; j < bsz; ++j ){
                int dx = bdx[j];
                managed_by[dx] = i;
                cost[dx] = w[dx] * dst( x[dx] ,y[dx] ,x[dxs],y[dxs] );
            }
            sx[i] = x[dxs], sy[i] = y[dxs];
        }

        int runs = 6;
        int csteps = 9+4;

        //if( k > 20 ) runs = 1;
        //if( k < 5 ) csteps = 8;
        printf("CASE %d Y\n",t);

        if( n == 800 ) runs --;

        for( ; runs -- ; ){
            for( int stp = 512; stp >= 1; stp /= 2 ){
                for( int k = 1; k < sz; ++k ){
                    int bdx = -1;
                    double best = 0;
                    bsz = 0;


                    for( int i = 0; i < csteps; ++i ){
                        double inc = 0;
                        int xt = sx[k] , yt = sy[k];
                        msz = 0;
                        xt += stp*d[i][0];
                        yt += stp*d[i][1];



                        for( int j = 0; j < n; ++j ){
                            double c = cost[j];
                            if( managed_by[j] == k ){
                                c = inf;
                                for( int l = 0; l < sz; ++l ){
                                    if( l == k ) continue;
                                    c = min( c , w[j]*dst( x[j], y[j], sx[l], sy[l] ) );
                                }
                            }

                            double a = c - w[j]*dst( xt, yt, x[j], y[j] );
                            if( a > 0 ) inc += a, mdx[msz++] = j;
                        }

                        if( inc > best ){
                            best = inc , bdx = i, bsz = msz;
                            for( int k = 0; k < bsz; ++k ) ::bdx[k]= mdx[k];
                        }
                    }

                    if( bdx != -1 ){
                       // printf("%.10lf\n",state());
                        sx[k] += stp*d[bdx][0];
                        sy[k] += stp*d[bdx][1];
                        for( int i = 0; i < bsz; ++i ){
                            int dx = ::bdx[i];
                            cost[dx] = w[dx] * dst( x[dx] ,y[dx] ,sx[k], sy[k] );
                        }
                        //printf("%.10lf\n\n",state());
                    }
                }
            }
        }

        for( int i = 1; i < sz; ++i )
            printf("%d %d\n",sx[i],sy[i]);

      //  printf("%.10lf\n",state());
        //printf("\n\n");

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <map>
#include <set>
#include <fstream>
#include <queue>
#include <assert.h>
#include <iomanip>
#include <math.h>
using namespace std;

const int inf = 999999;

int d[][2] = {{0,1} , {0,-1} , {1,0} , {-1,0} };

struct coord{
    int x,y;
    coord(){};
    coord( int p1, int p2 ):x(p1),y(p2){};

    int dst( coord b ){ return (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y); }
};

struct customer{
    int w,val;
    coord p,n;
    int cost( coord u ){ return w * p.dst( u ); }

    customer(){};
    customer( int p1, int p2, int p3 ):w(p3){
        p = coord(p1,p2);
        n = coord(0,0);
        val = cost( n );
    }
};

int n,m;
vector< customer > v;

int inc( coord p ){
    int sol = 0;
    for( int i = 0; i < v.size(); ++i ) sol += max( 0 , v[i].val - v[i].cost( p ) );
    return sol;
}

int makes_inc( coord p ){
    int sol = 0;
    for( int i = 0; i < v.size(); ++i ) sol += v[i].cost( p );
    return sol;
}

void update( coord p ){
    for( int i = 0; i < v.size(); ++i ){
        if( v[i].val - v[i].cost( p ) >= 0 ){
            v[i].val = v[i].cost(p);
            v[i].n = p;
        }
    }
}

int state(){
    int ret = 0;
    for( int i = 0; i < n; ++i ) ret += v[i].val;
    return ret;
}

coord best;

void chk( coord p , int v , int &sol ){
    if( sol < v ){
        sol = v;
        best = p;
    }
}

coord T;
void trybetter( coord c , int now , int step ){
    T = c;
    if( step == 2 ) return;

    for( int i = 0; i < 4; ++i ){
        coord nxt = c;
        nxt.x += d[i][0];
        nxt.y += d[i][1];

        int t = inc( nxt );

        if( t > now ){
            trybetter( nxt , t , step + 1 );
        }
    }
}

bool visi[1000];

int comps( int range ){
    int C = 0;
    memset( visi , false , sizeof(visi));
    for( int i = 0; i < n; ++i ){
        if( visi[i] ) continue;
        C++;
        for( int j = 0; j < n; ++j ){
            int r = v[i].p.dst( v[j].p );
            if( r <= range ) visi[j] = 1;
        }
    }
    return C;
}

void getcrds( int range ){
    memset( visi , false , sizeof(visi));
    for( int i = 0; i < n; ++i ){
        if( visi[i] ) continue;
        int cnt = 1;
        int better = 0;
        coord C = v[i].p;
        coord best = coord(0,0);

        for( int j = 0; j < n; ++j ){
            int r = v[i].p.dst( v[j].p );
            if( r <= range && visi[j] == false ){
                visi[j] = true;
                cnt ++;
                C.x += v[j].p.x;
                C.y += v[j].p.y;

                int w = inc( v[i].p );
                if( w > better ){
                    better = w;
                    best = v[i].p;
                }
            }
        }
        C.x /= cnt;
        C.y /= cnt;
        int w = inc( C );
        if( w > better ){
            better = w;
            best = C;
        }
        printf("%d %d\n",C.x,C.y);
        update( C );
    }
}

int main(){
    srand((unsigned)time(0));
    freopen("Ulaz.txt","r",stdin);

    int tests; scanf("%d",&tests);

    for( int t = 1; tests; --tests , t++){
        scanf("%d%d",&n,&m);

        v.clear();
        for( int i = 0; i < n; ++i ){
            int a,b,c; scanf("%d%d%d",&a,&b,&c); // x,y,w
            v.push_back( customer(a,b,c) );
        }


        if( n <= 20 ){
            printf("CASE %d Y\n",t);

            int lo = 0 , hi = 1000*1000*4;
            while( lo < hi ){
                int mid = (lo+hi)>>1;

                if( comps( mid ) <= m ) hi = mid;
                else lo = mid + 1;
            }
            getcrds( hi );
        }else{
            printf("CASE %d Y\n",t);

            int sinc = 0;
            for( int i = 0; i < m; ++i ){
                coord best = coord(0,0);
                int better = 0;
                for( int j = n-1; j >= 0; --j ){
                    int w = inc( v[j].p );
                    if( w > better ){
                        better = w;
                        best = v[j].p;
                    }
                }
                update( best );
                printf("%d %d\n",best.x,best.y);

            }
        }
        cout<<state()<<endl;

    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <map>
#include <set>
#include <fstream>
#include <queue>
#include <assert.h>
#include <iomanip>
#include <math.h>
using namespace std;

const int inf = 999999;

int d[][2] = {{0,1} , {0,-1} , {1,0} , {-1,0} };

struct coord{
    int x,y;
    coord(){};
    coord( int p1, int p2 ):x(p1),y(p2){};

    int dst( coord b ){ return (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y); }
};

struct customer{
    int w,val;
    coord p,n;
    int cost( coord u ){ return w * p.dst( u ); }

    customer(){};
    customer( int p1, int p2, int p3 ):w(p3){
        p = coord(p1,p2);
        n = coord(0,0);
        val = cost( n );
    }
};

int n,m;
vector< customer > v;
vector< coord > sols;

int inc( coord p ){
    int sol = 0;
    for( int i = 0; i < v.size(); ++i ) sol += max( 0 , v[i].val - v[i].cost( p ) );
    return sol;
}

int makes_inc( coord p ){
    int sol = 0;
    for( int i = 0; i < v.size(); ++i ) sol += v[i].cost( p );
    return sol;
}

void update( coord p ){
    for( int i = 0; i < v.size(); ++i ){
        if( v[i].val - v[i].cost( p ) >= 0 ){
            v[i].val = v[i].cost(p);
            v[i].n = p;
        }
    }
}

int refresh(){
    int ret = 0;
    for( int i = 0; i < n; ++i ){
        int dx = 0;
        for( int j = 1; j < sols.size(); ++j )
            if( v[i].p.dst( sols[j] ) < v[i].p.dst( sols[dx] ) ) dx = j;

        v[i].n = sols[dx];
        v[i].val = v[i].cost( sols[dx] );
        ret += v[i].val;
    }
    return ret;
}

coord best;

void chk( coord p , int v , int &sol ){
    if( sol < v ){
        sol = v;
        best = p;
    }
}

coord T;
void trybetter( coord c , int now , int step ){
    T = c;
    if( step == 2 ) return;

    for( int i = 0; i < 4; ++i ){
        coord nxt = c;
        nxt.x += d[i][0];
        nxt.y += d[i][1];

        int t = inc( nxt );

        if( t > now ){
            trybetter( nxt , t , step + 1 );
        }
    }
}

bool visi[1000];

int comps( int range ){
    int C = 0;
    memset( visi , false , sizeof(visi));
    for( int i = 0; i < n; ++i ){
        if( visi[i] ) continue;
        C++;
        for( int j = 0; j < n; ++j ){
            int r = v[i].p.dst( v[j].p );
            if( r <= range ) visi[j] = 1;
        }
    }
    return C;
}

void getcrds( int range ){
    memset( visi , false , sizeof(visi));
    for( int i = 0; i < n; ++i ){
        if( visi[i] ) continue;
        int cnt = 1;
        int better = 0;
        coord C = v[i].p;
        coord best = coord(0,0);

        for( int j = 0; j < n; ++j ){
            int r = v[i].p.dst( v[j].p );
            if( r <= range && visi[j] == false ){
                visi[j] = true;
                cnt ++;
                C.x += v[j].p.x;
                C.y += v[j].p.y;

                int w = inc( v[i].p );
                if( w > better ){
                    better = w;
                    best = v[i].p;
                }
            }
        }
        C.x /= cnt;
        C.y /= cnt;
        int w = inc( C );
        if( w > better ){
            better = w;
            best = C;
        }
        printf("%d %d\n",C.x,C.y);
        update( C );
    }
}

int main(){
    srand((unsigned)time(0));
  //  freopen("Ulaz.txt","r",stdin);

    int tests; scanf("%d",&tests);

    for( int t = 1; tests; --tests , t++){
        scanf("%d%d",&n,&m);

        v.clear();
        sols.clear();
        for( int i = 0; i < n; ++i ){
            int a,b,c; scanf("%d%d%d",&a,&b,&c); // x,y,w
            v.push_back( customer(a,b,c) );
        }

        printf("CASE %d Y\n",t);
        if( n <= 20 ){
                for( int i = 0; i < m; ++i ) sols.push_back( coord(0,0) );
                int curr = refresh();

                while( 1 ){
                bool ok = false;

                for( int k = 0; k < sols.size(); ++k ){
                    for( int i = 0; i < n; ++i ){
                        coord nxt = sols[k];
                        sols[k] = v[i].p;
                        int r = refresh();
                        if( r < curr ) ok = true, curr = r;
                        else if( r > curr ) sols[k] = nxt;
                    }
                }

                for( int k = 0; k < sols.size(); ++k ){
                    for( int i = 0; i < 4; ++i ){
                        coord nxt = sols[k];
                        sols[k].x += d[i][0];
                        sols[k].y += d[i][1];
                        int r = refresh();
                        if( r < curr ) ok = true, curr = r;
                        else if( r > curr ) sols[k] = nxt;
                    }
                }
                if( !ok ) break;
            }
            for( int i = 0; i < sols.size(); ++i )
                printf("%d %d\n",sols[i].x,sols[i].y);
        }else{

            int sinc = 0;
            for( int i = 0; i < m; ++i ){
                coord best = coord(0,0);
                int better = 0;
                for( int j = n-1; j >= 0; --j ){
                    int w = inc( v[j].p );
                    if( w > better ){
                        better = w;
                        best = v[j].p;
                    }
                }
                update( best );
                printf("%d %d\n",best.x,best.y);

            }
        }

    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <map>
#include <set>
#include <fstream>
#include <queue>
#include <assert.h>
#include <iomanip>
#include <math.h>
using namespace std;

struct coord{
    int x,y;
    coord(){};
    coord( int p1, int p2 ):x(p1),y(p2){};
};

struck kdtree{
    vector< coord > tree;
};

int main(){
    return 0;
}

#define SEED 54211
#define MINX  -1000
#define MAXX  1000
#define MINY -1000
#define MAXY  1000
#define MINW  1
#define MAXW  10

#include <cstdio>
#include <cstdlib>
#include <vector>
#include <algorithm>
#include <iterator>
#include <numeric>

#include <iostream>

using namespace std;

struct point {int x, y;};
typedef struct wpoint {int x, y, w;} WPoint;
int main ()
{
    freopen("Ulaz.txt","w",stdout);
  srand (SEED);
  int t; //The Numeber of test cases

  //cin >> t;
  t = 1;
  cout << t << endl;

  for (;t>0;t--) {
    int n, k, clusters, cluster_range;

    //cin >> n;
    n = 2000;// + rand()%11;
    cout << n << " ";
    //cin >> k;
    k = 17;
    cout << k << endl;

    //cin >> clusters;
    //cin >> cluster_range;
    clusters = 7;
    cluster_range = 5 + rand()%11;
    struct point cl_tab[clusters];

    for (int i=0; i<clusters; i++) {
      cl_tab[i].x = MINX+rand()%(MAXX-MINX+1);
      cl_tab[i].y = MINY+rand()%(MAXY-MINY+1);
    }


    std::vector< WPoint > v;

    for (int i=0; i<n;) {
	  WPoint wp;
      wp.x = cl_tab[i%clusters].x - cluster_range + rand()%(2*cluster_range+1);
      wp.y = cl_tab[i%clusters].y - cluster_range + rand()%(2*cluster_range+1);
      if (wp.x <= MAXX && wp.x>=MINX &&
                   wp.y <= MAXY && wp.y>=MINY) {
         wp.w = MINW + rand()%(MAXW-MINW+1);
	 v.push_back(wp);
         i++;
      }
    }
    random_shuffle( v.begin(), v.end() );
    for(std::vector<WPoint>::iterator it = v.begin(); it != v.end(); ++it) {
       cout << it->x << " "  << it->y << " " << it->w << endl;
    }
  } // test case
  return 0;
}

#include <cstdio>
#include <iostream>
using namespace std;

int main()
{
    freopen("domine.in","r",stdin);
    freopen("domine.out","w",stdout);
    int n,d,h;
    scanf("%d",&n);
    scanf("%d",&h);
    d = h-1;
    for( int i = 1; i < n && i < d+1 ;i++)
    {
        scanf("%d",&h);
        d = max( d , h + i - 1 );
    }
    if( d > n ) printf("%d\n",n);
    else printf("%d\n",d+1);
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <set>
#include <queue>
#include <algorithm>
#include <map>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
#include <cstdlib>
#include <stack>
using namespace std;

typedef long long ll;

const int inf = 999999999;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

int n,m,k;

vector< pair<double,int> > w;
bool used[1000];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d%d%d",&n,&m,&k);

    for( int i = 0; i < m; ++i ){
        for( int j = 0; j < n; ++j ){
            int dx;
            double val;
            scanf("%d%lf",&dx,&val);

            w.push_back( mk(val,dx) );
        }
    }
    sort( w.rbegin() , w.rend() );

    double sol = 0;
    for( int i = 0; k ; ++i , --k ){
        if( used[ w[i].s ] ){ k++; continue; }
        used[ w[i].s ] = 1;
        sol += w[i].f;
    }
    printf("%.1lf\n",sol);

    return 0;
} // ok

#include <iostream>
#include <vector>
#include <cstdio>
#include <string.h>
#include <string>
#include <cstdlib>
#include <set>
#include <queue>
#include <map>
using namespace std;

int f[100];

int make_failure( char *s , int *f ){
    f[0] = 0;
    for (int i = 1; i < strlen(s); i++) {
        f[i] = f[i - 1];
        while (f[i] > 0 && s[f[i]] != s[i])
            f[i] = f[f[i] - 1];

        if (s[f[i]] == s[i]) f[i]++;
    }
}

int match( char *txt , char *pattern , int *f ){
    int j = 0 , i = 0;
    int len = strlen(pattern);

    while( i < strlen(txt) ){
       // cout<<i<<" "<<j<<endl;
        if( pattern[j] == txt[i] ){
            j ++, i ++;
            if( j == len ) printf("match at %d\n",i-len), --j;
        }else if( j ) j = f[j];
        else i++;
    }
}

char pattern[100];
char txt[1000];

int main(){
    scanf("%s",txt);
    scanf("%s",pattern);

    make_failure( pattern , f );

    for( int i = 0; i < strlen(pattern); ++i )
        printf("%d\n",f[i]);

    match( txt , pattern , f );

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <stack>
#include <map>
#include <string.h>
#include <string>
#include <set>
#include <queue>
using namespace std;

const int maxp = 10000000;

int n;
string pattern,hay;
int f[maxp];

void makef( string &p , int *f ){
    f[0] = 0;
    int ln = p.size();
    for( int i = 1; i < ln; ++i ){
        f[i] = f[i-1];
        while( 1 ){
            if( p[ f[i] ] == p[i] ){ f[i] ++; break; }
            if( f[i] == 0 ) break;
            f[i] = f[ f[i] - 1 ];
        }
    }
}

void find_match(){
    int ln = pattern.size();

    int j = 0 , i = 0;
    do{
        char c = hay[i];
        while( 1 ){
            if( pattern[j] == c ){
                j++;
                if( j == ln ) printf("%d\n",i-ln+1);
                break;
            }else if( j > 0 ) j = f[j-1];
            else break;
        }
        ++i;
    }while( i != hay.size() );
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    cin.sync_with_stdio(false);
    while( cin>>n ){
        cin>>pattern>>hay;

        makef( pattern , f );


        find_match();
        printf("\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <algorithm>
using namespace std;

int n;
string pat,txt;

int main(){
    //freopen("Ulaz.txt","r",stdin);
    cin.sync_with_stdio(false);

    while( cin >> n  ){
        cin >> pat >> txt;

        string x = pat + "|" + txt;
        vector< int > f;
        f.push_back(0);

        int sz = pat.size();
        for( int i = 1; i < x.size(); ++i ){
            f.push_back( f[i-1] );
            while( f[i] > 0 && x[i] != x[ f[i] ] )
                f[i] = f[ f[i] - 1 ];
            if( x[ f[i] ] == x[i] ) f[i] ++;
            if( f[i] == pat.size() ) printf("%d\n",i-2*sz);
            cout<<i<<" "<<f[i]<<endl;
        }

        printf("\n");
    }

    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<math.h>
#include<algorithm>
#include<vector>
using namespace std;

const long long PRIME = 4799;

int main(){
    freopen("Ulaz.txt","r",stdin);
   int n,i,j;
   string needle,hay;
   while( cin.eof() == false ){
      cin>>n;
      cin>>needle>>ws>>hay>>ws;
      long long keys = 0 , sol = 0 , keyt=0;;
      long long pwbase = 1;
      int lenN = needle.size() , lenH = hay.size();
      for(i=0;i<lenN;i++){
         keys = (keys*PRIME + needle[i]);
         if( i!=lenN-1 )
           pwbase *= PRIME;
      }
      for(i=0;i<lenN;i++)
         keyt = (keyt*PRIME + hay[i]);
      if( keyt==keys ){printf("0\n");sol++;}
      for(i=lenN;i<lenH;i++){
         keyt = keyt - pwbase*hay[i-lenN];
         keyt = keyt*PRIME + hay[i];
         if( keyt==keys ){
            printf("%d\n",i-lenN+1);
            sol++;
         }
      }
     printf("\n");
   }
   return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <stack>
#include <map>
#include <string.h>
#include <string>
#include <set>
#include <queue>
using namespace std;

int main(){
    freopen("Ulaz.txt","w",stdout);
    int n = 500000 , m = 1000000;
    cout<<n<<endl;
    for( int i = 0; i < n; ++i ) cout<< char('a' + rand()%25);cout<<endl;
    for( int i = 0; i < m; ++i ) cout<< char('a' + rand()%25);cout<<endl;
    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <string.h>
#include <string>
#include <cstdlib>
#include <set>
#include <queue>
#include <map>
using namespace std;

int f[10000000];

int make_failure( string &pattern , int *f ){
    f[0] = 0;

    for( int i = 1; i < pattern.size(); ++i ){
        int j = f[i-1];
        while( 1 ){
            if( pattern[j] == pattern[i] ){ f[i] = j + 1; break; }
            if( j == 0 ){ f[i] = 0; break; }
            j = f[j];
        }
    }
}

int match(  string &txt , string &pattern , int *f ){
    int j = 0 , i = 0;
    int len = pattern.size();

    while( i < txt.size() ){
        if( pattern[j] == txt[i] ){
            j ++, i ++;
            if( j == len ) printf("%d\n",i-len), --j;
        }else if( j ) j = f[j];
        else i++;
    }
}

string pattern;
string txt;

int main(){
    freopen("Ulaz.txt","r",stdin);
    int n;
    while( cin.eof() == false ){
        cin >> n;
        cin >> pattern >> ws >> txt >> ws;

        make_failure( pattern , f );

        match( txt , pattern , f );
        cout<<endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <algorithm>
#include <stack>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 1500 + 55;
const int maxm = 100000 + 55;

struct mis{
    int r,c,v,dst;
    mis(){ dst = 0; };
    mis( int p1, int p2, int p3 ):r(p1),c(p2),v(p3){ dst = 0; };

    const bool operator<( const mis &m2 ) const {
        return v < m2.v;
    }
};

int h,w,m;
char mat[maxn][maxn];
vector< pii > out;
vector< pii > mouse;

int d[][2] = { {1,0} , {-1,0} , {0,1} , {0,-1} };

bool dead[maxm];
int pos[maxn][maxn];
char go[maxn][maxn][2];


int main(){
    freopen("misevi10.in","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    scanf("%d%d%d",&h,&w,&m);

    for( int i = 0; i < h; ++i ){
        for( int j = 0; j < w; ++j ){
            char c;
            while( c=getchar() ) if( c == ' ' || c == '#' ) break;
            mat[i][j] = c;
        }
        mat[i][w] = '\0';
    }

    for( int i = 0; i < w; ++i ) if( mat[0][i] == ' ') out.push_back( mk(0,i) );

    for( int i = 1; i < h-1; ++i ){
        if( mat[i][0] == ' ' ) out.push_back( mk(i,0) );
        if( mat[i][w-1] == ' ' ) out.push_back( mk(i,w-1) );
    }

    for( int i = 0; i < w; ++i ) if( mat[h-1][i] == ' ') out.push_back( mk(h-1,i) );

    queue< pii > q;
    for( int i = 0; i < out.size(); ++i ) q.push( out[i] ), pos[ out[i].f ][ out[i].s ] = 1;

    while( !q.empty() ){
        pii u = q.front(); q.pop();
        for( int i = 0 ; i < 4; ++i ){
            int r = u.f + d[i][0];
            int c = u.s + d[i][1];

            if( r < 0 || c < 0 || r >= h || c >= w ) continue;
            if( pos[r][c] || mat[r][c] == '#' ) continue;
            pos[r][c] = 1;

            go[r][c][0] = -d[i][0];
            go[r][c][1] = -d[i][1];
            q.push( mk(r,c) );
        }
    }
    memset( pos , 0 , sizeof(pos));

    vector< mis > p;
    for( int i = 0; i < m; ++i ){
        int a,b,c; scanf("%d%d%d",&a,&b,&c); a--,b--;
        pos[a][b] = i+1;
        p.push_back( mis(a,b,c) );
    }

    sort( p.begin() , p.end() );

    for( int i = 0; i < 1800; ++i ){
        for( int j = 0; j < m; ++j ){
            if( dead[j] ) continue;
            int rx = p[j].r;
            int cx = p[j].c;

            int r = rx + go[rx][cx][0];
            int c = cx + go[rx][cx][1];

            if( r == rx && c == cx ){
                dead[j] = 1;
                if( r == 0 || r == h-1 || c == w-1 || c == 0 )
                    printf("%d %d\n",p[j].v,p[j].dst); // outside
                continue; // maybe infinity
            }

            pos[rx][cx] = 0;
            if( pos[r][c] && pos[r][c]-1 < j ){
                int dx = pos[r][c] - 1;
                if( p[ dx ].v > p[ j ].v ) dead[j] = 1;
                else dead[ dx ] = 1 , pos[r][c] = 0;
            }
            if( dead[j] ) continue;
            pos[r][c] = j+1;
            p[j].r = r, p[j].c = c, p[j].dst++;
        }
    }


    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <set>
#include <queue>
#include <algorithm>
#include <map>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
#include <cstdlib>
#include <stack>
using namespace std;

typedef long long ll;

const int inf = 999999999;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

const int maxn = 1000 + 55;

int h,w;
char mat[maxn][maxn];

int n;
int x[maxn], y[maxn];

bool figure[maxn][maxn];

vector< pii > blocks[maxn];

vector< pii > same;

int main(){
  //  freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&h,&w);

    for( int i = 0; i < h; ++i ) scanf("%s",mat[i]);

    int lox = inf,loy = inf;
    scanf("%d",&n);

    for( int i = 0; i < n+1; ++i ){
        if( i < n ) scanf("%d%d",&x[i],&y[i]);
        if( i == 0 ) x[n] = x[0] , y[n] = y[0];

        lox = min( lox, x[i] );
        loy = min( loy, y[i] );

        if( i && y[i] != y[i-1] )
            blocks[x[i]].push_back( mk( min(y[i],y[i-1]) , max(y[i],y[i-1])));
    }
    n++;

    for( int i = 0; i < n; ++i ) x[i] -= lox, y[i] -= loy;


    for( int i = 0; i < h; ++i ){
        double xn = -0.5 , yn = i + 0.5;
        bool block = 0;

        for( int j = 0; j < w; ++j ){
            int cx = (int)ceil(xn);

            bool ok = 0;
            for( int k = 0; k < blocks[cx].size() && !ok; ++k )
                if( blocks[cx][k].f <= yn && yn <=  blocks[cx][k].s ) ok = 1;

            if( block ) figure[i][j] = block;
            if( ok ) block = !block;
            figure[i][j] = block;

            xn += 1;

        }
    }

    vector< pii > dots;

    for( int i = 0; i < h; ++i )
        for( int j = 0; j < w; ++j )
            if( figure[i][j] ) dots.push_back( mk(i,j) );

    int sol = 0;
    for( int ac = 0; ac < w; ac ++ ){
        for( int ar = 0; ar < h; ar ++ ){
            char ch;
            bool ok = 1;
            for( int i = 0; i < dots.size() && ok; ++i ){
                int r = ar + dots[i].f;
                int c = ac + dots[i].s;
                if( r >= h || c >= w ){ ok = 0; break; }

                if( i == 0 ) ch = mat[r][c];
                if( mat[r][c] != ch ) ok = 0;
            }
            sol += ok;

        }
    }
    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <set>
#include <queue>
#include <algorithm>
#include <map>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
#include <cstdlib>
#include <stack>
using namespace std;

typedef long long ll;

const int inf = 999999999;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

double ds[10];

const double eps = 10e-20;

int main(){
    double a,b,c,d;
    cin >> a >> b >> c >> d;

    double maxi = -inf;

    for( int i = 0; i < 10; ++i ){
        ds[i] = a/c + b/d;
        if( ds[i]-maxi > eps ) maxi = ds[i];

        double tmp = a;
        a = c;
        c = d;
        d = b;
        b = tmp;
    }

    for( int i = 0; i < 10; ++i )
        if( fabs(ds[i]-maxi) < eps ){ printf("%d\n",i); break; }

    return 0;
} // OK

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <algorithm>
#include <stack>
using namespace std;

int n,k;
int sums[1005];
int wins[1005];

int main(){
    freopen("takmicenje.in","r",stdin);
    freopen("takmicenje.out","w",stdout);
    scanf("%d%d",&n,&k);

    for( int i = 0; i < k; ++i ){
        int win = 0 , inc = -1;
        for( int j = 0; j < n; ++j ){
            int p; scanf("%d",&p);
            sums[j] += p;
            if( sums[j] > sums[win] ) win = j, inc = p;
        }
        wins[win]++;
    }
    int win = 0;
    for( int i = 1; i < n; ++i )
        if( wins[i] > wins[win] ) win = i;

    printf("%d\n",win+1);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <set>
#include <queue>
#include <algorithm>
#include <map>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
#include <cstdlib>
#include <stack>
using namespace std;

typedef long long ll;

const int inf = 999999999;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

char s1[100];
char s2[100];

int mini( char *n ){
    int ln = strlen(n);
    int v = 0;
    for( int i = 0; i < ln; ++i ){
        char c = n[i];
        if( c == '6' ) c = '5';
        v = v*10 + c-'0';
    }
    return v;
}

int maxi( char *n ){
    int ln = strlen(n);
    int v = 0;
    for( int i = 0; i < ln; ++i ){
        char c = n[i];
        if( c == '5' ) c = '6';
        v = v*10 + c-'0';
    }
    return v;
}

int main(){
    scanf("%s %s",s1,s2);

    int ln1 = strlen(s1);
    int ln2 = strlen(s2);

    int mina = mini(s1);
    int minb = mini(s2);

    int maxa = maxi(s1);
    int maxb = maxi(s2);

    printf("%d %d\n",mina+minb,maxa+maxb);



    return 0;
} // ok

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <set>
#include <queue>
#include <algorithm>
#include <map>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
#include <cstdlib>
#include <stack>
using namespace std;

typedef long long ll;

const int inf = 999999999;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

const int maxr = 1005;
const int maxc = 1005;
const int prime = 11173;

int h,w;
char mat[maxr][maxc];
int keys[maxc];

int stp[maxr];

map<int,int>m;

int main(){
    stp[0] = 1;
   // freopen("Ulaz.txt","r",stdin);
    for( int i = 1; i < maxr; ++i ) stp[i] = stp[i-1] * prime;

    scanf("%d%d",&h,&w);
    for( int i = 0; i < h; ++i ){
        scanf("%s",mat[i]);
        for( int j = 0; j < w; ++j )
            keys[j] = keys[j]*prime + mat[i][j];
    }

    int sol = 0;
    for( int i = 0; i < h; ++i ){

        bool ok = 1;
        m.clear();
        for( int j = 0; j < w && ok; ++j ){
            keys[j] -= stp[h-i-1]*mat[i][j];
            m[ keys[j] ] ++;

            if( m[ keys[j] ] != 1 ) ok = false;
        }

        if( !ok ) break;
        sol ++;
    }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <set>
#include <queue>
#include <algorithm>
#include <map>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
#include <cstdlib>
#include <stack>
using namespace std;

typedef long long ll;

const int inf = 999999999;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

int main(){
    freopen("Ulaz.txt","w",stdout);
    int n = 1000 , m = 1000;
    cout<<n<<" "<<m<<endl;

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < m; ++j ){
            char c = 'a' + rand()%25;
            cout<<c;
        }cout<<endl;
    }

    return 0;
}

#include <cstdio>
#include <math.h>
#include <vector>
#include <string.h>
#include <algorithm>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int inf = 99999999;
const int maxn = 555;

int h,w;
char mat[maxn][maxn];

int cost[maxn][30][30];
int dp[28][28];

bool cmp( pii a , pii b ){ return dp[a.f][a.s] < dp[b.f][b.s]; }

struct trio{
    int f,s,v;
    trio(){};
    trio( int a, int b, int c ):f(a),s(b),v(c) {};
    const inline bool operator<( const trio &t ) const {
        return v < t.v;
    }
};

trio prv[30*30];
short sz = 0;

int iterative(){

    for( int j = 0; j < 28; ++j )
        for( int k = 0; k < 28; ++k )
            dp[j][k] = inf;

    for( int i = 0; i < h; ++i ){
        sz = 0;
        if( i == 0 ) prv[sz++] = trio(26,26,0);
        else for( int a = 0; a < 26; ++a )
                for( int b = 0; b < 26; ++b )
                    if( dp[a][b] != inf ) prv[sz++] = trio(a,b,dp[a][b]);

        sort( prv , prv + sz );
        int tl = 55;
        if( sz < tl ) tl = sz;

        for( int a = 0; a < 26; ++a )
            for( int b = 0; b < 26; ++b ){
                dp[a][b] = inf;
                for( int k = 0; k < tl; ++k ){
                    if( a == prv[k].f || b == prv[k].s ) continue;
                    if( dp[a][b] >  prv[k].v + cost[i][a][b] ) dp[a][b] = prv[k].v + cost[i][a][b];
                }
            }
    }

    int sol = inf;
    for( int a = 0; a < 26; ++a )
        for( int b = 0; b < 26; ++b )
            sol = min( sol , dp[a][b] );
    return sol;
}

int rows[maxn];
vector< int > pos['z'-'a'+1][2];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&h,&w);
    for( int i = 0; i < h; ++i ){
        scanf("%s",mat[i]);
        for( int j = 0; j < w; ++j )
            pos[ mat[i][j] - 'a' ][j&1].push_back( i );
    }

    for( char a = 'a'; a <= 'z'; ++a ){
        for( char b = 'a'; b <= 'z'; ++b ){
            for( int i = 0; i < h; ++i ) rows[i] = w, cost[i][a-'a'][b-'a'] = inf;
            if( a == b ) continue;

            int x = a-'a' , y = b - 'a';
            for( int k = 0; k < pos[x][0].size(); ++k ) rows[ pos[x][0][k] ] --;
            for( int k = 0; k < pos[y][1].size(); ++k ) rows[ pos[y][1][k] ] --;

            for( int i = 0; i < h; ++i ) cost[i][a-'a'][b-'a'] = rows[i];
        }
    }


    int sol = iterative();
    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <algorithm>
using namespace std;

const int maxn = 25000 + 55;
const int maxx = 1000000;

int n;
int x1[maxn],y1[maxn],x2[maxn],y2[maxn];

vector< int > ys[maxx];
vector< int > xs[maxn];

bool vertical_share( int i ){
    int dx;
    vector<int> &x = ys[ x1[i] ];

    dx = lower_bound( x.begin(), x.end(), y1[i] ) - x.begin();
    if( dx &&              x[dx-1] >= y1[i] && x[dx-1] <= y2[i]  ) return 1;
    if( dx+1 < x.size() && x[dx+1] >= y1[i] && x[dx+1] < y2[i]  ) return 1;
    if( dx+2 < x.size() && x[dx+2] >= y1[i] && x[dx+2] <= y2[i]  ) return 1;


    vector<int> &w = ys[ x2[i] ];

    dx = lower_bound( w.begin(), w.end(), y1[i] ) - w.begin();
    if( dx &&              w[dx-1] >= y1[i] && w[dx-1] <= y2[i]  ) return 1;
    if( dx+1 < w.size() && w[dx+1] >= y1[i] && w[dx+1] <  y2[i]  ) return 1;
    if( dx+2 < w.size() && w[dx+2] >= y1[i] && w[dx+2] <= y2[i]  ) return 1;

    return 0;
}

bool horizontal_share( int i ){
    int dx;
    vector<int> &x = xs[ y1[i] ];

    dx = lower_bound( x.begin(), x.end(), x1[i] ) - x.begin();
    if( dx &&              x[dx-1] >= x1[i] && x[dx-1] <= x2[i]  ) return 1;
    if( dx+1 < x.size() && x[dx+1] >= x1[i] && x[dx+1] < x2[i]  ) return 1;
    if( dx+2 < x.size() && x[dx+2] >= x1[i] && x[dx+2] <= x2[i]  ) return 1;


    vector<int> &w = xs[ y2[i] ];

    dx = lower_bound( w.begin(), w.end(), x1[i] ) - w.begin();
    if( dx &&              w[dx-1] >= x1[i] && w[dx-1] <= x2[i]  ) return 1;
    if( dx+1 < w.size() && w[dx+1] >= x1[i] && w[dx+1] <  x2[i]  ) return 1;
    if( dx+2 < w.size() && w[dx+2] >= x1[i] && w[dx+2] <= x2[i]  ) return 1;

    return 0;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests ; --tests ){
        scanf("%d",&n);

        for( int i = 0; i < n; ++i ){
            scanf("%d%d%d%d",&x1[i],&y1[i],&x2[i],&y2[i]);

            ys[ x1[i] ].push_back( y1[i] );
            ys[ x1[i] ].push_back( y2[i] );
            ys[ x2[i] ].push_back( y1[i] );
            ys[ x2[i] ].push_back( y2[i] );

            xs[ y1[i] ].push_back( x1[i] );
            xs[ y1[i] ].push_back( x2[i] );
            xs[ y2[i] ].push_back( x1[i] );
            xs[ y2[i] ].push_back( x2[i] );
        }

        for( int i = 0; i < n; ++i ){
            sort( ys[ x1[i] ].begin(), ys[ x1[i] ].end() );
            sort( ys[ x2[i] ].begin(), ys[ x2[i] ].end() );
            sort( xs[ y1[i] ].begin(), xs[ y1[i] ].end() );
            sort( xs[ y2[i] ].begin(), xs[ y2[i] ].end() );
        }

        int sol = 0;

        for( int i = 0; i < n; ++i ){
            if( vertical_share( i ) || horizontal_share( i ) );
            else sol ++;
        }

        printf("%d\n",sol);

        for( int i = 0; i < n; ++i ){
            ys[ x1[i] ].clear(), ys[ x2[i] ].clear();
            xs[ y1[i] ].clear(), xs[ y2[i] ].clear();
        }
    }

    return 0;
}

#include <algorithm>
#include <vector>
#include <string.h>
#include <cstdio>
using namespace std;

const int maxn = 25000 + 55;
const int maxx = 1000000;

struct trio{
    int x,y,dx;
    trio(){};
    trio( int p1, int p2, int p3 ):x(p1),y(p2),dx(p3){};

    const inline bool operator<( const trio &t2 ) const {
        if( x != t2.x ) return x < t2.x;
        if( y != t2.y ) return y < t2.y;
        return dx < t2.dx;
    }
};

inline bool byY( trio t1, trio t2 ){
    if( t1.y != t2.y ) return t1.y < t2.y;
    if( t1.x != t2.x ) return t1.x < t2.x;
    return t1.dx < t2.dx;
}

int n;
trio w[maxn+maxn+maxn+maxn];
int sz = 0;

bool cant[maxn];
int c[maxn][4];

inline void readi( int &v ){
    static char c;
    while( (c=getchar())<'0' || c >'9' );
    v = c - '0';
    while( (c=getchar())>= '0' && c <= '9' ) v = v*10 + c - '0';
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests ; --tests ){
        scanf("%d",&n);
        sz = 0;

        for( int i = 0; i < n; ++i ){
            cant[i] = 0;
            int a,b,c,d; readi(a), readi(b), readi(c), readi(d);
            w[sz++] = trio(a,b,i);
            w[sz++] = trio(c,d,i);
            w[sz++] = trio(a,d,i);
            w[sz++] = trio(c,b,i);
            ::c[i][0] = a , ::c[i][1] = b , ::c[i][2] = c , ::c[i][3] = d;
        }

        sort( w , w + sz );

        for( int i = 0; i < n; ++i ){
            int s = lower_bound( w , w + sz , trio(c[i][0],c[i][1],0)  ) - w;
            int e = upper_bound( w , w + sz , trio(c[i][0],c[i][3],0)  ) - w;
            for( int j = s; j < e; ++j ) if( i != w[j].dx ) cant[i] = cant[ w[j].dx ] = 1;

             s = lower_bound( w , w + sz , trio(c[i][2],c[i][1],0)  ) - w;
             e = upper_bound( w , w + sz , trio(c[i][2],c[i][3],0)  ) - w;
            for( int j = s; j < e; ++j ) if( i != w[j].dx ) cant[i] = cant[ w[j].dx ] = 1;
        }


        sort( w , w + sz, byY );
        for( int i = 0; i < n; ++i ){
            int s = lower_bound( w , w + sz , trio(c[i][0],c[i][1],0) , byY ) - w;
            int e = upper_bound( w , w + sz , trio(c[i][2],c[i][1],0) , byY ) - w;
            for( int j = s; j < e; ++j ) if( i != w[j].dx ) cant[i] = cant[ w[j].dx ] = 1;

             s = lower_bound( w , w + sz , trio(c[i][0],c[i][3],0) , byY ) - w;
             e = upper_bound( w , w + sz , trio(c[i][2],c[i][3],0) , byY ) - w;
            for( int j = s; j < e; ++j ) if( i != w[j].dx ) cant[i] = cant[ w[j].dx ] = 1;
        }

        int sol = 0;
        for( int k = 0; k < n; ++k )
            if( !cant[k] ) sol ++;

        printf("%d\n",sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <algorithm>
using namespace std;

int t = 1;
int n = 25000;

int main(){
    freopen("Ulaz.txt","w",stdout);
    cout<<t<<endl;

    while( t -- ){
        cout<<n<<endl;
        for( int i = 0; i < n; ++i ){
            int r = 1+rand()%1000;
            int c = 1+rand()%1000;
            printf("%d %d %d %d\n",c,r,c+rand()%1000,r+rand()%1000);
        }
    }
    return 0;
}

#include <fstream>
#include <algorithm>
#include <functional>
#include <iostream>
#include <iterator>

using namespace std;

struct corner {
    int x, y;
    int barn;

    corner() {}
    corner(int x, int y, int barn) : x(x), y(y), barn(barn) {}
};

struct compare_x : public binary_function<corner, corner, bool> {
    bool operator()(const corner &a, const corner &b) const {
        if (a.x != b.x) return a.x < b.x;
        else return a.y < b.y;
    }
};

struct compare_y : public binary_function<corner, corner, bool> {
    bool operator()(const corner &a, const corner &b) const {
        if (a.y != b.y) return a.y < b.y;
        else return a.x < b.x;
    }
};

int main() {
    ifstream in("Ulaz.txt");

    int N;
    in >> N;
    in >> N;

    bool contact[N];
    int coords[N][4];
    corner corners[N * 4];

    fill(contact, contact + N, false);
    for (int i = 0; i < N; i++) {
        in >> coords[i][0] >> coords[i][1] >> coords[i][2] >> coords[i][3];
        corners[i * 4 + 0] = corner(coords[i][0], coords[i][1], i);
        corners[i * 4 + 1] = corner(coords[i][0], coords[i][3], i);
        corners[i * 4 + 2] = corner(coords[i][2], coords[i][3], i);
        corners[i * 4 + 3] = corner(coords[i][2], coords[i][1], i);
    }

    sort(corners, corners + 4 * N, compare_x());
    for (int i = 0; i < N; i++)
        for (int j = 0; j <= 2; j += 2) {
            corner *f = lower_bound(corners, corners + 4 * N,
                          corner(coords[i][j], coords[i][1], 0), compare_x());
            corner *l = upper_bound(corners, corners + 4 * N,
                          corner(coords[i][j], coords[i][3], 0), compare_x());

            for (corner *k = f; k != l; k++)
                if (k->barn != i) {
                    contact[i] = true;
                    contact[k->barn] = true;
                }
        }

    sort(corners, corners + 4 * N, compare_y());
    for (int i = 0; i < N; i++)
        for (int j = 1; j <= 3; j += 2) {
            corner *f = lower_bound(corners, corners + 4 * N,
                         corner(coords[i][0], coords[i][j], 0), compare_y());
            corner *l = upper_bound(corners, corners + 4 * N,
                         corner(coords[i][2], coords[i][j], 0), compare_y());

            for (corner *k = f; k != l; k++)
                if (k->barn != i) {
                    contact[i] = true;
                    contact[k->barn] = true;
                }
        }

    cout << count(contact, contact + N, false) << "\n";
    return 0;
}

#include <cstdio>
#include <string.h>
#include <assert.h>

const int maxn = 10000 + 55;
const int maxm = 1000 + 55;

char txt[maxn]; int n;
char pat[maxm]; int m;

short f[maxm];

void failure(){
    int len = strlen(pat);

    f[0] = 0;
    for( int i = 1; i < len; ++i ){
        int j = f[i-1];
        f[i] = 0;
        while(1){
            if( pat[j] == pat[i] ){ f[i] = j+1; break; }
            else if( j ) j = f[j-1];
            else break;
        }
    }
}

short dp[maxn][maxm];

short pre[maxm][255];

void doit(){
    for( char c = 'a'; c <= 'z'; ++c ){
        for( int match = 0; match < m; ++match ){
            short m = match;
            while( 1 ){
                if( pat[m] == c ){ m++; break; }
                else if( m ) m = f[m-1];
                else break;
            }
            pre[match][c] = m;
        }
    }
}

short solve2(){
    for( short i = 0; i <= m; ++i ) dp[n][i] = 0;

    for( short dx = n-1; dx >= 0; --dx ){
        for( short match = 0; match < m; ++match ){
            short &sol = dp[dx][match];
            sol = dp[dx+1][match] + 1;

            short s1,s2;
            s1 = s2 = 30000;

            if( txt[dx] == pat[match] && match != m-1 ) s1 = dp[dx + 1][ match + 1];
            if( txt[dx] != pat[match] ){
                if( match ){
                    short m = pre[match][ txt[dx] ];
//                    while( 1 ){
//                        if( pat[m] == txt[dx] ){ m++; break; }
//                        else if( m ) m = f[m-1];
//                        else break;
//                    }
                    s2 = dp[dx+1][m];
                }else s2 = dp[ dx + 1 ][0];
            }

            if( sol > s1 ) sol = s1;
            if( sol > s2 ) sol = s2;
            //printf("%d %d = %d [%d,%d] \n",dx,match,sol,s1,s2);
        }
    }
    return dp[0][0];
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);

    while( scanf("%s%s",txt,pat) == 2 ){
        n = strlen(txt);
        m = strlen(pat);

        failure();
        doit();

        short sol = solve2();
        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
using namespace std;

char txt[30];
char pat[30];

char tmp[30];

bool ok( char *p ){
    int len = strlen(p);
    int lenpat = strlen(pat);

    for( int i = 0; i < len - lenpat + 1; ++i ){
        bool ok = 1;
        for( int j = 0; j < lenpat && ok; ++j )
            if( pat[j] != p[i+j] ) ok = 0;
        if( ok ) return 0;
    }
    return 1;
}

int n,m;

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    while( scanf("%s%s",txt,pat) == 2 ){
        n = strlen(txt);
        m = strlen(pat);

        int sol = 999999999;

        for( int m = 0; m < (1<<n); ++m ){
            int sz = 0, del = 0;
            for( int k = 0; k < n; ++k )
                if( !(m&(1<<k)) ) tmp[sz++] = txt[k];
            del = n - sz;
            tmp[sz] = '\0';
            bool b = ok(tmp);

            if( b )sol = min( sol , del );
        }
        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <cstdlib>
#include <string>
#include <set>
#include <queue>
#include <iomanip>
using namespace std;

const int maxn = 10000 ;
const int maxm = 10 ;

int main(){
    int tests = 5000;
    srand((unsigned)time(0));
    freopen("Ulaz.txt","w",stdout);

    while( tests -- ){
        int n = 1+rand()%10;
        int m = 1+rand()%10;

        for( int i = 0; i < n; ++i ) cout<<char('a'+rand()%2);cout<<endl;
        for( int i = 0; i < m; ++i ) cout<<char('a'+rand()%2);cout<<endl;
        cout<<endl;
    }

    return 0;
}

#include <iostream>
#include <string.h>
#include <cstdio>
using namespace std;

char a[100000 + 55];
char b[100000 + 55];

int main(){
    while( scanf("%s %s",a,b) ){
        int ln1 = strlen(a);
        int ln2 = strlen(b);
        if( a[0] == '*' ) break;

        int xa = 0 , xb = 0;
        while( xa < ln1 && a[xa] == '0' ) xa++;
        while( xb < ln2 && b[xb] == '0' ) xb++;

        int posa = ln1 - xa;
        int posb = ln2 - xb;

        if( posa < posb ){
            printf("<");
        }else if( posa > posb ){
            printf(">");
        }else{
            bool ok = 0;
            for( int i = 0; i < posa && !ok; ++i ){
                if( a[xa] < b[xb] ) printf("<") , ok = 1;
                if( a[xa] > b[xb] ) printf(">") , ok = 1;
                xa ++ , xb ++;
            }
            if( !ok ) printf("=");
        }printf("\n");
    }
    return 0;
}

#include <iostream>
#include <string>
#include <fstream>
#include <math.h>
using namespace std;

int main(){
    cout<<""<<endl;
    return 0;
}

#include <iostream>
#include <cstdio>
#include <math.h>
using namespace std;

int sol[4];

int main(){

    for( int i = 1; i <= 6; ++i ){
        printf("%d %d %d %d\n",i,i,i,i);
        fflush(stdout);
        int a,b,c,d;
        scanf("%d%d%d%d",&a,&b,&c,&d);
        if( a == 1 ) sol[0] = i;
        if( b == 1 ) sol[1] = i;
        if( c == 1 ) sol[2] = i;
        if( d == 1 ) sol[3] = i;
    }

    printf("%d %d %d %d\n",sol[0],sol[1],sol[2],sol[3]);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <stack>
#include <map>
#include <set>
#include <queue>
#include <iomanip>
#include <math.h>
#include <cstdio>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair


typedef long long ll;

const int inf = 999999;
const int maxn = 100000 + 55;

struct dis_set{
    vector< int > sz;
    vector< int > id;

    void init( int n ){
        n += 55;
        sz.resize(n);
        id.resize(n);

        for( int i = 0; i < n; ++i ) sz[i] = 1 ,  id[i] = i;
    }

    dis_set(){};
    dis_set( int n ){ init(n); }

    int get_root( int x ){
        if( x == id[x] ) return x;
        return id[x] = get_root( id[x] );
    }

    int subtree_sz( int x ){
        return sz[ get_root(x) ];
    }

    bool merge( int a, int b ){
        int x = get_root( a ) , y = get_root( b );
        if( x == y ) return 1;

        if( sz[x] < sz[y] ) id[x] = y , sz[y] += sz[x];
        else id[y] = x , sz[x] += sz[y];

        return 0;
    }
};


struct coord{
    int x,y,s,dx;
    coord(){ dx=s= -inf; };
    coord( int p1, int p2 ):x(p1),y(p2){ dx=s= -inf; };

    inline const bool operator<( const coord &c ) const {
        return s < c.s;
    }
};


coord bit[maxn];

inline coord read( int dx ){
    coord sol = coord(-1,-1);
    sol.s = sol.dx = -inf;
    for( dx += 2; dx >= 1; dx -= dx & -dx )
        sol = max( sol , bit[dx] );
    return sol;
}

inline void update( int dx, coord w ){
    for( dx += 2; dx < maxn; dx += dx & -dx )
        bit[dx] = max( bit[dx] , w );
}

int n;
int x[maxn],y[maxn];
vector< coord > w;

int loy[maxn] , szlo;

int mx;
vector< pii > edge[1000000];

inline int cost( int i, int j ){
    static int xd,yd;
    if( x[i] > x[j] ) xd = x[i] - x[j];
    else xd = x[j] - x[i];

    if( y[i] > y[j] ) yd = y[i] - y[j];
    else yd = y[j] - y[i];
    return xd+yd;
}

void nearest(){
    for( int i = 0; i < n; ++i ) w[i].s = w[i].x + w[i].y;
    sort( w.begin() , w.end() ) ;
    for( int i = 0; i < maxn; ++i ) bit[i].x = bit[i].y = bit[i].dx = bit[i].s = -inf;

    for( int i = 0; i < n; ++i ){
        int xy = lower_bound( loy , loy + szlo , w[i].y ) - loy;
        coord x = read( maxn-xy-10 );

        coord add = w[i];
        add.s = w[i].x - w[i].y;
        add.dx = w[i].dx;


        update( maxn-xy-10 , add );
        if( x.dx != -inf ){
            int c = cost( w[i].dx , x.dx );
            edge[c].push_back( mk(w[i].dx,x.dx) );
            if( mx < c ) mx = c;
        }
    }
}


inline int readi( ) {
    static char c;
    while( (c = getchar())<'0' || c >'9' );
    int ret = c-'0';
    while( (c=getchar())>='0' && c <= '9' ) ret *= 10, ret += c-'0';
    return ret;
}

int main(){
    freopen("Ulaz.txt","r",stdin);

    vector< pii > sx;

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        x[i] = readi() , y[i] = readi();
        w.push_back( coord(x[i],y[i]) );
        w[i].dx = i;
    }

    for( int i = 0; i < 8; ++i ){
        szlo = 0;

        for( int j = 0; j < n; ++j ){
            int x = w[j].x , y = w[j].y;
            w[j].x = (x-y);
            w[j].y = (x+y);
            loy[szlo++] = w[j].y;
        }
        sort( loy , loy + szlo );
        nearest();
    }

    dis_set q( n + 5 );

    int sol = 0;
    for( int i = 0; i <= mx; ++i ){
        int sz = edge[i].size();
        for( int k = 0; k < sz; ++k ){
            int a = edge[i][k].f;
            int b = edge[i][k].s;

            if( !q.merge(a,b) ) sol = max( sol , i );
        }
    }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <string.h>
#include <string>
#include <map>
#include <set>
#include <queue>
#include <iomanip>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;
const int inf = 9999999;

struct coord{
    int x,y,dx;
    coord(){};
    coord( int p1, int p2):x(p1),y(p2){};
};

struct edge{
    int a,b,cost;
    edge(){};
    edge( int p1, int p2 ):a(p1),b(p2){};
    edge( int p1, int p2, int p3 ):a(p1),b(p2),cost(p3){};
};

int n;
vector< coord > dots, old;
vector< edge > e;

void near(){

}

int main(){
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        dots.push_back( coord(a,b) );
        dots[i].dx = i;
    } old = dots;

    for( int i = 0; i < 8; ++i ){



        for( int k = 0; k < n; ++k ){
            int x = dots[k].x , y = dots[k].y;
            dots[k].x = (x-y);
            dots[k].y = (x+y);
        }

        vector< int > lox,loy;
        for( int k = 0; k < n; ++k ) lox.push_back( dots[k].x ) , loy.push_back( dots[k].y );
        sort( lox.begin() , lox.end() );
        sort( loy.begin() , loy.end() );
        for( int k = 0; k < n; ++k ){
            dots[k].x = lower_bound( lox.begin() , lox.end() , dots[k].x ) - lox.begin();
            dots[k].y = lower_bound( loy.begin() , loy.end() , dots[k].y ) - loy.begin();
        }
    }

    return 0;
}

#include <cstdio>
#include <algorithm>
#include <vector>
#include <cctype>

using namespace std;

const int MaxN = ( 1 << 19 );

char buff[ MaxN ];
int Pos = MaxN;
inline char readch( ) {
 if( Pos == MaxN ) { Pos = 0; fread( buff, 1, MaxN, stdin );}
 return buff[Pos++];
}

int readint( ) {
 static char c;
 static int ret;
 while( !isdigit( c = readch() ) );
 ret = c-'0';
 while( isdigit( c = readch() ) ) ret *= 10, ret += c-'0';
 return ret;
}

int X[ MaxN ], Y[ MaxN ];
int TX[ MaxN ], TY[ MaxN ];
int F[ MaxN ];

int ngh[ MaxN ];

inline bool c1( int A, int B ) {
  if( Y[A] != Y[B] ) return Y[A] > Y[B];
  if( X[A] != X[B] ) return X[A] < X[B];
  return A < B;
}

inline bool c2( int A, int B ) {
  int r1, r2;
  r1 = X[A]+Y[A];
  r2 = X[B]+Y[B];
  if( r1 != r2 ) return r1 < r2;
  return c1( A, B );
}

int n;

int V[ MaxN ], T[ MaxN ];
void daq( int l, int r ) {
  if( l == r ) return;

  int mid = ( l+r ) >> 1;
  daq( l, mid );
  daq( mid+1, r );

  int p1, p2;
  p1 = l, p2 = mid+1;
  int gore = -1;
  int dist = -( 1<<30 );

  for( int i = 0; i < r-l+1; ++i )
    if( ( p1 <= mid && c2( V[p1], V[p2] ) ) || p2 == r+1 ) {
      T[i] = V[p1++];
      if( X[T[i]]-Y[T[i]] > dist ) {
        dist = X[T[i]]-Y[T[i]];
        gore = T[i];
      }
    }
    else {
      T[i] = V[p2++];
      if( ngh[T[i]] == -1 ) ngh[T[i]] = gore;
      else if( X[ngh[T[i]]]-Y[ngh[T[i]]] < dist ) ngh[T[i]] = gore;
    }

  for( int i = 0; i < r-l+1; ++i ) V[i+l] = T[i];
}



int find( int x ) {
  if( F[x] == -1 ) return x;
  return F[x] = find( F[x] );
}

inline void merge( int x, int y ) {
  F[find( y )] = find( x );
}

struct edge {
  int x,y;
  edge( int _x = 0, int _y = 0 ) {
    x = _x;
    y = _y;
  }
};

inline int dist( int A, int B ) { return abs( TX[A]-TX[B] )+abs( TY[A]-TY[B] ); }

bool c3( const edge &A, const edge &B ) {
  int d1, d2;
  d1 = dist( A.x, A.y );
  d2 = dist( B.x, B.y );
  if( d1 != d2 ) return d1 < d2;
  if( A.x != B.x ) return A.x < B.x;
  return A.y < B.y;
}

vector < edge > E;
vector < edge > temp;

int cnt[ MaxN << 1 ];
int pos[ MaxN << 1 ];
void ajd_gotovo() {
  for( int i = 0; i < E.size(); ++i ) ++cnt[dist( E[i].x, E[i].y )];
  pos[0] = 0;
  for( int i = 1; i < MaxN; ++i ) pos[i] = pos[i-1]+cnt[i-1];
  temp = E;
  for( int i = 0; i < temp.size(); ++i ) E[pos[ dist( temp[i].x, temp[i].y ) ]++] = temp[i];
}

int main( void ) {
    freopen("Ulaz.txt","r",stdin);
  n = readint();
  for( int i = 0; i < n; ++i ) X[i] = readint(), Y[i] = readint(), F[i] = -1;
  for( int i = 0; i < n; ++i ) TX[i] = X[i], TY[i] = Y[i], ngh[i] = -1;
  for( int i = 0; i < n; ++i ) V[i] = i;

  for( int i = 0; i < 8; ++i ) {
    sort( V, V+n, c1 );
    daq( 0, n-1 );

    for( int j = 0; j < n; ++j ) {
      int x, y;
      x = X[j], y = Y[j];
      X[j] = x-y, Y[j] = x+y;
      if( ngh[j] != -1 ) E.push_back( edge( j, ngh[j] ) );
      ngh[j] = -1;
    }
  }

  ajd_gotovo();
  int sol = 0;

  for( int i = 0; i < E.size(); ++i ) {
    if( find( E[i].x ) != find( E[i].y ) ) {
      merge( E[i].x, E[i].y );
      sol = dist( E[i].x, E[i].y );
    }
  }

  printf("%d\n",sol);
  return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <stack>
#include <map>
#include <set>
#include <queue>
#include <iomanip>
#include <math.h>
#include <cstdio>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair


typedef long long ll;

const int inf = 999999;
const int maxn = 100000 + 55;

struct dis_set{
    vector< int > sz;
    vector< int > id;

    void init( int n ){
        n += 55;
        sz.resize(n);
        id.resize(n);

        for( int i = 0; i < n; ++i ) sz[i] = 1 ,  id[i] = i;
    }

    dis_set(){};
    dis_set( int n ){ init(n); }

    int get_root( int x ){
        if( x == id[x] ) return x;
        return id[x] = get_root( id[x] );
    }

    int subtree_sz( int x ){
        return sz[ get_root(x) ];
    }

    bool merge( int a, int b ){
        int x = get_root( a ) , y = get_root( b );
        if( x == y ) return 1;

        if( sz[x] < sz[y] ) id[x] = y , sz[y] += sz[x];
        else id[y] = x , sz[x] += sz[y];

        return 0;
    }
};


struct coord{
    int x,y,s,dx;
    coord(){ dx=s= -inf; };
    coord( int p1, int p2 ):x(p1),y(p2){ dx=s= -inf; };

    inline const bool operator<( const coord &c ) const {
        return s < c.s;
    }
};


int bit[maxn];
int val[maxn];

inline int read( int dx ){
    int sol = -inf;
    for( dx += 2; dx >= 1; dx -= dx & -dx ){
        if( sol == -inf || bit[dx] != -inf && val[sol] < val[ bit[dx] ] )
            sol = bit[dx];
    }
    return sol;
}

inline void update( int dx, int w ){
    for( dx += 2; dx < maxn; dx += dx & -dx ){
        if( bit[dx] == -inf || val[ bit[dx] ] < val[w] )
            bit[dx] = w;
    }
}

int n;
int x[maxn],y[maxn];
vector< coord > w;

int loy[maxn] , szlo;

int mx;
vector< pii > edge[1000000];

inline int cost( int i, int j ){
    static int xd,yd;
    if( x[i] > x[j] ) xd = x[i] - x[j];
    else xd = x[j] - x[i];

    if( y[i] > y[j] ) yd = y[i] - y[j];
    else yd = y[j] - y[i];
    return xd+yd;
}

void nearest(){
    for( int i = 0; i < n; ++i ) val[ w[i].dx ] = w[i].x - w[i].y, w[i].s = w[i].x + w[i].y;
    sort( w.begin() , w.end() ) ;
    for( int i = 0; i < maxn; ++i ) bit[i] = -inf;

    for( int i = 0; i < n; ++i ){
        int xy = lower_bound( loy , loy + szlo , w[i].y ) - loy;
        int x = read( maxn-xy-10 );

        update( maxn-xy-10 , w[i].dx );
        if( x != -inf ){
            int c = cost( w[i].dx , x );
            edge[c].push_back( mk(w[i].dx,x) );
            if( mx < c ) mx = c;
        }
    }
}


inline int readi( ) {
    static char c;
    while( (c = getchar())<'0' || c >'9' );
    int ret = c-'0';
    while( (c=getchar())>='0' && c <= '9' ) ret *= 10, ret += c-'0';
    return ret;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    vector< pii > sx;

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        x[i] = readi() , y[i] = readi();
        w.push_back( coord(x[i],y[i]) );
        w[i].dx = i;
    }

    for( int i = 0; i < 8; ++i ){
        szlo = 0;

        for( int j = 0; j < n; ++j ){
            int x = w[j].x , y = w[j].y;
            w[j].x = (x-y);
            w[j].y = (x+y);
            loy[szlo++] = w[j].y;
        }
        sort( loy , loy + szlo );
        nearest();
    }

    dis_set q( n + 5 );

    int sol = 0;
    for( int i = 0; i <= mx; ++i ){
        int sz = edge[i].size();
        for( int k = 0; k < sz; ++k ){
            int a = edge[i][k].f;
            int b = edge[i][k].s;

            if( !q.merge(a,b) ) sol = max( sol , i );
        }
    }

    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <stack>
#include <map>
#include <set>
#include <queue>
#include <iomanip>
#include <fstream>
#include <math.h>
#include <cstdio>
using namespace std;


int main(){
    //for( int t = 1; ; t++ ){

        ofstream out("Ulaz.txt");
        srand((unsigned)time(0));
        int n = 100000;

        out<<n<<endl;

        for( int i = 0; i < n; ++i ){
            int a = 1 + rand()%50000;
            int b = 1 + rand()%50000;
            out<<a<<" "<<b<<endl;
        }

        system("MMST.exe");
        cout<<"  ";
        system("MMST_BRUTE.exe");
    //}

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <algorithm>
#include <iomanip>
#include <math.h>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

char c[10];
multiset< int > s;
set< int > same;

int main(){
    int n; scanf("%d",&n);
    int sz = 0;

    for( int i = 0; i < n; ++i ){
        int v; scanf("%s%d",c,&v);

        if( c[0] == 'i' ){
            s.insert( v );
            same.insert( v );
            sz ++; // increase  number of elements
        }else if( s.count(v) ){ // going to delete if we have element v in the multiset
            s.erase( s.lower_bound(v) ); // erase it
            if( s.count(v) == 0 ) same.erase( v ); // if all are occurences of v are errased erase it in the set
            sz --; // decrease number of elements
        }

        bool homo = 0, hetero = 0;
        if( same.size() < sz ) homo = 1;
        if( same.size() > 1 ) hetero = 1;

        if( homo && hetero ) printf("both\n");
        else if( homo ) printf("homo\n");
        else if( hetero ) printf("hetero\n");
        else printf("neither\n");

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <bitset>
using namespace std;

int n,m;

int main(){
    int t = 1;
    while( scanf("%d%d",&n,&m) == 2 ){
        if( n == 0 && m == 0 ) break;

        int sol = 0;
        bitset<256>c[n];
        for( int i = 0; i < n; ++i )
            c[i][i] = 1;

        for( int i = 0; i < m; ++i ){
            int a,b; scanf("%d%d",&a,&b); a--, b--;

            if( c[b][a] ){
                sol ++;
                continue;
            }

            for( int x = 0; x < n; ++x )
                if( c[x][a] ) c[x] |= c[b];
        }
        printf("%d. %d\n",t++,sol);
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <string>
#include <map>
#include <set>
#include <queue>
using namespace std;

const int inf = 102;

int n;
int h[100],dx;

int dp[103][103][103];

int solve( int last , int cnt , int strike ){
    if( cnt == 0 ) return strike == 0;

    int &sol = dp[last][cnt][strike];
    if( sol != -1 ) return sol;

    sol = 0;

    for( int i = 1; i <= min(last,cnt); ++i ){
        int fill = i - strike;
        if( fill < 0 ) continue;

        h[dx] = i; dx ++;
        sol += solve( i , cnt - i , max(strike + (fill%2==0?-1:+1),0) );
        dx--;
    }
    return sol;
}

int main(){
    int tests;
    scanf("%d",&tests);

    memset( dp , -1 , sizeof(dp));

    for( ; tests; --tests ){
        scanf("%d",&n);
        int sol = solve( inf , n , 0 );
        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <algorithm>
#include <map>
#include <cstdlib>
#include <math.h>
using namespace std;

typedef long long ll;

const int maxn = 1000000;
const int prime = 10007;

int n;
int v[maxn];
int stp[maxn];

int fwrd[maxn];
int back[maxn];

inline void readi( int &v ){
    static char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v *10 + c - '0';
}

void input(){
    stp[0] = 1;
    for( int i = 1; i < maxn; ++i ) stp[i] = stp[i-1] * prime;

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        readi(v[i]);
    }
}

void calc_fixes(){
    int h = 0;
    for( int i = 0; i < n; ++i ){
        h = h*prime + v[i];
        fwrd[i] = h;
    }

    h = 0;
    for( int i = n-1; i >= 0; --i ){
        h = h*prime + v[i];
        back[i] = h;
    }
}

int fsum( int f, int s ){
    int ss = fwrd[s];
    if( f ) ss -= fwrd[f-1]*stp[s-f+1];
    return ss;
}

int rsum( int f, int s ){
    int ss = back[f];
    if( s + 1 < n ) ss -= back[s+1]*stp[s-f+1];
    return ss;
}

int fs[maxn];
int ss[maxn];

void calc_f(){
    int f = 0;
    int mx = 1;

    fs[0] = mx;


    for( int i = 1; i < n; ++i ){
        if( f && v[f-1] == v[i] ) f--;
        else while( f < i && fsum(f,i) != rsum(f,i) ) f++;

        if( mx < i-f+1 ) mx = i-f+1;
        fs[i] = mx;
    }
}

void calc_s(){
    int f = n-1;
    int mx = 1;

    ss[n-1] = mx;


    for( int i = n-2; i >= 0; --i ){
        if( f+1<n && v[f+1] == v[i] ) f++;
        else while( f > i && fsum(i,f) != rsum(i,f) ) f--;

        if( mx < f-i+1 ) mx = f-i+1;
        ss[i] = mx;
    }
}

ll solution(){
    ll sol = 0;
    for( int i = 0; i < n; ++i ){
        ll x = fs[i] * (ll)ss[i+1];
        if( sol < x ) sol = x;
    }
    return sol;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    input();
    calc_fixes();

    calc_f();
    calc_s();

    printf("%lld\n",solution());
    return 0;
}

#include <algorithm>
#include <iostream>
#include <sstream>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include <vector>
#include <string>
#include <set>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstdlib>
#include <cstring>

#define sz(a) (int)a.size()
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define llong long long
#define zero(a) fabs(a) < 1e-9
#define resz(a, n) a.clear(), a.resize(n)
#define same(a, n) memset(a, n, sizeof(a))
#define make(a, b) make_pair(a, b)

using namespace std;

const int MAXN = 2000005;

struct Hasher {
	int BASE, p[MAXN], prefix[MAXN], suffix[MAXN];
	void initialize(int n, int base, int a[]) {
		BASE = base;
		p[0] = 1;
		for (int i = 1; i < MAXN; i++)
			p[i] = p[i - 1] * BASE;
		prefix[0] = suffix[n + 1] = 0;
		for (int i = 1; i <= n; i++)
			prefix[i] = prefix[i - 1] * BASE + a[i];
		for (int i = n; i >= 1; i--)
			suffix[i] = suffix[i + 1] * BASE + a[i];
	}
	int hashForward(int x, int y) {
		return prefix[y] - prefix[x - 1] * p[y - x + 1];
	}
	int hashBackward(int x, int y) {
		return suffix[x] - suffix[y + 1] * p[y - x + 1];
	}
};

int n, a[MAXN], f1[MAXN], f2[MAXN];
Hasher h1, h2;

bool palindrome(int x, int y) {
	if (h1.hashForward(x, y) == h1.hashBackward(x, y) && h2.hashForward(x, y) == h2.hashBackward(x, y))
		return true;
	return false;
}

int main() {
    freopen("Ulaz.txt","r",stdin);
	int m;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	if (n == 1) {
		printf("0\n");
		return 0;
	}
	h1.initialize(n, 3127, a), h2.initialize(n, 10007, a);
	f1[1] = m = 1;
	for (int i = 2; i <= n; i++) {
		for (int j = 2; j >= 1; j--) {
			int l = m + j;
			if (l > i)
				continue;
			if (palindrome(i - l + 1, i)) {
				m = l;
				break;
			}
		}
		f1[i] = m;
	}
	f2[n] = m = 1;
	for (int i = n - 1; i >= 1; i--) {
		for (int j = 2; j >= 1; j--) {
			int l = m + j;
			if (i + l - 1 > n)
				continue;
			if (palindrome(i, i + l - 1)) {
				m = l;
				break;
			}
		}
		f2[i] = m;
	}
	int ans = 1;
	for (int i = 1; i < n; i++)
		ans = max(ans, f1[i] * f2[i + 1]);
	printf("%d\n", ans);
	return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <algorithm>
#include <map>
#include <cstdlib>
#include <math.h>
using namespace std;

int main(){
    srand((unsigned)time(0));
    freopen("Ulaz.txt","w",stdout);

    int n = 1000000;
    cout<<n<<endl;

    for( int i = 0; i < n; ++i ) cout<<1+rand()%3<<" ";cout<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <stack>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <fstream>
#include <cstdio>
using namespace std;

#define pii pair<ll,ll>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

int d[][2] = { 1,2, -1,2 , 1,-2, -1,-2,  2,1, -2,1, 2,-1, -2,-1 };

const ll inf = 9999999999999LL;
const int maxn = 50;
ll dp[maxn*2][maxn*2];

ll jumps( ll r1, ll c1, ll r2, ll c2 ){
    ll xd = abs(c1-c2);
    ll yd = abs(r1-r2);
    ll mov = 0;

    if( yd > xd ) swap( xd , yd );

    if( xd > 30 && yd > 30 ){
        ll t = min(xd - yd,(xd-30)/2);
        xd -= t*2;

        if( yd - t < 0 ) yd = (yd+t)%2 == 1;
        else yd -= t;
        mov += t;

        if( xd > 20 && yd > 20 ){
            ll t = min(xd,yd) - 20;
            xd -= (t/3)*3;
            yd -= (t/3)*3;
            mov += (t/3)*2;
        }
    }
    if( xd > 30 ){
        ll t = (xd - 30)/2;
        xd -= t*2;

        if( yd - t < 0 ) yd = (yd+t)%2 == 1;
        else yd -= t;
        mov += t;
    }
    return mov + dp[xd][yd] - 1;
}

void preprocess(){
    queue< pii > q;
    q.push( mk( 0 , 0 )) ;
    dp[0][0] = 1;

    while( !q.empty() ){
        pii u = q.front(); q.pop();

        for( int i = 0; i < 8; ++i ){
            ll x = u.f + d[i][0];
            ll y = u.s + d[i][1];
            x = abs(x);
            y = abs(y);

            if( x >= maxn || y >= maxn ) continue;
            if( dp[x][y] ) continue;

            dp[x][y] = dp[u.f][u.s] + 1;
            q.push( mk(x,y) );
        }
    }
}

int n;
pii knights[20];
pii targets[20];

ll dst[20][20];
ll mem[16][1<<16];

ll solve( int dx , int mask ){

    if( dx == n ) return 0;

    ll &ref = mem[dx][mask];
    if( ref >= 0 ) return ref;

    ref = inf;

    for( int i = 0; i < n; ++i ){
        if( mask&(1<<i) ) continue;
        ref = min( ref , solve( dx + 1 , mask+(1<<i) ) + dst[dx][i] );
    }
    return ref;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
    preprocess();

    int t = 0;
    while( scanf("%d",&n) == 1 ){ t++;
        if( n == 0 ) break;

        for( int i = 0; i < n; ++i ){
            ll a,b; cin >> a >> b;
            knights[i] = mk(a,b);
        }

        for( int i = 0; i < n; ++i ){
            ll a,b; cin >> a >> b;
            targets[i] = mk(a,b);
            for( int k = 0; k < n; ++k )
                dst[k][i] = jumps( knights[k].f, knights[k].s, targets[i].f, targets[i].s );
        }

        for( int i = 0; i < n; ++i )
            for( int j = 0; j < (1<<n); ++j )
                mem[i][j] = -1;

        ll sol = solve( 0 , 0  );
        cout<<t<<". "<<sol<<endl;
    }


    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
using namespace std;

typedef long long ll;

ll g,t,a,d;

int main(){

    while( scanf("%lld%lld%lld%lld",&g,&t,&a,&d) == 4 ){
        if( g == -1 ) break;

        ll sol = g * t*(ll)(t-1) / 2;

        ll adv = g*(ll)a + d;
        ll stpg = 1;

        while( adv > stpg ) stpg <<= 1;

        ll toadd = stpg - adv;

        ll logit = stpg;
        while( logit > 1 ){
            sol += logit / 2;
            logit /= 2;
        }
        printf("%lld*%lld/%lld+%lld=%lld+%lld\n",g,a,t,d,sol,toadd);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <algorithm>
using namespace std;

int a[3];

int main(){
    while( scanf("%d %d %d",&a[0],&a[1],&a[2]) == 3 ){
        if( a[0] == 0 && a[1] == 0 && a[2] == 0 ) break;

        if( a[1] - a[0] == a[2] - a[1] ) printf("AP %d\n",2*a[2] - a[1] );
        else printf("GP %d\n",a[2]*a[2]/a[1]);
    }
    return 0;
}

#include <iostream>
#include <cstdio>
using namespace std;

int main(){
    int tests; scanf("%d",&tests);

    while( tests -- ){
        int n,a,d;
        scanf("%d%d%d",&n,&a,&d);
        int sol = (n*(n-1)/2)*d + n*a;
        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <math.h>
#include <map>
#include <iomanip>
#include <string.h>
#include <string>
#include <assert.h>
#include <cstdio>
using namespace std;

int v[5];

int main(){
    int n;
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        int a; scanf("%d",&a);
        v[ a % 3 ] ++;
    }


    int sol = 0;
    sol += v[0] / 2;
    int x = min( v[1] , v[2] );
    sol += x;
    v[1] -= x;
    v[2] -= x;

    cout << sol << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
using namespace std;

const int maxn = 20000 + 55;

int n,m;
int v[maxn];

int main(){
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&n,&m);
        for( int i = 0; i < n; ++i ) scanf("%d",&v[i]);

        sort( v , v + n );

        int sol = v[m-1] - v[0];

        for( int i = m; i < n; ++i )
            sol = min( sol , v[i] - v[i-m+1] );

        printf("%d\n",sol);
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <math.h>
#include <stack>
#include <iomanip>
#include <queue>
#include <set>
using namespace std;

typedef long long ll;

const int maxn = 75;

bool notprime[maxn];
vector< int > p;

int mod;
vector< int > x;

void solve( int n, int dx, ll v ){
    if( n == 0 ) x.push_back(v);

    for( int i = dx; i < p.size(); ++i ){
        if( n < p[i] ) continue;
        solve( n - p[i], i , (v*(ll)p[i])%mod);
    }
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    p.push_back(1);
    for( int i = 2; i <= 70; i ++ ){
        if( notprime[i] ) continue;
        p.push_back(i);

        for( int j = i+i; j < maxn; j += i ) notprime[j] = true;
    }

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        int n; scanf("%d%d",&n,&mod);
        x.clear();
        solve( n , 0 , 1 );
        sort( x.begin() , x.end() );
        x.erase( unique(x.begin(),x.end()),x.end());

        printf("%d\n",(int)x.size());
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <map>
#include <string>
using namespace std;

typedef long long ll;

const int maxn = 100 + 55;
const int mod = 1000000007;

int n,m;
int c[maxn];
vector< int > g[maxn];

int cntN,cycN;
bool visi[maxn];
int dst[maxn];

int dp[maxn][2];

void clear(){
    memset( dp, -1, sizeof(dp));
    for( int i = 0; i < maxn; ++i ) g[i].clear(), dst[i] = visi[i] = 0;
}

void input(){
    clear();
    scanf("%d%d",&n,&m);
    for( int i = 0; i < n; ++i ){
        scanf("%d",&c[i]);
        g[i].push_back( c[i] );
        g[ c[i] ].push_back( i );
    }
}


void dfs( int dad, int node ){
    cntN++;
    visi[node] = 1;
    if( dad == -1 ) dst[node] = 0;
    else dst[node] = dst[dad] + 1;

    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( visi[nxt] ){
            if( nxt != dad ) cycN = abs(dst[node] - dst[nxt]) + 1;
            continue;
        }
        dfs( node , nxt );
    }
}

int solve( int n, bool prevroot ){
    if( n == 1 ){
        if( prevroot ) return m-1;
        else return m-2;
    }

    int &sol = dp[n][prevroot];
    if( sol != -1 ) return sol;

    sol = 0;

    sol = ( sol + (m-1-(prevroot==false))*(ll)solve( n-1, false ) ) % mod;
    if( prevroot == false ) sol = ( sol + (ll)solve( n-1, true ) ) % mod;
    return sol;
}


int solve(){

    int sol = 1;
    for( int i = 0; i < n; ++i ){
        if( visi[i] ) continue;
        cntN=cycN=0;
        dfs( -1 , i );


        int cnt = ((m-1)*(ll)solve( cycN-1, 1 ))%mod;
        if( cntN == cycN ) cnt = (cnt+(ll)solve( cycN-1, 1 ) )%mod;


        int left = cntN - cycN;
        if( left > 0 ){
            cnt = (cnt*(ll)m)%mod; left --;
            for( int i = 0; i < left; ++i ) cnt = (cnt*(ll)(m-1))%mod;
        }
        sol = (sol*(ll)cnt)%mod;
    }
    return sol;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){

        input();

        int sol = solve();
        printf("%d\n",sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <set>
#include <queue>
#include <algorithm>
using namespace std;

typedef long long ll;

const int maxn = 1000000;

int n,m;
int out[maxn];

void input(){
    scanf("%d%d",&m,&n);

    for( int i = 1; i < n; ++i ){
        int p; scanf("%d",&p); p --;
        out[p] ++;
    }

    int sol = 1;

    for( int i = 0; i < n; ++i ){
        if( out[i] )sol = ( sol * (ll)out[i] ) % m;
        out[i] = 0;
    }

    printf("%d\n",sol);
}

int main(){
    int tests; scanf("%d",&tests);
    for( ; tests; --tests ){
        input();
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <algorithm>
#include <iomanip>
#include <math.h>
using namespace std;

const int maxn = 500000 + 55;

int n,m;
vector< int > g[maxn];

void clear();

void input(){
    scanf("%d%d",&m,&n);

    clear();

    for( int i = 1; i < n; ++i ){
        int p; scanf("%d",&p); p --;
        g[p].push_back( i );
        g[i].push_back( p );
    }
}

int f[maxn];
int fak[maxn];

int sz[maxn];
int prek[maxn];

void clear(){
    for( int i = 0; i <= n; ++i ){
        g[i].clear(), sz[i] = prek[i] = 0;
        f[i] = fak[i] = 0;
    }
}

int dfs( int node , int dad ){
    prek[node] = dad;
    sz[node] = 1;
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];

        if( nxt == dad ) continue;
        sz[node] += dfs( g[node][i] , node );
    }
}


void brojnik(){
    for( int i = 0; i < n; ++i ) f[ sz[i] - 1 ] ++;
}

void nazivnik(){

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < g[i].size(); ++j ){
            int nxt = g[i][j];
            if( nxt == prek[i] ) continue;
            f[ sz[nxt] ] --;
        }
    }
}

int ff[maxn][30], sf[maxn];

int solve(){
    for( int i  =0 ; i < 20; ++i ) cout<<f[i]<<" ";cout<<endl;
    int sol = 1;
    for( int i = 2; i < maxn; ++i )
        for( int j = 0; j < f[i]; ++j )
            for( int k = 1; k <= i; ++k )
                sol *= k;

    for( int i = 2; i < maxn; ++i )
        for( int j = 0; j < -f[i]; ++j )
            for( int k = 1; k <= i; ++k )
                sol /= k;

    return sol;
}

int main(){
    for( int i = 2; i < maxn; ++i ){
        int x = i;
        for( int j = 2; j*j <= x; ++j ){
            while( x % j == 0 ){
                x /= j;
                ff[i][ sf[i]++ ] = j;
            }
        }
        if( x > 1 ) ff[i][ sf[i]++ ] = x;
    }

    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests ; --tests ){
        input();
        dfs( 0 , -1 );
        brojnik();
        nazivnik();

        int sol = solve();
        printf("%d\n",sol);
    }

    return 0;
}

#include <cstdio>
using namespace std;

typedef long long ll;

const int maxn = 500000 + 55;
const int maxe = 1000000 + 55;

int n,m;

int cnte;
int head[maxn] , nx[maxe], point[maxe];

void add_edge( int a, int b ){
    nx[cnte] = head[a], point[cnte] = b, head[a] = cnte; cnte ++;
    nx[cnte] = head[b], point[cnte] = a, head[b] = cnte; cnte ++;
}

void clear();

inline void readi( int &v ){
    static char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c-'0';
    while( (c=getchar())>='0' && c <= '9' ) v = v*10 + c - '0';
}

int f[maxn];
int divs[maxn], nxt[maxn];


int prek[maxn];

void clear(){ cnte = 1; for( int i = 0; i <= n; ++i ) f[i] = 1, head[i]=0; }

int dfs( int node ){
    int sol = 1;

    for( int i = head[node]; i > 0; i=nx[i] ){
        int nxt = point[i];

        if( nxt == prek[node] ) continue;
        int s = dfs( nxt );
        sol += s;
        f[ s ] --;
    }
    return sol;
}

int S[maxn] , sstk = 0;

inline int fpow( int v, int stp ){
   sstk = 0;
   while(stp!=1 ){
      if( stp&1 ) stp--, S[sstk++] = 1;
      else stp >>= 1, S[sstk++] = 2;
   }
   int tmp = v;
   while( sstk > 0 ){
      sstk --;
      if( S[sstk] ==1 ) v  = (v*(ll)tmp)%m;
      else v =  (v*(ll)v)%m;
   }
   return v;
}

int solve(){
    int sol = 1;

    for( int i = n-1; i >= 2; --i ){
        if( f[i] == 0 );
        else if( divs[i] == i ){
            sol = (sol*(ll)fpow(i,f[i]))%m;
            continue;
        }else{
            f[ divs[i] ] += f[i];
            f[ nxt[i] ] += f[i];
        }
    }

    return sol;
}

bool vs[maxn];

void preproces(){
    for( int i = 2; i < maxn; i ++ ){
        if( vs[i] ) continue;
        divs[i] = i, nxt[i] = 1;

        int j = i+i;
        int cnt = 2;
        while( j < maxn ){
            vs[j] = 1, divs[j] = i, nxt[j] = cnt;
            cnt ++ , j += i;
        }
    }
}


int main(){
    prek[0] = -1;
    preproces();
   // return 0;

    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests ; --tests ){
        readi(m); readi(n);
        clear();

        for( int i = 1; i < n; ++i ){
            int p; readi(p); p --;
            add_edge( i , p );
            prek[i] = p;
        }
        dfs( 0 );

        int sol = solve();
        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <vector>
using namespace std;

const int maxn = 100000 + 66;

char txt[maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%s",txt);
        int len = strlen(txt);

        int dx = len;
        int cnt = 0;
        int wait = 0;

        int sol = 0;


        for( int i = len-1; i >= 0; --i ){
            if( txt[i] == 'G' ){
                if( i == len-cnt-1 ){
                    wait = 0 , cnt ++ , dx = i;
                    continue;
                }
                int elaps = dx - i - 1;
                int nw = max( wait + 1 - elaps , 0 );

                sol = max( sol , nw + (len-cnt-1) - i );

                wait = nw;
                dx = i;
                cnt ++;
            }
        }

        printf("%d\n",sol);

    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <vector>
using namespace std;

const int maxn = 100000 + 66;

char txt[maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%s",txt);
        int len = strlen(txt);

        int sol = 0;
        bool ok = 1;
        while( ok ){
            ok = 0;
            for( int i = 1; i < len; ++i ){
                if( txt[i] == 'B' && txt[i-1] == 'G' ){
                    ok = 1;
                    swap( txt[i] , txt[i-1] );
                    i++;
                }
            }
            for( int i = 0; i < len; ++i )
                cout<<txt[i]<<" ";cout<<endl;
            sol += ok;
        }

        printf("%d\n",sol);
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <algorithm>
#include <stack>
#include <string.h>
#include <string>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second

const int maxn = 100000;

char ex[maxn];

int main(){
    int t = 1;
    while( scanf("%s",ex) == 1 ){
        int n = strlen(ex);
        if( ex[0] == '(' && ex[1] == ')' && n == 2 ) break;

        int cnt = 0 , mx = 0;
        for( int i = 0; i < n; ++i ){
            if( ex[i] == '(' ) cnt ++;
            else if( ex[i] == ')' ) cnt --;
            mx = max( cnt , mx );
        }


        stack< int > stk;
        stk.push(-1);
        bool mode = !(mx%2);

        for( int i = 0; i < n; ++i ){
            if( ex[i] == '(' ){
                stk.push( -1 );
                mode = !mode;
            }else if( ex[i] == ')' ){
                mode = !mode;
                int u = stk.top(); stk.pop();

                if( stk.top() == -1 ) stk.top() = u;
                if( mode ) stk.top() = stk.top() && u;
                else stk.top() = stk.top() || u;
            }else{

                if( stk.top() == -1 ) stk.top() = ex[i] == 'T';
                else if( mode ) stk.top() = stk.top() && (ex[i]=='T');
                else stk.top() = stk.top() || (ex[i]=='T');
            }
        }
        if( stk.top() ) printf("%d. true\n",t);
        else printf("%d. false\n",t);
        t++;
    }


    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <math.h>
#include <map>
#include <iomanip>
#include <string.h>
#include <string>
#include <assert.h>
#include <cstdio>
using namespace std;

map<string,int> m;

int main(){
    int n;
    scanf("%d",&n);
    int sol = -1;
    string ss = "";
    while(n--){
        string w;
        cin >> w;

        m[w] ++;
        if( m[w] > sol )
            ss = w , sol = m[w];
    }
    cout <<  ss <<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <math.h>
#include <map>
#include <iomanip>
#include <string.h>
#include <string>
#include <assert.h>
#include <cstdio>
using namespace std;

string s1,s2;

int has[255];

int main(){
  //  freopen("Ulaz.txt","r",stdin);
    getline( cin , s1 );
    getline( cin , s2 );

    for( int i = 0; i < s1.size(); ++i )
        has[ s1[i] ] ++;


    bool ok = 1;
    for( int i = 0; i < s2.size(); ++i ){
        if( s2[i] == ' ' ) continue;
        has[ s2[i] ] --;
        if( has[ s2[i] ] < 0 ) ok = 0;
    }
    if( ok ) printf("YES\n");
    else printf("NO\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <stack>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <cstdio>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

int d[][2] = { 1,2, -1,2 , 1,-2, -1,-2,  2,1, -2,1, 2,-1, -2,-1 };

ll x1,y1,x2,y2;

const int e = 50;

ll dp[e][e];
bool visi[e][e];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    cin >> x1 >> y1 >> x2 >> y2;

    ll xd = abs(x1-x2);
    ll yd = abs(y1-y2);
    ll mov = 0;

    if( yd > xd ) swap( xd , yd );

    if( xd > 30 && yd > 30 ){
        ll t = min(xd - yd,(xd-30)/2);
        xd -= t*2;

        if( yd - t < 0 ) yd = (yd+t)%2 == 1;
        else yd -= t;
        mov += t;

        if( xd > 20 && yd > 20 ){
            int t = min(xd,yd) - 20;
            xd -= (t/3)*3;
            yd -= (t/3)*3;
            mov += (t/3)*2;
        }
    }
    if( xd > 30 ){
        ll t = (xd - 30)/2;
        xd -= t*2;

        if( yd - t < 0 ) yd = (yd+t)%2 == 1;
        else yd -= t;
        mov += t;
    }
   // cout<<xd<<" "<<yd<<" , "<<mov<<endl;

    queue< pii > q;
    q.push( mk( xd , yd )) ;
    visi[xd][yd] = 1;
    dp[xd][yd] = 0;

    while( !q.empty() ){
        pii u = q.front(); q.pop();

        for( int i = 0; i < 8; ++i ){
            ll x = u.f + d[i][0];
            ll y = u.s + d[i][1];
            x = abs(x);
            y = abs(y);

            if( x >= e || y >= e ) continue;
            if( visi[x][y] ) continue;

            visi[x][y] = 1;
            dp[x][y] = dp[u.f][u.s] + 1;
            q.push( mk(x,y) );
        }
    }

    cout << mov + dp[0][0] << endl;


    return 0;
}

#include <iostream>
#include <cstdlib>
#include <math.h>
#include <vector>
#include <set>
#include <stack>
#include <queue>
#include <map>
using namespace std;

typedef long long ll;
const int maxn = 50005;

int n;
int niz[maxn];
ll sol[maxn];
vector< int > v;
map< int , int> M;
map< int , int> I;

vector< int > ix[maxn];


int BIT[maxn];

void update( int idx , int val = 1 ){
    idx ++;
    for( ; idx < maxn; idx += idx & -idx )
        BIT[idx] += val;
}
int read( int idx ){
    idx++;
    int sol = 0;
    for( ; idx >= 1; idx -= idx & -idx )
        sol += BIT[idx];
    return sol;
}
int read( int l , int r ){
    if( r < l ) return 0;
    return read(r) - read(l-1);
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        scanf("%d",&niz[i]);
        v.push_back( niz[i] );
        update( i );

        if( I[ niz[i] ] == 0 ){
            I[ niz[i] ] = i+1;
            ix[ i ].push_back( i );
        }else
            ix[ I[niz[i]]-1 ].push_back( i );

        M[ niz[i] ] ++;
    }

    sort( v.begin() , v.end() );
    v.erase( unique(v.begin(),v.end()), v.end() );

    ll cnt = 0 , last = 1;

    for( int i = 0; i < v.size(); ++i ){
        int diff = v[i]-last;
        last = v[i]+1 ;
        ll jobs = read( 0 , n-1 );

        cnt += diff * jobs;
        jobs -= M[ v[i] ];

        int k = I[ v[i] ] - 1;
        int d = 0;

        for( int j = 0; j < ix[k].size(); ++j ){
            int sum = read(d,ix[k][j]-1);
            cnt += sum + 1;
            sol[ ix[k][j] ] = cnt;
            d = ix[k][j];

            update( ix[k][j] , -1 );
        }
        cnt += read(d,n-1);
    }

    for( int i = 0; i < n; ++i )
        printf("%lld\n",sol[i]);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <vector>
#include <math.h>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <set>
using namespace std;

int n;

bool o[65000];
int ky[65000];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    for( int i = 0; i <= 181; ++i )
        o[i*i] = i , ky[i*i] = i;

    while( cin >> n ){
        if( n == 0 )break;
        int s = 0;

        for( int i = 0; i <= 181 && i*i <= n; ++i ){
            for( int j = i; j <= 181 && i*i + j*j <= n; ++j ){
                for( int k = j; k <= 181 && i*i + j*j + k*k <= n; ++k ){
                    int d = n - i*i - j*j - k*k;
                    if( o[d] && ky[d] >= k )s++;
                }
            }
        }

        printf("%d\n",s);

    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <set>
#include <stack>
#include <map>
using namespace std;

int n;
bool mx[550][550];

short dp[550][550][20][3];

bool mem[550][550];
int sol[550][550];

int setv( int y1, int y2 , int x1 , int x2 , bool v ){
    int ret = 0;
    for( int i = y1; i <= y2; ++i )
        for( int j = x1; j <= x2; ++j ){
            mem[i][j] = v;
            ret += bool(v != mx[i][j]);
        }
    return ret;
}

void setm( int y1, int y2 , int x1 , int x2 , bool v ){ for( int i = y1; i <= y2; ++i )for( int j = x1; j <= x2; ++j )sol[i][j] = v; }

int maxx = INT_MAX;

int solve( int y1 , int y2,  int x1, int x2 , int deep  ){


    if( y1 == y2 && x1 == x2 ){
        mem[y1][x1] = mx[y1][x1];
        return 0;
    }

    int ymid = (y2 + y1 - 1) >> 1;
    int xmid = (x2 + x1 - 1) >> 1;


    int ret = INT_MAX;
    int si = dp[y1][x1][deep][0];
    int sj = dp[y1][x2][deep][1];
    if( dp[y1][x2][deep][2] != -1 )ret= dp[y1][x2][deep][2];

    if( si == -1 )
    for( int i = 0; i < 4; ++i ){
        for( int j = 0; j < 4; ++j ){
            if( i == j ) continue;

            int q = 0;

            for( int k = 0; k <= 1; ++k ){
                int m = i;
                if( k == 1 ) m = j;

                if( m == 0 ) q += setv( y1 , ymid , x1 , xmid , k );
                if( m == 1 ) q += setv( ymid + 1 , y2 , x1 , xmid , k );
                if( m == 2 ) q += setv( y1 , ymid , xmid + 1 , x2 , k );
                if( m == 3 ) q += setv( ymid + 1 , y2 , xmid + 1 , x2 , k );
            }


            for( int k = 0; k < 4; ++k ){
                if( k == i || k == j ) continue;

                if( k == 0 ) q += solve( y1 , ymid , x1 , xmid , deep + 1 );
                if( k == 1 ) q += solve( ymid + 1 , y2 , x1 , xmid , deep + 1  );
                if( k == 2 ) q += solve( y1 , ymid , xmid + 1 , x2 , deep + 1  );
                if( k == 3 ) q += solve( ymid + 1 , y2 , xmid + 1 , x2 , deep + 1  );

            }

            if( ret > q )
                ret = q , si = i , sj = j;
        }
    }

    for( int k = 0; k <= 1; ++k ){
        int m = si;
        if( k == 1 ) m = sj;

        if( m == 0 ) setm( y1 , ymid , x1 , xmid , k );
        if( m == 1 ) setm( ymid + 1 , y2 , x1 , xmid , k );
        if( m == 2 ) setm( y1 , ymid , xmid + 1 , x2 , k );
        if( m == 3 ) setm( ymid + 1 , y2 , xmid + 1 , x2 , k );
    }

    if( x1 == xmid ){
        for( int k = 0; k < 4; ++k ){
            if( k == si || k == sj ) continue;

            if( k == 0 ) sol[y1][x1] = mx[y1][x1];
            if( k == 1 ) sol[y2][x1] = mx[y2][x1];
            if( k == 2 ) sol[y1][x2] = mx[y1][x2];
            if( k == 3 ) sol[y2][x2] = mx[y2][x2];
        }
    }

    dp[y1][x1][deep][0] = si;
    dp[y1][x2][deep][1] = sj;
    dp[y1][x2][deep][2] = ret;

    return ret;
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d",&n);

    char c;
    for( int i = 1; i <= n; ++i )
        for( int j = 1; j <= n; ++j ){
            while( c = fgetc(in) ) if( c == '0' || c == '1' ) break;
            mx[i][j] = c - '0';
        }

    memset( dp , -1, sizeof(dp));
    int ss = solve( 1 , n , 1 , n , 0 );

    printf("%d\n",ss);


    for( int i = 1; i <= n; ++i ){
        for( int j = 1; j <= n; ++j ){
            putchar(sol[i][j]+'0');
        }putchar('\n');
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <vector>
#include <set>
#include <queue>
using namespace std;

int main(){
    int tests;
    scanf("%d",&tests);
    for( ; tests; --tests ){

        int n,v;
        scanf("%d",&n);

        int sol = 0;

        for( int i = 1; i <= n; ++i){
            scanf("%d",&v);
            for( int j = 0; j < v; ++j )
                sol ^= i;
        }

        if( sol )
            printf("Tom Wins\n");
        else
            printf("Hanks Wins\n");



    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
using namespace std;

#define pq priority_queue
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 205;
const int source = maxn + maxn + 100;
const int sink    = maxn + maxn + 101;
const int inf = 9999999;

int n1,n2,n3;
int c[maxn*3];

int cap[maxn*3][maxn*3];
vector< int > G[maxn*3];


void add_edge( int from, int to, int cp ){
    G[from].push_back( to );
    G[to].push_back(from);
    cap[from][to] += cp;
}


bool visi[ maxn * 3 ];
int dad[maxn * 3];

int flw(){
    memset( visi , false , sizeof(visi));

    pq< pair<int,pii> > Q;
    pair<int,pii> u;

    Q.push( mk( inf , mk(source,-1) ) );

    while( !Q.empty() ){
        u = Q.top(); Q.pop();

        int now = u.s.f;
        int fat = u.s.s;

        if( visi[now] ) continue;
        dad[now] = fat;
        if( now == sink )break;

        visi[ now ] = true;

        for( int i = 0; i < G[now].size(); ++i ){
            int mm = min( u.f , cap[ now ][ G[now][i] ] );
            //cout<<now<<" -> "<<G[now][i]<<" = "<<mm<<endl;
            if( mm ) Q.push( mk( mm , mk(G[now][i],now) ) );
        }
    }

    if( u.s.f != sink ) return -1;
    int f = u.f;
   // cout<<f<<endl;

    int it = u.s.f;
    while( dad[it] != -1 ){
        cap[ dad[it] ][ it ] -= f;
        cap[ it ][ dad[it] ] += f;
        it = dad[it];
    }

    return f;
}


int flow(){
    int sol = 0;
    while( 1 ){
        int f = flw();
        if( f == -1 )break;
        sol += f;
    }
    return sol;
}



int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d%d",&n1,&n2,&n3);

    for( int i = 1; i <= n2; ++i ){
        scanf("%d",&c[i]);
        add_edge( n1 + i , n1 + i + maxn , c[i] );
    }

    for( int i = 1; i <= n1; ++i ){
        int q,d;
        scanf("%d",&q);
        for( int j = 0; j < q; ++j ){
            scanf("%d",&d);
            add_edge( i , d , inf );
        }
    }

    for( int i = n1+1; i <= n2+n1; ++i ){
        int q,d;
        scanf("%d",&q);
        for( int j = 0; j < q; ++j ){
            scanf("%d",&d);
            add_edge( i + maxn , d , inf );
        }
    }

    for( int i = 1; i <= n1; ++i )
        add_edge( source, i , 1 );

    for( int i = n1+n2+1; i <= n1+n2+n3; ++i )
        add_edge( i , sink , 1 );

    printf("%d\n",flow() );

    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <math.h>
#include <stack>
#include <set>
#include <queue>
#include <math.h>
using namespace std;

typedef long long ll;

class BigNum{   // BIG_NUM_CLASS
   private:
      static const int NewBasis = 11;
      static const ll PLACES = 100000000000LL;
   public:
      ll digits[105],sz;
      BigNum(){}
      BigNum( ll v ):sz(0){while( v ) digits[sz++] = (v%PLACES) , v/=PLACES; }
      BigNum( char* );
      BigNum( const BigNum &z ){ sz = z.sz; for( int i = 0; i < sz; ++i )digits[i] = z.digits[i]; }

      BigNum operator+(const BigNum&);
      BigNum operator-(const BigNum&);
      inline void WriteLn();
      inline void Write();
      void operator=(BigNum);
      bool operator<(const BigNum&);
      bool operator>(const BigNum&);
      bool operator==(const BigNum&);
};


inline void BigNum::operator=(BigNum b2 ){
   sz = b2.sz;
   for( int i = 0; i < b2.sz; ++i )
        digits[i] = b2.digits[i];
}


inline ll getv( string &s ){
    ll r = 0;
    for( int i = 0; i < s.size(); ++i )
        r = r*10 + s[i] - '0';
    return r;
}

BigNum::BigNum( char *f ){
    sz = 0;
   int k = 0;
   ll v = 0;
   int len = strlen(f);
   string T;
   for( int i = len-1; i >= 0; --i ){

       T = string(1,f[i])+T;
       k++;

       if( k == NewBasis ){
          digits[sz++] = ( getv(T) );
          T = "";
          k = 0;
       }
   }
   if( k ) digits[sz++] = ( getv(T) );
   while( sz !=0 && digits[sz-1] == 0 )sz--;
}

inline bool BigNum::operator==( const BigNum &b2 ){
   if( b2.sz != sz )return  false;
   for( int i = 0; i < sz; ++i )
      if( digits[i] != b2.digits[i] )return false;
   return true;
}

bool BigNum::operator<( const BigNum &b2 ){
   if( b2.sz > sz )return true;
   else if( b2.sz < sz )return false;
   else{
       for( int i = sz-1; i >=0 ; --i ){
         if( digits[i] < b2.digits[i] )
            return true;
         else if( digits[i] > b2.digits[i] )
            return false;
      }
   }
   return false;
}
bool BigNum::operator>( const BigNum &b2 ){
   if( b2.sz < sz )return true;
   else if( b2.sz > sz )return false;
   else{
      for( int i = sz-1; i >=0 ; --i ){
         if( digits[i] > b2.digits[i] )
            return true;
         else if( digits[i] < b2.digits[i] )
            return false;
      }
   }
   return false;
}



BigNum BigNum::operator+( const BigNum &b2 ){
   BigNum A = *this , B = b2;
   if( A.sz == 0 ) return B;
   else if ( B.sz == 0 ) return A;

   if( A.sz < B.sz )swap(A,B);
   BigNum sum = B;
   ll tmp = 0;
   for( int i = 0; i < B.sz; ++i ){
      ll ss = B.digits[i] + A.digits[i] + tmp;
      sum.digits[i] = ss%PLACES;
      tmp = ss / PLACES;
   }
   for( int i = B.sz; i < A.sz; ++i ){
      ll ss = A.digits[i] + tmp;
      sum.digits[sum.sz++] = ( ss % PLACES );
      tmp = ss/PLACES;
   }
   while( tmp ){
      sum.digits[sum.sz++] = ( tmp % PLACES);
      tmp /= PLACES;
   }
   return sum;
}

BigNum BigNum::operator-(const BigNum& b2){
   if( (*this) > b2 ){
      ll add = 0;
      int len1 = sz;
      int len2 = b2.sz;
      BigNum ret = (*this);
      for( int i = 0; i < len1 && ( add != 0 || i < len2 ); ++ i ){
         ll num1 = digits[i];
         ll num2 = ( i < len2 ? b2.digits[i] : 0 ) + add;
         add = 0;

         while( num1 < num2 ) num1 += PLACES , add ++;

         ret.digits[i] = num1 - num2;

      }
      while( ret.digits[ret.sz-1] == 0 )ret.sz--;
      return ret;
   }else if( (*this) == b2 )return BigNum(0LL);
   else return BigNum(-1LL);
}

inline void BigNum::WriteLn(){
   if( sz == 0 )printf("0");
   for( int i = sz-1; i >=0; --i )
      cout<<" "<<digits[i];
   printf("\n");
}











int f[11];
int n,s,q;
BigNum Q;


char buff[105];
int used[255];

BigNum dp[105][105];

BigNum rc = 0LL;
char solc[105];

inline bool OverZero( BigNum a ){
    if( a.sz == 0 ) return false;
    for( int i = 0; i < a.sz; ++i )
        if( a.digits[i] < 0 ) return false;
    return true;
}
inline bool EqZero( BigNum a ){
    if( a.sz == 0 ) return true;
    return false;
}


bool found = false;
BigNum solve( int idx , int diff , BigNum ss ){
    if( idx == n ){
        BigNum T = Q - ss - f[diff];
        if( T.sz == 0 || T.digits[0] == -1  ){
            memcpy( solc , buff , sizeof solc );
            rc = ss;
            found = true;
        }
        return f[diff];
    }

    if( dp[idx][diff].sz != 0 && OverZero(Q - dp[idx][diff] - ss) ) return dp[idx][diff];

    BigNum sol = 0LL;

    for( char c = 'A'; c < 'A' + s && !found; ++c ){
        int plus = 0;
        if( used[c] == 0 )plus ++;

        if( diff + plus == 11 ) continue;

        used[c] ++ , buff[idx] = c;
        sol = sol +  solve( idx + 1 , diff + plus , ss+sol );
        used[c] --;

        if( found ) return sol;

        if( OverZero(Q - sol - ss) ){
            memcpy( solc , buff , sizeof solc );
            rc = sol + ss;
        }else
            found = true;
    }
    dp[idx][diff] = sol;
    return sol;
}

char rec2[105];
int MMM[11][11];

inline int fs( int len , int s ){
    int g = 1;
    for( int i = 0; i < len; ++i , --s )
        g *= s;
    return g;
}

int m , c;
void solve2( int idx , int ss ){

    if( idx == m ) return;

    int sol = 0;

    for( int i = 0; i <= 9; ++i ){
        if( used[i] ) continue;
        rec2[idx] = '0' + i;

        int p =fs(m - idx-1 , 10 - idx - 1 );
        int now = sol + p;

        if( c == now && idx == m-1 ) return;

        if( ss+now >= c ){
            used[i] ++;
            solve2( idx + 1 , ss + sol );
            return;
        }else
            sol += p;

    }

}

char bff[200];
int mapp[255];

char zzz[] = {"343423\0"};;

int main(){

    for( int i = 0; i <= 10; ++i )
        for( int j = 0; j <= 10; ++j )
            MMM[i][j] = fs(i,j);
    f[0] = 1 , f[1] = 10;
    for( int i = 2 , k = 9; i <= 10; ++i , k-- )f[i] = f[i-1]*k;

    scanf("%d%d%d",&s,&n,&q);

    for( int i = 0; i < q; ++i ){

        scanf("%s",bff);

        Q= BigNum(bff);
        Q = Q + 1;

        buff[n] = '\0';
        found = false;

        memset( used , 0 , sizeof(used));

        solve( 0 , 0 , 0LL );
        if( q == 20 ) return 0;

        m = 0;
        BigNum f = Q - rc;

        c = 0;
        for( int i = f.sz-1; i >= 0 ; --i )
            c = c * 10 + f.digits[i];

        memset( used , 0 , sizeof(used));
        for( int i = 0; i < n; ++i ){
            if( used[ solc[i] ] == 0 ) m++;
            used[ solc[i] ]++;
        }

        rec2[m] = '\0';
        memset( used , 0 , sizeof(used));
        solve2     ( 0 , 0 );

        int k = 0;
        memset( used , 0 , sizeof(used));
        for( int i = strlen(solc)-1; i >= 0; --i ){
            if( used[ solc[i] ] == 0 ) mapp[ solc[i] ] = rec2[k++];
            used[ solc[i] ] ++;
        }

        printf("%s",solc);
        for( int i = strlen(solc)-1; i >= 0; --i )
            printf("%c",(char)mapp[ solc[i] ]);
        putchar('\n');

    }

    return 0;
}

/* circle_circle_intersection() *
 * Determine the points where 2 circles in a common plane intersect.
 *
 * int circle_circle_intersection(
 *                                // center and radius of 1st circle
 *                                double x0, double y0, double r0,
 *                                // center and radius of 2nd circle
 *                                double x1, double y1, double r1,
 *                                // 1st intersection point
 *                                double *xi, double *yi,
 *                                // 2nd intersection point
 *                                double *xi_prime, double *yi_prime)
 *
 * This is a public domain work. 3/26/2005 Tim Voght
 *
 */
#include <stdio.h>
#include <iostream>
#include <math.h>
using namespace std;

int circle_circle_intersection(double x0, double y0, double r0,
                               double x1, double y1, double r1,
                               double *xi, double *yi,
                               double *xi_prime, double *yi_prime)
{
  double a, dx, dy, d, h, rx, ry;
  double x2, y2;

  /* dx and dy are the vertical and horizontal distances between
   * the circle centers.
   */
  dx = x1 - x0;
  dy = y1 - y0;

  /* Determine the straight-line distance between the centers. */
  //d = sqrt((dy*dy) + (dx*dx));
  d = hypot(dx,dy); // Suggested by Keith Briggs

  /* Check for solvability. */
  if (d > (r0 + r1))
  {
    /* no solution. circles do not intersect. */
    return 0;
  }
  if (d < fabs(r0 - r1))
  {
    /* no solution. one circle is contained in the other */
    return 0;
  }

  /* 'point 2' is the point where the line through the circle
   * intersection points crosses the line between the circle
   * centers.
   */

  /* Determine the distance from point 0 to point 2. */
  a = ((r0*r0) - (r1*r1) + (d*d)) / (2.0 * d) ;
  cout<<"A: "<<a<<endl;

  /* Determine the coordinates of point 2. */
  x2 = x0 + (dx * a/d);
  y2 = y0 + (dy * a/d);

  /* Determine the distance from point 2 to either of the
   * intersection points.
   */
  h = sqrt((r0*r0) - (a*a));

  /* Now determine the offsets of the intersection points from
   * point 2.
   */
  rx = -dy * (h/d);
  ry = dx * (h/d);

  /* Determine the absolute intersection points. */
  *xi = x2 + rx;
  *xi_prime = x2 - rx;
  *yi = y2 + ry;
  *yi_prime = y2 - ry;

  return 1;
}

#define TEST

#ifdef TEST

void run_test(double x0, double y0, double r0,
              double x1, double y1, double r1)
{
  double x3, y3, x3_prime, y3_prime;

  printf("x0=%F, y0=%F, r0=%F, x1=%F, y1=%F, r1=%F :\n",
          x0, y0, r0, x1, y1, r1);
  circle_circle_intersection(x0, y0, r0, x1, y1, r1,
                             &x3, &y3, &x3_prime, &y3_prime);
  printf("  x3=%F, y3=%F, x3_prime=%F, y3_prime=%F\n",
            x3, y3, x3_prime, y3_prime);
}

int main(void)
{
  /* Add more! */

  double x3 , y3;
  double p1,p2;

  circle_circle_intersection( 0 , 0 , 3 , 0 , 2 , 3 , &x3 , &y3 ,  &p1 , &p2 );

  cout<<" | "<<p1<<" "<<p2<<endl;
  cout<<x3<<" "<<y3<<endl;


  return 0;
}
#endif


#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

int n;
char txt[100005][35];

int hash[30][30];

int main(){
    freopen("kaladont.in","r",stdin);
    freopen("kaladont.out","w",stdout);

    int n;
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        scanf("%s",txt[i]);
        hash[ txt[i][0] - 'A' ][ txt[i][1] - 'A' ] ++;
    }

    for( int i = 0; i < n; ++i ){
        int len = strlen(txt[i]);
        int pl = txt[i][ len - 2 ] - 'A';
        int l  = txt[i][ len - 1 ] - 'A';


        int minus = 0;
        if( pl == txt[i][0] - 'A' && l == txt[i][1] - 'A' ) minus = 1;


        if( hash[pl][l]-minus == 0 )
            printf("%s\n",txt[i]);
    }

    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<iomanip>
#include<set>
#include<math.h>
#include<queue>
#include<list>
#include<string.h>
#include<assert.h>
#include<map>
using namespace std;

#define ok(x,y) (x>=0&&x<maxn&&y>=0&&y<maxn)
#define pq priority_queue

const int null = 1200;
const int maxn = 2600;

int subx = 0;
int suby = 0;

struct coord{
   int x,y;
   coord( int p1, int p2 ):x(p1),y(p2){};
   coord(){};
};

inline int getnum( int a = 0){
    char c;
    int M = 1;
    while( (c=getchar())<'0' || c>'9' ) if( c == '-' ) M *= -1;;
    int v = c - '0';
    while( (c=getchar())>='0' && c<='9' ) v = v * 10 + c - '0';

    return M*(v+a);
}

inline coord getcoord( int a = 0){
    int a1 = getnum(a) , a2 = getnum(a);
    return coord( a1 , a2 );
}


coord s , e;
vector< int > L[maxn];
int P[maxn][maxn];
bool ING[maxn][maxn];

int d[][2] = { 0,1,  0,-1,  1,0,  -1,0 };

void makeb(){
    int n = (int)getnum();
    coord now = getcoord();
    now.x -= subx;
    now.y -= suby;

    for( int i = 0; i < n; ++i ){
        coord add = getcoord();

        for( int j = 0; j < fabs(add.x); ++j ){
            if( add.x < 0 ) now.x--;
            else now.x ++;
        }

        for( int j = 0; j < fabs(add.y); ++j ){
            if( add.y < 0 ) now.y--;
            else now.y ++;

            if( add.y > 0 ) L[ (int)now.y - 1 ].push_back( now.x );
            if( add.y < 0 ) L[ (int)now.y ].push_back( now.x );
        }
    }
}


struct data{
    coord prev,now;
    long double p;
    data(){};
    data( coord p1, coord p2 , long double  p3 ):prev(p1),now(p2),p(p3){};

    bool operator<( const data &d2 ) const {
        return p < d2.p;
    }
};

vector< coord > sor;
vector< int > pw;

coord prv[maxn][maxn];long double Z[maxn][maxn];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    s = getcoord();

    subx = s.x - null;
    suby = s.y - null;
    s.x = null , s.y = null;


    e = getcoord();
    e.x -= subx;
    e.y -= suby;

    makeb();

    int m;
    m = getnum();
    for( int i = 0; i < m; ++i ) makeb();




    for( int i = 0; i < null + null; ++i ){
        sort( L[i].begin() , L[i].end() );
        for( int j = 0; j < L[i].size(); j += 2 )
            for( int k = L[i][j]; k < L[i][j+1]; ++k ){
                P[i][k] = 100;
                Z[i][k] = -1;
                ING[i][k] = true;
            }
    }



    m = getnum();
    for( int i = 0; i < m; ++i ){
        coord C = getcoord();
        C.x -= subx;
        C.y -= suby;
        int d = getnum();
        sor.push_back(C);
        pw.push_back(d);
        ING[ C.y ][ C.x ] = false;
    }


    for( int i = 0; i < null + null; ++i ){
        for( int j = 0; j < L[i].size(); j += 2 )
            for( int k = L[i][j]; k < L[i][j+1]; ++k ){
                for( int l = 0; l < sor.size(); ++l ){
                    int d = abs(sor[l].x-k) + abs(sor[l].y-i);
                    long double p = (1.00/pw[l])*d;
                    int pi = round( p * 100 );
                    P[i][k] = min( P[i][k] , pi );
                }
            }
    }

//    for( int i = null + 6; i >= null; --i ){
//        for( int j = null; j <= null + 6; ++j )
//            cout<<setw(10)<<P[i][j];
//        cout<<endl;
//    }

    pq<data>Q;
    Z[s.y][s.x] = P[s.y][s.x]/100.0;
    Q.push( data( coord(-1,-1) , s , P[s.y][s.x]/100.0 ) );


    while( !Q.empty()  ){
        data u = Q.top(); Q.pop();
        prv[u.now.y][u.now.x] = u.prev;

        if( u.now.y == e.y && u.now.x == e.x )
            break;

        for( int i = 0; i < 4; ++i ){
            int xn = u.now.x + d[i][0];
            int yn = u.now.y + d[i][1];

            if( ok(yn,xn) == false || ING[yn][xn] == false ) continue;

            long double p = u.p * (P[yn][xn]/100.0);

            if( Z[yn][xn] < p   ){
                Z[yn][xn] = p;
                Q.push( data( u.now , coord(xn,yn) , p ) );
            }
        }
    }

    string sol = "";
    coord u = e;

    while( prv[u.y][u.x].x != -1 ){
        coord prev = prv[u.y][u.x];

        if( prev.x > u.x ) sol += "L";
        else if( prev.x < u.x ) sol += "R";
        else if( prev.y > u.y ) sol += "D";
        else sol += "U";

        u = prev;
    }

    reverse( sol.begin() , sol.end() );
    cout<<sol.size()<<endl;
    cout<<sol<<endl;
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <set>
#include <vector>
#include <iomanip>
#include <stack>
#include <map>
#include <queue>
#include <string.h>
#include <algorithm>
using namespace std;

const int maxn = 1000000;
const int mod = 10000;
int A[maxn + 5];

int main(){
    A[0] = 1;
    A[1] = 0;
    A[2] = 0;
    A[3] = 1;
    for( int i = 4; i <= maxn; ++i )
        A[i] = (A[i-2] + A[i-3])%mod;

    int tests,n;
    scanf("%d",&tests);
    for( ; tests; --tests ){
        scanf("%d",&n);
        n++;
        printf("%d\n",A[n]);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <set>
#include <vector>
#include <iomanip>
#include <stack>
#include <map>
#include <queue>
#include <string.h>
#include <algorithm>
using namespace std;

int n;
const int maxn = 1000000;
const int mod = 1000;

int f[maxn+5];
int p[maxn+5];


int main(){
    int tests;

    scanf("%d",&tests);

    f[1] = 1 , f[2] = 1;
    p[1] = 1 , p[2] = 2;


    for( int i = 3; i <= maxn; ++i ){
        f[i] = (f[i-1] + f[i-2])%mod;
        p[i] = (2*p[i-1] + p[i-2])%mod;
    }



    for( ; tests; --tests ){
        scanf("%d",&n);
        n++;
        printf("%d\n",(p[n]*f[n])%mod);
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <stack>
using namespace std;

typedef unsigned long long ll;

int a1,a2;

ll s , n;

int main(){
    while(  scanf("%d%d",&a1,&a2) == 2 ){
        s = a1 , n = a2;
        if( s == 0 && n == 0 ) break;
        n--;
        ll q = n*n + n + 2;
        ll d = n;
        ll f = s - 2;
        q += f * d;

        cout<<q<<endl;

    }

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;


class TheSequencesLevelOne {
    public:
        vector <int> find(vector <int> seq)
        {
            vector< int > sol;
            for( int i = 0; i < seq.size(); ++i ){
                int x = seq[i];
                if( x%4 == 0 || x%7 == 0 ) sol.push_back( x );
                else{
                    int y1,y2;
                    for( y1 = x+1; y1%4 != 0 && y1%7 != 0; ++y1 );
                    for( y2 = x-1; y2%4 != 0 && y2%7 != 0; --y2 );

                    int d1 = abs( x - y1 ) , d2 = abs( x - y2 );

                    if( d1 < d2 ) sol.push_back(y1);
                    else if( d2 < d1 )sol.push_back(y2);
                    else if( y1 < y2 )sol.push_back(y1);
                    else sol.push_back(y2);
                }
            }
            return sol;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const vector <int> &Expected, const vector <int> &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: " << print_array(Expected) << endl; cerr << "\tReceived: " << print_array(Received) << endl; } }
	void test_case_0() { int Arr0[] = {1, 2, 3, 4, 5, 6, 7}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = {0, 0, 4, 4, 4, 7, 7 }; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); verify_case(0, Arg1, find(Arg0)); }
	void test_case_1() { int Arr0[] = {1000000000, 999999995}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = {1000000000, 999999994 }; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); verify_case(1, Arg1, find(Arg0)); }
	void test_case_2() { int Arr0[] = {4, 7, 7, 4}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = {4, 7, 7, 4 }; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); verify_case(2, Arg1, find(Arg0)); }
	void test_case_3() { int Arr0[] = {44, 47, 77, 74, 474, 444, 747, 7777777}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = {44, 48, 77, 72, 472, 444, 748, 7777777 }; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); verify_case(3, Arg1, find(Arg0)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    TheSequencesLevelOne c;
    c.__test();
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;


class TheSequencesLevelTwo {
    public:
        vector <int> find(vector <int> v)
        {
            int mini = 0;
            for( int i = 1; i < v.size(); ++i )
                if( v[mini] > v[i] ) mini = i;

            vector< int > sol;
            vector< int > srt;

            for( int k = 0; k < v.size(); ++k )
                if( k != mini )
                    srt.push_back( v[k] );

            sol.push_back( v[mini] );
            sort( srt.begin() , srt.end() );

            for( int k = 0; k < srt.size(); k+=2 ){
                if( k+1 < srt.size() )sol.push_back( srt[k+1] );
                sol.push_back( srt[k] );
            }

            return sol;


        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const vector <int> &Expected, const vector <int> &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: " << print_array(Expected) << endl; cerr << "\tReceived: " << print_array(Received) << endl; } }
	void test_case_0() { int Arr0[] = {1, 5, 10}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = {1, 10, 5 }; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); verify_case(0, Arg1, find(Arg0)); }
	void test_case_1() { int Arr0[] = {47}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = {47 }; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); verify_case(1, Arg1, find(Arg0)); }
	void test_case_2() { int Arr0[] = {7, 2, 5, 4}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = {2, 5, 4, 7 }; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); verify_case(2, Arg1, find(Arg0)); }
	void test_case_3() { int Arr0[] = {51, 49, 97, 9, 10, 89, 90, 41, 58}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = {9, 41, 10, 51, 49, 89, 58, 97, 90 }; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); verify_case(3, Arg1, find(Arg0)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    TheSequencesLevelTwo c;
    c.__test();
}
// END CUT HERE

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

typedef long long ll;

int H;
int m;
vector< int > s;
const int mod = 1234567891;

ll dp[60][60][60];

ll solve( int idx , int ldx , int rdx ){
    ll &ref = dp[idx][ldx][rdx];
    if( ref != -1 ) return ref;

    if( idx == s.size() ){
        bool ok = true;
        if( rdx == 55 || ldx == 55 ) return 0;
        if(  H - s[ldx] > m ) ok = false;
        if(  H - s[rdx] > m ) ok = false;
        return ok;
    }

    ll sol = 0;
    if( ldx == 55 || s[idx]-s[ldx] <= m )sol = ( sol + solve( idx + 1 , idx , rdx ) ) % mod;
    if( rdx == 55 || s[idx]-s[rdx] <= m )sol = ( sol + solve( idx + 1 , ldx , idx ) ) % mod;

    return  ref = sol%mod;
}


class TheSequencesLevelThree {
    public:
        int find(vector <int> seq, int k)
        {
            m = k;

            H = 0;
            for( int i = 0; i < seq.size(); ++i )
                H = max ( H , seq[i] );

            s.clear();
            for( int i = 0; i < seq.size(); ++i )
                if( seq[i] != H )
                    s.push_back( seq[i] );

            sort( s.begin() , s.end() );


            memset( dp , -1 , sizeof(dp));
            ll sol = solve( 0 , 55 , 55 );
            return sol%mod;;

        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arr0[] = {1, 2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 10; int Arg2 = 6; verify_case(0, Arg2, find(Arg0, Arg1)); }
	void test_case_1() { int Arr0[] = {1, 5, 10, 4}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 6; int Arg2 = 4; verify_case(1, Arg2, find(Arg0, Arg1)); }
	void test_case_2() { int Arr0[] = {4, 44, 7, 77}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 1; int Arg2 = 0; verify_case(2, Arg2, find(Arg0, Arg1)); }
	void test_case_3() { int Arr0[] = {96, 29, 21, 90, 46, 77, 31, 63, 79}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 44; int Arg2 = 126; verify_case(3, Arg2, find(Arg0, Arg1)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    TheSequencesLevelThree c;
    c.__test();
}
// END CUT HERE

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <stack>
#include <map>
#include <stack>
#include <iomanip>
#include <queue>
#include <vector>
#include <string.h>
#include<cstdio>
#include<vector>
#include<iostream>
#include<algorithm>
#include<math.h>
using namespace std;




class BigNum{   // BIG_NUM_CLASS
   public:
      vector<int>digits;
      BigNum(){}
      BigNum( int v ){while( v ) digits.push_back(v%10) , v/=10; }
      BigNum( char*,int );
      BigNum( const BigNum &z ){ digits = z.digits; }
      BigNum operator*(const int&);
      BigNum operator+(const BigNum&);
      inline void WriteLn();
      void operator=(BigNum);
};

void BigNum::operator=(BigNum b2 ){
   digits.clear();
   digits=b2.digits;
}

BigNum BigNum::operator*( const int &a ){
    BigNum ret = (*this);

    for( int i = 0; i < ret.digits.size(); ++i )
        ret.digits[i] *= a;

    for( int i = 0; i < ret.digits.size(); ++i ){
        int v = ret.digits[i];
        ret.digits[i] = v % 10;
        v /= 10;
        if( v ){
            if( i == ret.digits.size() - 1 )ret.digits.push_back( v );
            else ret.digits[i+1] += v;
        }
    }
    return ret;
}



BigNum BigNum::operator+( const BigNum &b2 ){
   BigNum A = *this , B = b2;
   if( A.digits.size() < B.digits.size() )swap(A,B);
   BigNum sum = B;
   int tmp = 0;
   for( int i = 0; i < B.digits.size(); ++i ){
      int ss = B.digits[i] + A.digits[i] + tmp;
      sum.digits[i] = ss%10;
      tmp = ss / 10;
   }
   for( int i = B.digits.size(); i < A.digits.size(); ++i ){
      int ss = A.digits[i] + tmp;
      sum.digits.push_back( ss % 10 );
      tmp = ss/10;
   }
   while( tmp ){
      sum.digits.push_back( tmp % 10 );
      tmp /= 10;
   }
   return sum;
}


inline void BigNum::WriteLn(){
   if( digits.size() == 0 )printf("0");
   for( int i = digits.size()-1; i >=0; --i )
      printf("%d",digits[i]);
   printf("\n");
}






const int maxn = 10000;


BigNum f[maxn];

int n;
int srch[maxn];
char txt[maxn][maxn];
vector< int > idx;


bool cmp( int a, int b ){
     int l1 = strlen( txt[a] );
     int l2 = strlen( txt[b] );
     return lexicographical_compare( txt[a] , txt[a] + l1 , txt[b] , txt[b] + l2 );
}

int main(){

    f[0] = 1;
    for( int i = 1; i <= 1100; ++i )
        f[i] = f[i-1] * i;

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        idx.clear();
        scanf("%d",&n);

        for( int i = 0; i < n; ++i ){
            scanf("%s",txt[i]);
            idx.push_back( i );
        }

        sort( idx.begin() , idx.end() , cmp );


        for( int i = 0; i < n; ++i )
            srch[ idx[i] ] = i;

        BigNum sol = BigNum(1);

        for( int i = 0; i < n; ++i ){
            int d =  srch[i] , o = 0;

            for( int k = 0; k < i; ++k ) if( srch[k] <= srch[i] ) o ++;
            d -= o;

            if( d == 0 ) continue;
            sol = sol + f[n-i-1]*d;
        }
        sol.WriteLn();
    }

    return 0;
}

#include <cstdio>
#include <math.h>
#include <cstdlib>
#include <vector>
#include <math.h>
#include <stack>
#include <map>
#include <string>
#include <iostream>
#include <string.h>
#include <algorithm>
#include <assert.h>
using namespace std;

typedef long long ll;
const int maxn = 1005;

int mod;
ll a ,b;
char sa[maxn] , sb[maxn] , sn[maxn];
char mem[maxn];

void del( char *b ){
    while( strlen(b) && b[ strlen(b) - 1 ] == '0' ) swap( b[ strlen(b) - 1] , b[ strlen(b) ] );
}

void div2( char *num ){
    int len = strlen(num);

    memset( mem ,  0 , sizeof(mem));
    for( int i = 0; i < len; ++i )mem[i] = '0';
    mem[len] = '\0';

    for( int i = len - 1; i >= 0; --i ){
        int g = num[i] - '0';
        if( g % 2 == 0 ) mem[i] += g>>1;
        else{
            assert( i-1 >= 0 );
            mem[i-1] += 5 , mem[i] += (g-1)>>1;
        }
    }
    del( mem );
    memcpy( num , mem , sizeof mem );
}

ll adj[2][2] , m[2][2] , pw[2][2];


ll res[2][2];
void mmul( ll a[2][2] , ll b[2][2] ){
    res[0][0] = res[0][1] = res[1][0] = res[1][1] = 0;
    for( int i = 0; i < 2; ++i )
        for( int j = 0; j < 2; ++j )
            for( int k = 0; k < 2; ++k )
                res[i][j] = (res[i][j] + a[i][k] * b[k][j] ) % mod;
    memcpy( a , res , sizeof res );
}


int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz2.txt","w",stdout);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%s%s%s%d",&sa,&sb,&sn,&mod);

        b = a = 0;
        for( int i = 0; i < strlen(sa); ++i )a = (a*10 + sa[i]-'0') % mod;
        for( int i = 0; i < strlen(sb); ++i )b = (b*10 + sb[i]-'0') % mod;
        reverse( sn , sn + strlen(sn));

        int len = strlen( sn );
        del(sn);

        stack< int > stp;
        while( strlen(sn) ){
            if( sn[0] % 2 == 0 ){
                stp.push(1);
                div2(sn);
            }else{
                stp.push(2);
                sn[0]--; del( sn );
            }
        }

        if( stp.size() == 0 ){
            printf("%d\n",1%mod);
            continue;
        }
        stp.pop();

        adj[0][0] = adj[0][1] = 1 , adj[1][0] = adj[1][1] = 0;
        m[0][0] = 1 ,  m[1][1] = a , m[1][0] = 0 , m[0][1] = b;


        memcpy( pw , m , sizeof m );

        while( stp.empty() == false ){
            int u = stp.top(); stp.pop();

            if( u == 2 )mmul( pw , m );
            else mmul( pw, pw );
        }
        mmul( adj , pw );
        printf("%lld\n",adj[0][1]%mod);
    }


    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <stack>
#include <map>
#include <vector>
#include <iomanip>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair
#define ok(y,x) (x>=0&&y>=0&&y<n&&x<m)

const int inf = 9999999;

int n,m;
char mx[100][100];

pii X;
vector< pii > fin;
int dst[100][100];

int d[][2] = { -1,0 , 1,0 , 0,-1 , 0,1 };


int dijkstra( pii s , pii e ){
    memset( dst , 1 , sizeof(dst));

    pair< int , pii > u;
    priority_queue< pair< int , pii > > pq;

    pq.push( mk( inf , s ) );

    while( !pq.empty() ){
        u = pq.top(); pq.pop();

        if( u.s.f == e.f && u.s.s == e.s ) break;

        int v = inf - u.f;

        for( int i = 0; i < 4; ++i ){
            int xn = u.s.f + d[i][0];
            int yn = u.s.s + d[i][1];

            if( ok(yn,xn) == false ) continue;


            int c1 = mx[yn][xn];
            int c2 = mx[u.s.s][u.s.f];

            int cost = 0;
            if( c1 == '$' || c2 == '$' ) cost = 2;
            else if( c1-c2 == 0 ) cost = 1;
            else if( abs(c1-c2) == 1 ) cost = 3;
            else continue;

            if( dst[yn][xn] > cost ){
                dst[yn][xn] = cost;
                pq.push( mk( inf - v - cost , mk(xn,yn) ) );
            }
        }
    }

    if( u.s.f == e.f && u.s.s == e.s ) return inf - u.f;
    else return -1;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    for( ;tests; --tests ){
        scanf("%d%d",&n,&m);
        fin.clear();

        for( int i = 0; i < n; ++i ){
            scanf("%s",mx[i]);
            for( int j = 0; j < m; ++j ){
                if( mx[i][j] == 'X' ) X = mk(j,i) , mx[i][j] = '$';
                else if( mx[i][j] =='$' ) fin.push_back( mk(j,i) );
            }
        }

        bool ok = true;
        vector< int > v;
        for( int i = 0; i < fin.size() && ok; ++i ){
            int d = dijkstra(  X , fin[i] );
            if( d == -1 ) ok = false;
            else v.push_back( d );
        }

        if( ok == false ){
            printf("-1\n");
            continue;
        }

        sort( v.begin() , v.end() );

        int sz = fin.size();
        int sol = 9999999;


        for( int i = 0; i < (1<<sz); ++i ){

            int s1 = 0 , s2 = 0;

            for( int k = sz-1; k >= 0; --k ){
                if( i&(1<<k) ){
                    if( !s1 ) s1 += v[k];
                    else s1 += 2*v[k];
                }else{
                    if( !s2 ) s2 += v[k];
                    else s2 += 2*v[k];
                }
            }

            sol = min( sol , max( s1,s2 ) );

        }


        printf("%d\n",sol);
    }

    return 0;
}


#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <vector>
#include <set>
#include <map>
#include <queue>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

vector< char > cm;

void input(){
    char c;
    while( scanf("%c",&c) == 1 ){
        if( c == 'P' ) break;
        if( c == 'E' || c == 'N' || c == 'W' || c == 'S' )
            cm.push_back(c);
    }
}

int d[][2] = { -1,0, 1,0,  0,-1,  0,1 };
int o[][2] = { -1,0, 1,0,  0,-1,  0,1, -1,-1,  1,1,  -1,1,  1,-1 };

map< pii , bool > M;
map< pii , bool > V;
vector< pii > crds;

vector< int > srch[20050];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    char c;
    cin >> c;

    for( int t = 0; t < 10; ++t ){
        cm.clear();
        M.clear();
        V.clear();
        crds.clear();
        for( int i = 0; i < 20015; ++i ) srch[i].clear();

        input();

        int x(0), y(0);
        int mx(0),my(0);
        V[ mk(y,x) ] = M[ mk(y,x) ] = true;

        for( int i = 0; i < cm.size(); ++i ){
            if( cm[i] == 'S' ) y--;
            else if( cm[i] == 'N' ) y++;
            else if( cm[i] == 'E' ) x++;
            else x--;

            V[ mk(y,x) ] = M[ mk(y,x) ] = true;
            crds.push_back( mk(y,x) );

            if( x < mx ) mx = x , my = y;
        }
        queue< pii > q;
        q.push( mk(my,mx-1) );

        int sol = M.size();
        pii u,a;

        while( !q.empty() ){
            u = q.front(); q.pop();

            for( int i = 0; i < 4; ++i ){
                int xn = u.s + d[i][0];
                int yn = u.f + d[i][1];

                a = mk(yn,xn);

                if( V[ a ] ) continue;

                bool ok = false;
                for( int i = 0; i < 8 && !ok; ++i ){
                    int xz = xn + o[i][0];
                    int yz = yn + o[i][1];

                    ok = M[ mk(yz,xz) ];
                }

                if( ok ){
                    V[ a ] = true;
                    q.push( a );
                }
            }
        }

        int delta=  10005;

        for( int i = 0; i < crds.size(); ++i ){
            for( int j = 0; j < 4; ++j ){
                int xn = crds[i].s + d[j][0];
                int yn = crds[i].f + d[j][1];

                if( xn == crds[i].s ) continue;

                a = mk(yn,xn);

                if( V[ a ] ) continue;

                M[ a ] = V[ a ] = true;
                sol++;
                srch[ yn+delta ] .push_back(xn);
            }
        }

        for( int i = 0; i < 20015; ++i ){
            if( srch[i].size() == 0 ) continue;
            sort( srch[i].begin() , srch[i].end() );

            if( srch[i].size() % 2  ) continue;

            for( int j = 0; j < srch[i].size(); j += 2){

                int d = abs(srch[i][j+1]-srch[i][j]) -1;
                if( d > 0 )
                sol += d;
            }
        }
        printf("%d\n",sol);
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <fstream>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int d1,d2,d3;
vector< int > divs;

int sz;
vector< int > facs;

void solve( int idx , int f ){
    divs.push_back( f );
    if( idx == sz )
        return;

    for( int i = idx; i < sz; ++i )
        solve( i+1 , f * facs[i] );

}

void getdiv( int v ){

    int d = v;
    for( int i = 2; i*i <= d; ++i ){
        while( v % i == 0 ){
            v /= i;
            facs.push_back( i );
        }
    }
    if( v != 1 ) facs.push_back(v);

    sz = facs.size();
    solve( 0 , 1 );
    facs.clear();
}

int main(){
    int tests;

    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d%d",&d3,&d1,&d2);

        divs.clear();
        if( d2 != 0  )getdiv( d2 );
        else if(  d1 != 0 ){
            getdiv(d1);
            sort( divs.begin() , divs.end() );
            divs.erase( unique( divs.begin(),divs.end() ) , divs.end() );

            int sol = 0;
            for( int i = 0; i < divs.size(); ++i ){
                int cx = d1 / divs[i];
                int cb = divs[i];
                if( (cb-1)*cb + (cx-1)*cx == 2*d3 )
                    sol++;
            }
            printf("%d\n",sol*2);
            continue;

        }else if( d3 != 0){
            int n1 , n2;
            int D = 1 + 8*d3;

            int sq = (int)sqrt(D);

            if( sq*sq == D )
                printf("3\n");
            else
                printf("0\n");

            continue;
        }

        sort( divs.begin() , divs.end() );
        divs.erase( unique( divs.begin(),divs.end() ) , divs.end() );

        int sol = 0;
        for( int i = 0; i < divs.size(); ++i ){
            int v = (d2 / divs[i]) + divs[i];

            int c1 = divs[i];
            int c3 = d2 / divs[i];

            if( d1 % v )continue;


            int c2 = d1 / v;

            if( (c3-1)*c3 + (c2-1)*c2 + (c1-1)*c1 != 2*d3 ) continue;

            sol ++;
        }
        printf("%d\n",sol);

    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <vector>
#include <set>
#include <queue>
using namespace std;

char mx[300][300];

bool IsPath( char c ){
    if( c == '_' || c == '/' || c == '\\' ) return true;
    return false;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    int n;
    cin >> n;

    char c;
    int r = 0 , col = 0;
    while( scanf("%c",&c) == 1 ){
        if( c == '\n' ){
            r ++;
            col = 0;
            //if( r == n +2 ) break;
            continue;
        }
        mx[r][col] = c;
        col++;
    }
    int y,x;
    bool ok = true;
    for( int i = 250; i >= 0 && ok; --i ){
        for( int j = 0; j <= 250 && ok; ++j ){
            if( IsPath(mx[i][j])  ){
                y = i , x = j;
                ok = false;
            }
        }
    }

//    for( int i = 0; i <= n + 1; ++i ){
//        cout<<i<<" = ";
//        for( int j = 0; j <= 20; ++j ){
//            cout<<mx[i][j]<<" ";
//        }cout<<endl;
//    }
    vector< char > moves;
    while( true ){
        moves.push_back( mx[y][x] );

        if( mx[y][x] == '_' ){
            if( mx[y][x+1] == '_' );
            else if( mx[y+1][x+1] == '\\' )y++;
            else if( mx[y][x+1] == '/' );
            else break;
        }else if( mx[y][x] == '\\' ){
            if( mx[y][x+1] =='/' );
            else if( mx[y][x+1] == '_' );
            else if( mx[y+1][x+1] == '\\' )y++;
            else break;
        }else if( mx[y][x] == '/' ){
            if( mx[y][x+1] =='\\' );
            else if( mx[y-1][x+1] == '_' )y--;
            else if( mx[y-1][x+1] == '/' )y--;
            else break;
        }


        x++;
//        cout<<y<<" "<<x<<" = "<<mx[y][x]<<endl;
    }

//    for( int i = 0; i < moves.size(); ++i ){
//        cout<<i<<": " <<moves[i]<<endl;
//    }

    printf("Total Walk Distance = %d\n",moves.size());
    for( int i = 0; i < moves.size(); ++i ){
        int cnt = 0 , j = i;
        for( j = i; j < moves.size() && moves[j] == moves[i]; ++j )cnt++;

        if( moves[i] == '/' )printf("Up %d steps\n",cnt);
        else if( moves[i] == '\\' )printf("Down %d steps\n",cnt);
        else if( moves[i] == '_'  )printf("Walk %d steps\n",cnt);
        i = j-1;
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <math.h>
using namespace std;

int n;
const int mod = 761238923;

int dp[105][105];

int solve( int idx , int cnt ){
    if( idx == n+1  ) return cnt == n;
    
    if( dp[idx][cnt] != -1 ) return dp[idx][cnt];
    
    int sol = 0;
    for( int i = cnt; i <= idx; ++i )
         sol  = ( sol + solve( idx + 1 , i ) ) % mod;
    return dp[idx][cnt] = sol;
}

int main(){
    while( scanf("%d",&n) == 1 ){
           if( n == 0 )break;
           
           memset( dp , -1, sizeof(dp));
           printf("%d\n",solve(1,0) );
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <set>
#include <vector>
#include <iomanip>
#include <stack>
#include <map>
#include <queue>
#include <string.h>
#include <algorithm>
using namespace std;

int val[1000000];

int main(){
    int tests;
    scanf("%d",&tests);

    for( ; tests ; --tests ){
        int n;
        scanf("%d",&n);

        if( n >= 0 && n <= 4 ){
            printf("%d\n",n);
            continue;
        }
        int i , s = 0 , k = 2;
        for( i = 0; s+k <= n;  i++, k ++ ){
            s+=k;
            val[i] = k;
        }
        k = n - s;
        if( k ) for( int j = i - 1; j >= 0 && k; --j ) val[j] ++ , k --;
        if( k ) val[ i - 1] ++;

        for( int j = 0; j < i; ++j )
            printf("%d ",val[j]);
        printf("\n");
    }

    return 0;
}

#include <iostream>
#include <cstdio>
using namespace std;

typedef unsigned long long ull;

int n;
ull K;
int v[25];

ull f( int n ){
    ull ret = 1;
    for( int k = 2; k <= n; ++k )
        ret *= k;
    return ret;
}

bool used[30];
int sol[30];

int main(){
    cin >> n >> K;

    ull ss = 0;
    for( int i = 1; i <= n; ++i ){
        ull p = f(n-i);

        int k;
        for( k = 1; k <= n; ++k ){
            if( used[k] ) continue;
            if( ss+p >= K ) break;
            ss += p;
        }

        used[k] = true;
        sol[i] = k;
    }

    for( int i = 1; i <= n; ++i )
        printf("%d ",sol[i]);
    putchar('\n');

    return 0;
}

#include <iostream>
#include <stack>
#include <math.h>
#include <map>
#include <algorithm>
#include <set>
#include <queue>
#include <ext/hash_map>
using namespace std;
using namespace __gnu_cxx;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;
const int prime = 89833;

vector< int > dx;
char txt[20005];


hash_map <int,int> M[20005];

int main(){
    freopen("Ulaz.txt","r",stdin);
    int n;
    scanf("%d",&n);


    ll sol = 0;
    for( int i = 0; i < n; ++i ){
        dx.push_back(i);

        int dx = 0;
        char c;
        while( c = getchar() ) if( (c >= 'a' && c <= 'z') || ( c >= 'A' && c <= 'Z' ) || c == ' ' ) break;
        txt[dx++] = c;
        while(1){
            c = getchar();
            if( (c >= 'a' && c <= 'z') || ( c >= 'A' && c <= 'Z' ) || c == ' ' )txt[dx++] = c;
            else break;
        }

        ll key = 0;
       // ll now = 0;
       // cout<<"WORD: "<<i<<" = "<<endl;
        for( int k = 0; k < dx; ++k ){
            key = (key * prime + txt[k] );
            M[k][key] ++;

            if( M[k][key] == 1 ) continue;

          //  if( sol < M[k][key] * (ll)(k+1) ){
                //cout<<i<<" "<<k<<endl;
                //cout<<"pattern:"<<endl;
              //  for( int l = 0; l <= k; ++l )
              //      cout<<txt[l];cout<<endl;
           // }

            sol = max( sol , M[k][key] * (ll)(k+1) );
        }

    }
    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <iomanip>
using namespace std;

int id[500005] , col[500005];

int f( int x ){
    if( x == id[x] ) return x;
    int oldDad = id[x];
    id[x] = f( id[x] );

    col[x] = (col[x] + col[oldDad])%3;
    return id[x];
}

void merge( int a, int b , int c ){
    int x = f(a) , y = f(b);
    id[x] = y;
    col[x] = ( col[b] - col[a] + 3 + c ) % 3;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        int n,k;
        scanf("%d%d",&n,&k);

        for( int i = 0; i <= n+5; ++i )
            id[i] = i , col[i] = 0;

        int ss = 0;

        for( int i = 0; i < k; ++i ){
            int c,a,b; scanf("%d%d%d",&c,&a,&b);

            if( a > n || b > n  ){ ss ++; continue; }


            if( c == 1 ){
                if( f(a) == f(b) ) ss += (col[a]%3) != (col[b]%3);
                else merge( a , b , 0 );
            }else{
                if( f(a) == f(b) ) ss += (col[a]%3) != ((col[b]+1)%3);
                else merge( a , b , 1 );
            }
        }
        printf("%d\n",ss);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <algorithm>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <vector>
using namespace std;

vector< int > w;
char s[20];

inline bool prime( int &v ){
    if( v!=2 && v%2 == 0 ) return false;
    for( int i = 3; i*i <= v; i += 2 )
        if( v % i == 0 ) return false;
    return true;

}

vector< int > p;

bool ok[800000];
const int cs = 500005;

int main(){
    for( int i = 2; i <= cs; ++i )
        if( !ok[i] ){
            p.push_back(i);
            for( int k = i+i; k <= cs; k += i )
                ok[k] = true;
        }


    for( int i = 0; w.size() <= 113; ++i ){
        int sz = 0;
        int q = p[i];
        while( q ){
            s[sz++] = q % 10;
            q /= 10;
        }

        bool ok = true;
        for( int k = 0; k < (sz>>1) && ok; ++k )
            if( s[k] != s[ sz-k-1 ] )
                ok = false;

        if( ok )
            w.push_back( p[i] );
    }

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        int n;
        scanf("%d",&n);

        int val = w[n-1];
        int pro = 1;

        while( val ){
            if( val%10 )pro *= val % 10;
            val /= 10;
        }

        printf("%d %d\n",w[n-1],p[pro-1]);

    }


    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <set>
#include <queue>
#include <assert.h>
#include <math.h>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const double pi = acos(0.0) * 2;

double h , d , alfa;

bool brk[23];

int main(){

    freopen("Ulaz.txt","r",stdin);
  //  freopen("Izlaz.txt","w",stdout);
    scanf("%lf%lf%lf",&h,&d,&alfa);


    int cnt = 0;
    bool ok = false;

    for( int steps = 0; steps <= 5500; ++steps ){

        double mx = h / cos( alfa / 2.0 );

        if( steps * d < h ) continue;

        cnt ++;
        int s = 0;
        double x = 0 , z = h;

        if( cnt > 1000 ) break;

        vector< pair<double,double> > wec;
        ok = false;




        while( fabs(z) > 0.0000000001 && s < steps ){

            double xt = x , zt = z;

            double q = hypot( x , 0 );
           // cout<<d<<endl;
            double rem = d - q;
            //cout<<rem<<endl;
            double r = tan( alfa / 2.0 ) * ( h - z );

            double w = rem - r;

            double lo = 0 , hi = 10000;
            while( lo < hi ){
                w = (lo+hi) / 2;
                double xa = sin( (alfa/2.0) ) * w;
                double za = sin( (pi/2) - (alfa/2.0) ) * w;
                double xn,zn;

                if( fabs(lo-hi) < 0.000001 ) break;

                if( xt > 0 ) xn = -r - xa;
                else x = r + xa;
                zn = z - za;

                if( hypot(xt-xn,zt-zn) >= d ) hi = w;
                else lo = w;
            }

            double xa = sin( (alfa/2.0) ) * hi;
            double za = sin( (pi/2) - (alfa/2.0) ) * hi;


            if( xt > 0 )x = -r - xa;
            else x = r + xa;
            z -= za;

            //cout<<" XA , ZA ======= "<<xa<<" "<<za<<endl;
            //cout<<xt<<" "<<x<<" | "<<zt<<" "<<z<<" => "<<hypot(x-xt,z-zt)<<" [ "<<x-xt<<" , "<<z-zt<<" ] "<<endl<<endl;


            if( z < -0.00001 ) break;

            if( z - (steps-s-1)*(d) >= 0 ){

                double df = fmod( zt , d );
                if( fabs(df) < 0.0000000001 ) df += d;

                double xa = sqrt( d*d - df*df );


                if( xt > 0 ) x = xt - xa;
                else x = xt + xa;


                z = (steps-s)*d - d;


                ok = true;
                wec.push_back( mk(x,z) );

                while( fabs(z) > 0.0000000001 ){
                    z -= d;
                    wec.push_back( mk(x,z) );
                }

                break;

            }else wec.push_back( mk(x,z) );
            s++;
        }

        if( fabs(z) < 0.00000001 ) ok = true;

        if( ok ){
            cout<<wec.size()<<endl;
            for( int k = 0; k < wec.size(); ++k ){
                cout<<wec[k].f<<" 0 "<<wec[k].s<<endl;
            }
            break;
        }

    }

    if( !ok ){
        printf("-1\n");
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <cstdlib>
#include <string>
#include <string.h>
#include <math.h>
#include <queue>
#include <stack>
#include <vector>
#include <map>
#include <assert.h>
#include <set>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

int h,w;
char txt[105][105];

vector< pii > x;
vector< pii > l;


struct data{
    int a,b,c;
    data(){};
    data( int p1, int p2 , int p3 ):a(p1),b(p2),c(p3){};
    const bool operator<( const data &d ) const {
        return a < d.a || ( a == d.a && c < d.c );;
    }

};

bool ok[100005];
bool me[100005];

int main(){
  //  freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&h,&w);

    for( int i = 0; i < h; ++i ){
        scanf("%s",txt[i]);
        for( int k = 0; k < w; ++k ){
            if( txt[i][k] == 'X' ) x.push_back( mk(i,k) );
            if( txt[i][k] == 'L' ) l.push_back( mk(i,k) );
        }
    }

    vector< data > q;

    for( int i = 0; i < x.size(); ++i )
        for( int j = 0; j < l.size(); ++j )
            q.push_back( data(    (x[i].f-l[j].f)*(x[i].f-l[j].f)  +  (x[i].s-l[j].s)*(x[i].s-l[j].s) , i , j ) );

    sort( q.begin(), q.end() );

    int sol = 0;
    for( int i = 0; i < q.size(); ++i ){
        if( me[ q[i].c ] )
            continue;

        int j;
        int cnt = 0;
        for( j = i; j < q.size() && q[j].c == q[i].c && q[j].a == q[i].a; ++j ){
            cnt += ok[ q[j].b ] == false;

            if( ok[ q[j].b ] == false)
                 me[ q[i].c ] = true;

            ok[ q[j].b ] = true;
        }
        i = j-1;
        if( cnt > 1 ) sol ++;
    }

    printf("%d\n",sol);


    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <algorithm>
#include <map>
#include <stack>
#include <cstdlib>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

int len;
char txt[51];

//map< pair< pii , int > , short > dp[55][4];
//map< pair< pii , int > , short > nxt[55][4];

int  dp[55][4][30][30][30];
int nxt[55][4][30][30][30];

int solve( int idx , int a , int b , int c , int d , int now ){

    if( idx == len ) return 0;

    if( idx ){
        if( now == 0 && a != txt[idx-1] )cout<<"A"<<endl;
        if( now == 1 && b != txt[idx-1] )cout<<"B"<<endl;
        if( now == 2 && c != txt[idx-1] )cout<<"C"<<endl;
        if( now == 3 && d != txt[idx-1] )cout<<"D"<<endl;
    }

    int d1,d2,d3,d4;

    d1 = d2 = d3 = d4 = 0;

    if(a)d1 = a - 'a' + 1;
    if(b)d2 = b - 'a' + 1;
    if(c)d3 = c - 'a' + 1;
    if(d)d4 = d - 'a' + 1;

    int h[4] , sz = 0;
    h[0] = h[1] = h[2] = h[3] = 0;

    if( idx ){
        if( now == 0 ) d1 = 55; else h[sz++] = d1;
        if( now == 1 ) d2 = 55; else h[sz++] = d2;
        if( now == 2 ) d3 = 55; else h[sz++] = d3;
        if( now == 3 ) d4 = 55; else h[sz++] = d4;
    }


    pair< pii , int > m;
    m = mk( mk(h[0],h[1]) , h[2] );


    if( dp[idx][now][h[0]][h[1]][h[2]] != -1 ) return dp[idx][now][h[0]][h[1]][h[2]];


    int ch = txt[idx];
    int sol = 999999;

    int s0 = solve( idx + 1 , ch , b , c , d , 0 ) + abs(now-0) + abs( a - ch );
    int s1 = solve( idx + 1 , a , ch , c , d , 1 ) + abs(now-1) + abs( b - ch );
    int s2 = solve( idx + 1 , a , b , ch , d , 2 ) + abs(now-2) + abs( c - ch );
    int s3 = solve( idx + 1 , a , b , c , ch , 3 ) + abs(now-3) + abs( d - ch );

    int q;

    if( sol > s0 ) q = 0 , sol = s0;
    if( sol > s1 ) q = 1 , sol = s1;
    if( sol > s2 ) q = 2 , sol = s2;
    if( sol > s3 ) q = 3 , sol = s3;

    nxt[idx][now][h[0]][h[1]][h[2]] = q;


    return dp[idx][now][h[0]][h[1]][h[2]] = sol;

}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
    scanf("%s",txt);

    len = strlen(txt);

    memset( dp , -1, sizeof(dp));
    int s = solve( 0 , 0 , 0 , 0 , 0 , 1 ) + len;



    int a,b,c,d,now;
    a = b = c = d = now = 0;
    now = 1;

    for( int i = 0; i < len; ++i ){

        int d1,d2,d3,d4;

        d1 = d2 = d3 = d4 = 0;

        if(a)d1 = a - 'a' + 1;
        if(b)d2 = b - 'a' + 1;
        if(c)d3 = c - 'a' + 1;
        if(d)d4 = d - 'a' + 1;

        int h[4] , sz = 0;
        h[0] = h[1] = h[2] = h[3] = 0;


        if( i ){
            if( now == 0 ) d1 = 55; else h[sz++] = d1;
            if( now == 1 ) d2 = 55; else h[sz++] = d2;
            if( now == 2 ) d3 = 55; else h[sz++] = d3;
            if( now == 3 ) d4 = 55; else h[sz++] = d4;
        }


        int ref = nxt[i][now][h[0]][h[1]][h[2]];

        for( ; now < ref; ++now) printf(">");
        for( ; now > ref; --now) printf("<");

        if( now == 0 ){
            for( ; a < txt[i]; ++a )printf("+");
            for( ; a > txt[i]; --a )printf("-");
        }

        if( now == 1 ){
            for( ; b < txt[i]; ++b )printf("+");
            for( ; b > txt[i]; --b )printf("-");
        }

        if( now == 2 ){
            for( ; c < txt[i]; ++c )printf("+");
            for( ; c > txt[i]; --c )printf("-");
        }

        if( now == 3 ){
            for( ; d < txt[i]; ++d )printf("+");
            for( ; d > txt[i]; --d )printf("-");
        }

        printf(".");
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <cstdlib>
#include <string>
#include <string.h>
#include <math.h>
#include <queue>
#include <stack>
#include <vector>
#include <map>
#include <assert.h>
#include <set>
using namespace std;

int main(){
    int k;
    cin >> k;
    int q = (int)ceil(log2(k));

    int s = 1;
    for( int i = 0; i < q; ++i )
        s *= 2;

    int f1 = s;

    int cnt = 0;
    while( k ){
        if( k >= s ){
            k -= s;
        }else{
            s >>= 1;
            cnt++;
        }
    }

    cout<<f1<<" "<<cnt<<endl;



    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <stack>
#include <map>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <vector>
using namespace std;

int n,m,d;
char txt[25][25];

int cnt[255];
char s[4][2005];

const int source = 1000;
const int sink = 1001;
const int inf = 99999;

struct edge{
    int a,b;
    int cost;
    edge( int p1, int p2, int p3 ):a(p1),b(p2),cost(p3){};
    edge(){};
};

vector< edge > w;
int dp[2005];
edge *dad[2005];

int bell( int source , int sink ){

    for( int i = 0; i < 1005; ++i ){
        dp[i] = inf;
        dad[i] = NULL;
    }

    dp[source] = 0;

    for( int i = 0; i < 1000; ++i ){
        for( int k = 0; k < w.size(); ++k ){
            if( dp[ w[k].a ] + w[k].cost < dp[ w[k].b ] ){
                dp[ w[k].b ] = dp[ w[k].a ] + w[k].cost;
                dad[ w[k].b ] = &w[k];
            }
        }
    }

    return dp[sink];
}


int main(){



    scanf("%d%d",&n,&m);
    for( int i = 0; i < n; ++i ){
         scanf("%s",txt[i]);
         for( int j = 0; j < m; ++j )
            cnt[ txt[i][j] ] ++;
    }

    int sz = 0;
    for( int i = 0; i < n/2; ++i )
        for( int j = 0; j < m/2; ++j )
            s[0][sz++] = txt[i][j];

    sz = 0;
    for( int i = 0; i < n/2; ++i )
        for( int j = m-1; j >= m/2; --j )
            s[1][sz++] = txt[i][j];

    sz = 0;
    for( int i = n-1; i >= n/2; --i )
        for( int j = 0; j < m/2; ++j )
            s[2][sz++] = txt[i][j];

    sz = 0;
    for( int i = n-1; i >= n/2; --i )
        for( int j = m-1; j >= m/2; --j )
            s[3][sz++] = txt[i][j];

    d = m*n/4;
    s[0][d] = s[1][d] = s[2][d] = s[3][d] = '\0';


    for( int i = 'a'; i <= 'z'; ++i )
        for( int z = 0; z < cnt[i]/4; ++z )
            w.push_back( edge( source , i , 0 ) );


    for( int c = 'a'; c <= 'z'; ++c ){
        for( int i = 0; i < d; ++i ){
            int cst = 0;
            for( int k = 0; k < 4; ++k ) cst += s[k][i] != c;

            w.push_back( edge( c , 255+i  , cst ) );
        }
    }

    for( int i = 0; i < d; ++i )
        w.push_back( edge(255+i , sink , 0) );

    int sol = 0;

    while( true ){
        int f = bell( source , sink );
        if( f == inf ) break;

        sol += f;

        int it = sink;
        while( dad[it] != NULL ){

            int nxt = dad[it]->a;

            swap( dad[it]->a , dad[it]->b );
            dad[it]->cost = -(dad[it]->cost);


            it = nxt;
        }

    }

    printf("%d\n",sol);

    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:preface
*/
#include <iostream>
#include <string>
using namespace std;

string w[] = { "I" , "IV" , "V" , "IX" , "X" , "XL" , "L" , "XC" , "C" , "CD" , "D" , "CM" , "M" };
int    v[] = { 1   ,   4  ,  5  ,   9  ,  10 ,  40  , 50  ,  90  , 100 ,  400 , 500 ,  900 , 1000 , 9999 };

string cv( int a ){
    string sol = "";
    while( a ){
        int k = 0;
        for( ; v[k+1] <= a; ++k );
        a -= v[k];
        sol += w[k];
    }
    return sol;
}

int cnt[255];

int main(){
    freopen("preface.in","r",stdin);
    freopen("preface.out","w",stdout);

    int n;
    cin >> n;

    for( int i = 1; i <= n; ++i ){
        string q = cv( i );
        for( int j = 0; j < q.size(); ++j )
            cnt[ q[j] ] ++;
    }

    if( cnt['I'] )printf("I %d\n",cnt['I']);
    if( cnt['V'] )printf("V %d\n",cnt['V']);
    if( cnt['X'] )printf("X %d\n",cnt['X']);
    if( cnt['L'] )printf("L %d\n",cnt['L']);
    if( cnt['C'] )printf("C %d\n",cnt['C']);
    if( cnt['D'] )printf("D %d\n",cnt['D']);
    if( cnt['M'] )printf("M %d\n",cnt['M']);


    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <cstdlib>
#include <string>
#include <string.h>
#include <math.h>
#include <queue>
#include <stack>
#include <vector>
#include <map>
#include <assert.h>
#include <set>
using namespace std;

int main(){
    int h , m;
    cin >> h >> m;
    m += 60 * h;
    m -= 45;
    if( m < 0 ) m += 24*60;
    cout<<m/60<<" "<<m-(m/60)*60<<endl;

    return 0;
}

#include <iostream>
#include <cstdlib>
#include <algorithm>
#include <math.h>
#include <fstream>
#include <stack>
#include <map>
#include <vector>
using namespace std;

int n;
char txt[2005];

int sol[2005] , sz = 0;

int main(){
//    freopen("strana.in","r",stdin);
//    freopen("strana.out","w",stdout);

freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    scanf("%s",txt);

    int slen = 2;

    for( int i = 0; i < n; ++i ){

        int k;
        for( k = 1; i-k >= 0 && i+k < n && txt[i-k] == txt[i+k]; ++k );

        int len = ((k-1)<<1) + 1;

        if( slen < len ) slen = len , sz = 0;
        if( slen == len ) sol[sz++] = i - k + 1;


        if( txt[i] == txt[i+1] ){
            for( k = 1; i-k >= 0 && i+k+1 < n && txt[i-k] == txt[i+k+1]; ++k );

            len = ((k-1)<<1) + 2;

            if( slen < len ) slen = len , sz = 0;
            if( slen == len ) sol[sz++] = i - k + 1;
        }


    }

    if( sz == 0 ){
        printf("-1\n");
        return 0;
    }

    sort( sol , sol + sz );

    printf("%d\n",slen);

    for( int i = 0; i < sz; ++i ){
        for( int k = 0; k < slen; ++k )
            putchar( txt[ sol[i] + k ] );
        putchar('\n');
    }


    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <vector>
#include <vector>
#include <string.h>
#include <iomanip>
using namespace std;

typedef long long ll;

class SumOfConsecutiveNumbers
{
  public:
    int largestN(int S)
    {
    ll n = S;
    ll sol = 1;

    for( ll i = 2; ((i*(i+1))>>1) <= n; ++i ){
        ll lo = 1, hi = n;

        bool ok = false;
        while( lo <= hi  && !ok ){
            ll mid = (lo+hi)>>1;
            ll sum = i*(mid-1);

            sum += (i*(i+1))>>1;
            if( sum == n ) ok = true;

            if( sum > n ) hi = mid - 1;
            else lo = mid + 1;
        }
        if( ok ) sol = i;
    }

    return (int)sol;
};};

int main(){
    SumOfConsecutiveNumbers Q;
    cout<<Q.largestN(31793)<<endl;
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <cstdlib>
#include <string>
#include <string.h>
#include <math.h>
#include <queue>
#include <stack>
#include <vector>
#include <map>
#include <assert.h>
#include <set>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

const int maxn = 100005;

int n;
int p[maxn][3];
int srt[3][maxn];

struct edge{
    int s,e;
    int type;
    edge(){};
    edge( int p1, int p2 , int p3 ):s(p1),e(p2),type(p3){};
    bool operator<( const edge &e2 ) const {
        return abs(s-e) < abs(e2.s-e2.e);
    }
};

int id[maxn];
int sz[maxn];


inline int find( int x ){
    for( ; x != id[x]; x = id[x] ) id[x] = id[ id[x] ];
    return x;
}
inline bool merge( int a, int b ){
    int x = find(a);
    int y = find(b);
    if( x == y ) return true;

    if( sz[x] < sz[y] ) id[x] = y, sz[y] += sz[x];
    else id[y] = x , sz[x] += sz[y];

    return false;
}


vector< int > V[300006];
map<int,int>M[3];
int inc;


int main(){
  //  freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int k = 0; k < maxn; ++k ) id[k] = k , sz[k] = 1;

    for( int i = 0; i < n; ++i ){
        int x,y,z; scanf("%d%d%d",&x,&y,&z);
        p[i][0] = x;
        p[i][1] = y;
        p[i][2] = z;
        srt[0][i] = x;
        srt[1][i] = y;
        srt[2][i] = z;

        if( M[0][x] == 0 ) M[0][x]= inc++;
        if( M[1][y] == 0 ) M[1][y]= inc++;
        if( M[2][z] == 0 ) M[2][z]= inc++;

        V[ M[0][x] ].push_back(i);
        V[ M[1][y] ].push_back(i);
        V[ M[2][z] ].push_back(i);
    }
    sort( srt[0] , srt[0] + n );
    sort( srt[1] , srt[1] + n );
    sort( srt[2] , srt[2] + n );

    vector< edge > e;

    for( int i = 0; i < n-1; ++i ){
        e.push_back( edge( srt[0][i] , srt[0][i+1] , 0 ) );
        e.push_back( edge( srt[1][i] , srt[1][i+1] , 1 ) );
        e.push_back( edge( srt[2][i] , srt[2][i+1] , 2 ) );
    }
    int sol = 0;
    sort( e.begin() , e.end() );

    for( int i = 0; i < e.size(); ++i ){
        vector< int > &x1 = V[  M[ e[i].type ][ e[i].s ]  ];
        vector< int > &x2 = V[  M[ e[i].type ][ e[i].e ]  ];
        int c = abs( e[i].s - e[i].e );

        for( int k = 0; k < x2.size(); ++k ){
            if( merge( x1[0] , x2[k] ) ) continue;
            sol += c;
        }
        for( int k = 1; k < x1.size(); ++k ){
            if( merge( x1[0] , x1[k] ) ) continue;
            sol += c;
        }

    }
    printf("%d\n",sol);


    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <stack>
#include <map>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
using namespace std;

typedef long long ll;

const int maxn = 100005;

int n;
int w[maxn] , cap[maxn] , cost[maxn];

struct data{
    ll p , dx;
    data(){};
    data( ll p1, ll p2 ):p(p1),dx(p2){};

    bool operator < ( const data & d2  ) const {
        return p > d2.p;
    }
};

ll mincost = 999999999999999LL;
int sdx = 0;

void check( ll cost , int soldx ){
    if( cost < mincost ){
        sdx = soldx;
        mincost = cost;
    }
}

bool del[maxn];

int main(){

    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    scanf("%d",&n);

    for( int i = 0; i < n; ++i )
        scanf("%d %d %d",&w[i], &cap[i], &cost[i] );

    ll sum = 0 , h2o = 0;

    priority_queue< data > pq;

    for( int i = n-1; i >= 0; --i ){
        h2o += w[i];
        if( h2o <= cap[i] ){
            sum += cost[i];
            del[i] = true;
        }else{
            pq.push( data( h2o - cap[i] , i ) );
        }
    }


    check( sum , n-1 );
    ll take = 0;

    for( int i = n-2; i >= 0; --i ){

        if( del[i+1] ){
            del[i+1] = false;
            sum -= cost[i+1];
        }

        take += w[i+1];


        while( !pq.empty() ){
            data u = pq.top();

            if( u.dx > i ){
                pq.pop();
                continue;
            }

            if( u.p - take <= 0 ){
                pq.pop();
                del[u.dx] = true;
                sum += cost[u.dx];
            }else
                break;
        }


        check( sum , i );
    }

    sum = 0 , h2o = 0;
    printf("%d\n",mincost);

    for( int i = sdx; i >= 0; --i ){
        h2o += w[i];
        if( h2o <= cap[i] ){
            sum += cost[i];
            printf("%d\n",i+1);
        }else{
            pq.push( data( h2o - cap[i] , i ) );
        }
    }



    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <stack>
#include <map>
#include <algorithm>
#include <math.h>
#include <queue>
#include <map>
#include <set>
using namespace std;

typedef unsigned long long ll;

vector< int > p;

bool isprime( int &v ){
    if( v % 2 == 0 && v != 2 ) return false;
    for( int i = 3; i*i <= v; i +=2 )
        if( v % i == 0 ) return false;
    return true;
}


ll q,n;
int sol;

inline ll mypow( ll base , int exp , ll prv = 1 ){
    ll ret = 1;
    for( int k = 1; k <= exp; ++k ){
        ret *= base;
        int a1 = 0 , a2 = 0;
        ll a = ret , b = prv;
        while( a ){ a1 ++; a /= 10; }
        while( b ){ a2 ++; b /= 10; }
        if( ret*prv > n || a1+a2 > 19  ) return -1;
    }
    return ret;
}

struct dat{
    int p1, p2, p3;
    ll p4;
    dat(){};
    dat( int a, int b, int c , ll d ):p1(a),p2(b),p3(c),p4(d){};
};


void getv( int dx , int divs , int last, ll val ){

    stack< dat > stk;
    stk.push( dat(dx,divs,last,val ) );

    while( !stk.empty() ){
        dx = stk.top().p1;
        divs = stk.top().p2;
        last = stk.top().p3;
        val = stk.top().p4;
        stk.pop();

        if( divs > sol ){
            sol = divs;
            q = val;

        }else if( divs == sol ){
            q = min ( q , val );
            continue;
        }

        if( divs < sol && val >= q ) continue;




        for( int i = 2; i <= last; ++i ){
            ll z = mypow( p[dx], i-1 , val );

            if( z == -1 ) break;

            stk.push( dat(dx+1 , i*divs , i , val * z) );
        }

    }
}


char c;
void readi( ll &v ){
    while( (c = getchar())<'0' || c > '9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' )
        v = v * 10 + c - '0';
}

int main(){

    for( int i = 2; i < 60; ++i )
        if( isprime(i) )
            p.push_back(i);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        readi(n);

        q = n;
        sol = 0;

        getv( 0 , 1 , 10 , 1 );

        printf("%I64d %d\n",q,sol);


    }

    return 0;
}

#include <iostream>
#include <cstdlib>
#include <algorithm>
#include <fstream>
#include <math.h>
#include <cstdio>
#include <set>
#include <queue>
#include <vector>
using namespace std;

int n,m;

inline int getx( int x, int y ){
    return (y/n)*n + x/n;
}


int mx[105][105];

int b[105][105];
int col[105][105];
int row[105][105];

bool ok = false;

void solve( int x, int y ){
    if( x == m ) x = 0 , y ++;

    if( y == m ){

        ok = true;
        for( int i = 0; i < m; ++i ){
            for( int j = 0; j < m; ++j ){
                printf("%d ",mx[i][j]);
            }
            putchar('\n');
        }
        putchar('\n');
        return;
    }

    if( mx[y][x] != 0 ) solve( x + 1 , y );
    else{
        int bx = getx( x , y );
        for( int i = 1; i <= m; ++i ){

            if( b[bx][i] ) continue;
            if( col[x][i] ) continue;
            if( row[y][i] ) continue;

            mx[y][x] = i;
            b[bx][i] = col[x][i] = row[y][i] = 1;

            solve( x + 1 , y );

            mx[y][x] = 0;
            b[bx][i] = col[x][i] = row[y][i] = 0;
        }
    }

}


int main(){
    //freopen("ultrasudoku.in","r",stdin);
    //freopen("ultrasudoku.out","w",stdout);


    scanf("%d",&n);
    m = n*n;

    for( int i = 0; i < m; ++i ){
        for( int j = 0; j < m; ++j ){
            scanf("%d",&mx[i][j]);

            int bx = getx( j , i );

            b[bx][ mx[i][j] ] = true;
            row[i][ mx[i][j] ] = true;
            col[j][ mx[i][j] ] = true;

        }
    }

    solve( 0 , 0 );

    if( !ok ){
        printf("Nema rjesenja!\n");
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <algorithm>
#include <fstream>
#include <set>
#include <cstdlib>
#include <math.h>
#include <vector>
#include <queue>
#include <string.h>
using namespace std;

const int inf = 16843009;

int n,m;
int cost[1005][1005][2];
vector<int>g[1005];


void add_edge( int a, int b, int c ){
    g[a].push_back(b);
    if( cost[a][b][0] >= cost[a][b][1] ) cost[a][b][0] = min( cost[a][b][0] , c );
    else cost[a][b][1] = min( cost[a][b][1] , c );

    if( cost[a][b][0] > cost[a][b][1] ) swap( cost[a][b][0] , cost[a][b][1] );
}


struct data{
    int now , dad , cost;
    data( int p1, int p2, int p3 ):now(p1),dad(p2),cost(p3){};
    data(){};
    bool operator < ( const data & d2 ) const {
        return cost > d2.cost;
    }
};

bool visi[1005];
int dad[1005];

int flow( int s , int e ){

    memset( dad , -1 , sizeof(dad));
    memset( visi , 0 , sizeof(visi));
    data u;
    priority_queue< data > pq;
    pq.push( data( 1 , -1 , 0 ) );

    while( !pq.empty() ){
        u = pq.top();
        pq.pop();

        if( visi[ u.now ] ) continue;
        visi[u.now] = true;
        dad[u.now] = u.dad;

        if( u.now == e ) break;

        for( int k = 0; k < g[u.now].size(); ++k ){
            int nxt = g[u.now][k];

            if( cost[u.now][nxt][0] != inf )pq.push( data( nxt , u.now , u.cost + cost[u.now][nxt][0] ) );
            if( cost[u.now][nxt][1] != inf )pq.push( data( nxt , u.now , u.cost + cost[u.now][nxt][1] ) );
        }
    }

    int it = n;
    while( dad[it] != -1 ){
        int now = dad[it];
        int nxt = it;

        cost[now][nxt][0] = inf;
        cost[nxt][now][0] = - cost[nxt][now][0];

        it = dad[it];
    }

    return u.cost;
}


int main(){

    memset( cost , 1 , sizeof(cost));
    scanf("%d%d",&n,&m);

    for( int i = 0; i < m; ++i ){
        int a,b,c; scanf("%d%d%d",&a,&b,&c);
        add_edge( a,b,c );
        add_edge( b,a,c );
    }

    int sol = flow( 1 , n ) + flow( 1 , n );

    cout<<sol<<endl;


    return 0;
}

#include <iostream>
#include <set>
#include <algorithm>
#include <fstream>
#include <map>
#include <stack>
#include <fstream>
#include <cstdlib>
#include <queue>
#include <vector>
using namespace std;

const int maxm = 1000000;
const int maxn = 10000;
const char *ans = "IMPOSSIBLE\0";

int n,m;
int jed[maxm+5][3];

bool done[maxn+5];

vector< int > g[maxn+5];
vector< int > s[maxn+5];

void mark_done( int node ){
    done[node] = true;
    for( int i = 0; i < g[node].size(); ++i )
        if( !done[ g[node][i] ] )
            mark_done( g[node][i] );
}

bool visi[maxn];
int val[maxn];

int data;

int c1 , c2 , c3;

bool chk( int node , int v ){

    visi[node] = true;
    val[node] = v;
    bool ok = true;

    for( int i = 0; i < s[node].size(); ++i ){
        if( visi[ g[node][i] ] ){
            int a = v;
            int b = val[ g[node][i] ];

            if( a + b != s[node][i] ){
                 c1 = a , c2 = b , c3 = i;
                 data = (a+b) - s[node][i];
                 return false;
            }
        }else
            ok = chk( g[node][i] , s[node][i] - v );

        if( !ok ) return false;
    }
    return true;
}

bool chk2( int node , int v ){
    visi[node] = true;
    val[node] = v;
    bool ok = true;

    for( int i = 0; i < s[node].size(); ++i ){
        if( visi[ g[node][i] ] ){
            int a = v;
            int b = val[ g[node][i] ];

            if( a + b != s[node][i] && c1 == a && c2 == b && c3 == i  ){
                 data = (a+b) - s[node][i];
                 return false;
            }
        }else
            ok = chk2( g[node][i] , s[node][i] - v );

        if( !ok ) return false;
    }
    return true;
}

void con_to_zero( int node ){
    val[node] = visi[node] = 0;
    for( int i = 0; i < g[node].size(); ++i )
        if( visi[ g[node][i] ] )
            con_to_zero( g[node][i] );
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);


   // if( m > 20 && m < 1200 )


    for( int i = 0; i < m; ++i ){
        int a,b,c; scanf("%d%d%d",&a,&b,&c); c *= 100;
        jed[i][0] = a , jed[i][1] = b , jed[i][2] = c;
        g[a].push_back(b);
        s[a].push_back(c);

        g[b].push_back(a);
        s[b].push_back(c);
    }

    for( int i = 1; i <= n; ++i ){
        if( done[i] ) continue;
        mark_done(i);

        con_to_zero( i );
        if( chk( i , -9229934 ) ){
            printf("%s\n",ans);
            return 0;
        }


        int lo = -1000000000 , hi = 1000000000 , sol = -1000000005;
        while( lo <= hi ){
            int mid = (lo+hi)>>1;

            int d1 = 0 , d2 = 0;

            con_to_zero(i);
            if( chk( i , mid ) ){ sol = mid; break; };
            d1 = data;

            con_to_zero(i);
            if( chk( i , mid+1) ){ sol = mid+1; break; };
            d2 = data;

            if( abs( d1 ) < abs( d2 ) )
                 hi = mid - 1;
            else
                 lo = mid + 1;
        }


        if( sol == -1000000005 ){
            printf("%s\n",ans);
            return 0;
        }

    }



    for( int i = 1; i <= n; ++i )
        printf("%.2f\n",val[i]/100.0);


    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <algorithm>
#include <stack>
#include <cstdlib>
#include <map>
#include <set>
#include <queue>
#include <iomanip>
using namespace std;

const int source = 240;
const int sink = 241;
const int inf = 99999999;

#define pq priority_queue
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int mxn = 255;


int n,m;
int cap[mxn][mxn];

int h[mxn][3];
int s[mxn][3];

int dad[mxn];
int dst[mxn];

inline int d( int a , int b ){
    if( a < n && b < n+m ) return abs(h[a][0]-s[b-n][0]) + abs(h[a][1]-s[b-n][1])+1;
    else if( b < n && a < n+m ) return -(abs(h[b][0]-s[a-n][0]) + abs(h[b][1]-s[a-n][1]) + 1);
    else return 0;
}

int flow(){

    for( int i = 0; i <= sink; ++i )
        dad[i] = -1, dst[i] = inf;

    dst[source] = 0;
    pii u;
    pq< pii > q;
    q.push( mk( inf , source ) );

    while( !q.empty() ){
        u = q.top(); q.pop();

        if( u.s == sink ) break;

        for( int k = 0; k <= sink; ++k ){
            int c = d(u.s,k);
            if( cap[u.s][k] > 0 && dst[k] >  dst[u.s]+c ){
                dst[k] = c + dst[u.s];
                dad[k] = u.s;
                q.push( mk( inf-dst[k] , k ) );
            }
        }

    }

    if( u.s == sink ) return 1;
    else return 0;
}

int mem[mxn][mxn];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);

    for( int i = 0; i < n; ++i ){
        scanf("%d%d%d",&h[i][0],&h[i][1],&h[i][2]);
        cap[source][i] += h[i][2];
    }
    for( int i = 0; i < m; ++i ){
        scanf("%d%d%d",&s[i][0],&s[i][1],&s[i][2]);
        cap[n+i][sink] += s[i][2];
    }

    for( int i = 0; i < n; ++i )
        for( int j = 0; j < m; ++j )
            cap[i][n+j] = inf;

    memcpy( mem , cap , sizeof cap );

    int f;
    while( f = flow() ){

        int maxcap = inf;
        int it = sink;

        while( dad[it] != -1 ){
            int f = dad[it] , s = it;
            maxcap = min( maxcap , cap[f][s] );
            it = dad[it];
        }

        it = sink;
        while( dad[it] != -1 ){

            int f = dad[it] , s = it;

            cap[f][s] -= maxcap;
            cap[s][f] += maxcap;

            it = dad[it];
        }
    }

    int mysol = 0 , ofsol = 0;

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < m; ++j ){
            int ds = abs( h[i][0]-s[j][0] ) + abs( h[i][1]-s[j][1] ) + 1;
            int c = mem[i][j+n] - cap[i][j+n];
            mysol += c * ds;

            scanf("%d",&c);
            ofsol += c * ds;
        }
    }

    if( mysol < ofsol ){
        printf("SUBOPTIMAL\n");
        for( int i = 0; i < n; ++i ){
            for( int j = 0; j < m; ++j ){
                int c = mem[i][j+n] - cap[i][j+n];
                printf("%d ",c);
            }
            putchar('\n');
        }
    }else{
        printf("OPTIMAL");
    }

    return 0;
}




#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

typedef long long ll;
const int maxn = 1006;

int h,w;
char txt[maxn][maxn];

vector< pii > m;
vector< pii > s;

ll row[maxn*20];
ll col[maxn*20];

long long solve( vector< pii > &v ){
    ll ret = 0;

    vector< int > x;
    vector< int > y;

    memset( row , 0 , sizeof(row));
    memset( col , 0 , sizeof(col));

    for( int i = 0; i < v.size(); ++i ){
        col[ v[i].f ] ++;
        row[ v[i].s ] ++;
        x.push_back( v[i].f );
        y.push_back( v[i].s );
    }

    sort( x.begin() , x.end() );
    x.erase( unique(x.begin(),x.end()) , x.end() );

    sort( y.begin() , y.end() );
    y.erase( unique(y.begin(),y.end()) , y.end() );

    for( int i = 0; i < y.size(); ++i )
        for( int j = i+1; j < y.size(); ++j )
            ret += row[ y[i] ] * row[ y[j] ] * ( y[j]-y[i] );

    for( int i = 0; i < x.size(); ++i )
        for( int j = i+1; j < x.size(); ++j )
            ret += col[ x[i] ] * col[ x[j] ] * ( x[j]-x[i] );

    return ret;
}

int main(){

    scanf("%d%d",&h,&w);

    int q = 10*maxn;

    for( int i = 0; i < h; ++i ){
        scanf("%s",txt[i]);
        for( int j = 0; j < w; ++j ){
            double x = (double)((j+i)/2.0);
            double y = (double)((j-i)/2.0);
            if( txt[i][j] == 'M' )m.push_back( mk(x*10 + q,y*10 + q) );
            if( txt[i][j] == 'S' )s.push_back( mk(x*10 + q,y*10 + q) );
        }
    }

    cout<<solve(m)/10<<" "<<solve(s)/10<<endl;


    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <vector>
#include <string.h>
#include <string>
#include <time.h>
using namespace std;

const int maxn = 205;

char txt[maxn];
char brk[maxn][maxn];
int sz;

int  exB[maxn];
char A[maxn] , B[maxn];
char C[maxn];

void proces( char *txt , int ex[maxn] , char x[maxn] ){
    int len = strlen(txt);
    int now = 0;
    memset( ex , -1 , sizeof(ex));

    for( int i = 0; i < len; ++i ){
        if( txt[i] == '['  ){
            int j;
            int k = 0;
            for( j = i+1; txt[j] != ']'; ++j ){
                if( txt[j] == txt[j+1] && txt[j] == '\'' ){
                    brk[sz][k++] = txt[j++];
                }else
                    brk[sz][k++] = txt[j];
            }
            brk[sz][k] = '\0';

            ex[now] = sz;
            x[now++] = 1;
            i = j , sz++;
        }else if( txt[i] != '\'' )x[now++] = txt[i];
        else x[now++] = txt[i++];
    }
    x[now] = '\0';
}


inline bool G( char c , char *s ){
    if( s[0] == '\0' ) return false;

    if( s[1] == '-' && s[0] != '\0' && s[1] != '\0' && s[2] != '\0' )
        return G(c,s+3) || (s[0] <= c && c <= s[2] );
    else
        return G(c,s+1) || (s[0] == c );
}//ok

inline bool F( char c , char *s ){
    if( s[0] == '^' ) return !G( c , s + 1 );
    else return G( c , s );
}//ok


int lena , lenb;
int dp[maxn][maxn];

inline bool solve( int a , int b ){
    if( dp[a][b] != -1 ) return dp[a][b];
    if( a == lena && b == lenb ) return true;

    bool ret = false;

    if( B[b] == '%' ){
        for( int k = a; k <= lena; ++k ) ret |= solve( k , b + 1 );
    }else if( B[b] == '_' ){
        ret = solve( a + 1 , b + 1 );
    }else if( B[b] == 1 ){
        if( F( A[a] , brk[ exB[b] ] )  ) ret = solve( a + 1 , b + 1 );
    }else if( A[a] == B[b]  ){
        ret = solve( a + 1 , b + 1 );
    }

    return dp[a][b] = ret;
}

char c;
char txta[maxn] , txtb[maxn];

char like[] = "like\0";

int main(){
   // freopen("Ulaz.txt","r",stdin);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        sz = 0;
        int n = 1;
        int b  =0;
        while( (txt[0] = getchar()) != '\'' );
        while( (txt[n] = getchar()) != '\n'  )n++;
        txt[n++] = '\0';

        bool isin = false;
        int len = strlen(txt) , p ;
        for( int i = 0; i < len; ++i ){
            if( txt[i] == '\'' ) isin = !isin;

            if( isin == false ){
                bool ok = true;
                for( int j = i; j < i + 4; ++j )
                    if( txt[j] != like[j-i] ) ok = false;
                if( ok ){
                    p = i;
                    break;
                }
            }
        }




        len = strlen(txt);
        int AL,AR , BL,BR;
        for( AL = 0; txt[AL] != '\''; AL++ );
        for( AR = p; txt[AR] != '\''; AR-- );
        for( BL = p; txt[BL] != '\''; BL++ );
        for( BR = len-1; txt[BR] != '\''; BR-- );



        int now = 0;
        for( int i = AL+1; i < AR; ++i )
            if( txt[i] != '\'' )A[now++] = txt[i];
            else A[now++] = txt[i++];
        A[now] = '\0';

        now = 0;
        for( int i = BL+1; i < BR; ++i )C[now++] = txt[i];
        C[now] = '\0';




        proces( C , exB , B );

        lena = strlen(A);
        lenb = strlen(B);


        for( int i = 0; i <= lena; ++i )
            for( int j = 0; j <= lenb; ++j )
                dp[i][j] = -1;




        bool ok = solve( 0 , 0 );


        if( ok ) printf("YES\n");
        else printf("NO\n");

    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <vector>
#include <vector>
#include <string.h>
#include <iomanip>
#include <queue>
using namespace std;

int dp[1200000];
const int inf = 16843009;

class MultiSubstract
{
  public:
    int getMinOperations(int M, int S, int T)
    {
      memset( dp , 1 , sizeof(dp));
      queue< int > Q;
      Q.push(1);
      dp[1] = 0;

      while(!Q.empty() ){
          int u = Q.front();
          Q.pop();

          if( u-S >= 1 && dp[u-S] == inf ){
            dp[u-S] = dp[u] + 1;
            Q.push( u-S );
          }

          if( u*M <= 1000000 && dp[u*M] == inf ){
            dp[u*M] = dp[u] + 1;
            Q.push( u*M );
          }


      }

      if( dp[T] == inf ) return -1;

      return dp[T];
  }
};


int main(){
    MultiSubstract q;
    cout<<q.getMinOperations(3,100,43)<<endl;
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <stack>
#include <math.h>
#include <cstdlib>
#include <fstream>
#include <math.h>
#include <set>
#include <map>
#include <vector>
using namespace std;

int main(){
    int n;
    ifstream cin("Ulaz.txt");
    cin >> n;

    int len = 0;


    for( int i = 31; i >= 0; --i ){
        if( n & ( 1 << i ) ){
            len = i;
            break;
        }
    }

    set< int > st;

    for( int i = 0; i <= len; ++i ){
        int d = n & 1;
        n >>= 1;

        if( d )n |= 1 << len;



        st.insert(n);
    }

    return st.size();
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <math.h>
#include <cstdlib>
using namespace std;

int n;
int dp[5005][5005];
char a[5005] , b[5005];

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d%s",&n,a);
    memcpy( b , a , sizeof a );
    reverse( b , b + n );

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < n; ++j ){
            if( a[i] == b[j] ) dp[i+1][j+1] = dp[i][j] + 1;
            else dp[i+1][j+1] = max( dp[i][j+1] , dp[i+1][j] );
        }
    }
    int c = dp[ n ][ n ];
    printf("%d\n", strlen(a) - c );

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <stack>
using namespace std;


int main(){
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        int n,k; scanf("%d%d",&n,&k);

        int z = n - (int)ceil( (k+1)/2.0 );
        int w = (k-1) / 2;

        int sol = ((n-k)&((k-1)/2)) == 0;
        cout<<sol<<endl;


    }


    return 0;
}

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <vector>
#include <math.h>
#include <algorithm>
using namespace std;

const int maxexp = 18;
const int maxpow = 1 << 18;
const int lowlvl = 1 << 17;

int v,n;
int tree[maxpow];

inline void update( int idx , int val ){
    int now = lowlvl + idx;
    tree[now] = val;

    while( now != 1 ){
        now >>= 1;
        tree[now] = max( tree[now<<1] , tree[(now<<1)|1] );
    }
}

int qv;
inline int query( int node , int lo , int hi ){
    if( tree[node] < qv ) return -1;
    if( node >= lowlvl ) return node;

    int R = query( node * 2 , lo , (lo+hi)>>1 );
    if( R == -1 ) R = query( node * 2 + 1 , ((lo+hi)>>1)+1 , hi );
    return R;
}

inline int query( int val ){
    qv = val;
    return query( 1 , lowlvl , lowlvl*2 - 1 );
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&v,&n);

        memset( tree, 0 , sizeof(tree));
        for( int i = 0; i < 100005; ++i ) update( i , v );

        for( int i = 0; i < n; ++i ){
            char ch;
            while( ch = getchar() ) if( (ch >= '0' && ch <= '9') || ch == 'b' ) break;

            if( ch == 'b' ){
                int t,c;
                scanf("%d%d",&t,&c);

                i += t - 1;

                for( int k = 0; k < t; ++k ){
                    int dx = query(c);
                    update( dx - lowlvl , tree[dx] - c );
                }

            }else{
                int c = ch - '0';
                while( (ch=getchar()) >= '0' && ch <= '9' ) c = c * 10 + ch - '0';

                int dx = query( c );
                update( dx - lowlvl , tree[dx] - c );
            }
        }

        int sol1 = 0 , sol2 = 0;
        for( int i = 0; i < 100005; ++i ) if( tree[i+lowlvl] != v ) sol1 ++ , sol2 += tree[i+lowlvl];
        printf("%d %d\n",sol1,sol2);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <math.h>
using namespace std;

double a,b;
int c;

double round2( double q ){
    q = (double)( (int)q*100 );
    q  /= 100;
    return q;
}

int main(){

    int t = 0;
    while( cin >> a >> b >> c ){
        if( fabs(a)<0.0001 && fabs(b)<0.0001 && c == 0 ) break;
        t++;
        double f1 = a;
        double f2 = b;
        int f3 = c;

        for( int i = 0; i < c; ++i ){
            double add = a * b * ((12.0/c)/12.0);

            add = round2(add);
            add /= 100;


            a += add;
        }
        printf("Case %d. $%.2lf at %.2lf%% APR compounded %d times yields $%.2lf\n",t,f1,f2,f3,a);

    }

    return 0;
}

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <math.h>
#include <algorithm>
#include <iomanip>
#include <string>
#include <map>
#include <queue>
#include <vector>
using namespace std;

const int maxn = 20000;

int in[maxn];
map< string , int > m;
bool y[maxn];
vector< int > g[maxn];
vector< int > rg[maxn];

int main(){
  //  freopen("Ulaz.txt","r",stdin);
    int sc = 1;
    string s;
    getline(cin,s);
    while( cin.eof() == false ){
        cin >> s;
        if( s.size() == 0 || s == "0" ) continue;

        if( m[s] == 0 ) m[s] = sc++;
        int f = m[s];

        y[f] = true;

        while( cin >> s ){

            if( s == "0" ) break;
            if( m[s] == 0 ) m[s] = sc++;
            int v = m[s];
            g[f].push_back(v);
            rg[v].push_back(f);
        }
    }

    int sol = 0;
    queue<int>q;
    for( int i = 1; i < sc; ++i ){
        sort( g[i].begin() , g[i].end() );
        g[i].erase( unique(g[i].begin(),g[i].end()),g[i].end());

        sort( rg[i].begin() , rg[i].end() );
        rg[i].erase( unique(rg[i].begin(),rg[i].end()),rg[i].end());

        in[i] = g[i].size();
        if( in[i] == 0 ) q.push( i );
    }

    while( !q.empty() ){
        int u = q.front(); q.pop();

        if( y[u] )sol ++;
        else continue;

        for( int i = 0; i < rg[u].size(); ++i ){
            int nxt = rg[u][i];
            in[nxt] --;
            if( in[nxt] == 0 ) q.push( nxt );
        }
    }
    cout<<sol<<endl;


    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <algorithm>
#include <stack>
#include <set>
#include <map>
using namespace std;

const int inf = 99999999;

int n,m,d,l;
int a[50005];
int rows[50005];


int main(){
    scanf("%d%d%d%d",&n,&m,&d,&l);

    for( int i = 0; i < n; ++i ) scanf("%d",&a[i]);

    int sol = 0;
    int minv = inf;
    sort( a , a + n );
    reverse( a , a + n );

    memset( rows , 1 , sizeof(rows));
    int dx = 0;

    for( int i = 0; dx < n; ++i ){
        for( int j = 0; j < m && dx < n; ++j ){
            if( rows[j] - d >= l && a[dx] >= l ){
                rows[j] = min( rows[j] - d , a[dx] );
                sol++;
            }else j --;
            dx++;
        }
    }
    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <algorithm>
#include <stack>
#include <set>
#include <map>
using namespace std;

const int inf = 99999999;

int n,m,d,l;
int a[50005];

int main(){
    scanf("%d%d%d%d",&n,&m,&d,&l);

    for( int i = 0; i < n; ++i ) scanf("%d",&a[i]);

    int sol = 0;
    int minv = inf;
    sort( a , a + n );

    int dx = 0;

    for( int col = 0; dx < n ; ++col ){

        for( int j = 0; dx < n && j < m; ++j ){
            if( a[dx] - col * d >= l )
                sol ++;
            else j--;
            dx++;
        }
    }
    printf("%d\n",sol);

    return 0;
}


#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <stack>
#include <map>
#include <cstdlib>
#include <vector>
#include <math.h>
#include <string.h>
using namespace std;

typedef long long ll;
const int maxq = 1000000000;

int primes[] = {2,3,5,7};
vector< int > oks;


void calc( int prv , ll now ){
    if( now > maxq ) return;
    oks.push_back(now);

    for( int i = prv; i < 4; ++i ) calc( i , now * primes[i] );
}

ll A , B;
ll dp[20][6000];

long long solve( ll now , int left , int p ){
    ll minx = now , maxx = now;
    for( int i = 0; i < left; ++i ) minx = minx*10 , maxx = maxx*10 + 9;

    int dx;
    if( maxx < A || minx > B ) return 0;
    else if(  minx >= A &&  maxx <= B ){
        dx = lower_bound( oks.begin() , oks.end() , p ) - oks.begin();
        if( dp[left][dx] != -1 )return dp[left][dx] ;
    }

    if( left == 0 && p == 1 ) return 1;
    else if( left== 0 ) return 0;

    int sol = 0;
    for( int i = 1; i <= 9; ++i ) if( p%i == 0 )sol += solve( now * 10 + i , left - 1 , p / i );

    if(  minx >= A &&  maxx <= B ) dp[left][dx] = sol;

    return sol;
}

int main(){
    calc( 0 , 1 );

    int tests;
    scanf("%d",&tests);

    while( tests-- ){

    ll f,s;
    cin >> f >> s;

    memset( dp, -1 , sizeof(dp));
    ll sol = 0;

    sort( oks.begin() , oks.end() );


    for( int i = 0; i < oks.size(); ++i ){
        A = ceil( f/(double)oks[i]);
        B = s / oks[i];

        for( int k = 1; k <= 18; ++k ) sol += solve( 0 , k , oks[i] );
    }
    cout<<sol<<endl;


    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <algorithm>
#include <set>
#include <queue>
#include <vector>
#include <map>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

struct emp{
    int dx,earn,h;
    emp(){};
    emp( int p1, int p2, int p3 ):dx(p1),earn(p2),h(p3){};
};

int n,q;
vector< emp > work;
vector< int > task;
int id_key[1000005];

int out[30005];
int sol1[30005] , sol2[30005];
vector< int >rg[30005];

void clear(){
    work.clear();
    task.clear();

    for( int i = 0; i <= n+2; ++i ){
        sol1[i] = sol2[i] = 0;
        rg[i].clear();
    }
}

void input(){
    scanf("%d%d",&n,&q);
    for( int i = 1; i <= n; ++i ){
        int id,cash,h; scanf("%d%d%d",&id,&cash,&h);
        work.push_back( emp(id,cash,h) );
        id_key[id]  = i;
    }
    for( int i = 0; i < q; ++i ){
        int q; scanf("%d",&q);
        task.push_back( q );
    }
}

bool cmp( emp a , emp b ){
    if( a.h < b.h ) return true;
    if( a.h == b.h && a.earn < b.earn ) return true;
    return false;
}

void getimmediate(){
    vector< emp > srt = work;
    sort( srt.begin() , srt.end() , cmp );

    set< pair< int , pii > > s;

    for( int i = srt.size()-1; i >= 0; --i ){
        pair< int,pii > srch = mk( srt[i].earn + 1 , mk(srt[i].h,-1) );
        set< pair< int,pii > > :: iterator f = s.lower_bound( srch );

        int dad = 0 , dadkey;
        int now = id_key[ srt[i].dx ];

        if( f != s.end() )dad =  f->s.s;
        dadkey = id_key[dad];

        sol1[now] = dad;

        out[dadkey] ++;
        rg[ now ].push_back( dadkey );


        s.insert( mk(srt[i].earn , mk(srt[i].h,srt[i].dx) )  );
    }
}

void getcnt(){
    queue< int > q;
    for( int i = 1; i <= n; ++i )
        if( out[i] == 0 ) q.push( i );

    while( !q.empty() ){
        int u = q.front(); q.pop();
        for( int i = 0; i < rg[u].size(); ++i ){
            int nxt = rg[u][i];

            sol2[nxt] += sol2[u] + 1;

            out[nxt] --;
            if( out[nxt] == 0 ) q.push( nxt );
        }
    }
}

void print(){
    for( int i = 0; i < q; ++i ){
        int key = id_key[ task[i] ];
        printf("%d %d\n",sol1[key],sol2[key]);
    }
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        clear();
        input();
        getimmediate();
        getcnt();

        print();
    }
    return 0;
}

#include <cstdio>
#include <algorithm>

int v[1000000],sz = 0;
int s[1000000],ss = 0;
const int maxn = 10000000;

int main(){

    for( int i = 1; i*i <= maxn; ++i )
        for( int j = 1; i*i+j*j*j*j <= maxn; ++j ){
            if( i == 0 && j == 0 ) continue;
            v[sz++] = i*i+j*j*j*j;
        }

    for( int i = 0; i < sz; ++i ){
        bool isprime = true;
        if( v[i] != 2 && v[i]%2 == 0 )isprime = false;
        if( isprime ) for( int j = 3; j*j <= v[i] && isprime; j += 2 ) if( v[i] % j == 0 ) isprime = false;


        if( isprime )s[ss++] = v[i];
    }

    std::sort( s , s + ss );

    int now = 0;
    for( int k = 0; k < ss; ++k )
        if( !k || s[k] != s[k-1] )s[now++] = s[k];
    ss = now;



    int tests;
    scanf("%d",&tests);


    for( ; tests; --tests ){
        int n;
        scanf("%d",&n);
        printf("%d\n",std::upper_bound( s , s + ss , n ) - s );
    }
    return 0;
}

#include <iostream>
using namespace std;

int main(){
    int n,m;

    while( scanf("%d%d",&n,&m) == 2 ){

        if( n == 0 && m == 0 ) break;

        int sol = 0;
        for( int i = 2; i <= n; ++i ) sol = (sol+m)%i;
        printf("%d %d %d\n",n,m,sol+1);

    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <fstream>
#include <algorithm>
#include <vector>
#include <set>
#include <queue>
using namespace std;

int n,m;

int dp[105][105][2];

int solve( int dx , int cnt ,  bool p ){

    if( dx == n ) return cnt == m;
    if( dp[dx][cnt][p] != -1 ) return dp[dx][cnt][p];

    int sol = 0;

    sol += solve( dx + 1 , cnt , false );
    sol += solve( dx + 1 , cnt + p , true );


    return dp[dx][cnt][p] = sol;
}

int main(){

    int tests;
    scanf("%d",&tests);

    for( int t = 1; t <= tests; ++t ){
        int q; scanf("%d%d%d",&q,&n,&m);

        memset( dp , -1 , sizeof(dp));
        int s = solve( 0 , 0 , false  );

        cout<<q<<" "<<s<<endl;
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <algorithm>
#include <stack>
#include <iomanip>
#include <set>
#include <vector>
#include <string.h>
#include <string>
using namespace std;

vector< int > p;
vector< int > divs;
vector< int > del;

void solve( int idx , int v ){
    divs.push_back(v);


    for( int i = idx; i < p.size(); ++i ){

       //cout<<v<<" * "<<p[i]<<" => "<<endl;
       if( idx == i )solve( i + 1 , v * p[i] );
       else if( i && p[i] != p[i-1] ) solve( i + 1 , v * p[i] );
    }
}

void getdivs( int n ){
    p.clear();
    divs.clear();


    for( int i = 2; i*i <= n; i ++ ){
        while( n%i == 0 ){
            n /= i;
            p.push_back(i);
        }
    }
    if( n > 1 ) p.push_back(n);

    solve( 0 , 1  );

}


int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    int n,sol=0;

    while( scanf("%d",&n) == 1 ){
        if( n == 0 ) break;

        sol = 0;
        getdivs( n );


        int sz = divs.size();
        for( int i = 0; i < sz; ++i ){
            int d = divs[i] - 1;
            if( d % 2 == 0 && n%(d+1) == 0 )sol++;
        }


        getdivs(n*10);


        sz = divs.size();
        for( int i = 0; i < sz; ++i ){
            int d = divs[i] - 1;
            if( d % 2 == 1 && n%(d+1) == divs[i]/2 )sol++;
        }


        printf("%d\n",sol);


    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
using namespace std;

char txt[30005];

int main(){
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%s",txt);
        int n = strlen(txt);

        for( int i = 0; i < n; i += 2 ){
            if( txt[i] == '0' ) for( ; i < n; ++i ) cout<<txt[i]; // LEFT PART
            else if( i + 1 < n && txt[i+1] == '1' ) { // RIGHT PART
                printf("10");
                for( i += 2; i < n; ++i ) printf("%c", '0' + (txt[i] == '0') );
            }else if( i + 1 < n ) printf("11"); // stip left and right
             else printf("%c",txt[i]);
        }


        putchar('\n');
    }

    return 0;
}

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <math.h>
#include <iomanip>
#include <algorithm>
using namespace std;

int tests;

int n,sol=0;
int niz[100];
bool ok[10];

void solve( int dx ){

    if( dx == n ){
        memset( ok , false , sizeof(ok));

        bool add = true;

        for( int i = 0; i < n && add; ++i ){
            int k = -1;
            for( int j = niz[i]; j <= n && k == -1; ++j ) if( ok[j] == false ) k = j;
            if( k == -1 ) add = false;
            else ok[k] = true;
        }

        sol += add;
        return;
    }

    for( niz[dx] = 1; niz[dx] <= n; niz[dx]++ ){
        solve( dx + 1 );
    }

}

const int mod = 10007;

int solve( int a,  int exp ){
    if( exp == 0 ) return 1;
    if( exp == 1 ) return a%mod;
    else if( exp%2 == 0 ){
        int q = solve( a , exp / 2 )%mod;
        return (q*q)%mod;
    }else{
        return (solve( a , exp - 1 ) * (a%mod))%mod;
    }
}


int main(){
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d",&n);

        int base = n + 1;
        int stp = n - 1;

        printf("%d\n",solve(base,stp)%mod);
    }

    return 0;
}

#include <iostream>
#include <fstream>
#include <cstdio>
#include <vector>
#include <math.h>
#include <set>
#include <queue>
#include <string>
#include <string.h>
#include <algorithm>
#include <map>
#include <iomanip>
using namespace std;

int n,m;
const int prime = 59509;

vector< string >  getpath(){
    string tmp;
    getline(cin,tmp);

    vector< string > ret;

    string w = "";
    for( int i = 0; i < tmp.size(); ++i ){
        if( tmp[i] == '/' ){
            if( w.length() > 0 ) ret.push_back(w);
            w = "";
        }else w = w + tmp[i];
    }
    if( w.length() > 0 ) ret.push_back(w);

    return ret;
}

struct trie{
    vector< string > names;
    vector< trie* > poks;

    int has( string q ){
        for( int i = 0; i < names.size(); ++i )
            if( names[i] == q ) return i;
            return -1;
    }

    void kill(){
        for( int i = 0; i < poks.size(); ++i ) poks[i]->kill();
        names.clear();
        poks.clear();
    }

};

trie dad;

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);

    int tests;
    scanf("%d",&tests);

    int t = 1;

    for( ; tests; --tests ){
        scanf("%d%d\n",&n,&m);

        dad.kill();

        for( int i = 0; i < n; ++i ){
            vector< string > h = getpath();

            trie *p = &dad;
            for( int i = 0; i < h.size(); ++i ){
                int v = p->has( h[i] );

                if( v == -1 ){
                    v = p->names.size();
                    p->names.push_back( h[i] );
                    p->poks.push_back( new trie );
                }

                p = p->poks[v];
            }
        }
        int sol = 0;

        for( int i = 0; i < m; ++i ){
            vector< string > h = getpath();
            trie *p = &dad;

            for( int i = 0; i < h.size(); ++i ){
                int v = p->has( h[i] );

                if( v == -1 ){
                    sol ++;
                    v = p->names.size();
                    p->names.push_back( h[i] );
                    p->poks.push_back( new trie );
                }

                p = p->poks[v];
            }
        }
        printf("Case #%d: %d\n",t,sol);
        t++;



    }

    return 0;
}

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <math.h>
#include <algorithm>
#include <queue>
#include <map>
using namespace std;

typedef long long ll;

int n,k;

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);

    int tests;
    scanf("%d",&tests);
    for( int t = 1; t <= tests; ++t ){
        scanf("%d%d",&n,&k);

        ll cnt = 0;
        for( ll i = 0 , p2 = 1; i < n; ++i , p2 <<= 1 )
            cnt += p2;

        bool on = false;

        if( cnt == k ) on = true;
        else if( cnt < k ){
            ll w = cnt + 1;
            ll d = k / w;

            if( k % w == 0 ) d --;

            k = k - w * d;
            if( cnt == k ) on = true;
        }

        if( on ) printf("Case #%d: ON\n",t);
        else printf("Case #%d: OFF\n",t);

    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <set>
#include <vector>
#include <iomanip>
#include <queue>
using namespace std;

typedef long long ll;

const ll inf = 100000000000000000LL;
const int maxn = 1000005;

struct coord{
    ll x,y;
    coord(){};
    coord( ll p1, ll p2 ):x(p1),y(p2){};
};

int n;
ll a,b,c;
ll f[maxn];
ll dp[maxn];

inline ll ccw( coord z , coord a , coord b ){ return (b.y-z.y)*(a.x-z.x) - (a.y-z.y)*(b.x-z.x); };

int sz = 0;
coord hull[maxn];

void add_coord( coord v ){
    while( sz >= 2 && ccw( hull[sz-2] , hull[sz-1] , v ) <= 0LL ) sz--;
    hull[sz++] = v;
}

ll calc( int i , ll x ){
    return hull[i].x*x + hull[i].y;
}

ll bs( ll x ){
    int lo = 0 , hi = sz;
    ll sol = 0;
    while( lo <= hi ){
        int mid = (lo+hi)>>1;
        ll v = calc( mid , x );
        ll w = calc( mid + 1 , x );

        sol = max( sol , v );

        if( v < w ) lo = mid + 1;
        else hi = mid - 1;
    }
    return sol;
}

int main(){
    cin >> n >> a >> b >> c;

    for( int i = 1; i <= n; ++i ){
        int x; scanf("%d",&x);
        f[i] = f[i-1] + x;
    }

    for( int i = 1; i <= n; ++i ) dp[i] = -inf;

    for( int i = 1; i <= n; ++i ){
        ll val = 0;
        ll add = c + f[i]*f[i]*a;

        val = bs( f[i]*a );

        dp[i] = val + add;

        add_coord( coord( -2*f[i],f[i]*f[i]*a+dp[i] ) );
    }
    cout<<dp[n] + b*f[n]<<endl;

    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstdlib>
#include <iomanip>
#include <math.h>
using namespace std;

int n,m;
int a[20005];

int cntL[1005] , cntR[1005];

int main(){
    scanf("%d%d",&m,&n);

    for( int i = 0; i < n; ++i ) scanf("%d",&a[i]);

    cntR[ a[0] ] ++;
    int nxt = 1;

    int s = 0;

    for( int i = 0; i < (n>>1); ++i ){
        cntL[ a[i] ] ++;
        cntR[ a[i] ] --;

        for( ; nxt <= i+i+1; ++nxt )
            cntR[ a[nxt] ] ++;

        int sol = 0;
        for( int k = 0; k <= m; ++k ){
            if( sol > 0 ) sol -= cntR[k];
            if( sol < 0 ) sol = 0;
            sol += cntL[k];
        }

        if( sol == 0 ) s = max( s , i + 1 );

    }
    printf("%d\n",s);

    return 0;
}

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <math.h>
#include <algorithm>
#include <queue>
#include <map>
using namespace std;

typedef long long ll;

int r,m,n;
int sz[1005];
ll dp[1005][2];

ll jmp[1005][2];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    int tests;
    scanf("%d",&tests);

    for( int t = 1; t <= tests; ++t ){

        memset( dp , -1, sizeof(dp));

        scanf("%d%d%d",&r,&m,&n);
        for( int i = 0; i < n; ++i ) scanf("%d",&sz[i]);

        for( int i = 0; i < n; ++i ){
            int j;
            ll sum=0;
            for( j = i; sum + sz[j] <= m; j = (j+1)%n ){
                sum += sz[j];
                if( j == (i-1+n)%n ) break;
            }
            jmp[i][0] = j;
            jmp[i][1] = sum;
        }



        int now = 0;
        ll earn = 0;

        for( int i = 1; i <= r; ++i ){

            if( dp[now][0] != -1 && i + (i-dp[now][0]) < r ){
                int diff = i - dp[now][0];
                ll cost = earn - dp[now][1];

                int left = r - i + 1;
                int times = left / diff;


                i += times * diff;
                earn += times * cost;
                --i;

                continue;
            }

            dp[now][0] = i;
            dp[now][1] = earn;

            earn += jmp[now][1];
            now = jmp[now][0];
        }

        cout<<"Case #"<<t<<": "<<earn<<endl;
    }


    return 0;
}

#include <iostream>
#include <fstream>
#include <cstdio>
#include <vector>
#include <math.h>
#include <set>
#include <queue>
#include <string>
#include <string.h>
#include <algorithm>
#include <map>
#include <iomanip>
using namespace std;

const int mod = 100003;


int sols[] = { 1 , 2 , 3 , 5 , 8 , 14 , 24 , 43 , 77 , 140 , 256 , 472 , 874 , 1628 , 3045 , 5719 , 10780 , 20388 , 38674 , 73562 , 140268 , 268066 , 513350 , 984911 , 984911 };

int dp[1000];

int f( int n , int k ){

    for( int i = 0; i < k; ++i ) dp[i] = 0;
    dp[k] = dp[k+1] = 1;

    for( int i = k+2; i <= n; ++i ){
        dp[i] = 0;
        for( int j = 1; j <= k; ++j )
            dp[i] = (dp[i]+dp[i-j])%mod;
    }
    return dp[n];
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
    int tests;
    scanf("%d",&tests);

    for( int t = 1; t <= tests; ++t ){
        int n;
        cin >> n;
        n--;

        int sol = 0;
        for( int i = 2; i <= n + 1; ++i )sol = (sol+f( n , i ))%mod;
        printf("Case #%d: %d\n",t,(sol+1)%mod);

    }

    return 0;
}

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <algorithm>
#include <math.h>
#include <fstream>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int n;
char d[1005];

void div( int v ){
    int now = 0;
    for( int i = n-1; i >= 0; --i ){
        now = now * 10 + d[i];
        d[i] = now / v;
        now %= v;
    }
    while( n && d[n-1] == 0 ) n--;
}

void add( int v ){
    d[0] += v;
    for( int i = 0; i < n; ++i ){
        if( d[i]/10 && i+1 == n ) n++;
        d[i+1] += d[i]/10;
        d[i] %= 10;
    }
}
void sub( int v ){ // v = [0,10]
    d[0] -= v;
    for( int i = 0; i < n; ++i )
        if( d[i] < 0 ) d[i] += 10 , d[i+1] -= 1;
    while( n && d[n-1] == 0 ) n--;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%s",d);
    n = strlen(d);

    reverse( d , d + n );
    for( int i = 0; i < n; ++i ) d[i] -= '0';

    int sol = 0;

    while( n > 1 ){

        int v = d[1] * 10 + d[0];

        if( v % 4 == 0 ){
            sol += 2;
            div( 4 );
        }else if( v % 2 == 0 ){
            sol ++;
            div( 2 );
        }else if( (v+1)%4 == 0 ){
            sol ++;
            add( 1 );
        }else{
            sol ++;
            sub( 1 );
        }

        //for( int i  = n-1; i >= 0; --i )
        //    cout<<(int)d[i];
        //cout<<" = "<<sol<<endl;
    }
    if( d[0] == 1 ) sol += 1;
    if( d[0] == 2 ) sol += 2;
    if( d[0] == 3 ) sol += 3;
    if( d[0] == 4 ) sol += 3;
    if( d[0] == 5 ) sol += 4;
    if( d[0] == 6 ) sol += 4;
    if( d[0] == 7 ) sol += 5;
    if( d[0] == 8 ) sol += 4;
    if( d[0] == 9 ) sol += 5;

    cout<<sol<<endl;

    return 0;
}

#include <cstdio>
#include <queue>
using namespace std;

const int maxe = 2000005;
const int maxn = 1000005;

int nedge = 1;
int next[maxe] , head[maxn] , point[maxe];

bool vis[maxn];

inline void add_edge( int u , int w ){
    point[nedge] = w , next[nedge] = head[u] , head[u] = (nedge++);
    point[nedge] = u , next[nedge] = head[w] , head[w] = (nedge++);
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    int n,m;
    scanf("%d%d",&n,&m);

    for( int i = 0; i < m; ++i ){
        int f,s; scanf("%d%d",&f,&s);
        add_edge( f , s );
        add_edge( s , f );
    }

    int sol = 0;
    queue< int > q;

    q.push( 1 );
    vis[1] = true;

    while( !q.empty() ){
        int u = q.front() ; q.pop();

        for( int i = head[u]; i > 0 ; i = next[i] ){
            int w = point[i];
            if( vis[w] == false ){
                vis[w] = true;
                sol ++;
                q.push( w );
            }
        }
    }

    printf("%d\n",sol);


    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:lamps
*/
#include <iostream>
#include <vector>
#include <set>
#include <math.h>
#include <set>
#include <string>
#include <string.h>
#include <queue>
#include <map>
#include <algorithm>
using namespace std;

#define f first
#define s second
#define mk make_pair

int n,c;
string final;

map<string,int>M;

bool ok ( string chk ){
    bool ret = true;
    for( int i = 0; i < n && ret; ++i ){
        if( final[i] == 'x' ) continue;
        if( final[i] != chk[i] ) ret = false;
    }
    return ret;
}

string button1( string p ){
    string ret = p;
    for( int i = 0; i < p.size(); ++i )
        ret[i] = ( ret[i] == '0' ) + '0';
    return ret;
}

string button2( string p ){
    string ret = p;
    for( int i = 0; i < p.size(); i += 2 )
        ret[i] = ( ret[i] == '0' ) + '0';
    return ret;
}

string button3( string p ){
    string ret = p;
    for( int i = 1; i < p.size(); i += 2 )
        ret[i] = ( ret[i] == '0' ) + '0';
    return ret;
}

string button4( string p ){
    string ret = p;
    for( int i = 0; 3*i < p.size(); ++i )
        ret[i*3] = ( ret[i*3] == '0' ) + '0';
    return ret;
}

void make_final(){
    final = string(n,'x');
    int q;
    while( scanf("%d",&q) ){
        if( q == -1 ) break;
        final[q-1] = '1';
    }

    while( scanf("%d",&q) ){
        if( q == -1 ) break;
        final[q-1] = '0';
    }
}

int main(){
    freopen("lamps.in","r",stdin);
    freopen("lamps.out","w",stdout);

    scanf("%d%d",&n,&c);
    make_final();

    vector< pair< string , int > > moves;
    moves.push_back( mk( string(n,'1') , 0 ) );

    for( int i = 0; i < 4; ++i ){
        int sz = moves.size();
        for( int k = 0; k < sz; ++k ){
            string s1 = button1( moves[k].f );
            string s2 = button2( moves[k].f );
            string s3 = button3( moves[k].f );
            string s4 = button4( moves[k].f );

            moves.push_back( mk(s1, (moves[k].s+1) ) );
            moves.push_back( mk(s2, (moves[k].s+1) ) );
            moves.push_back( mk(s3, (moves[k].s+1) ) );
            moves.push_back( mk(s4, (moves[k].s+1) ) );
        }
    }

    sort( moves.begin() , moves.end() );
//    moves.erase( unique(moves.begin(),moves.end()),moves.end() );

    bool sol = false;

    for( int i = 0; i < moves.size(); ++i ){
        if( M[ moves[i].f ] ) continue;

        if( c%2 == moves[i].s%2 && c >= moves[i].s && ok( moves[i].f ) ){
            cout<<moves[i].f<<endl;
            M[ moves[i].f ] = true;
            sol = true;
        }
    }

    if( sol == false ) cout<<"IMPOSSIBLE\n";

    return 0;
}

#include <iostream>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <queue>
#include <stack>
#include <map>
using namespace std;

typedef long long ll;

const int maxn = 200000;

ll m,mod;

char txt[maxn+5];
ll c1[maxn+5];


struct data{
    ll stp10;
    ll stp11;
    ll pfx;
    ll sfx;
    ll sol;
    ll val;
    ll n;
    data(){};
    data( ll p1 , ll p2 , ll p3, ll p4 , ll p5 , ll p6 , ll p7 ){
        stp10 = p1;
        stp11 = p2;
        pfx = p3;
        sfx = p4;
        sol = p5;
        val = p6;
        n = p7;
    }
};

data prvi;


data solve( ll n ){
    data ret;
    if( n == 1 ) ret = prvi;
    else if( n%2 == 0 ){
        data q = solve( n / 2 );

        ret.stp10 = ( q.stp10 * q.stp10                        )%mod;
        ret.stp11 = ( q.stp11 * q.stp10 + q.stp11              )%mod;
        ret.pfx =   ( q.val * q.stp11 + 2*q.pfx                )%mod;
        ret.sfx =   ( q.sfx * q.stp10 + q.val*q.n + q.sfx      )%mod;
        ret.n =     ( q.n * 2                                  )%mod;
        ret.val =   ( q.val * q.stp10 + q.val                  )%mod;
        ret.sol =   ( q.sfx * q.stp11 + 2*q.sol  +  q.n * q.pfx)%mod;

    }else{
        data q = solve( n - 1 );

        ret.stp10 = ( q.stp10 * prvi.stp10                         )%mod;
        ret.stp11 = ( q.stp11 * prvi.stp10 + prvi.stp11            )%mod;
        ret.pfx =   ( q.val * prvi.stp11 + prvi.pfx + q.pfx        )%mod;
        ret.sfx =   ( q.sfx * prvi.stp10 + prvi.val*q.n + prvi.sfx )%mod;
        ret.n =     ( q.n + prvi.n                                 )%mod;
        ret.val =   ( q.val * prvi.stp10 + prvi.val                )%mod;
        ret.sol =   ( q.sfx * prvi.stp11 +  prvi.sol+q.sol   +  q.n * prvi.pfx ) % mod;

    }

    return ret;
}


int main(){

    scanf("%s",txt);
    cin >> m >> mod;

    int len = strlen(txt);

    ll tmp = 0;
    ll pfx = 0 , sfx = 0 , sum = 0;


    for( int i = 1; i <= len; ++i ){
        tmp = (tmp*10 + 1)%mod;
        c1[i] = tmp;
    }

    tmp = 0;
    for( int i = 0; i < len; ++i ){
        ll q = txt[i] - '0';

        ll mul = (c1[len-i]*(i+1))%mod;
        tmp = (tmp + q * mul)%mod;
    }

    sum = tmp;
    tmp = 0;

    for( int i = 0; i < len; ++i ){
        tmp = (tmp*10 + txt[i] - '0' )%mod;
        pfx = (pfx + tmp)%mod;
    }

    ll p10 = 1 , p11 = 0 , rtmp = 0;
    tmp = 0;

    for( int i = len-1; i >= 0; --i ){
        tmp = (tmp + (txt[i] - '0')*p10 )%mod;
        rtmp = (rtmp*10 + txt[i] - '0')%mod;
        p11 = (p11 * 10 + 1)%mod;
        p10 = (p10*10)%mod;
        sfx = (sfx + tmp)%mod;
    }
    p11 = (p11*10)%mod;


    prvi = data( p10, p11, pfx, sfx ,sum , tmp , len );

    data sol = solve( m );

    cout<<sol.sol<<endl;



    return 0;
}

#include <iostream>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <cstdio>
#include <string>
#include <string.h>
using namespace std;

char getc( char c ){
    switch (c){
        case 'w': return 'q';
        case 'e': return 'w';
        case 'r': return 'e';
        case 't': return 'r';
        case 'y': return 't';
        case 'u': return 'y';
        case 'i': return 'u';
        case 'o': return 'i';
        case 'p': return 'o';
        case '[': return 'p';
        case ']': return '[';

        case '1': return '`';
        case '2': return '1';
        case '3': return '2';
        case '4': return '3';
        case '5': return '4';
        case '6': return '5';
        case '7': return '6';
        case '8': return '7';
        case '9': return '8';
        case '0': return '9';
        case '-': return '0';
        case '=': return '-';

        case 's': return 'a';
        case 'd': return 's';
        case 'f': return 'd';
        case 'g': return 'f';
        case 'h': return 'g';
        case 'j': return 'h';
        case 'k': return 'j';
        case 'l': return 'k';
        case ';': return 'l';
        case '\'': return ';';
        case '\\': return '\'';

        case 'x': return 'z';
        case 'c': return 'x';
        case 'v': return 'c';
        case 'b': return 'v';
        case 'n': return 'b';
        case 'm': return 'n';
        case ',': return 'm';
        case '.': return ',';
        case '/': return '.';

        default: return ' ';
    }
}

char txt[10005];

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int n = 0;
    char c;
    while( (c=getchar()) != '\n' && c != -1 ){
         txt[n++] = c;
    }
    txt[n] = '\0';

    int cnt = 0;

    char prv = ' ';
    for( int i = 0; i < strlen(txt); ++i ){
        char q = getc( txt[i] );
        printf("%c",q);

        if( prv == ' ' ) cnt += q != ' ';

        prv = q;
    }

    printf(" %d\n",cnt);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <math.h>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 300;

int d[][2] = { {1,0} , {0,-1} , {-1,0} , {0,1} };

int h,w;
int mx[maxn][maxn];
bool not_cycle[maxn*maxn];
vector< int > g[maxn*maxn];

int getkey( int x, int y ){
    return y * w + x;
}

void input(){
    scanf("%d%d",&h,&w);
    for( int i = 0 ; i < h; ++i ){
        for( int j = 0; j < w; ++j ){
            scanf("%d",&mx[i][j]);
            if( mx[i][j] == 0 ) continue;

            int q = mx[i][j] - 1;

            int xn = j + d[q][0];
            int yn = i + d[q][1];
            g[ getkey(xn,yn) ].push_back( getkey(j,i) );
        }
    }
}

int dfs( int node ){
    int sol = 0;
    not_cycle[node] = true;
    for( int i = 0; i < g[node].size(); ++i )
        sol = max( sol , dfs( g[node][i] ) + 1 );
    return sol;
}

int dfsII( int node , int end ){
    not_cycle[node] = 1;
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( nxt == end ) return 0;

        int f = dfsII( nxt , end ) + 1;
        if( f >= 0 ) return f;
    }
    not_cycle[node] = 0;
    return -9999;
}

int non_cycles(){
    int ret = 0;
    for( int i = 0; i < h; ++i ){
        for( int j = 0; j < w; ++j ){
            int k = getkey(j,i);
            if( mx[i][j] ) continue;

            ret += dfs(k);
        }
    }
    return ret;
}

int cycles(){
    int sol = 0;
    for( int i = 0; i < h; ++i ){
        for( int j = 0; j < w; ++j ){
            int k = getkey(j,i);
            if( not_cycle[k] || mx[i][j] == 0 ) continue;

            int s = dfsII(k,k) + 1;
            if( s >= 0 )sol += s;
        }
    }
    return sol;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    input();

    int sol = non_cycles() + cycles();
    printf("%d\n",sol);

    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:runround
*/
#include <iostream>
#include <fstream>
#include <vector>
#include <math.h>
#include <stack>
#include <set>
#include <queue>
#include <map>
#include <string.h>
#include <algorithm>
using namespace std;

int n;
bool used[10];
int val[10];

vector< int > V;

int L;
void combine( int idx , int remain ){
    if( remain == 0 ){
        int q = 0;
        for( int i = 0; i < L; ++i )
            q = q * 10 + val[i];
        if( idx == 0 )V.push_back( q );
        return;
    }

    if( val[idx] != 0 ) return;

    for( int i = 1; i <= 9; ++i ){
        if( used[i] ) continue;
        val[idx] = i;
        used[i] = true;

        combine( (i+idx)%L , remain - 1 );

        used[i] = false;
        val[idx] = 0;
    }

}


void getcombys( int len ){
    L = len;
    combine( 0 , L );
}

int main(){
    freopen("runround.in","r",stdin);
    freopen("runround.out","w",stdout);
    for( int i = 1; i <= 9; ++i ) getcombys( i );

    sort( V.begin() , V.end() );

    int n;
    cin >> n;

    int q = *upper_bound( V.begin() , V.end() , n );
    cout<<q<<endl;


    return 0;
}

#include <iostream>
#include <vector>
#include <set>
#include <math.h>
#include <cstdlib>
#include <queue>
#include <cstdio>
using namespace std;

typedef long long ll;

const int mod = 1000000;
const int maxn = 100005;

int fpow( int x , int e ){
    if( e == 0 ) return 1;
    else if( e == 1 ) return x;
    else if( e % 2 == 0 ){
        int q = fpow( x , e / 2 );
        return (q*(ll)q)%mod;
    }else{
        int q = fpow( x , e - 1 );
        return (q*(ll)x)%mod;
    }
}

int n;
int s[3];
int v[3][maxn];
int hash[maxn];


int solve( int kolut , int mjesto ){
    if( kolut == 0 ) return 0;

    int emp = 0;
    if( hash[kolut] == 0 || mjesto == 0 ) emp ++;
    if( emp == 1 && (hash[kolut] == 1 || mjesto == 1) ) emp ++;

    int sol = 0;

    if( hash[kolut] != mjesto ) sol = ( solve( kolut - 1 , emp ) + fpow(2,kolut-1)  )%mod;
    else sol = solve( kolut - 1 , mjesto );

    return sol;
}


int main(){
    scanf("%d",&n);
    scanf("%d%d%d",&s[0],&s[1],&s[2]);

    for( int i = 0; i < 3; ++i )
        for( int j = 0; j < s[i]; ++j ){
            scanf("%d",&v[i][j]);
            hash[ v[i][j] ] = i;
        }

    int base = hash[ n ];


    int sol = solve( n - 1 , base );

    printf("%d\n%d\n",base+1,sol);

    return 0;
}

#include <iostream>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <map>
#include <vector>
#include <algorithm>
#include <string.h>
using namespace std;

const int inf = (int)10e8;

struct coord{
    int x,y;
    coord(){};
    coord( int p1, int p2  ):x(p1),y(p2){};
};

bool sy( coord a, coord b ){ return (a.y<b.y || (a.y == b.y && a.x < b.x)); }
bool sx( coord a, coord b ){ return (a.x<b.x || (a.x == b.x && a.y < b.y)); }

int n;
vector< coord > v;
vector< coord > xv , yv;

int main(){

   // freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        int x,y; scanf("%d%d",&x,&y);

        v.push_back( coord(x,y) );

        xv.push_back( v[i] );
        yv.push_back( v[i] );
    }

    sort( xv.begin() , xv.end() , sx );
    sort( yv.begin() , yv.end() , sy );

    int q;
    scanf("%d",&q);

    for( int i = 0; i < q; ++i ){
        int x1,y1,x2,y2;
        scanf("%d%d%d%d",&x1,&y1,&x2,&y2);

        int sol = 0;
        vector< coord > :: iterator it1,it2;

        it1 = lower_bound( xv.begin() , xv.end() , coord(x1,y1) , sx );
        it2 = lower_bound( xv.begin() , xv.end() , coord(x1,y2) , sx );
        if( it2 == xv.end() || it2->y > y2 || it2->x != x1 )it2 --;

        if( it1->x == x1 )sol +=  max( (int)(it2 - it1) + 1,0);

        it1 = lower_bound( xv.begin() , xv.end() , coord(x2,y1) , sx );
        it2 = lower_bound( xv.begin() , xv.end() , coord(x2,y2) , sx );
        if( it2 == xv.end() || it2->y > y2 || it2->x != x2 )it2 --;

        if( it1->x == x2 )sol +=  max( (int)(it2 - it1) + 1,0);

        //cout<<sol<<endl;


        it1 = lower_bound( yv.begin() , yv.end() , coord(x1,y1) , sy );
        it2 = lower_bound( yv.begin() , yv.end() , coord(x2,y1) , sy );
        if( it2 == yv.end() || it2->x >= x2 || it2->y != y1 )it2 --;
        if( it1->x == x1 )it1 ++;

        //cout<<(it1->x)<<" "<<(it1->y)<<endl;
       // cout<<(it2->x)<<" "<<(it2->y)<<endl;

        if( it1->y == y1 )sol +=  max( (int)(it2 - it1) + 1,0);


        it1 = lower_bound( yv.begin() , yv.end() , coord(x1,y2) , sy );
        it2 = lower_bound( yv.begin() , yv.end() , coord(x2,y2) , sy );
        if( it2 == yv.end() || it2->x >= x2 || it2->y != y1 )it2 --;
        if( it1->x == x1 )it1 ++;

       // cout<<(it1->x)<<" "<<(it1->y)<<endl;
        //cout<<(it2->x)<<" "<<(it2->y)<<endl;

        if( it1->y == y2 )sol +=  max( (int)(it2 - it1) + 1,0);



        printf("%d\n",sol);

    }


    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:prefix
*/
#include <iostream>
#include <vector>
#include <set>
#include <math.h>
#include <set>
#include <string>
#include <string.h>
#include <queue>
#include <map>
#include <algorithm>
using namespace std;

int sz = 0;
char pat[205][15];
int lens[205];

int len;
char txt[200005];


void input(){
    char c;
    while( c = getchar() ){
        if( (c == ' ' || c == '\n') && lens[sz] > 0 ) sz ++;
        else if( c == '.' ) break;
        else if( c >= 'A' && c <= 'Z' ) pat[sz][ lens[sz] ++ ] = c;
    }

    while( (c=getchar()) != -1 ){
        if( c >= 'A' && c <= 'Z' )txt[len++] = c;
    }
}

bool dp[200005];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    freopen("prefix.in","r",stdin);
    freopen("prefix.out","w",stdout);
    input();

    for( int i = 0; i < len; ++i ){

        bool ok = false;

        for( int k = 0; k < sz && !ok; ++k ){
            int prv = i - lens[k];

            if( prv > -1 && dp[prv] == 0 ){
                continue;
            }else{
                bool same = true;

                for( int d = 0; d < lens[k] && same; ++d )
                    if( txt[i-d] != pat[ k ][ lens[k] - d - 1 ] ) same = false;
                ok = same;
            }
//            if( ok ){
//                cout<<i<<endl;
//                for( int d = 0; d < lens[k]; ++d )
//                    cout<<pat[k][d]<<" ";cout<<endl;
//            }
        }
        dp[i] = ok;
    }

    bool found = false;
    for( int i = len-1; i >= 0; --i ){
        if( dp[i] != 0 ){
            cout<<i+1<<endl;
            found = true;
            break;
        }
    }

    if( found == false ) cout<<0<<endl;



    return 0;
}

#include <iostream>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <cstdio>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 10005;
const int maxk = 1005;
const int mod = 10000000;

int n,k;
int dp[maxn];
int v[maxk];

int main(){
    freopen("matematika.in","r",stdin);
    freopen("matematika.out","w",stdout);
    scanf("%d%d",&n,&k);

    for( int i = 0; i < k; ++i )scanf("%d",&v[i]);


    dp[0] = 1;

    for( int i = 0; i < k; ++i ){
        for( int j = 0; j <= n; ++j ){
            if( j + v[i] <= n )
                dp[ j + v[i] ] = (dp[j+v[i]] + dp[j] )%mod;
        }
    }

    printf("%d\n",dp[n]);

    return 0;
}

#include <cstdio>
#include <string.h>
using namespace std;

int h,w;
char txt[1000][1000];
char sol[1000][1000];

int d[][2] = { -1,-1,  0,-1 , 1,-1 , 0,1 , 1,1 , -1,1 ,  1,0 , -1,0 };

int main(){
    scanf("%d%d",&h,&w);
    for( int i = 0; i < h; ++i ){
        for( int j = 0; j < w; ++j ){
            char ch;
            while( ch=getchar() ) if( ch == '*' || ch == '.' ) break;
            txt[i][j] = ch;
        }
    }

    for( int i = 0; i < h; ++i ){
        for( int j = 0; j < w; ++j ){
            int cnt = 0;
            for( int k = 0; k  < 8; ++k ){
                int xn = d[k][0] + j;
                int yn = d[k][1] + i;
                if( xn < 0 || yn < 0 || xn >= w || yn >= h ) continue;
                cnt += txt[yn][xn] == '*';
            }

            if( txt[i][j] == '*' ) sol[i][j] = '*';
            else sol[i][j] = cnt + '0';
        }
    }

    for( int i = 0; i < h; ++i ){
        for( int j = 0; j < w; ++j )
            putchar(sol[i][j]);
        putchar('\n');
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <set>
#include <queue>
#include <algorithm>
#include <fstream>
#include <sstream>
#include <string.h>
#include <string>
#include <stack>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<short,short>

const short maxn = 300;
const short maxm = 1500;
const short source = 1805;
const short sink = 1806;
const short maxnm = maxn + maxm + 100;


vector< short > :: iterator work[maxnm];
vector< short > :: iterator end[maxnm];

vector< short > g[maxnm];


short n,m;
char txt[maxnm][maxnm];

short dist[maxnm];
short dad[maxnm];
short cap[maxnm][maxnm];;

short mem_n[maxn];
short mem_m[maxnm];

short dst[maxnm][maxnm];


inline void add_edge( short a, short b , short c ){
    g[a].push_back(b);
    g[b].push_back(a);
    cap[a][b] = c;
}


bool bfs(){
    memset( dist , -1 , sizeof(dist));

    queue< short >Q;
    dist[source] = 0;
    Q.push(source);

    while( !Q.empty() ){
        short u = Q.front(); Q.pop();
        for( short i = 0; i <g[u].size(); ++i ){
            short nxt = g[u][i];
            if( dist[nxt] < 0 && cap[u][nxt] ){
                dist[nxt] = dist[u] + 1;
                Q.push( nxt );
            }
        }
    }
    return ( dist[sink] >= 0 );
}


short flow( short x ){
    if( x == sink ) return 1;

    for( ; work[x]!=end[x]; ++work[x] ){
        short y = *work[x];
        if( dist[x] + 1 != dist[ y ] || cap[x][y] == 0 ) continue;

        short f = flow( y );
        if( f == 0 )continue;

        if( x < n && ( y >= n && y <= 1800 ) ) mem_n[x] = y , mem_m[y] = x;

        cap[x][y] --;
        cap[y][x] ++;
        return f;
    }
    return 0;
}


short sols[maxn][maxm];



bool visited[maxnm];
bool instk[maxnm];
short low[maxnm];
short dx[maxnm];
short scc = 0 , grp = 0;
short belongs[maxnm];
stack<short>e;
vector< short > com[maxnm];

void dfs( short node ){
    visited[node] = true;
    low[node] = dx[node] = ++scc;
    short cnt = scc;

    e.push( node );
    instk[node] = true;

    for( short i = 0; i < g[node].size(); ++i ){
        short w = g[node][i];
        if( cap[node][w] == 0 || w > 1800 ) continue;

        if( visited[w] == false ){
            dfs( w );
            low[node] = min( low[node] , low[w] );
        }else if( dx[w] < dx[node] ){
            if( instk[w] ){
                low[node] = min( low[node] , dx[w] );
            }
        }
    }

    if( dx[node] == low[node] ){
        grp ++;
        while( e.empty() == false && dx[ e.top() ] >= dx[node] ){
            com[grp].push_back( e.top() );
            belongs[ e.top() ] = grp;
            instk[ e.top() ] = false;

            e.pop();
        }
    }

}

short out[maxnm];
vector< short > sg[maxnm];
vector< short > rg[maxnm];

bool vis[maxnm];

short con;

void trav( short node ){
    vis[ node ] = true;

    for( short i = 0; i < com[con].size(); ++i ){
        short n1 = com[con][i];
        for( short j = 0; j < com[node].size(); ++j ){
            short n2 = com[node][j];
            dst[n1][n2] = 1;
        }
    }

    for( short i = 0; i < sg[node].size(); ++i ){
        short nxt = sg[node][i];
        if( vis[nxt] ) continue;

        trav( nxt );

    }
}


void spoji( short adj[maxnm][maxnm] ){
    for( short i = 0; i < maxnm; ++i ){
        for( short j = 0; j < maxnm; ++j ){
            dst[i][j] = cap[i][j];
            if( dst[i][j] == 0 ) dst[i][j] = -1;
        }
    }

    for( short i = 0; i < n+m; ++i ){
        if( visited[i] ) continue;
        dfs( i );
    }

    //queue< short > q;

    for( short i = 1; i <= grp; ++i ){
        for( short j = 0; j < com[i].size(); ++j ){
            short node = com[i][j];
            for( short k = 0; k < g[node].size(); ++k ){
                short nxt = g[node][k];

                if( cap[node][nxt] == 0 || nxt > 1800 ) continue;

                sg[ i ].push_back( belongs[nxt] );
            }
        }
        sort( sg[i].begin() , sg[i].end() );
        sg[i].erase( unique(sg[i].begin(),sg[i].end()),sg[i].end() );
        //out[i] = sg[i].size();

        //if( out[i] == 0 ) q.push( i );
    }

//    for( short i = 1; i <= grp; ++i )
//        for( short j = 0; j < sg[i].size(); ++j ){
//            cout<<sg[i][j]<<" ";
//            rg[ sg[i][j] ].push_back( i );
//        }


    for( short i = 1; i <= grp; ++i ){
        con = i;
        memset( vis , false , sizeof(vis));
        trav( i );
    }

}


int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d%d",&n,&m);

    bool isone = true;

    for( short i = 0; i < n; ++i ){
        scanf("%s",txt[i]);
        for( short j = 0; j < m; ++j ){
            if( txt[i][j] == '1' ) add_edge( i , n+j , 1 );
            else isone = false;
        }
    }

    if( isone ){
        for( short i = 0; i < n; ++i ){
            for( short j = 0; j < m; ++j )
                cout<<0;
            cout<<endl;
        }
        return 0;
    }

    for( short i = 0; i < n; ++i ) add_edge( source , i , 1 );
    for( short i = 0; i < m; ++i ) add_edge( n+i , sink , 1 );

    for( short i = 0; i < m+n; ++i ) end[i] = g[i].end();
    end[source] = g[source].end();
    end[sink] = g[sink].end();


    short s,sol=0;
    while( bfs() ){
        for( short i = 0; i < m+n; ++i ) work[i] = g[i].begin();
        work[source] = g[source].begin();
        work[sink] = g[sink].begin();

        while( true ){
            short f = flow ( source );
            if( f == 0 ) break;
            sol += f;
        }
    }


    if( sol < n ){
        for( short i = 0; i < n; ++i ){
            for( short j = 0; j < m; ++j )
                printf("1");
            printf("\n");
        }
        return 0;
    }


    memset( dst , -1 , sizeof(dst));

    spoji( dst );
    //return 0;


    for( short i = 0; i < n; ++i ){
        for( short j = 0; j < m; ++j ){
            short n1 = i , n2 = n+j;

            if( cap[n1][n2] == 0 && txt[i][j] == '1' )
                 continue;


            if( txt[i][j] == '0' ){
                sols[i][j] = 1;
                continue;
            }

            short del = mem_m[ n2 ];
            short prv = mem_n[ n1 ];

            cap[n1][prv] = 1;
            cap[prv][n1] = 0;

            cap[prv][sink] = 1;
            cap[sink][prv] = 0;

            cap[source][del] = 1;
            cap[del][source] = 0;

            bool Q = false;
            for( short k = 0; k < m && !Q; ++k ){
                if( dst[del][n+k] == -1 ) continue;
                if( cap[n+k][sink] ) Q = true;
            }
            if( Q == false ) sols[i][j] = 1;


            cap[n1][prv] = 0;
            cap[prv][n1] = 1;

            cap[prv][sink] = 0;
            cap[sink][prv] = 1;

            cap[source][del] = 0;
            cap[del][source] = 1;

        }
    }

    for( short i = 0; i < n; ++i ){
        for( short j = 0; j < m; ++j )
            printf("%d",sols[i][j]);
        printf("\n");
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <map>
#include <algorithm>
using namespace std;

int n,m;

bool grp[1005];
bool edge[1005][1005];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    scanf("%d%d",&n,&m);

    for( int i = 0; i < m; ++i ){
        int a,b; scanf("%d%d",&a,&b); a-- , b--;
        edge[a][b] = edge[b][a] = 1;
    }

    bool improve = true;
    while( improve ){
        improve = false;
        for( int i = 0; i < n; ++i ){

            int sz = 0;
            int S = 0;
            for( int j = 0; j < n; ++j ){
                sz += edge[i][j];
                if( edge[i][j] )S += grp[i] == grp[j];
            }

            if( S > (sz/2) ){
                grp[i] = !grp[i];
                improve = true;
            }

        }
    }
    int sol = 0,s1=0,s2=0;
    for( int i = 0; i < n; ++i ){
        s1 += grp[i] == 0;
        s2 += grp[i] == 1;
        for( int j = i+1; j < n; ++j ){
            if( edge[i][j] && grp[i] != grp[j] ) sol ++;
        }
    }

    if( sol < m / 2 ){
        printf("-1\n");
        return 0;
    }

    printf("%d %d\n",s1,s2);
    for( int i = 0; i < n; ++i ) if( grp[i] == 0 ) printf("%d ",i+1); printf("\n");
    for( int i = 0; i < n; ++i ) if( grp[i] == 1 ) printf("%d ",i+1); printf("\n");

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

#define pii pair<int,int>
#define mk make_pair
#define f first
#define s second

typedef long long ll;


vector< int > line;


class TheMoviesLevelOneDivOne {
    public:
        long long find(int n, int m, vector <int> row, vector <int> seat)
        {
            int s = row.size();
            ll sol = 0;
            vector< pii > used;

            for( int i = 0; i < s; ++i ) used.push_back( mk( row[i] , seat[i] ) );

            used.push_back( mk( n , 0 ) );
            used.push_back( mk( 1 , 0 ) );
            sort( used.begin() , used.end() );


            for( int i = 0; i < used.size(); ++i ){
                int k;

                line.clear();
                line.push_back( 0 );

                for( k = i; k < used.size(); ++k ){
                    if( used[k].f != used[i].f ) break;
                    line.push_back( used[k].s );
                }

                line.push_back( m + 1 );
                sort( line.begin() , line.end() );


                for( int k = 0; k+1 < line.size(); ++k ){
                    if( line[k+1] - line[k] - 2 > 0 )
                        sol += abs(line[k+1] - line[k]) - 2;
                }

                if( i ){
                    int d = used[i].f - used[i-1].f - 1;
                    sol += d * (ll)(m-1);
                }

                i = k-1;
            }



            return sol;

        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const long long &Expected, const long long &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { int Arg0 = 200; int Arg1 = 300; int Arr2[] = {1, 2}; vector <int> Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); int Arr3[] = {2, 3}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); long long Arg4 = 1LL; verify_case(0, Arg4, find(Arg0, Arg1, Arg2, Arg3)); }
	void test_case_1() { int Arg0 = 2; int Arg1 = 3; int Arr2[] = {1, 1, 1, 2, 2, 2}; vector <int> Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); int Arr3[] = {1, 2, 3, 1, 2, 3}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); long long Arg4 = 0LL; verify_case(1, Arg4, find(Arg0, Arg1, Arg2, Arg3)); }
	void test_case_2() { int Arg0 = 4; int Arg1 = 7; int Arr2[] = {1}; vector <int> Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); int Arr3[] = {1}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); long long Arg4 = 23LL; verify_case(2, Arg4, find(Arg0, Arg1, Arg2, Arg3)); }
	void test_case_3() { int Arg0 = 10; int Arg1 = 8; int Arr2[] = {1, 9, 6, 10, 6, 7, 9, 3, 9, 2}; vector <int> Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); int Arr3[] = {7, 7, 3, 3, 7, 1, 5, 1, 6, 2}; vector <int> Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); long long Arg4 = 54LL; verify_case(3, Arg4, find(Arg0, Arg1, Arg2, Arg3)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    TheMoviesLevelOneDivOne c;
    c.__test();
}
// END CUT HERE

#include <stdio.h>
#include <string.h>
#include <iostream>
#include <stack>
#include <vector>
#include <sstream>
using namespace std;

vector< int > L , S , vec;

int n;
int dp[1<<20] , nxt[1<<20];

int solve( int mask ){

    if( mask == (1<<n)-1 ) return 0;
    if( dp[mask] != -1 ) return dp[mask];

    int T = 0 , lvl = 0 , sol = 0;
    for( int i = 0; i < n; ++i ) if( mask&(1<<i) ) T += L[i] , lvl += 47;

    lvl = lvl + 74 - T;
    cout<<lvl<<endl;

    for( int i = 0; i < n; ++i ){
        if( mask&(1<<i) ) continue;

        int stime = S[i];
        int newlvl = lvl + 47 - L[i];
        if( lvl - stime < 0 || newlvl < 0 ) continue;

        int w = solve( mask | (1<<i) );

        if( sol < w+1 ){
            sol = w+1;
            nxt[mask] = i;
        }

    }

    return dp[mask] = sol;
}


class TheMoviesLevelTwoDivOne {
    public:
        vector <int> find(vector <int> length, vector <int> scary)
        {
            vec.clear();
            n = length.size();
            L = length , S = scary;

            memset( nxt , -1 , sizeof(nxt));
            memset( dp , -1, sizeof(dp));

            solve ( 0 );

            int now = 0;
            while( nxt[now] != -1 ){
                vec.push_back( nxt[now]);
                now |= (1<<nxt[now]);
            }

            for( int i = 0; i < n; ++i ){
                if( now&(1<<i) )continue;
                vec.push_back(i);
            }

            return vec;
        }



// BEGIN CUT HERE
void __test()
{
// END CUT HERE

// BEGIN CUT HERE
		static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }
// END CUT HERE

// BEGIN CUT HERE
}
// END CUT HERE

// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const vector <int> &Expected, const vector <int> &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: " << print_array(Expected) << endl; cerr << "\tReceived: " << print_array(Received) << endl; } }
	void test_case_0() { int Arr0[] = {100,50}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = {1,1}; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); int Arr2[] = {0, 1 }; vector <int> Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); verify_case(0, Arg2, find(Arg0, Arg1)); }
	void test_case_1() { int Arr0[] = {100, 50}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = {1, 49}; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); int Arr2[] = {1, 0 }; vector <int> Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); verify_case(1, Arg2, find(Arg0, Arg1)); }
	void test_case_2() { int Arr0[] = {100, 100, 100, 100}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = {77, 76, 75, 74}; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); int Arr2[] = {3, 0, 1, 2 }; vector <int> Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); verify_case(2, Arg2, find(Arg0, Arg1)); }
	void test_case_3() { int Arr0[] = {100}; vector <int> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arr1[] = {99}; vector <int> Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); int Arr2[] = {0 }; vector <int> Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); verify_case(3, Arg2, find(Arg0, Arg1)); }

// END CUT HERE

};
// BEGIN CUT HERE
int main()
{
    TheMoviesLevelTwoDivOne c;
    c.__test();
}
// END CUT HERE

#include <iostream>
#include <fstream>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <string.h>
#include <string>
using namespace std;

int lens,lent;
char sub[100];
char txt[1000];

char c[100];
int sz = 0;

int dp[1000][1000][2];

int solve( int dxa , int dxb , bool islo ){
    if( dxb == lent ) return 1;
    if( dp[dxa][dxb+1][islo] != -1 ) return dp[dxa][dxb+1][islo];

    int sol = 0;

    int to = lent;
    if( dxb == -1 ) to--;

    for( int i = dxb+1; i <= to; ++i ){
        bool ok = true;
        for( int j = dxb+1; j < i; ++j ) if( txt[j] == txt[i] ) ok = false;

        if( !ok || ( islo == false && txt[i] != -1 && txt[i] > sub[dxa])  ) continue;

        c[sz++] = txt[i];

        sol += solve( dxa + 1 , i , islo | (txt[i] < sub[dxa]) );
        sz--;

    }

    return dp[dxa][dxb+1][islo] = sol;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%s",sub);
    scanf("%s",txt);

    lens = strlen(sub);
    lent = strlen(txt);


    memset( dp , -1 , sizeof(dp));
    for( int i = lens; i < 60; ++i ) sub[i] = -1;
    for( int i = lent; i < 60; ++i ) txt[i] = -1;

    int sol = solve( 0 , -1 , 0 );

    printf("%d\n",sol);

    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:subset
*/
#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <stack>
#include <map>
#include <queue>
using namespace std;

int n;
int cnt[220];


int main(){
    freopen("subset.in","r",stdin);
    freopen("subset.out","w",stdout);
    scanf("%d",&n); n --;

    int s0 = 0 , e0 = n/2;
    int s1 = e0 + 1 , e1 = n;

    int d = e0 - s0 + 1;


    for( int i = 0; i < (1<<d); ++i ){
        int s = 0;
        for( int k = 0; k < d; ++k )
            if( i&(1<<k) ) s += k+1;
        cnt[s] ++;

    }

    int sum = (n+1)*(n+2) / 2;
    int hlf = sum / 2;
    long long  sol = 0;

    if( sum%2 ){
        printf("0\n");
        return 0;
    }

    d = e1 - s1 + 1;
    for( int i = 0; i < (1<<d); ++i ){
        int s = 0;
        for( int k = 0; k < d; ++k ) if( i&(1<<k) ) s += k + s1 + 1;

        int B = hlf - s;
        if( B < 0 ) continue;

        sol += cnt[B];
    }

    printf("%lld\n",sol/2);

    return 0;
}

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <iomanip>
#include <math.h>
#include <queue>
#include <stack>
#include <map>
#include <vector>
using namespace std;

#define priority_queue pq
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

int n,m;
int niz[500005];
int mn[500005] , mx[500005];

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);

    for( int i = 0; i < n; ++i )
        scanf("%d",&niz[i]);

    mn[0] = niz[0];
    for( int i = 1; i < n; ++i ) mn[i] = min( mn[i-1] , niz[i] );

    mx[n-1] = niz[n-1];
    for( int i = n-2; i >= 0; --i ) mx[i] = max( mx[i+1] , niz[i] );



    int sol = -1000000000;
    for( int i = 0; i <= m; ++i ){
        sol = max( sol , mx[n-m-1+i] - mn[i] );

    }


    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <vector>
#include <stack>
#include <map>
#include <iomanip>
#include <queue>
#include <string.h>
#include <string>
using namespace std;

struct coord{
    int r,c;
    coord(){};
    coord( int p1, int p2 ):r(p1),c(p2){};
};

int h,w;
coord mario , princeza;
char txt[100][100];

int dst[100][100];

int d[][2] = { {1,0} , {0,1} , {-1,0} , {0,-1} };

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&h,&w);

    for( int i = 0; i < h; ++i ){
        scanf("%s",txt[i]);
        for( int j = 0; j < w; ++j ){
            if( txt[i][j] == 'M' ) mario = coord( i , j );
            else if( txt[i][j] == 'P' ) princeza = coord( i , j );
        }
    }

    memset( dst , -1 , sizeof(dst));
    dst[ mario.r ][ mario.c ] = 0;

    queue< coord > q;
    q.push( mario );

    while( !q.empty() ){
        coord u = q.front(); q.pop();

        for( int i = 0; i < 4; ++i ){
            int r = u.r + d[i][0];
            int c = u.c + d[i][1];

            if( r < 0 || c < 0 || r >= h || c >= w ) continue;
            if( dst[r][c] != -1 || txt[r][c] == '#' ) continue;

            dst[r][c] = dst[u.r][u.c] + 1;
            q.push( coord(r,c) );
        }
    }

    int sol = dst[princeza.r][princeza.c] * 2;

    if( sol >= 0 )
        printf("%d\n", dst[princeza.r][princeza.c] * 2 );
    else
        printf("-1\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <math.h>
#include <set>
#include <algorithm>
#include <map>
#include <queue>
#include <vector>
using namespace std;

const int maxn = 1005;
const int inf = 99999999;


int n;
int p[maxn];
int x[maxn];
int s[maxn];

int dp[maxn][maxn];

int cost( int a, int b ){ return s[b] * ( 1000 / s[a] ); }
int costp( int a, int b ){ return p[b] * ( 1000 / p[a] ); }
bool srt( int a , int b ){ return p[a] < p[b]; }

int prvL[maxn];
int prvR[maxn];


vector< int > cit;
void backtrace( int dx , int prv[maxn] ){
    cout<<x[dx]<<" ";
    if( dx == 0 ) return;
    cit.push_back( x[dx]+1 );
    backtrace( prv[dx] , prv );
}

int q[1005][1005][2];

int solve( int left , int right ){
    int nxt = max( left , right ) + 1;
    if( dp[left][right] != -1 ) return dp[left][right];
    if( nxt == n ) return cost( right , left );


    int s1 = solve( left , nxt ) + cost( right , nxt );
    int s2 = solve( nxt , right ) + cost( nxt , left );


    if( s1 < s2 ){
        q[left][right][0] = left;
        q[left][right][1] = nxt;
    }else{
        q[left][right][0] = nxt;
        q[left][right][1] = right;
    }

    return dp[left][right] = min( s1 , s2 );

}

int main(){

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%d",&p[i]);
        x[i] = i;
    }

    //cout<<costp(0,1) + costp(1,3) + costp(3,4) + costp(4,2) + costp(2,6) + costp(6,5) + costp(5,7) + costp(7,8) + costp(8,9) + costp(9,1)<<endl;

    sort( x , x + n , srt );

    for( int i = 0; i < n; ++i ) s[i] = p[ x[i] ];

    memset( dp , -1 , sizeof(dp));
    memset( q , -1 , sizeof(q));

    int sol = solve( 0 , 0 );


    vector< int > l , r;

    int a = 0 , b = 0;
    while( a != -1 && b != -1 ){

        int na = q[a][b][0];
        int nb = q[a][b][1];

        if( na != a ) l.push_back( x[a]+1 );
        if( nb != b ) r.push_back( x[b]+1 );


        a = na;
        b = nb;
    }

    vector< int > v;
    for( int i = l.size()-1; i >= 0; --i )
        v.push_back( l[i] );

    for( int i = 1; i < r.size(); ++i )
        v.push_back( r[i] );

    int it;
    for( it = 0; v[it] != 1 ; ++it );


    for( int i = 0; i < n; ++i )
        cout<<v[ (i+it)%n ]<<" ";cout<<endl;
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <stack>
#include <map>
#include <cstdlib>
#include <vector>
#include <math.h>
#include <string.h>
using namespace std;

typedef long long ll;
const int maxq = 1000000000;

int primes[] = {2,3,5,7};
vector< int > oks;


void calc( int prv , ll now ){
    if( now > maxq ) return;
    oks.push_back(now);

    for( int i = prv; i < 4; ++i ) calc( i , now * primes[i] );
}

ll A , B;
ll dp[20][6000];

long long solve( ll now , int left , int p ){
    ll minx = now , maxx = now;
    for( int i = 0; i < left; ++i ) minx = minx*10 , maxx = maxx*10 + 9;

    int dx;
    if( maxx < A || minx > B ) return 0;
    else if(  minx >= A &&  maxx <= B ){
        dx = lower_bound( oks.begin() , oks.end() , p ) - oks.begin();
        if( dp[left][dx] != -1 )return dp[left][dx] ;
    }

    if( left == 0 && p == 1 ) return 1;
    else if( left== 0 ) return 0;

    int sol = 0;
    for( int i = 1; i <= 9; ++i ) if( p%i == 0 )sol += solve( now * 10 + i , left - 1 , p / i );

    if(  minx >= A &&  maxx <= B ) dp[left][dx] = sol;

    return sol;
}

int main(){
    calc( 0 , 1 );

    ll f,s;
    cin >> f >> s;

    memset( dp, -1 , sizeof(dp));
    ll sol = 0;

    sort( oks.begin() , oks.end() );


    for( int i = 0; i < oks.size(); ++i ){
        A = ceil( f/(double)oks[i]);
        B = s / oks[i];

        for( int k = 1; k <= 18; ++k ) sol += solve( 0 , k , oks[i] );
    }
    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <math.h>
#include <fstream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <string.h>
using namespace std;

const int maxn = 1000;

int n,taxi,bus;
int dp[maxn+5];
int idx[maxn+5];

int pre[maxn+5][maxn+5];


int solve( int R ){
    if( dp[R] != -1 ) return dp[R];
    if( R == 1000 ) return 0;

    int sol = 0;
    for( int i = 0; i < n; ++i )
        if( idx[i] > R ) sol += (idx[i] - R) * taxi;



    for( int i = R+1; i <= 1000; ++i )
        sol = min( sol , solve( i ) + pre[R][i]*taxi + bus );

    return dp[R] = sol;
}

int mem[maxn+5];


int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);
    scanf("%d%d",&bus,&taxi);

    for( int i = 0; i < n; ++i ){
        scanf("%d",&idx[i]);
        mem[ idx[i] ]++;
    }

    for( int i = 0; i <= 1000; ++i ){
        int cL , cR , L , R;

        cL = cR = L = R = 0;
        for( int k = 0; i-k >= 0 && i+k <= 1000; ++k ){
            L += cL , R += cR;
            cL += mem[i-k];
            if( k ) cR += mem[i+k];
            pre[i-k][i+k] = (L+R);
        }

        cL = cR = L = R = 0;
        for( int k = 0; i-k >= 0 && i+k+1 <= 1000; ++k ){
            L += cL , R += cR;
            cL += mem[i-k];
            cR += mem[i+k+1];
            pre[i-k][i+k+1] = (L+R);
        }
    }



    memset( dp , -1 , sizeof(dp));
    int s = solve( 0 );



    cout<<s<<endl;

    return 0;
}

1621
#include <iostream>
#include <vector>
#include <math.h>
#include <set>
#include <queue>
#include <cstdlib>
#include <iomanip>
#include <stack>
#include <assert.h>
#include <string.h>
#include <string>
#include <fstream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int inf = 999999999;
const int maxn = 100005;
const int mod = 10000;
const int maxb = 2*maxn;

struct gelender{
    int f, s;
    gelender(){};
    gelender( int p1, int p2 ):f(p1),s(p2){};
    bool operator<( const gelender &e2 ) const {
        return f < e2.f || ( f == e2.f && s < e2.s );
    }
};

int n;
vector< gelender > g;
int mem[maxb];

void input(){
    scanf("%d",&n);

    vector< int > lo;
    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        g.push_back( gelender(a,b) );

        lo.push_back(a);
        lo.push_back(b);
    }
    sort( lo.begin() , lo.end() );
    lo.erase( unique( lo.begin() , lo.end() ) , lo.end() );

    for( int i = 0; i < n; ++i ){
        int a = g[i].f;
        int b = g[i].s;

        g[i].f = lower_bound( lo.begin() , lo.end() , a ) - lo.begin();
        g[i].s = lower_bound( lo.begin() , lo.end() , b ) - lo.begin();
    }
}

void calc_maxx(){
    int now = inf , k = n - 1;
    sort( g.begin() , g.end() );


    for( int i = maxb; i >= 0; --i ){
        mem[i] = now;

        while( k >= 0 && i == g[k].f ){
            now = min( now , g[k].s );
            k --;
        }
    }
}

int dp[maxb];

int solve(){
    int sol = 0 , now = 0;
    int k = 0;

    int lim = inf;
    for( int i = 0; i < n; ++i )
        lim = min( lim , g[i].s );

    for( int i = 0; i < maxb && k < n; ++i ){
        now = (now+dp[i])%mod;

        while( k < n && i == g[k].f ){
            int add = now;
            if( add == 0 && g[k].f <= lim ) add = 1;


            int nxt = mem[ g[k].s  ];

            if( nxt == inf ){
                sol = (sol + add)%mod;
            }else{
                dp[ g[k].s + 1 ] = ( dp[ g[k].s + 1 ] + add ) % mod;
                dp[ nxt + 1    ] = ( dp[ nxt + 1    ] - add + 100*mod) % mod;
            }
            ++k;
        }
    }

    return sol;
}

int main(){

    input();
    calc_maxx();
    int sol = solve();


    printf("%d\n",sol%mod);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <vector>
#include <map>
#include <iomanip>
#include <cstdio>
#include <string.h>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>
#define inf 1000000000

const int maxe = 500;

int source , sink;

int ecnt = 2;

int dst[maxe] , cap[maxe] , next[maxe] , head[maxe] , point[maxe] , work[maxe];

inline void add_edge( int a, int b , int c ){
    cap[ecnt] = c , point[ecnt] = b , next[ecnt] = head[a] , head[a] = ecnt++;
    cap[ecnt] = 0 , point[ecnt] = a , next[ecnt] = head[b] , head[b] = ecnt++;
}

int n,m;

bool bfs(){
    queue< int > q;
    q.push( source );

    int u;
    memset( dst , -1 , sizeof(dst));

    dst[source] = 0;

    while( !q.empty() ){
        u = q.front(); q.pop();
        for( int i = head[u]; i > 1; i = next[i] ){
            if( dst[ point[i] ] >= 0 || cap[ i ] <= 0 ) continue;
            dst[ point[i] ] = dst[u] + 1;
            q.push( point[i] );
        }
    }
    return dst[sink] > 0;
}

int flow( int node , int mincap ){
    if( node == sink ) return mincap;

    for( ; work[node] > 1; work[node] = next[ work[node] ] ){
        int i = work[node];

        if( dst[node] + 1 == dst[ point[i] ] && cap[i] > 0 ){
            int f = flow( point[i] , min( mincap , cap[i] ) );
            if( f == 0 ) continue;

            cap[i] -= f;
            cap[i^1] += f;

            return f;
        }
    }

    return 0;
}


int dinic(){
    int sol = 0;
    int q = 0;
    while( bfs() ){
        for( int i = 0; i < n; ++i ) work[i] = head[i];
        while(1){
            int f = flow( source , inf );
            if( f == 0 ) break;
            sol += f;
        }
    }
    return sol;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&m,&n);

    source = 0 , sink = n - 1;

    for( int i = 0; i < m; ++i ){
        int a,b,c; scanf("%d%d%d",&a,&b,&c); a--,b--;
        add_edge( a , b , c );
    }


    int sol = dinic();
    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <math.h>
#include <algorithm>
#include <queue>
#include <map>
using namespace std;

int cnt[10000];

int main(){

    int o;
    cin >> o;

    int g = o / 2;
    if( o%2 == 0 ) g -= 2;

    long long sol = 0;
    for( int i = 1; i <= g; ++i )sol += i;


    cout<<sol/3<<endl;

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <string>
#include <string.h>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
using namespace std;

struct coord{
    int x,y;
    coord(){};
    coord( int p1, int p2 ):x(p1),y(p2){};
};

bool srtX( coord a , coord b ){
    return a.x < b.x;
}
bool srtY( coord a , coord b ){
    return a.y < b.y;
}


inline double dist( coord a , coord b ){ return hypot( a.x - b.x , a.y - b.y ); }
inline double sq( double v ){return v*v; }



int n;
vector< coord > p;


double solve( int lo , int hi ){

    if( hi-lo <= 0 ) return 10e9;

    int mid = (lo+hi)>>1;

    double d1 = solve( lo , mid );
    double d2 = solve( mid + 1 , hi );

    double h = min(d1,d2);

    vector< coord > inarea;

    for( int i = lo; i <= hi; ++i )
        if(  p[mid].x - p[i].x < h )
            inarea.push_back( p[i] );

    sort( inarea.begin() , inarea.end() , srtY );

    int prv = 0;

    for( int i = lo; i <= hi; ++i ){
        while( p[i].x-p[prv].x > h ) prv++;
        for( int j = prv; j < i; j++ )
            h = min( h , dist( p[i] , p[j] )  );
    }

    return h;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        int x,y; scanf("%d%d",&x,&y);
        p.push_back( coord(x,y) );
    }

    sort( p.begin() , p.end() , srtX );

    double sol = solve( 0 , n-1 );

    printf("%.10lf\n",sol);


    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <algorithm>
using namespace std;

int dp[7000][7000];
char txt[7000];
char rtx[7000];


int solve(){
    int len1 = strlen(txt);
    int len2 = strlen(rtx);
    int mx = max( len1, len2 );


    for( int i = 1; i <= len1; ++i ){
        for( int j = 1; j <= len2; ++j ){
            if( txt[i-1] == rtx[j-1] )
                dp[i][j] = dp[i-1][j-1] + 1;
            else
                dp[i][j] = max( dp[i-1][j] , dp[i][j-1] );
        }
    }
    return dp[len1][len2];
}

int main(){
    int tests;
    scanf("%d",&tests);

    while( tests -- ){

        scanf("%s",txt);
        memcpy( rtx , txt , sizeof txt );
        reverse( rtx , rtx + strlen(rtx) );


        int sol = solve();
        printf("%d\n",strlen(txt)-sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <set>
#include <iomanip>
#include <stack>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
using namespace std;

typedef long long ll;

int n;

ll power[25] , x;

int dx[25] , sz = 0;

int main(){
    freopen("Ulaz.txt","r",stdin);
    power[0] = 1;
    for( int i = 1; i <= 20; ++i )
        power[i] = power[i-1] * 3;

    cin >> n >> x;
    bool ok = false;

    for( int i = 1; i < (1<<n); ++i ){
        ll s = 0;
        for( int k = 0; k < n; ++k ) if( i&(1<<k) ) s += power[k];

        if( s == x ){
            ok = true;
            printf("\n");
            bool f = false;
            for( int k = 0; k < n; ++k ){
                if( i&(1<<k) ){
                    if( f )printf(" ");
                    f = true;
                    printf("%d",k+1);
                }
            }printf("\n");
            break;
        }else if( s > x ){
            ll q = s - x;
            sz = 0;
            for( int k = n-1; k >= 0; --k ) if( ~i&(1<<k) ) if( q >= power[k] ) q -= power[k] , dx[sz++] = k+1;
            if( q == 0 ){
                ok = true;
                for( int k = sz-1; k >= 0; --k ){
                    if( k != sz-1 ) printf(" ");
                    printf("%d",dx[k]);
                }putchar('\n');

                bool f = false;
                for( int k = 0; k < n; ++k ){
                    if( i&(1<<k) ){
                        if( f )printf(" ");
                        f = true;
                        printf("%d",k+1);
                    }
                }putchar('\n');
                 break;
            }
        }
    }
    if( ok == false )printf("-1\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
#include <iomanip>
using namespace std;

const int inf = 9999999;

int n;
string txt[20];
int comm[20][20];

int dp[1<<15][20];
int mem[1<<15][20];
int ss[20];

int solve( int mask , int lst ){
    if( mask == (1<<n) - 1 ) return 0;

    int &ref = dp[mask][lst];

    if( ref != -1 ) return ref;

    int mx = inf;

    for( int i = 0; i < n; ++i ){
        if( mask&(1<<i) )continue;

        int nxt = lst;
        if( comm[lst][i] != txt[i].size() ) nxt = i;

        int a = txt[i].size() - comm[lst][i];
        int cnt = solve( mask|(1<<i) , nxt ) + a;

        if( cnt < mx ){
            mx = cnt;
            mem[mask][lst]= i;
        }

    }
    return ref = mx;
}

void clear(){
    memset( comm , 0 , sizeof(comm));
    for( int i = 0; i <= (1<<n); ++i )
        for( int j = 0; j <= n; ++j ){
            dp[i][j]  = -1;
            mem[i][j] = -1;
        }
}

char buff[105];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    int tests,T=1;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        memset( comm , 0 , sizeof(comm));
        scanf("%d",&n); clear();
        for( int i = 0; i < n; ++i ) cin >> txt[i];

        for( int i=0; i<n; i++ )
            for( int j=0; j<n; j++ )
                if( i!=j && txt[j].find(txt[i])!=string::npos ){
                    swap( txt[i] , txt[--n] );
                    break;
                }


        for( int i = 0; i < n; ++i ){
            for( int j = 0; j < n; ++j ){
                int len = txt[i].size();
                int mx = 0;
                for( int s = 0; s < len; ++s ){
                    bool ok = true;
                    for( int k = 0; s+k < len && k < txt[j].size(); ++k ){
                        if( txt[i][s+k] != txt[j][k] ) ok = false;
                    }
                    if( ok ){
                        mx = len - s;
                        if( s + txt[j].size() < len ) mx = txt[j].size();
                        break;
                    }
                }

                comm[i][j] = mx;
            }
        }

        int sol = solve( 0 , n );
        printf("Scenario #%d:\n",T++);

        int f = 0 ,s = n , cnt = 0;
        while( mem[f][s] != -1 ){
            int nxt = mem[f][s];
            int ser = dp[ f|(1<<nxt) ][nxt] + txt[nxt].size() - comm[s][nxt];

            string s1 = txt[nxt].substr( comm[s][nxt] );

            for( int i = 0; i < n; ++i ){
                if( i == nxt ) continue;
                if( f&(1<<i) )continue;
                int stat = f|(1<<i);

                if( dp[stat][i] + txt[i].size() - comm[s][i] != ser ) continue;

                string q = txt[i].substr( comm[s][i] );
                if( s1 > q ) s1 = q , nxt = i;

            }


            int cm = comm[s][nxt];


            for( int k = cm; k < txt[nxt].size(); ++k )
                putchar( txt[nxt][k] ) , cnt ++;
            f |= 1<<nxt;
            if( comm[s][nxt] != txt[nxt].size() ) s = nxt;

        }putchar('\n');putchar('\n');

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <set>
#include <algorithm>
#include <string>
#include <string.h>
#include <iomanip>
#include <queue>
#include <stack>
#include <map>
using namespace std;

struct coord{
    int x,y;
    coord(){};
    coord( int p1, int p2 ):x(p1),y(p2){};
    bool operator<( const coord &c ) const {
        return ( x < c.x || (x == c.x && y < c.y ));
    }
};

const int inf = 1000005000;

int n,clvl;
set< coord > slvl[100005];


int main(){

    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    int sol = 0;
    slvl[0].insert( coord(-inf,-inf) );

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        coord p = coord(a,b);

        int lo = 0, hi = clvl, s = 0;
        while( lo <= hi ){
            int mid = (lo+hi)>>1;
            bool ok = false;


            set< coord > :: iterator it = slvl[mid].lower_bound( p );
            if( it != slvl[mid].begin() ){
                it --;
                if( p.x > it->x && p.y > it->y ) ok = true;
                if( it != slvl[mid].begin() ){
                    it--;
                    if( p.x > it->x && p.y > it->y ) ok = true;
                }
            }


            if( ok )lo = mid + 1 , s = mid;
            else hi = mid - 1;
        }

        while( 1 ){
            set< coord > :: iterator it = slvl[s+1].lower_bound( p );
            if( it == slvl[s+1].end() ) break;
            if( p.x <= it->x && p.y <= it->y )slvl[s+1].erase(it);
            else break;
        }

        bool ok = true;
        set< coord > :: iterator it = slvl[s+1].lower_bound( p );
        if( it != slvl[s+1].begin() ){
            it --;
            if( it->x <= p.x && it->y <= p.y ) ok = false;
        }


        if( ok )slvl[s+1].insert( p );
        clvl = max( clvl , s + 1 );
    }

    printf("%d\n",clvl);

    return 0;
}

#include <iostream>
#include <vector>
#include <set>
#include <iomanip>
#include <stack>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 10050;
const int mod = 5000000;

int n,k;
int v[maxn+50];
int sr[maxn+50];

int cnt[55][maxn+50];

int dp[55][maxn+50];

int add( int y, int x , int v ){
    for( x += 2; x <= maxn; x += x & -x )
        dp[y][x] = ( dp[y][x]+v )%mod;
}

int read( int y, int x ){
    int ret = 0;
    for( x += 2; x >= 1; x -= x & -x )
        ret = ( ret+dp[y][x] )%mod;
    return ret;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&k);

    for( int i = 0; i < n; ++i ){
        scanf("%d",&v[i]);
        sr[i] = v[i];
    }
    sort( sr , sr + n );
    for( int i = 0; i < n; ++i ) v[i] = lower_bound( sr , sr + n , v[i] ) - sr;


    for( int i = 0; i < n; ++i ){
        if( cnt[0][ v[i] ] == 0 ) add( 1 , v[i] , 1 );
        cnt[0][ v[i] ] = 1;

        for( int j = 1; j < 50; ++j ){
            int r = read( j , v[i] - 1 );
            r -= cnt[j][ v[i] ];

            r %= mod;
            r += 2*mod;
            r %= mod;

            add( j + 1 , v[i] , r );
            cnt[j][ v[i] ] = ( cnt[j][ v[i] ]+r ) % mod;
        }
    }

    int sol = read( k , maxn );
    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <set>
#include <math.h>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
using namespace std;


class BigNum{   // BIG_NUM_CLASS
   private:
      static const int NewBasis = 8;
      static const int PLACES = 100000000;
   public:
      vector<char>digits;
      BigNum(){}
      BigNum( int v ){while( v ) digits.push_back(v%10) , v/=10; }
      BigNum( char* );
      BigNum( const BigNum &z ){ digits = z.digits; }
      BigNum operator*(const BigNum&);
      BigNum operator+(const BigNum&);
      BigNum operator-(const BigNum&);
      inline void WriteLn();
      void operator=(BigNum);
      bool operator<(const BigNum&);
      bool operator>(const BigNum&);
      bool operator==(const BigNum&);
};

void BigNum::operator=(BigNum b2 ){
   digits.clear();
   digits=b2.digits;
}

BigNum::BigNum( char *f ){
    int len = strlen(f);
   for( int i = len-1; i >=0; --i )
      digits.push_back( f[i]-'0' );
    while( digits.size() > 0 && digits.back() == 0 )digits.pop_back();
}

bool BigNum::operator<( const BigNum &b2 ){
   if( b2.digits.size() > digits.size() )return true;
   else if( b2.digits.size() < digits.size() )return false;
   else{
       for( int i = digits.size()-1; i >=0 ; --i ){
         if( digits[i] < b2.digits[i] )
            return true;
         else if( digits[i] > b2.digits[i] )
            return false;
      }
   }
   return false;
}
bool BigNum::operator>( const BigNum &b2 ){
   if( b2.digits.size() < digits.size() )return true;
   else if( b2.digits.size() > digits.size() )return false;
   else{
      for( int i = digits.size()-1; i >=0 ; --i ){
         if( digits[i] > b2.digits[i] )
            return true;
         else if( digits[i] < b2.digits[i] )
            return false;
      }
   }
   return false;
}


BigNum BigNum::operator+( const BigNum &b2 ){
   BigNum A = *this , B = b2;
   if( A.digits.size() < B.digits.size() )swap(A,B);
   BigNum sum = B;
   int tmp = 0;
   for( int i = 0; i < B.digits.size(); ++i ){
      int ss = B.digits[i] + A.digits[i] + tmp;
      sum.digits[i] = ss%10;
      tmp = ss / 10;
   }
   for( int i = B.digits.size(); i < A.digits.size(); ++i ){
      int ss = A.digits[i] + tmp;
      sum.digits.push_back( ss % 10 );
      tmp = ss/10;
   }
   while( tmp ){
      sum.digits.push_back( tmp % 10 );
      tmp /= 10;
   }
   return sum;
}

BigNum BigNum::operator-(const BigNum& b2){
   if( (*this) > b2 ){
      int add = 0;
      int len1 = digits.size();
      int len2 = b2.digits.size();
      BigNum ret = (*this);
      for( int i = 0; i < len1 && ( add != 0 || i < len2 ); ++ i ){
         int num1 = digits[i];
         int num2 = ( i < len2 ? b2.digits[i] : 0 ) + add;
         add = 0;

         while( num1 < num2 ) num1 += 10 , add ++;

         ret.digits[i] = num1 - num2;

      }
      while( ret.digits.size() > 0 && ret.digits.back() == 0 )ret.digits.pop_back();
      return ret;
   }
}


inline void BigNum::WriteLn(){
   if( digits.size() == 0 )printf("0");
   for( int i = digits.size()-1; i >=0; --i )
      printf("%d",digits[i]);
   printf("\n");
}

char txt[305];


int main(){

    int tests;
    scanf("%d",&tests);

    while( tests -- ){

        BigNum b,c,d,a1,a2;

        scanf("%s",txt); b = BigNum(txt);
        scanf("%s",txt); c = BigNum(txt);
        scanf("%s",txt); d = BigNum(txt);

        if( b > c ) a1 = b - c;
        else if( b < c ) a1 = c - b;

        if( c > d ) a2 = c - d;
        else if( c < d )a2 = d - c;


        BigNum sol = a1 + a2;

        sol.WriteLn();

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <set>
#include <math.h>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
using namespace std;


int n;
int v[2005];

int main(){

    while( scanf("%d",&n) == 1 ){
        if( n == 0 ) break;

        for( int i = 0; i < n; ++i )
            scanf("%d",&v[i]);

        sort( v , v + n );

        int sol = 0;

        for( int i = 0; i < n; ++i ){
            for( int j = i+1; j < n - 1; ++j ){

                int s = v[i] + v[j];
                int lo = j + 1 , hi = n - 1;
                int ver = n;

                while( lo <= hi ){
                    int mid = (lo+hi)>>1;

                    if( s < v[mid] ) hi = mid-1 , ver = mid;
                    else lo = mid + 1;
                }

                sol += n-ver;

            }
        }
        printf("%d\n",sol);


    }


    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
#include <iomanip>
using namespace std;

const int maxn = 10055;
const int lg = 15;
const int BOTTOM = 1<<14;
const int inf = 99999999;
const int STP = 14;

int n;
int v[maxn];
int l1,r1,l2,r2;


struct cvor{
    int tot,maxx,left,right;
    cvor(){};
    cvor( int p1, int p2, int p3, int p4 ):tot(p1),maxx(p2),left(p3),right(p4){};
};

cvor tree[1<<15];


void proces( int node , int lo , int hi ){

    if( node >= BOTTOM ) return;

    int &tot = (tree[node].tot = 0);
    int &left = (tree[node].left = -inf );
    int &right = (tree[node].right = -inf );
    int &maxx = (tree[node].maxx = -inf );

    int cmx = 0;
    int cle = 0;
    int cri = 0;

    for( int i = lo; i <= hi; ++i ){

        if( cmx < 0 ) cmx = 0;
        tot += tree[i].tot;
        cmx += tree[i].tot;
        cle += tree[i].tot;
        cri += tree[hi-(i-lo)].tot;

        maxx = max( cmx , maxx );
        left = max( left , cle );
        right = max( right , cri );
    }
    int mid = (lo+hi)>>1;
    proces( node<<1 , lo , mid );
    proces( (node<<1)+1 , mid + 1 , hi );
}



int L,R;
cvor query( int idx, int deep ){
    if( R < L ) return cvor(-inf,-inf,-inf,-inf);

    int lb = idx    * (1<<(STP-deep));
    int rb = (idx+1)* (1<<(STP-deep)) - 1;
    int mid = (lb+rb)>>1;

    if(lb >= L && rb <= R ){
         return tree[idx];
    }
    if(  L <= mid && mid < R  ){

        cvor left  = query( idx*2  , deep+1 );
        cvor right = query( idx*2+1, deep+1 );

        cvor sol;


        sol.tot  = left.tot + right.tot;
        sol.left = max( left.left , left.tot + right.left );
        sol.right= max( right.right , right.tot + left.right );
        sol.maxx = max(  max(left.maxx,right.maxx) , right.left+left.right );

        return sol;
      }

      if(  (lb <= L && L <= mid) || (lb <= R && R <= mid)  )
         return query( idx*2  , deep + 1 );

      else if( (mid < R && R <= rb) || (mid < L && L <= rb)  )
         return query( idx*2+1, deep + 1 );

    return cvor(-inf,-inf,-inf,-inf);
}

cvor query2( int l , int r ){
    L = l , R = r;
    return query( 1 , 0 );
}


int main(){
   // freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        memset( tree , 0 , sizeof(tree));

        scanf("%d",&n);
        for( int i = 0; i < n; ++i ){
            scanf("%d",&v[i]);
            tree[BOTTOM+i].tot = tree[BOTTOM+i].left = tree[BOTTOM+i].right = tree[BOTTOM+i].maxx = v[i];
        }

        proces( 1 , BOTTOM , (BOTTOM<<1)-1 );

        int m;
        scanf("%d",&m);

        for( ; m ; --m ){
            scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
            l1 += BOTTOM - 1;
            l2 += BOTTOM - 1;
            r1 += BOTTOM - 1;
            r2 += BOTTOM - 1;

            cvor q = query2(l2,r1);
            int sol1 = q.maxx;
            int sol = q.maxx, sol3 = -inf , sol4 = -inf;

            int mid = 0;
            if( r1 + 1 <= l2 - 1 ) mid = query2( r1 + 1, l2 - 1 ).tot;


            if( r1 < l2 ){
                sol1 = query2( l1, r1 ).right + mid + query2( l2, r2 ).left;
            }else{
                sol3 = query2( l2,r2 ).left + query2( l1,l2-1 ).right;
                sol4 = query2( l1,r1 ).right + query2( r1+1, r2 ).left;
            }


            int ss = max( sol3,sol4 );
            ss = max( ss , sol1 );
            ss = max( ss , sol );

            printf("%d\n",ss );

        }


    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <set>
#include <algorithm>
#include <stack>
#include <map>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <cstdio>
using namespace std;

const int mod = 1000000;

int n;

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    scanf("%d",&n);

    int sol = 1;
    sol += n / 2;
    sol += n / 3;
    for( int i = 3; i <= n; i += 3 ){
        sol += (n-i)>>1;
        if( sol >= mod ) sol %= mod;
    }
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <fstream>
#include <math.h>
#include <algorithm>
#include <stack>
#include <vector>
using namespace std;

vector< int > g[100] , rg[100];

bool visi[100];

int tezi( int node ){
    int ret = 1;
    visi[node] = true;
    for( int i = 0; i < g[node].size(); ++i ){  int nxt = g[node][i];
        if( visi[nxt] == false )
            ret += tezi( nxt );
    }
    return ret;
}

int laksi( int node ){
    int ret = 1;
    visi[node] = true;
    for( int i = 0; i < rg[node].size(); ++i ){  int nxt = rg[node][i];
        if( visi[nxt] == false )
            ret += laksi( nxt );
    }
    return ret;
}


int main(){
    freopen("Ulaz.txt","r",stdin);
    int n,m;
    scanf("%d%d",&n,&m);

    for( int i = 0; i < m; ++i ){
        int a,b;
        scanf("%d%d",&a,&b);
        g[a].push_back(b);
        rg[b].push_back(a);
    }

    int sol1 = 0 , sol2 = 0;

    for( int i = 1; i <= n; ++i ){
        memset( visi ,false, sizeof(visi));
        int c = abs( tezi(i) - laksi(i) );

        int cn = 0;
        for( int k = 1; k <= n; ++k ) cn += visi[k] == false;

        cout<<i<<" => "<<c<<" "<<cn<<endl;

        if( c - cn > 0 ) sol1 ++;
        else if( (c+cn)%2 ) sol2++;

    }

    printf("%d %d\n",sol1,sol2);


    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <stack>
#include <string.h>
#include <string>
#include <iomanip>
#include <cstdio>
using namespace std;

int h,w;
char txt[105][105];
int d[][2] = { {1,0} , {-1,0} , {0,1} , {0,-1} , {-1,-1} , {1,1} , {-1,1} , {1,-1} };

bool nom[105][105];
bool pro[105][105];
bool mines[105][105];

int getdx( int r, int c ){ return r * w + c; }

double mat[5005][5005];
map<int,int>m;

int ceq;
int sol[5005];
int equ[5005];


void gaussian(){
    int r = 0;
    for( int c = 0; c < ceq; ++c ){

        int dx = -1;

        for( int i = r; i < ceq && dx == -1 ; ++i )
            if( mat[i][c] != 0 ) dx = i;

        if( dx == -1 ) continue;
        if( r != dx )for( int i = 0; i <= ceq; ++i ) swap( mat[r][i] , mat[dx][i] );


        double div = mat[r][c];
        for( int i = 0; i <= ceq; ++i )
             mat[r][i] /= div;

        for( int i = 0; i < ceq; ++i ){
            if( i == r ) continue;

            double koef = mat[i][c];
            if( fabs(koef) < 0.000001 ) continue;

            for( int j = 0; j <= ceq; ++j ) mat[i][j] -= koef*mat[r][j];
        }

        r++;
    }

    for( int i = 0; i < ceq; ++i ){
        int dx = -1;

        for( int j = 0; j < ceq && dx == -1; ++j ) if( fabs(mat[i][j]) > 0.0000001 ) dx = j;
        sol[dx] = (int)round(mat[i][ceq]);
    }

}


int main(){
    freopen("Ulaz2.txt","r",stdin);
    //freopen("Izlaz2.txt","w",stdout);

    scanf("%d%d",&h,&w);
    for( int i = 0; i < h; ++i )
        scanf("%s",txt[i]);

    bool ok = true;
    while( ok ){
        ok = false;
        for( int i = 0; i < h-1; ++i ){
            for( int j = 0; j < w; ++j ){
                int undef = 0 , cntm = 0;
                for( int k = 0; k < 8; ++k ){
                    int r = i + d[k][0];
                    int c = j + d[k][1];
                    if( r < 0 || c < 0 || r >= h || c >= w ) continue;
                    if( nom[r][c] == false && mines[r][c] == false ) undef ++;
                    else if( mines[r][c] ) cntm ++;
                }

                if( undef == txt[i][j] - '0' - cntm )
              //  cout<<"undef: "<<i<<" "<<j<<" , "<<txt[i][j]<<" , "<<cntm<<" | "<<undef<<endl;
                for( int k = 0; k < 8; ++k ){
                    int r = i + d[k][0];
                    int c = j + d[k][1];
                    if( r < 0 || c < 0 || r >= h || c >= w || mines[r][c] || nom[r][c] ) continue;
                    mines[r][c] = true;
                    ok = true;
                }

                else if( txt[i][j] - '0' - cntm == 0 )
                  //  cout<<i<<" "<<j<<" , "<<txt[i][j]<<" , "<<cntm<<endl;
                for( int k = 0; k < 8; ++k ){
                    int r = i + d[k][0];
                    int c = j + d[k][1];
                    if( r < 0 || c < 0 || r >= h || c >= w || mines[r][c] || nom[r][c] ) continue;
                    nom[r][c] = true;
                    ok = true;
                }
            }
        }

    }
//
    for( int i = 0; i < h; ++i ){
        for( int j = 0; j < w; ++j ){
           if( mines[i][j] ) cout<<"1"; else if( nom[i][j] )cout<<"0";
           else cout<<"?";
        }cout<<endl;
    }cout<<endl;

    int eq = 0;
    int pos = 0;

    int undef = 0;

    for( int i = 0; i < h; ++i ){
        for( int j = 0; j < w; ++j ){
            if( nom[i][j] == false && mines[i][j] == false ){
                undef ++;
                int cnt = txt[i][j] - '0';

                for( int k = 0; k < 8; ++k ){
                    int r = i + d[k][0];
                    int c = j + d[k][1];
                    if( r < 0 || c < 0 || r >= h || c >= w ) continue;
                    if( mines[r][c] ) cnt --;
                    else if( nom[r][c] == false ){
                        int key = getdx( r,c );
                        if( m[key] == 0 ) m[key] = ++pos;

                        mat[eq][ m[key] -1 ] = 1;
                    }
                }
                equ[eq++] = cnt;
            }
        }
    }

    for( int i = 0; i < eq; ++i )
        mat[i][pos] = equ[i];

    ceq = min( eq , pos );

    gaussian();


    for( int i = 0; i < h; ++i ){
        for( int j = 0; j < w; ++j ){
            if( mines[i][j] || (sol[ m[getdx(i,j)] - 1] && m[getdx(i,j)] != 0) )putchar('1');
            else putchar('0');
        }cout<<endl;
    }



    return 0;
}

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <algorithm>
#include <math.h>
#include <fstream>
#include <set>
#include <queue>
#include <string.h>
#include <stack>
using namespace std;

int n;
char d[1005];

void div( int v ){
    int now = 0;
    for( int i = n-1; i >= 0; --i ){
        now = now * 10 + d[i];
        d[i] = now / v;
        now %= v;
    }
    while( n && d[n-1] == 0 ) n--;
}

void add( int v ){
    d[0] += v;
    for( int i = 0; i < n; ++i ){
        if( d[i]/10 && i+1 == n ) n++;
        d[i+1] += d[i]/10;
        d[i] %= 10;
    }
}
void sub( int v ){ // v = [0,10]
    d[0] -= v;
    for( int i = 0; i < n; ++i )
        if( d[i] < 0 ) d[i] += 10 , d[i+1] -= 1;
    while( n && d[n-1] == 0 ) n--;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%s",d);
    n = strlen(d);

    reverse( d , d + n );
    for( int i = 0; i < n; ++i ) d[i] -= '0';

    int sol = 0;

    while( n > 1 ){

        int v = d[1] * 10 + d[0];

        if( v % 4 == 0 ){
            sol += 2;
            div( 4 );
        }else if( v % 2 == 0 ){
            sol ++;
            div( 2 );
        }else if( (v+1)%4 == 0 ){
            sol ++;
            add( 1 );
        }else{
            sol ++;
            sub( 1 );
        }

        //for( int i  = n-1; i >= 0; --i )
        //    cout<<(int)d[i];
        //cout<<" = "<<sol<<endl;
    }
    if( d[0] == 1 ) sol += 1;
    if( d[0] == 2 ) sol += 2;
    if( d[0] == 3 ) sol += 3;
    if( d[0] == 4 ) sol += 3;
    if( d[0] == 5 ) sol += 4;
    if( d[0] == 6 ) sol += 4;
    if( d[0] == 7 ) sol += 5;
    if( d[0] == 8 ) sol += 4;
    if( d[0] == 9 ) sol += 5;

    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <stack>
#include <map>
#include <fstream>
#include <queue>
#include <set>
using namespace std;

inline void readi( int &v ){
    static char c;
    while( (c=getchar()) < '0' || c > '9' );
    v = c - '0';
    while( (c=getchar()) >= '0' && c <= '9' ) v = v * 10 + c - '0';
}

int months[] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 };

inline int getdays( int m ){
    int ret = 0;
    for( int i = 0; i < m - 1; ++i )
        ret += months[i];
    return ret;
}

inline int getinv( int v , int mod ){
    int stp = mod - 2;

    stack< bool > s;
    while( stp ){
        if( stp&1 ) s.push( 0 ) , stp ^= 1;
        else s.push( 1 ) , stp >>= 1;
    }

    int r = 1;
    while( s.empty() == false ){
        int u = s.top(); s.pop();
        if( u ) r = (r*r) % mod;
        else r = (r*v) % mod;
    }

    return r;
}

int n,m;
int mat[305][305];
int pro[305][305];

int mod5[305];
int mod73[305];

bool solve( int *sol , int mod ){

    for( int i = 0; i < n; ++i )
        for( int j = 0; j <= m; ++j )
            pro[i][j] = ( mat[i][j] + 100*mod ) % mod;

    int r = 0, lst = 0;
    for( int c = 0; c < m; ++c ){

        int dx = -1;
        for( int i = r; i < n && dx == -1; ++i )
            if( pro[i][c] != 0 ) dx = i;

        if( dx == -1 ) continue;

        for( int i = 0; i <= m; ++i ) swap( pro[dx][i] , pro[r][i] );

        int div = getinv( pro[r][c] , mod );
        for( int i = 0; i <= m; ++i ) pro[r][i] = ( pro[r][i] * div ) % mod;

        for( int i = 0; i < n; ++i ){
            if ( i == r ) continue;

            int coef = pro[i][c];
            for( int k = 0; k <= m; ++k ){
                pro[i][k] = ( pro[i][k] - coef*pro[r][k] )%mod;
                pro[i][k] += mod;
                pro[i][k] %= mod;
            }
        }

        r++;
        lst = r;
    }

    for( int i = lst; i < n; ++i ) if( pro[i][m] ) return false;

    for( int i = 0; i < m; ++i ){
        int k = 0; for( ; k < m; ++k ) if( pro[i][k] ) break;
        sol[k] = (pro[i][m] + 10*mod ) % mod;
    }

}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    readi(n) , readi(m);

    for( int i = 0; i < n; ++i ){
        int d1,m1,d2,m2;
        readi(d1), readi(m1), readi(d2), readi(m2);

        int s1 = d1 + getdays(m1);
        int s2 = d2 + getdays(m2);

        for( int j = 0; j < m; ++j )
            readi( mat[i][j] );

        mat[i][m] = (s2-s1+20*365)%365;
    }

    bool b1 = solve( mod5 , 5 );
    bool b2 = solve( mod73 , 73 );

    if( b1 == false || b2 == false ){
        printf("-1\n");
        return 0;
    }


    int m1 = 73 * getinv( 73 , 5 );
    int m2 = 5 * getinv( 5 , 73 );


    for( int i = 0; i < m; ++i ) {
        int w = (m1*mod5[i] + m2*mod73[i])%365;
        if( w == 0 ) printf("365\n");
        else printf( "%d\n", w );
    }



    return 0;
}

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <cstdio>
#include <stack>
#include <map>
#include <algorithm>
#include <string.h>
#include <fstream>
#include <iomanip>
using namespace std;

typedef long long ll;

const int xsz = 27*5;
const int mod = 1000000007;
const int summer = 27*5-5;

int n,m;
int dst[255][255];

int mat[xsz][xsz];
int bas[xsz][xsz];
int ras[xsz][xsz];


inline void geta( char &c ){ while( c = getchar() ) if(  (c>='0'&&c<='9') || (c>='a'&&c<='z')  ) break;}

int getidx( char c , int lvl ){
    int dx = c - 'a';
    dx *= 5;
    return dx + lvl;
}

int sol[xsz][xsz];

void mul( int s[xsz][xsz] , int f[xsz][xsz] ){

    for( int i = 0; i < xsz; ++i )
        for( int j = 0; j < xsz; ++j )
            for( int k = 0; k < xsz; ++k )
                sol[i][j] = ( sol[i][j] + s[i][k] * (ll)f[k][j])%mod;

    for( int i = 0; i < xsz; ++i ){
        for( int j = 0; j < xsz; ++j ){
            s[i][j] = sol[i][j];
            sol[i][j] = 0;
        }
    }
}

int main(){

    scanf("%d%d",&n,&m);

    for( int i = 'a'; i <= 'z'; ++i )
        for( int j = 'a'; j <= 'z'; ++j )
            dst[i][j] = 1;

    for( int i = 0; i < m; ++i ){
        char a,b,c;
        geta(a) , geta(b) , geta(c);

        dst[a][b] = c - '0';
        dst[b][a] = c - '0';
    }

    mat[summer][summer] = 1;


    for( int i = 'a'; i <= 'z'; ++i ){
        int s1 = getidx( i , 0 );
        int s2 = getidx( i , 1 );
        int s3 = getidx( i , 2 );
        int s4 = getidx( i , 3 );
        int s5 = getidx( i , 4 );

        mat[s2][s1] = 1;
        mat[s3][s2] = 1;
        mat[s4][s3] = 1;
        mat[s5][s4] = 1;

        bas[0][s1] = 1;
        mat[s1][summer] = 1;
    }

    for( int i = 'a'; i <= 'z'; ++i )
        for( int j = 'a'; j <= 'z'; ++j ){ // edge i -> j
            int x = getidx( i , 0 );
            int y = getidx( j , dst[i][j] - 1 );
            mat[x][y] = 1;
        }

    int sol = 0;

    memcpy( ras , mat , sizeof mat );


    n++;
    stack< bool > stk;
    while( n > 1 ){
        if( n&1 ) stk.push( 0 ) , n --;
        else stk.push( 1 ) , n >>= 1;
    }

    while( stk.empty() == false ){
        int u = stk.top(); stk.pop();
        if( u == 0 )mul( ras , mat );
        else mul( ras , ras );
    }

    mul( bas , ras );


    printf("%d\n",bas[0][summer]);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <math.h>
#include <set>
#include <algorithm>
using namespace std;

const int maxn = 1300000;
const int maxe = 2300000;

struct edge{
    int a,b,c;
    edge(){};
    edge( int p1, int p2, int p3 ):a(p1),b(p2),c(p3){};

    inline bool operator<( const edge &e2 ) const {
        return c < e2.c;
    }
};

int n,m,k;
edge e[maxe];
int id[maxn];
int sz[maxn];

int find( int x ){
    if( x == id[x] ) return x;
    return id[x] = find( id[x] );
}

bool merge( int a, int b ){
    int x = find(a) , y = find(b);

    if( x == y ) return true;

    if( sz[x] < sz[y] )
        id[x] = y, sz[y] += sz[x];
    else
        id[y] = x, sz[x] += sz[y];

    return false;
}


char c;
inline void readi( int &v ){
    while( (c=getchar()) < '0' || c > '9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' )
        v = v*10 + c-'0';
}


int main(){
    freopen("Ulaz.txt","r",stdin);
    for( int i = 0; i <= maxn; ++i ) id[i] = i , sz[i] = 0;

    scanf("%d%d%d",&n,&m,&k);

    for( int i = 0; i < m; ++i ){
        int a,b;
        readi( a );
        readi( b );
        merge(a,b);
    }

    for( int i = 0; i < k; ++i ){
        readi( e[i].a );
        readi( e[i].b );
        readi( e[i].c );
    }

    sort( e , e + k );

    long long sol = 0;

    for( int i = 0; i < k; ++i ){
        bool q = merge( e[i].a , e[i].b );
        if( q == false ) sol += e[i].c;
    }

    cout<< sol <<endl;


    return 0;
}

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <iomanip>
#include <math.h>
#include <queue>
#include <stack>
#include <map>
#include <vector>
using namespace std;

#define priority_queue pq
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

int n,m;
int niz[500005];
int mn[500005] , mx[500005];

int main(){
    scanf("%d%d",&n,&m);

    for( int i = 0; i < n; ++i )
        scanf("%d",&niz[i]);

    mn[0] = niz[0];
    for( int i = 1; i < n; ++i ) mn[i] = min( mn[i-1] , niz[i] );

    mx[n-1] = niz[n-1];
    for( int i = n-2; i >= 0; --i ) mx[i] = max( mx[i+1] , niz[i] );



    int sol = -1000000000;
    for( int i = 0; i <= m; ++i ){
        sol = max( sol , mx[n-m-1+i] - mn[i] );

    }


    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <set>
#include <algorithm>
#include <queue>
#include <iomanip>
#include <stack>
#include <cstdio>
using namespace std;

const int maxn = 50000 + 25;

int n,q;
vector< int > g[maxn];
char isred[maxn];

int cnt_col = 0;

int sz[maxn];
int mark[maxn];
int root[maxn];
int prv[maxn];

vector< int > sub[maxn];


int pre( int node , int dad ){
    int sol = 1;
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( nxt == dad ) continue;

        sol += pre( nxt , node );
    }
    return sz[node] = sol;
}

void hld( int node , int color , int dad ){

    mark[ node ] = color;
    prv[ node ] = dad;
    sub[ color ].push_back( node );

    int mx = -1;


    for( int i = 0; i < g[node].size(); ++i ){
        if( mx == -1 && g[node][i] != dad ) mx = i;
        if( mx > -1 && sz[ g[node][mx] ] < sz[ g[node][i] ] && g[node][i] != dad ) mx = i;
    }

    if( mx != -1 )hld( g[node][mx] , color , node );

    for( int i = 0; i < g[node].size(); ++i )
        if( mx != i && g[node][i] != dad ){
            root[ ++cnt_col ] = g[node][i];
            hld( g[node][i] , cnt_col , node );
        }
}

int mask[maxn];
int *dbit[maxn];

void add( int y, int x , int val ){
    int s = sub[y].size() + 3;
    for( int dx = x + 2; dx <= s; dx += dx & -dx ){
        dbit[y][dx] += val;
    }
}

int read_row( int y, int x ){
    int sol = 0;
    for( int dx = x + 2; dx >= 1; dx -= dx & -dx ){
        sol += dbit[y][dx];
    }
    return sol;
}

void preprocess(){
    for( int i = 0; i <= cnt_col; ++i ){
        int s = sub[i].size();

        dbit[i] = new int[s+10];
        for( int k = 0; k < s; ++k ){
            dbit[i][k] = 0;
            mask[ sub[i][k] ] = k;
        }

        for( int k = s; k < s+10; ++k )
            dbit[i][k] = 0;
    }

    for( int i = 0; i < n; ++i )
        if( isred[i] == '0' )
            add( mark[i] , mask[i] , +1 );
}

void change( int node ){
    int w = 1;
    if( isred[node] == '0' ) w = -1 , isred[node] = '1';
    else isred[node] = '0';

    //cout<<"Change "<<node<<" to "<<isred[node]<<endl;

    add( mark[node] , mask[node] , w );
}

int query( int node , int kth ){
    vector< int > c;
    vector< int > q;

    int now = node;
    while( now != -1 ){
        c.push_back( mark[now] );
        q.push_back( now );

        now = root[ mark[now] ];
        now = prv[now];
    }


    reverse( c.begin() , c.end() );
    reverse( q.begin() , q.end() );

    //for( int i = 0; i < c.size(); ++i )
   //     cout<<" -> "<<c[i]<<" "<<q[i]<<endl;

    int cnt = 0, k = 0;
    while( cnt < kth && k < c.size() ){
        cnt += read_row( c[k] , mask[ q[k] ] );
        //cout<<"Till node: "<<q[k]<<" = "<<cnt<< " ,,, "<<mask[ q[k] ] <<endl;
        ++k;
    }

    if( cnt < kth ) return -2;
    k--;
    cnt -= read_row( c[k] , mask[ q[k] ] );
    //cout<<"NOW: "<<cnt<<endl;

    int lo = 0 , hi = sub[ c[k] ].size() - 1;
    int col = c[k];


    while( lo < hi ){
        int mid = (lo+hi) / 2;

        int add = read_row( col , mask[ sub[col][mid] ] );


        if( cnt + add >= kth ) hi = mid;
        else lo = mid + 1;

    }
    return sub[col][hi];

}


int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d%d",&n,&q);
    scanf("%s",isred);

    for( int i = 0; i < n-1; ++i ){
        int a,b; scanf("%d%d",&a,&b); a-- , b--;
        g[a].push_back( b );
        g[b].push_back( a );
    }

    pre( 0 , -1 );

    hld( 0 , 0 , -1 );
    preprocess();


    for( int i = 0; i < q; ++i ){
        int c,a,b;
        scanf("%d%d",&c,&a);

        if( c == 1 ){
            scanf("%d",&b);
            printf("%d\n",query(b-1,a)+1 );
        }else{
            change(a-1);
        }
    }

    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<cstdlib>
#include<math.h>
#include<iomanip>
#include<stack>
using namespace std;

const int maxn = 100005;

int n,m;
vector<int>graph[maxn ];
bool visited[maxn ];
int low_id[maxn ];
int id[maxn ];
bool in_stack[maxn ];
stack<int>S;

int newn = 0;
int in_group[maxn ];
vector<int>groups[maxn ];
bool not_valid[maxn ];

int scc_counter;
void SCC( int node ){
   visited[node] = low_id[node] = id[node] = scc_counter++;
   S.push(node);
   in_stack[node] = true;
   for( int i=0;i<graph[node].size();i++){
      if( visited[ graph[node][i] ] == false ){
         SCC( graph[node][i] );
         low_id[node] = min( low_id[node],low_id[graph[node][i]] );
      }else if( in_stack[ graph[node][i] ]==true && id[ graph[node][i] ]<id[node] ){
         low_id[node] = min( low_id[node],id[graph[node][i]] );
      }
   }
   if( low_id[node] == id[node] ){
      while( S.empty() == false && id[ S.top() ]>= id[node] ){
         in_stack[S.top()]= false;
         in_group[S.top()] = newn;
         groups[newn].push_back(S.top());
         S.pop();
      }
      newn++;
   }

}

void tarjan(){
   for( int i=1;i<=n;i++){
      if( visited[i] == false )
         SCC(i);
   }
}

int main(){
   int i,j,k,a,b;

      scanf("%d",&n);

      scc_counter = 1 , newn = 0;
      for(i=0;i<=n;i++){
         graph[i].clear();
         groups[i].clear();
         visited[i] = false;
         low_id[i] = id[i] = in_stack[i] = not_valid[i] = in_group[i] =  0;
      }
      scanf("%d",&m);
      for(i=0;i<m;i++){
         scanf("%d%d",&a,&b);
         graph[a].push_back(b);
      }
      tarjan();

      for(i=0;i<newn;i++)
         if( not_valid[ i ] == false )
            for(j=0;j<groups[i].size() && !not_valid[i] ;j++)
               for(k=0;k<graph[ groups[i][j] ].size() && !not_valid[i];k++)
                  if( in_group[ graph[groups[i][j]][k] ] != i )
                     not_valid[i] = true;

      int sol = 0;
       for(i=1;i<=n;i++)
         if( not_valid[ in_group[i] ] == false)
            sol ++;

        printf("%d\n",sol);

      for(i=1;i<=n;i++)
         if( not_valid[ in_group[i] ] == false)
            printf("%d ",i);
      printf("\n");


   return 0;
}


#include <iostream>
#include <vector>
#include <cstdio>
#include <stack>
#include <map>
#include <fstream>
#include <set>
using namespace std;

string s1[20] , s2[20];
int g1[20] , g2[20];

map<string,int>m;

int main(){
  //  freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    while( tests -- ){

        m.clear();

        for( int i = 0; i < 16; ++i ){
            cin >> s1[i];
            cin >> s2[i];
            scanf("%d%d",&g1[i],&g2[i]);

            if( g1[i] > g2[i] ) m[ s1[i] ] ++;
            else if( g1[i] < g2[i] ) m[ s2[i] ] ++;
        }

        string w = s1[0];
        for( int i = 0; i < 16; ++i ){
            if( m[ s1[i] ] > m[ w ]  ) w = s1[i];
            if( m[ s2[i] ] > m[ w ]  ) w = s2[i];
        }

        cout<<w<<endl;

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
#include <algorithm>
#include <map>
#include <iomanip>
#include <cstdio>
using namespace std;

int n;
double mat[20][20];

double sol[1<<18];

int bipc[1<<18];

int dx[20];

void solve( int mask , double p ){
    sol[mask] += p;

    for( int L = mask; L >= 0; --L ){

        int cnt = 0 , sz = 0;
        for( int i = 0; i < n; ++i ) if( L&(1<<i) )cnt ++ , dx[sz++] = i;


        for( int i = 0; i < sz; ++i ){
            int f = dx[i];
            if( ~L&(1<<f) )continue;

            for( int j = 0; j < sz; ++j ){
                int s = dx[j];
                if( ~L&(1<<s) )continue;
                if( f == s ) continue;

                sol[ L^(1<<s) ] += sol[L] * mat[f][s] * 2.00/(cnt*(cnt-1));
            }
        }
    }
}

int main(){
   // for( int i = 0; i < (1<<18); ++i )
   //     bipc[i] = __builtin_popcount(i);
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i )
        for( int j = 0; j < n; ++j )
            scanf("%lf",&mat[i][j]);

    solve( (1<<n)-1 , 1 );
    for( int i = 0; i < n; ++i )
        printf("%.6lf ",sol[1<<i]);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <map>
#include <algorithm>
#include <stack>
#include <iomanip>
#include <set>
#include <cstdio>
#include <string>
#include <string.h>
using namespace std;

int n;
set< int > s;

int main(){

    scanf("%d",&n);
    for( int  i = 0; i < n; ++i ){
        int v;
        scanf("%d",&v);
        s.insert(v);
    }

    if( s.size() > 1 ){
        set< int > :: iterator it = s.begin();
        it++;
        cout<<(*it)<<endl;
    }else
        cout<<"NO"<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <stack>
#include <string.h>
#include <cstdio>
#include <algorithm>
using namespace std;

int n;
string nam[1000];
map<string,int>m;

int points[1000];
int goals[1000];
int missed[1000];

string getname(){
    char c;
    while( c = getchar() )
        if( (c>='a' && c <='z') || (c>='A' && c <= 'Z') )break;

    string w = string(1,c);
    while( c = getchar() )
        if( (c>='a' && c <='z') || (c>='A' && c <= 'Z') ) w += string(1,c);
        else break;
    return w;
}

int readi(){
    char c;
    while( (c=getchar())<'0' || c > '9');
    int v = c - '0';
    while( (c=getchar())>='0' && c <= '9' )
        v = v * 10 + c - '0';
    return v;
}

struct team{
    string name;
    int c1,c2,c3;
    const bool operator<( const team &t ) const {
        if( c1 < t.c1 ) return true;
        else if( c1 == t.c1 ){
            if( c2 < t.c2 ) return true;
            else if( c2 == t.c2 ) return c3 < t.c3;
        }
        return false;
    }
};

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        cin >> nam[i];
        m[ nam[i] ] = i;
    }

    for( int i = 0; i < (n*(n-1)/2); ++i ){
        string s1 = getname();
        string s2 = getname();

        int c1,c2;
        c1 = readi();
        c2 = readi();

        int h1 = m[s1];
        int h2 = m[s2];

        if( c1 > c2 ) points[h1] += 3;
        else if( c1 < c2 ) points[h2] += 3;
        else points[h1] ++ , points[h2] ++;

        goals[h1] += c1;
        goals[h2] += c2;

        missed[h1] += c2;
        missed[h2] += c1;
    }

    vector< team > t;

    for( int i = 0; i < n; ++i ){
        team q;
        q.name = nam[i];
        q.c1 = points[i];
        q.c2 = ( goals[i] - missed[i] );
        q.c3 = goals[i];

        t.push_back( q );
    }

    sort( t.begin() , t.end() );
    reverse( t.begin() , t.end() );

    vector< string > sol;

    for( int i = 0; i < t.size() / 2; ++i ){
        sol.push_back( t[i].name );
    }
    sort( sol.begin() , sol.end() );

    for( int i = 0; i < sol.size(); ++i )
        cout<<sol[i]<<endl;


    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <algorithm>
#include <set>
#include <stack>
#include <algorithm>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

int n,m;
char mx[1005][1005];
int hig[1005][1005];

int L[1005] , R[1005];


int main(){
    //freopen("Ulaz.txt","r",stdin);

        scanf("%d%d",&n,&m);

        char c;
        for( int i = 0; i < n; ++i ){
            for( int j = 0; j < m; ++j ){
                while( c = getchar() )
                    if( c == '0' || c == '1' ) break;
                mx[i][j] = c;
            }
        }

        for( int i = 0; i < m; ++i ){
            int cnt = 1;
            for( int j = 0; j < n; ++j ){
                if( mx[j][i] == '1' )cnt = 0;
                hig[j][i] = cnt++;
            }
        }

        int sol = 0;
        for( int i = 0; i < n; ++i ){

            stack< pii > stk;
            stk.push( mk( 0 , -1 ) );
            for( int k = 0; k < m; ++k ){
                while( stk.empty() == false && stk.top().f >= hig[i][k] ) stk.pop();
                if( stk.empty() == false )L[k] = stk.top().s+1;
                else L[k] = k;
                stk.push( mk( hig[i][k] , k ) );
            }
            while( stk.empty() == false ) stk.pop();

            stk.push( mk( 0 , m ) );
            for( int k = m-1; k >= 0; --k ){

                while( stk.empty() == false && stk.top().f >= hig[i][k] ) stk.pop();
                if( stk.empty() == false )R[k] = stk.top().s-1;
                else R[k] = k;
                stk.push( mk( hig[i][k] , k ) );
            }

            for( int k = 0; k < m; ++k )
                sol = max( sol , ( R[k] - L[k] + 1 )*2 +  hig[i][k]*2 );

        }
        printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <map>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <algorithm>
#include <string.h>
#include <cstdio>
using namespace std;

typedef long long ll;

const int maxn = 5050;
const ll inf = 9999999999999999LL;

struct item{
    int t,c;
    item(){};
    item( int p1, int p2 ):t(p1),c(p2){};
};

int n;
vector< item > v;
ll ss[maxn];

ll dp[2000+50][maxn+50];

ll solve( int dx , int time ){

    if( time > n )
        return ss[dx];

    if( dx == n ){
        if( time >= 0 ) return 0;
        else return -inf;
    }

    ll &ref = dp[dx][time+2500];
    if( ref != -1 ) return ref;

    ll sol = solve( dx + 1 , time - 1 ) + v[dx].c;
    sol = max( sol , solve( dx + 1 , time + v[dx].t ) );


    return  ref = sol;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    ll sum = 0;
    memset( dp , -1, sizeof(dp));

    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        v.push_back( item(a,b) );
        sum += b;
    }

    for( int i = n-1; i >= 0; --i )
        ss[i] = ss[i+1] + v[i].c;



    cout<<sum - solve(0,0)<<endl;;


    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <math.h>
#include <string.h>
#include <string>
#include <algorithm>
#include <stack>
#include <set>
#include <queue>
#include <map>
#include <cstdio>
using namespace std;


const int maxn = 100000;
const int prime = 87383;
const int uniq = -1;
const int mod = 1000000;


int n;
int stp[maxn+50];
int v[maxn+50];
int dp[maxn+50][16];

inline int geteq( int dxa , int dxb ){
    int L = 0;
    while( 1 ){
        if( dp[dxa][0] != dp[dxb][0] || dxa >= n || dxb >= n ) return L;

        int sol = -1;

        for( int i = 0; i < 16 && sol == -1; ++i )
            if( dp[dxa][i] != dp[dxb][i] ) sol = i - 1;

        L += 1 << sol;
        dxa += 1 << sol;
        dxb += 1 << sol;
    }
    return L;
}

inline int readi(){
    char c;
    while( (c=getchar())<'0' || c > '9');
    int v = c - '0';
    while( (c=getchar())>='0' && c <= '9' )
        v = v * 10 + c - '0';
    return v;
}

int orig[maxn+50];
map< int , int > m;
vector< int > pos[maxn+50];

int main(){
   // freopen("Ulaz.txt","r",stdin);

    stp[0] = 1;
    for( int i = 1; i <= maxn; ++i ) stp[i] = (stp[i-1] * prime)%mod;

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        v[i] = readi();

        orig[i] = v[i];

        if( m[v[i]] == 0 ) m[ v[i] ] = i + 1;
        v[i] = m[v[i]] - 1;

        pos[v[i]].push_back( i );
    }

    int f = 0;
    int r = 0;
    for( int i = 0; i < n; ++i ){
        r = (r*prime + v[i])%mod;
        if( i + 1 == (1<<f) )dp[0][f] = r , f++;
    }

    for( int i = 1; i < n; ++i ){
        for( int L = 0; L < 16; ++L ){
            if( i + (1<<L) > n ){
                dp[i][L] = uniq;
                continue;
            }
            int h = dp[i-1][L];
            h -= (v[i-1]*stp[(1<<L)-1])%mod;

            h %= mod;
            h += 2*mod;
            h %= mod;

            h = (h*prime)%mod;
            h = (h+v[i+(1<<L)-1])%mod;
            dp[i][L] = h;
        }
    }

    int sdx = 0;

    for( int i = 0; i < n; ++i ){
        int w = v[i];
        for( int j = 0; j < pos[w].size(); ++j ){
            if( pos[w][j] <= i ) continue;

            int sz = geteq( i , pos[w][j] );
            if( i + sz >= pos[w][j] ) sdx = i + sz;

        }
    }

    printf("%d\n",n-sdx);

    for( int k = sdx; k < n; ++k )
        printf("%d ",orig[k]);
    putchar('\n');



    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <map>
#include <algorithm>
#include <stack>
#include <iomanip>
#include <set>
#include <cstdio>
#include <string>
#include <string.h>
using namespace std;

#define pii pair<int,int>
#define mk make_pair
#define f first
#define s second

int n,m,v;
vector< pii > sol;

vector< int > w;
bool used[100005];

int main(){
    scanf("%d%d%d",&n,&m,&v);

    if( n == 1 || n == 2 ){
        printf("-1\n");
        return 0;
    }

    if( v == 1 ) w.push_back( 2 ) , w.push_back( 1 ) , used[2] = used[1] = true;
    else  w.push_back( 1 ) , w.push_back( v ) , used[1] = used[v] = true;

    for( int i = 1; i <= n; ++i ) if( used[i] == false ) w.push_back( i );

    for( int i = 0; i < n - 1; ++i )
        sol.push_back( mk(w[i] , w[i+1]) ) , m--;



    for( int i = 1; i < n && m > 0; ++i ){
        for( int j = i+2; j < n && m > 0; ++j ){

            sol.push_back( mk(w[i],w[j]) );
            m--;
        }
    }


    if( m ){
        printf("-1\n");
        return 0;
    }

    for( int i = 0; i < sol.size(); ++i )
        printf("%d %d\n",sol[i].f,sol[i].s);



    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <map>
#include <algorithm>
#include <stack>
#include <iomanip>
#include <set>
#include <cstdio>
#include <string>
#include <string.h>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxc = 10000;

int n;
vector< pii > w;

vector< int > open[maxc*3];
vector< int > close[maxc*3];
bool nailed[1005];

int main(){
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        a += maxc;
        b += maxc;
        if( a > b ) swap(a,b);
        open[a].push_back( i );
        close[b].push_back( i );
    }

    vector< int > inq;
    vector< int > sol;

    for( int i = 0; i <= (maxc<<1); ++i ){
        for( int j = 0; j < open[i].size(); ++j ) inq.push_back( open[i][j] );

        for( int j = 0; j < close[i].size(); ++j ){
            int z = close[i][j];
            if( nailed[z] )continue;

            sol.push_back(i-maxc);
            for( int k = 0; k < inq.size(); ++k ) nailed[ inq[k] ] = true;
            inq.clear();
            break;
        }
    }

    printf("%d\n",sol.size());
    for( int i = 0; i < sol.size(); ++i )printf("%d ",sol[i] );

    return 0;
}

#include <iostream>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <vector>
#include <map>
#include <algorithm>
#include <string.h>
#include <set>
#include <iomanip>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define y first
#define x second
#define mk make_pair

const int inf = 999999;

int d[][2] = { {1,0} , {-1,0} , {0,1} , {0,-1} };

int sol1,sol2;
int h,w,k;
char mx[100][100];

pii beg;
vector< pii > ks;
bool visi[55][55];
int dst[55][55];

int man( pii a , pii b ){
    if( b.x == inf ) return inf;

    for( int i = 0; i < 55; ++i )
        for( int j = 0; j < 55; ++j )
            dst[i][j] = inf;

    dst[a.y][a.x] = 0;
    queue< pii > q;
    q.push(a);

    while( !q.empty() ){
        pii u = q.front(); q.pop();

        for( int i = 0; i < 4; ++i ){
            int x = u.x + d[i][0];
            int y = u.y + d[i][1];

            if( x < 0 || y < 0 || x >= w || y >= h ) continue;
            if( mx[y][x] == 'V' ) continue;

            if( dst[y][x] != inf ) continue;
            dst[y][x] = dst[u.y][u.x] + 1;
            q.push( mk(y,x) );
        }
    }

    return dst[b.y][b.x];
}


int main(){
  //  freopen("Ulaz.txt","r",stdin);
    scanf("%d%d%d",&h,&w,&k);

    for( int i = 0; i < h; ++i ){
        for( int j = 0; j < w; ++j ){
            char c;
            while( c=getchar() )
                if( c == 'D' || c == 'V' || c == 'K' || c == '.' ) break;
            mx[i][j] = c;
            if( c == 'K' ){
                sol1 ++;
                ks.push_back( mk(i,j) );
            }else if( c == 'D' )
                beg = mk(i,j);
        }
    }
    visi[ beg.y ][ beg.x ] = true;
    pii now = beg;
    int cnt = 0;

    while( cnt != sol1 ){
        pii nxt = mk(inf,inf);

        for( int i = 0; i < sol1; ++i ){
            if( visi[ ks[i].y ][ ks[i].x ] ) continue;

            int d = man( now , ks[i] );
            int p = man( now , nxt );

            if( d < p ) nxt = ks[i];
        }

        sol2 += man( now , nxt );
        now = nxt;
        visi[ nxt.y ][ nxt.x ] = true;
        cnt ++;
    }

    printf("%d %d\n",sol1,sol2);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <iomanip>
using namespace std;

int mx[25][25];
const int n = 20 , m = 20;
int sol = 0;

int main(){
    freopen("Ulaz.txt","r",stdin);

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < m; ++j ){
            cin >> mx[i][j];
            cout<<setw(3)<<mx[i][j];
        }cout<<endl;
    }


    for( int i = 0; i < n; ++i )
        for( int j = 0; j < m - 3; ++j )
            sol = max( sol , mx[i][j] * mx[i][j+1] * mx[i][j+2] * mx[i][j+3] );

    for( int i = 0; i < n-3; ++i )
        for( int j = 0; j < m; ++j )
            sol = max( sol , mx[i][j] * mx[i+1][j] * mx[i+2][j] * mx[i+3][j] );


    for( int i = 0; i < n-3; ++i )
        for( int j = 0; j < m-3; ++j )
            sol = max( sol , mx[i][j] * mx[i+1][j+1] * mx[i+2][j+2] * mx[i+3][j+3] );

    for( int i = 0; i < n-3; ++i )
        for( int j = 3; j < m; ++j )
            sol = max( sol , mx[i][j] * mx[i+1][j-1] * mx[i+2][j-2] * mx[i+3][j-3] );


    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <iomanip>
using namespace std;

typedef long long ll;

int divs( ll v ){

    int sol = 1;

    for( int i = 2; i*(ll)i < v; ++i ){
        int e = 0;
        while( v % i == 0 )
            e ++ , v /= i;

        sol = sol * (e+1);
    }
    if( v > 1 ) sol *= 2;

    return sol;
}

int main(){

    ll v = 0;

    for( int i = 1; i < 100000  ; ++i ){
        v += i;

        //cout<<v<<" "<<divs(v)<<endl;

        if( divs(v) > 500 ){
            cout<<v<<endl;
            break;
        }
    }

    return 0;
}

#include <iostream>
#include <math.h>
#include <set>
#include <vector>
#include <queue>
#include <iomanip>
#include <map>
using namespace std;

typedef long long ll;

const int maxn = 10000005;

int dp[maxn];

int f( ll n ){
  //  printf("%d\n",n);
    if( n < maxn && dp[n] != -1 ) return dp[n];

    int sol = -1;

    if( n == 1 ) sol = 1;
    else if( n % 2 == 0 )sol = f( n / 2 ) + 1;
    else sol = f( 3 * n + 1 ) + 1;

    if( n < maxn ) dp[n] = sol;
    return sol;
}

int main(){
    memset( dp , -1, sizeof(dp));

    int sol = 1 , len = 1;

    for( int i = 2; i < 1000000; ++i ){
        int ln = f( i );
        if( ln > len ) sol = i , len = ln;
    }
    cout<<sol<<endl;


    return 0;
}

#include <iostream>
#include <string.h>
using namespace std;





char num[] = {
"1071508607186267320948425049060001810561404811705533607443750388370351\
0511249361224931983788156958581275946729175531468251871452856923140435\
9845775746985748039345677748242309854210746050623711418779541821530464\
7498358194126739876755916554394607706291457119647768654216766042983165\
2624386837205668069376\0"
};


int main(){

    int sol = 0;
    for( int i = 0; i < strlen(num); ++i )
        sol += num[i] - '0';

    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <string.h>
#include <iomanip>
using namespace std;

string f1[] = { "one" , "two" , "three" , "four" , "five" , "six" , "seven" , "eight" , "nine" };
string fs[] = { "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen" , "seventeen","eighteen","nineteen"};
string f2[] = { "ten", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety", };

string f3 = "hundred";

string get( int v ){
    if( v == 1000 ) return "onethousand";

    if( v >= 1 && v <= 9 )return f1[v-1];
    if( v == 10 ) return f2[0];
    if( v >= 11 && v <= 19 ) return fs[v-11];

    string ret = "";

    int cnt = 0;

    while( v >= 100 ){
        cnt ++;
        v -= 100;
    }

    if( cnt ){
        ret = f1[cnt-1];
        ret = ret + f3;

        if( v ) ret += "and";
    }

    cnt = 0;
    while( v >= 10 ){
        cnt ++;
        v -= 10;
    }

    if( cnt == 1 ){
        if( v == 0 ) ret += f2[0];
        else ret += fs[v-1];
        return ret;
    }else if( cnt ){
         ret += f2[cnt-1];
         if( v )ret += f1[v-1];
         return ret;
    }else{
        if( v ) ret += f1[v-1];
        return ret;
    }
}


int main(){
    int sol = 0;
    for( int i = 1; i <= 1000; ++i )
        sol += get(i).size();

    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <set>
#include <string.h>
#include <iomanip>
#include <stack>
using namespace std;

int n;
int mx[105][105];
int dp[105][105];

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int i = 1; i <= n; ++i )
        for( int j = 1; j <= i; ++j )
            scanf("%d",&mx[i][j]);

    int sol = 0;

    for( int i = 1; i <= n; ++i ){
        for( int j = 1; j <= i; ++j ){
            dp[i][j] = max( dp[i-1][j] + mx[i][j]   , dp[i][j] );
            dp[i][j] = max( dp[i-1][j-1] + mx[i][j] , dp[i][j] );

            sol = max( sol , dp[i][j] );
        }
    }

    printf("%d\n",sol);


    return 0;
}

#include <iostream>
using namespace std;

char s[] = {"9332621544394415268169923885626670049071596826438162146859296389521759\
9993229915608941463976156518286253697920827223758251185210916864000000\
000000000000000000\0"};

int main(){
    int sol = 0;
    for( int i = 0; i < strlen(s); ++i )
        sol += s[i] - '0';
    cout<<sol<<endl;
    return 0;
}

#include <iostream>
#include <cstdio>
using namespace std;

typedef long long ll;

int main(){

    ll v = 600851475143LL;
    ll sol = 1;

    for( int i = 2; i*i <= v; ++i ){

        while( v % i == 0 ){
             v /= i;
             sol = i;
        }
    }
    sol = max( sol , v );
    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;

typedef long long ll;

bool isok( int v ){
    vector< int > q;
    while( v ){
        q.push_back( v % 10 );
        v /= 10;
    }

    int n = q.size();

    for( int i = 0; i < n; ++i )
        if( q[i] != q[ n - i - 1 ] ) return false;
    return true;
}

int main(){
    ll sol = 0;

    for( ll i = 0; i < 1000; ++i ){
        for( ll k = 0; k < 1000; ++k ){
            if( isok(i*k) )
                sol = max( sol , i*k );
        }
    }
    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
using namespace std;

typedef long long ll;

int fac[20];
int cnt[20];

bool isok(){
    for( int i = 1; i <= 20; ++i ){
        memset( cnt , 0 , sizeof(cnt));

        int d = i;
        for( int k = 2; k <= d; ++k )
            while( d%k == 0 )
                d /= k , cnt[k] ++;

        for( int i = 1; i <= 20; ++i )
            if( fac[i] < cnt[i] ) return false;
    }

    return true;
}

int main(){

    ll v = 1;
    for( int i = 2; i <= 20; ++i ){
         v *= i;


         int d = i;
         for( int k = 2; k <= d; ++k )
            while( d % k == 0 )
                d /= k, fac[k] ++;
    }
    cout<<isok()<<endl;

    bool chg = true;

    while( chg ){
        chg = false;

        for( int i = 2; i <= 20; ++i ){
            if( fac[i] ){
                fac[i] --;
                if( isok() ) chg = true;
                else fac[i] ++;
            }
        }
    }

    for( int i = 1; i <= 20; ++i )
        cout<<fac[i]<<" ";cout<<endl;

    ll sol = 1;
    for( int i = 1; i <= 20; ++i )
        for( int j = 0; j < fac[i]; ++j )
            sol *= i;

    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
using namespace std;

typedef long long ll ;

int main(){
    ll s1 = 0;
    ll s2 = 0;


    for( int i = 1; i <= 100; ++i ){
        s1 += i*i;
        s2 += i;
    }
    s2 *= s2;

    cout<<abs(s1-s2);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
using namespace std;

typedef long long ll ;

bool isprime( int v ){
    if( v != 2 && v % 2 == 0 ) return false;

    for( int i = 3; i*i <= v; i+= 2 )
        if( v % i == 0 ) return false;
    return true;
}

int main(){

    int cnt = 0;

    for( int i = 2; i <= 1000000; ++i )
        if( isprime(i) ){
            cnt ++;
            if( cnt == 10001 ){
                cout<<i<<endl;
                break;
            }
        }



    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
using namespace std;

typedef long long ll;

char txt[] = { "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450" };



int main(){
    ll v = 0;

    for( int i = 0; i < strlen(txt)-5; ++i ){
        ll sol = 1;
        for( int k = 0; k < 5; ++k )
            sol = sol * (txt[i+k]-'0');
        v = max( v , sol );
    }
    cout<<v<<endl;



    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
using namespace std;

typedef long long ll;


int main(){

    for( int i = 1; i <= 1000; ++i ){
        for( int j = 1; j <= 1000; ++j ){
            int c = i*i + j*j;

            int rc = round( sqrt(c) );

            if( i + j + rc == 1000 && fabs( rc - sqrt(c) ) < 0.000001  ){
                cout<<i<<" "<<j<<" "<<rc<<" , "<<c<<endl;
                cout<<"SOL: "<<i*j*rc<<endl;
            }
        }
    }



    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <map>
#include <set>
#include <queue>
#include <algorithm>
using namespace std;

const int maxn = 100000000;
const int maxsq = 10000;
const int maxp = 5762000;


vector< int > primes;
bool siv[maxn+5];
int ps[maxp] , sz = 0;

int main(){

    int n;
    for( int x = 1; x <= maxsq; ++x ){
        for( int y = 1; y <= maxsq; ++y ){
            n = ((x*x)<<2) + y*y;
            if( n <= maxn && ( n%12 == 1 || n%12 == 5 ) )
                siv[n] = !siv[n];

            n = 3*x*x + y*y;
            if( n <= maxn && n%12 == 7 )
                siv[n] = !siv[n];

            n = 3*x*x - y*y;
            if( n <= maxn && x > y && n%12 == 11 )
                siv[n] = !siv[n];
        }
    }

    for( int i = 5; i <= maxsq; ++i ){
        if( siv[i] )
            for( int k = i*i; k <= maxn; k += i*i )
                siv[k] = false;
    }

    ps[sz++] = 2;
    ps[sz++] = 3;

    for( int i = 5; i <= maxn; ++i )
        if( siv[i] == true )
            ps[sz++] = i;


    int x;
    while( scanf("%d",&x) ){
        if( x == 0 ) break;

        double q = x / log(x);
        int cnt = upper_bound( ps , ps + sz , x ) - ps;

        printf("%.1lf\n",100*(fabs(cnt-q)/cnt) );
    }



    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
using namespace std;

#define f first
#define s second
#define mk make_pair

int n,m;
vector< int > g[1005];
bool non[1005][1005];

bool visi[1005];

int f,s;

void dfs( int node , bool bugg = 0 ){

    if( node != s || bugg  ){
        visi[node] = true;
        non[f][node] = true;
    }

    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( visi[nxt] == false ) dfs( nxt , 1);
    }

}

vector< pair<int,int> > e;

int main(){
    scanf("%d%d",&n,&m);

    for( int i = 0; i < m; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        g[a].push_back(b);
        e.push_back( mk(a,b) );
    }

    for( int i = 1; i <= n; ++i ){
        memset( visi , false , sizeof(visi));

        for( int j = 0; j < g[i].size(); ++j ){
            f = i , s = g[i][j];
            dfs( s );
        }
    }

    int cnt = 0;
    for( int i = 0; i < e.size(); ++i ){
        if( non[ e[i].f ][ e[i].s ] == false )
            cnt++;
    }

    printf("%d\n",cnt);

    for( int i = 0; i < e.size(); ++i ){
        if( non[ e[i].f ][ e[i].s ] == false )
            printf("%d %d\n",e[i].f,e[i].s);
    }


    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <map>
#include <fstream>
#include <queue>
using namespace std;

#define f first
#define s second
#define mk make_pair

int n;
vector< pair<int,int> >e;

int main(){
   // freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        scanf("%d",&n);
        e.clear();

        for( int i = 0; i < n; ++i ){
            int a,b; scanf("%d%d",&a,&b);
            e.push_back( mk(a,0) );
            e.push_back( mk(b,1) );
        }

        sort( e.begin() , e.end() );

        int cnt = 0, sol = 0;

        for( int i = 0; i < e.size(); ++i ){
            if( !e[i].s ) cnt++;
            else cnt--;
            sol = max( sol , cnt );
        }

        printf("%d\n",sol);

    }

    return 0;
}

#include <iostream>
#include <fstream>
#include <stack>
#include <map>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
#include <queue>
#include <string>
#include <string.h>
using namespace std;

typedef long long ll;

const int mod = 100000;

int n;
char txt[300];
int dp[205][205];

bool over = false;

int solve( int lo , int hi ){
    if( lo >= hi ) return 1;

    int &ref = dp[lo][hi];
    if( ref != -1 ) return ref;

    ref = 0;

    if( txt[lo] == ')' || txt[lo] == ']' || txt[lo] == '}' ) return 0;

    for( int close = lo + 1; close <= hi; close += 2 ){
        if( txt[close] == '(' || txt[close] == '[' || txt[close] == '{' ) continue;
        if( txt[close] == ')' && txt[lo] != '(' && txt[lo] != '?' ) continue;
        if( txt[close] == ']' && txt[lo] != '[' && txt[lo] != '?' ) continue;
        if( txt[close] == '}' && txt[lo] != '{' && txt[lo] != '?' ) continue;

        int add = ( solve( lo + 1 , close - 1 ) * (ll)solve( close + 1 , hi ) ) %mod;

        if( txt[close] == '?' && txt[lo] == '?' ) add *= 3;

        ref = (ref+add);
        if( ref >= mod ) over = true;
        ref = ref%mod;
    }
    return ref;
}

int main(){
  //freopen("Ulaz.txt","r",stdin);
    scanf("%d%s",&n,txt);

    memset( dp , -1 , sizeof(dp));
    int sol = solve( 0 , n - 1);

    if( over == false )
        printf("%d\n",sol);
    else
        printf("%.5d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <map>
#include <cstdio>
#include <string>
#include <string.h>
#include <iomanip>
using namespace std;

typedef long long ll;

const int mod = 1000000007;

int n,s;
int c[105];

int dp[3000][3000];

int solve( int state, int rem ){
    if( state < 0 ) return 0;
    if( rem == 0 ) return state == 0;

    int &ref = dp[state][rem];
    if( ref != -1 ) return ref;

    return ref = (solve( state - 1 , rem - 1 ) + solve( state + 1 , rem - 1 ))%mod;
}

inline int getinv( int v , int mod ){
    int stp = mod - 2;

    stack< bool > s;
    while( stp ){
        if( stp&1 ) s.push( 0 ) , stp ^= 1;
        else s.push( 1 ) , stp >>= 1;
    }

    int r = 1;
    while( s.empty() == false ){
        int u = s.top(); s.pop();
        if( u ) r = (r*(ll)r) % mod;
        else r = (r*(ll)v) % mod;
    }

    return r;
}

int C( int n ){
    int f = 1;
    for( int i = 2; i <= 2*n; ++i ) f = (f*(ll)i)%mod;

    int d = 1;
    for( int i = 2; i <= n; ++i )
        d = (((d*(ll)i)%mod)*i)%mod;

    d = (d*(ll)(n+1))%mod;

    return (f*(ll)getinv(d,mod))%mod;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        s = 0;

        scanf("%d",&n);
        for( int i = 0; i < n; ++i ) scanf("%d",&c[i]) , s += c[i];

        int sol = C( s ) , f = 1;


        for( int i = 2; i <= s; ++i ) f = (f*(ll)i)%mod;
        for( int i = 0; i < n; ++i ){
            int q = 1;
            for( int k = 2; k <= c[i]; ++k ) q = (q*(ll)k)%mod;

            f = (f*(ll)getinv(q,mod))%mod;
        }
        cout<<(sol*(ll)f)%mod<<endl;

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <algorithm>
#include <stack>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 200055;

bool mins;
char c;
inline bool readi( int &v ){
    mins = false;
    while( (c=getchar())<'0' || c > '9' ) if( c == '-' )break; else if( c == EOF ) return false;

    if( c != '-' )v = c - '0';
    else v = 0 , mins = true;

    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
    if( mins ) v *= -1;
    return true;
}

int n,n2;
int range[maxn][2];
int v[maxn<<1],sz;
int dx[maxn],xz;
int bit[maxn<<1];
int sol[maxn];

inline bool cmp( int a , int b ){ return range[a][0] < range[b][0] || ( range[a][0] == range[b][0] && range[a][1] > range[b][1] ); }


inline int query( int dx ){
    int r = 0;
    for( dx += 2; dx >= 1; dx -= dx & -dx )
        r += bit[dx];
    return r;
}

inline int add( int dx ){
    for( dx += 2; dx <= n2; dx += dx & -dx )
        bit[dx] ++;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    while( readi(n) ){ sz = 0 , xz = 0 , n2 = 0;

        for( int i = 0; i < n; ++i ){
            readi( range[i][0] ) , readi( range[i][1] );
            v[sz++] = range[i][0];
            v[sz++] = range[i][1];
            dx[xz++] = i;
        }

        sort( v , v + sz );

        for( int i = 0; i < n; ++i ){
            bit[i] = 0;
            range[i][0] = lower_bound( v , v + sz , range[i][0] ) - v;
            range[i][1] = lower_bound( v , v + sz , range[i][1] ) - v;
            if( range[i][0] > n2 ) n2 = range[i][0];
            if( range[i][1] > n2 ) n2 = range[i][1];
        }
        for( int i = n; i <= n2+50; ++i ) bit[i] = 0;

        sort( dx , dx + xz , cmp );


        for( int i = 0; i < n; ++i ){
            int mins = 0;
            int k = i-1;
            while( k>=0&&range[dx[k]][0]==range[dx[i]][0]&&range[dx[k]][1]==range[dx[i]][1])k--,mins++;

            int q = query( (n2-range[ dx[i] ][1]) ) - mins;
            add( n2-range[ dx[i] ][1] );
            sol[dx[i]] = q;
        }

        for( int i = 0; i < n; ++i ){
            if( i ) printf(" ");
            printf("%d",sol[i]);
        }
        putchar('\n');
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <algorithm>
#include <stack>
#include <string>
#include <string.h>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

vector< pii > v;

int main(){
    freopen("Ulaz.txt","r",stdin);
    FILE *out = fopen("Izlaz2.txt","w");
    int n,T=0;

    while( scanf("%d",&n) == 1 ){
        printf("DONE: %d\n",T++);
        v.clear();

    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        v.push_back(mk(a,b));
    }

    for( int i = 0; i < n; ++i ){
        int sol = 0;
        for( int j = 0; j < n; ++j ){
            if( i == j ) continue;
            if( v[i].f == v[j].f && v[i].s == v[j].s ) continue;
            if( v[j].f <= v[i].f && v[i].s <= v[j].s ) sol ++;
        }
        fprintf(out,"%d ",sol);
    }fprintf(out,"\n");


    }
    return 0;
}

#include <iostream>
#include <fstream>
#include <cstdlib>
#include <stack>
#include <map>
#include <algorithm>
#include <set>
using namespace std;


inline void readi( int &v ){
    char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
}




int dp[2005][2005];
int f[2005] , s[2005];

inline int readseq( int *f ){
    int v, sz = 0;
    while( 1 ){
        readi(v); if( v == 0 ) break;
        f[sz++] = v;
    }
    return sz;
}

int len1,len2;


int solve(){

    for( int i = 1; i <= len1; ++i ){
        for( int j = 1; j <= len2; ++j ){
            if( f[i-1] == s[j-1] ) dp[i][j] = dp[i-1][j-1] + 1;
            else dp[i][j] = max( dp[i-1][j] , dp[i][j-1] );
        }
    }
    return dp[len1][len2];
}


int main(){
    freopen("Ulaz.txt","r",stdin);
    int tests;
    readi( tests );

    while( tests -- ){

        len1 = readseq( f );

        int sol = 0;

        while( 1 ){
            len2 = readseq( s );
            if( len2 == 0 ) break;

            sol = max( sol , solve() );
        }

        printf("%d\n",sol);

    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <math.h>
#include <cstdlib>
#include <vector>
#include <math.h>
#include <set>
#include <queue>
#include <map>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

int n1,n2;
char a[100] , b[100];

int dx;
char txt[100];

int L;
int dp[100][100];
vector< pii > moves[100][100];

int szi[100][100];


int solve( int idxa, int idxb ){

    if( szi[idxa+1][idxb+1] != -1 && dx + szi[idxa+1][idxb+1] - 1 != L )
         return szi[idxa+1][idxb+1];

    int mx = 1;
    int sz = moves[idxa+1][idxb+1].size();

    for( int i = 0; i < sz; ++i ){

        txt[dx++] = a[ moves[idxa+1][idxb+1][i].f ];
        txt[dx] = '\0';

        mx = max( mx , solve( moves[idxa+1][idxb+1][i].f , moves[idxa+1][idxb+1][i].s ) + 1 );

        dx--;
    }

  //  cout<<"set: "<<" [ "<<dx<<" ]   "<<idxa+1<<" "<<idxb+1<<" | "<<mx<<endl;
    szi[idxa+1][idxb+1] = mx;

    if( dx == L )
        printf("%s\n",txt);

    return mx;
}


int lcsq( char *a , char *b ){
    int len1 = strlen(a);
    int len2 = strlen(b);

    for( int i = 0; i < len1; ++i )
        for( int j = 0; j < len2; ++j )
            if( a[i] == b[j] )
                dp[i+1][j+1] = dp[i][j] + 1;
            else
                dp[i+1][j+1] = max( dp[i][j+1] , dp[i+1][j] );

    return dp[len1][len2];
}


int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        memset( szi , -1 , sizeof(szi));
        scanf("%s%s",a,b);
        n1 = strlen(a);
        n2 = strlen(b);

        for( int i = -1; i < n1; ++i ){
            for( int j = -1; j < n2; ++j ){
                moves[i+1][j+1].clear();
                for( char k = 'a'; k <= 'z'; ++k ){

                    int z1 = i+1 , z2 = j+1;

                    for( ; z1 < n1 && a[z1] != k ; ++z1 );
                    for( ; z2 < n2 && b[z2] != k ; ++z2 );

                    if( z1 == n1 || z2 == n2 ) continue;

                    moves[i+1][j+1].push_back( mk(z1,z2) );
                }
            }
        }


        dx = 0;
        L = lcsq( a , b );
        solve( -1, -1 );
        if( tests > 1 )cout<<endl;

    }

    return 0;
}

#include <iostream>
#include <fstream>
#include <stack>
#include <math.h>
#include <vector>
#include <set>
#include <queue>
#include <map>
using namespace std;

int d,c,m,n;
int v[105];
int dp[105][300];

inline bool ok( int c1, int c2 ){
    if( c1 == -1 || c2 == -1 ) return true;
    return abs(c1-c2) <= m;
}

int solve( int dx , int prv ){
    if( dx == n ) return 0;
    int &ref = dp[dx][prv+1];

    if( ref != -1 ) return ref;

    int sol = solve( dx + 1 , prv ) + d; // delete

    int diff = abs( prv - v[dx] );

    for( int i = 0; i <= 255; ++i ){
        if( diff > abs(i-v[dx]) && ok(prv,i) )
            sol = min( sol , solve( dx , i ) + c ); // insert

        if( ok(prv,i) ) sol = min( sol , solve( dx + 1 , i ) + abs(v[dx]-i)  ); // change
    }

    if( ok(prv,v[dx]) ) sol = min( sol , solve( dx + 1 , v[dx] ) ); // do nothing;

    return ref = sol;
}

int main(){
  //  freopen("Ulaz.txt","r",stdin);
//freopen("Izlaz.txt","w",stdout);
    int tests;
    scanf("%d",&tests);

    for( int t = 1; t <= tests; ++t ){

        memset( dp , -1, sizeof(dp));
        scanf("%d%d%d%d",&d,&c,&m,&n);
        for( int i = 0; i < n; ++i ) scanf("%d",v+i);

        int sol = solve( 0 , -1 );

        printf("Case #%d: %d\n",t,sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
using namespace std;

typedef long long ll;

bool isprime( int v ){
    if( v != 2 && v % 2 == 0 ) return false;

    for( int i = 3; i*i <= v; i += 2 )
        if( v % i == 0 ) return false;
    return true;
}

int main(){

    ll sol = 0;

    for( int i = 2; i < 2000000; ++i )
        if( isprime(i) ) sol += i;

    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <string.h>
using namespace std;

int n;
char txt[2005];

int dp[2005];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        scanf("%d",&n);
        scanf("%s",txt);

        int sol = 0;
        memset( dp , 0 , sizeof(dp));

        for( int i = 0; i < n; ++i ){

            int p = 0;
            for( int k = i; k >= 0; --k )
                p = max( p , dp[k] );

            int sweet = 0,sour = 0;
            for( int k = 0; i+k < n; ++k ){
                if( txt[i+k] == '1' ) sweet ++;
                else sour ++;

                if( sweet > sour ){
                    dp[i+k+1] = max( dp[i+k+1],k + 1 + p);
                    sol = max( sol , k + 1 + p );
                }
            }
        }
        printf("%d\n",sol);


    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <math.h>
#include <algorithm>
#include <map>
#include <iomanip>
#include <string.h>
#include <string>
#include <stack>
using namespace std;

typedef unsigned long long ll;

const int maxn = 50050;
const int mod = 98765431;

int n,t;
int cow[maxn];

int cop[2][2];
int mat[2][2];
int mul[2][2];
int buf[2][2];

void init( int v ){
    memset( mat , 0 , sizeof(mat));
    memset( mul , 0 , sizeof(mul));
    memset( cop , 0 , sizeof(cop));

    mat[0][0] = v;

    mul[0][1] = 1;
    mul[1][0] = n-1;
    mul[1][1] = n-2;

    memcpy( cop , mul , sizeof mul );
}

void multy( int a[2][2] , int b[2][2] ){

    for( int i = 0; i < 2; ++i )
        for( int j = 0; j < 2; ++j )
            for( int k = 0; k < 2; ++k )
                buf[i][j] = ( buf[i][j] + a[i][k] * (ll)b[k][j] ) % mod;

    for( int i = 0; i < 2; ++i ){
        for( int j = 0; j < 2; ++j ){
            a[i][j] = buf[i][j];
            buf[i][j] = 0;
        }
    }


}


void nth( int n ){
    stack<bool>s;

    while( n > 1 ){
        if( n&1 )s.push(0) , n --;
        else s.push(1) , n >>= 1;
    }


    while( s.empty() == false ){
        int u = s.top(); s.pop();
        if( u == 0 ) multy( mul , cop );
        else multy( mul, mul );
    }
}

int sol[maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d%d",&n,&t);
    for( int i = 0; i < n; ++i ) scanf("%d",&cow[i]);

    int sum = 0;

    init( cow[0] );
    nth( t );

    for( int i = 0; i < n; ++i ){

        int s1 = (cow[i]*(ll)mul[0][0])%mod;
        int s2 = (cow[i]*(ll)mul[0][1])%mod;

        sol[i] = (sol[i] + s1 - s2)%mod;
        sum = (sum+s2)%mod;
    }

    for( int i = 0; i < n; ++i )
        cout<<(sol[i]+sum+mod)%mod<<" ";cout<<endl;


    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <math.h>
#include <string>
#include <string.h>
#include <set>
#include <stack>
#include <map>
#include <algorithm>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int inf = 999999999;

int n,limit;
int dst[105][105];
int toll[105][105];

int dp[105][1050];

int main(){
    //freopen("Ulaz.txt","r",stdin);

    while(1){

        scanf("%d%d",&n,&limit);
        if( n == 0 && limit == 0 )break;

        for( int i = 0; i < n; ++i )
            for( int j = 0; j < n; ++j )
                scanf("%d",&dst[i][j]);

        for( int i = 0; i < n; ++i )
            for( int j = 0; j < n; ++j )
                scanf("%d",&toll[i][j]);

        for( int i = 0; i <= n; ++i )
            for( int j = 0; j <= 1000; ++j )
                dp[i][j] = inf;

        pair< pii , int > u;
        priority_queue< pair< pii , int > >pq;
        pq.push( mk( mk(inf,inf) , 0 ));

        dp[0][0] = 0;


        while( !pq.empty() ){
            u = pq.top(); pq.pop();

            int t = inf-u.f.f;
            int d = inf-u.f.s;

            //cout<<u.s<<" , "<<t<<" "<<d<<endl;

            if( u.s == n-1 ) break;

            for( int i = 0; i < n; ++i ){
                int nt = t+toll[u.s][i];
                int nd = d+dst[u.s][i];

                //cout<<" | "<<i<<" = "<<nt<<" , "<<nd<<" , "<<dp[i][d]<<endl;

                if( nd > limit || dp[i][d] <= nt ) continue;
                dp[i][nd] = nt;

                pq.push( mk( mk(inf-nt,inf-nd) , i ));
            }
        }

        printf("%d %d\n",inf-u.f.f,inf-u.f.s);

    }


    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <math.h>
#include <string>
#include <string.h>
#include <set>
#include <stack>
#include <map>
#include <algorithm>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int inf = 999999999;

int n,limit;
int dst[105][105];
int toll[105][105];

int dp[105][1050];

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests;
    scanf("%d",&tests);

    while(tests--){

        scanf("%d%d",&n,&limit);
        if( n == 0 && limit == 0 )break;

        for( int i = 0; i < n; ++i )
            for( int j = 0; j < n; ++j )
                scanf("%d",&dst[i][j]);

        for( int i = 0; i < n; ++i )
            for( int j = 0; j < n; ++j )
                scanf("%d",&toll[i][j]);

        for( int i = 0; i <= n; ++i )
            for( int j = 0; j <= 1000; ++j )
                dp[i][j] = inf;

        pair< pii , int > u;
        priority_queue< pair< pii , int > >pq;
        pq.push( mk( mk(inf,inf) , 0 ));

        dp[0][0] = 0;


        while( !pq.empty() ){
            u = pq.top(); pq.pop();

            int t = inf-u.f.f;
            int d = inf-u.f.s;

            //cout<<u.s<<" , "<<t<<" "<<d<<endl;

            if( u.s == n-1 ) break;

            for( int i = 0; i < n; ++i ){
                int nt = t+toll[u.s][i];
                int nd = d+dst[u.s][i];

                //cout<<" | "<<i<<" = "<<nt<<" , "<<nd<<" , "<<dp[i][d]<<endl;

                if( nd > limit || dp[i][d] <= nt ) continue;
                dp[i][nd] = nt;

                pq.push( mk( mk(inf-nt,inf-nd) , i ));
            }
        }

        if( u.s == n-1 )
            printf("%d %d\n",inf-u.f.f,inf-u.f.s);
        else
            printf("-1\n");

    }


    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <string>
#include <string.h>
#include <stack>
#include <map>
#include <iomanip>
#include <queue>
using namespace std;

int tests;
char txt[105];

int len;
int dp[105];

int solve( int dx  ){

    int &ref = dp[dx+1];
    if( ref != -1 ) return ref;

    ref = 1;
    char c = -128;
    if( dx >= 0 ) c = txt[dx];

    for( int i = dx+1; i < len; ++i ){
        if( c > txt[i] ) continue;
        ref = max( ref , solve( i ) + 1 );
    }

    return ref;
}

char stk[200];
int leg = 0;

void print( int dx , int sz ){
    if( sz == 0 ){
        stk[leg] = '\0';
        printf("%s\n",stk);
        return;
    }

    char last = -128;
    if( dx >= 0 ) last = txt[dx];

    for( int c = 'a'; c <= 'z'; ++c ){
        if( c < last ) continue;

        stk[leg++] = c;

        for( int i = dx+1; i < len; ++i ){
            if( txt[i] != c ) continue;
            if( dp[i+1] != sz ) continue;

            print( i , sz - 1 );
            break;
        }

        leg--;
    }

}


int main(){
    freopen("Ulaz.txt","r",stdin);

    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%s",txt);
        len = strlen(txt);

        memset( dp , -1 , sizeof(dp));

        int r = solve( -1 );

        print( -1 , r - 1 );
        printf("\n");

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <set>
#include <algorithm>
#include <map>
#include <stack>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 50005;

int n;
int lvl[maxn];
int h[maxn];
int w[maxn];
int d[maxn];
int V;

double calc( double L ){
    double ret = 0;
    for( int i = 0; i < n; ++i ){
        double q = L - lvl[i];
        if( q < 0 ) q = 0;

        double hig = min( q , (double)h[i] );
        ret += hig*w[i]*d[i];
    }
    return ret;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        scanf("%d",&n);
        for( int i = 0; i < n; ++i )
            scanf("%d%d%d%d",&lvl[i],&h[i],&w[i],&d[i]);
        scanf("%d",&V);

        double lo = 0 , hi = 1500001;
        while( hi - lo > 0.00001 ){
            double mid = (lo+hi)/2;
            double cap = calc( mid );

            if( cap < V ) lo = mid;
            else hi = mid;
        }
        if( lo <= 1300000.5 )
            printf("%.2lf\n",lo);
        else
            printf("OVERFLOW\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <algorithm>
#include <stack>
#include <map>
#include <queue>
#include <string>
#include <string.h>
using namespace std;

int n;
string digs;
int bit[10005],sz;

int main(){
   //freopen("Ulaz.txt","r",stdin);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        memset( bit , 0 , sizeof(bit));
        sz = 0;

        cin >> digs;


        n = digs.size() - 1;
        reverse( digs.begin() , digs.end() );
        continue;

        for( int i = 0; i <= n; ++i )digs[i] -= '0';
        while( n + 1 ){
            int rem = 0;
            for( int i = n; i >= 0; --i ){
                rem = rem * 10 + digs[i];
                digs[i] = rem / 2;
                rem %= 2;
            }
            bit[sz++] = rem;
            while( n >= 0 && digs[n] == 0 ) n --;
        }
        int to = 0;
        for( to = sz; to >= 0; to -- ) if( bit[to] ) break;

        for( int i = 0; i < to; ++i )
            if( bit[i] <= 0 ) bit[i] += 2 , bit[i+1] --;


        int sol = 0;
        for( int i = 0; i < sz; ++i )
            sol += bit[i];
        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <string>
#include <string.h>
#include <iomanip>
#include <set>
#include <iomanip>
#include <queue>
#include <stack>
#include <map>
#include <algorithm>
#include <assert.h>
using namespace std;

const int maxx = 1000100*2;

struct event{
    int x1,x2,c;
    event(){};
    event( int p1 , int p2, int p3 ):x1(p1),x2(p2),c(p3){};

    bool operator<( const event &e ) const {
        return x2 < e.x2;
    }
};

int n;
vector< event > order;


int bit[maxx];

void update( int dx , int val ){
    for( dx += 5; dx < maxx ; dx += dx & -dx )
        bit[dx] = max( bit[dx] , val );
}

int read( int dx ){
    int ret = 0;
    for( dx += 5; dx >= 1; dx -= dx & -dx )
        ret = max( ret , bit[dx] );
    return ret;
}


int main(){
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        scanf("%d",&n);

        vector< int > lo;
        order.clear();

        for( int i = 0; i < n; ++i ){
            int a,b,c; scanf("%d%d%d",&a,&b,&c);
            order.push_back( event(a,a+b,c) );
            lo.push_back( a );
            lo.push_back( a+b );
        }

        sort( lo.begin() , lo.end() );
        for( int i = 0; i < n; ++i ){
            order[i].x1 = lower_bound( lo.begin(),lo.end(), order[i].x1 ) - lo.begin();
            order[i].x2 = lower_bound( lo.begin(),lo.end(), order[i].x2 ) - lo.begin();
        }

        int mx = lo[ lo.size()-1 ];
        for( int i = 0; i <= mx; ++i )
            bit[i] = 0;

        sort( order.begin() , order.end() );

        int solution = 0;

        for( int i = 0; i < n; ++i ){
            int sol = read( order[i].x1 ) + order[i].c;
            update( order[i].x2 , sol );

            solution = max( solution , sol );
        }

        printf("%d\n",solution);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <iomanip>
using namespace std;

const int inf = 999999999;

int tipke,slova;
char tip[333],slo[333];
int fq[333];

int dp[333][333];
int nxt[333][333];

int solve( int dx, int key ){

    if( dx == slova ) return 0;
    if( key == tipke ) return inf;

    int &ref = dp[dx][key];
    if( ref != -1 ) return ref;

    ref = solve( dx , key+1 );
    nxt[dx][key] = dx-1;

    int sum = 0;

    for( int i = dx; i < slova; ++i ){
        sum += (i-dx+1)*fq[i];

        int ss = solve( i+1 , key+1 ) + sum;
        if( ref > ss ){
            ref = ss;
            nxt[dx][key] = i;
        }
    }
    return ref;
}

int main(){

    int tests,t;
    scanf("%d",&tests);

    for( t = 1; tests; --tests , t++ ){

        scanf("%d%d",&tipke,&slova);
        scanf("%s%s",tip,slo);

        for( int i = 0; i < slova; ++i ) scanf("%d",&fq[i]);

        memset( nxt, -1 , sizeof(nxt));
        memset( dp , -1 , sizeof(dp));
        int sol = solve( 0, 0 );

        printf("Keypad #%d:\n",t);

        int k1(0),k2(0);
        while( k2 < tipke ){
            int to = nxt[k1][k2];

            printf("%c: ",tip[k2]);
            for( int i = k1; i <= to; ++i )printf("%c",slo[i]);
            printf("\n");

            k1 = to+1;
            k2++;
        }
        printf("\n");

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <stack>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
using namespace std;

int n,m;
char txt[200];
int hash[255];

int mask, dx;

bool taut(){
    char ch = txt[dx++];
    if( ch >= 'a' && ch <= 'z' ) return mask&(1<<hash[ch]);
    if( ch == 'N' ) return !taut();

    bool a,b;

    a = taut();
    b = taut();

    if( ch == 'C' ) return a && b;
    if( ch == 'D' ) return a || b;
    if( ch == 'I' ) return !(a == true && b == false);
    if( ch == 'E' ) return (a&&b) || ((!a)&&(!b));

}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        scanf("%s",txt);
        n = strlen(txt);

        m = 0;
        memset( hash , -1 , sizeof(hash));

        for( int i = 0; i < n; ++i ){
            char c = txt[i];
            if( hash[c] != -1 || c < 'a' || c > 'z' ) continue;
            hash[c] = m++;
        }
        bool ok = true;

        for( int i = (1<<m)-1; i >= 0; --i ){
            mask = i, dx = 0;

            bool ret = taut();
            if( ret == false ){
                 ok = false;
                 break;
            }
        }

        if( ok ) printf("YES\n");
        else printf("NO\n");

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <math.h>
#include <stack>
#include <map>
#include <algorithm>
#include <string>
#include <queue>
#include <string.h>
#include <fstream>
#include <sstream>
using namespace std;

static int n;
static vector< int > g[10005];

static void init(){
    for( int i = 0; i <= n; ++i ) g[i].clear();
}

static vector< int > path;
static int visi[10005];

int main(){

    ifstream in1("Ulaz.txt");
    ifstream in2("Izlaz.txt");
    ifstream soli("Izlaz2.txt");

    int tests;
    in1 >> tests;

    int line = 0;

    for( ; tests; --tests ){
        memset( visi , 0 , sizeof(visi));

        in1>>n; line ++;
        init();

        for( int i = 0; i < n - 1; ++i ){
            int a,b; in1>>a>>b;
            g[a].push_back(b);
            g[b].push_back(a);
        }

        string lin;
        int sol , sol2;
        in2 >> sol;
        soli >> sol2;
        getline(in2,lin);

        if( sol != sol2 ){
            cout<<"WRONG SIZE "<<sol<<" "<<sol2<<" | "<<line<<endl;
            return 0;
        }

        for( int i = 0; i < sol; ++i ){
            getline(in2,lin);

            stringstream in3(lin);

            while( in3.eof() == false ){
                int node;
                in3 >> node;
                path.push_back( node );
            }

            //for( int i = 0; i < path.size(); ++i )
            //    cout<<path[i]<<" ";cout<<endl;

            for( int i = 0; i < path.size() - 1; ++i ){

                int now = path[i];
                int nxt = path[i+1];
                visi[now] ++;

                bool ok = false;

                for( int j = 0; j < g[now].size(); ++j )
                    if( nxt == g[now][j] ) ok = true;

                if( ok == false ){
                    cout<<"PATH RULE IS BROKEN"<<endl;
                    return 0;
                }
            }
            visi[ path[ path.size() - 1 ] ] ++;

            path.clear();

        }

        for( int i = 1; i <= n; ++i )
            if( visi[i] != 1 ){
                cout<<"VISIT RULE IS BROKEN "<<i<<" [ "<<visi[i]<<" ] "<<endl;
                return 0;
            }

        cout<<"OK!"<<endl;
    }

    return 0;
}

#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

#define pb push_back
#define sz size()
#define MAXN 10001
const int oo=(int)1e6;
typedef vector<int>vi;
int t,n,a,b,dp[MAXN][2],satu[MAXN],dua[MAXN][2],cnt,next[MAXN],nilai[MAXN];
vi g[MAXN],v1;
vi ans[MAXN];
bool used[MAXN];

//0 cabang 1
//1 cabang 2

int dfs(int u,int par){
    //type 0
    dp[u][0]=oo;
    int tot=0;
    int tmp;
    for (vi::iterator it=g[u].begin();it!=g[u].end();it++){
        if (*it==par) continue;
        dfs(*it,u);
        tot+=min(dp[*it][0],dp[*it][1])+1;
    }
    for (vi::iterator it=g[u].begin();it!=g[u].end();it++){
        if (*it==par) continue;
        tmp=tot-(min(dp[*it][0],dp[*it][1])+1)+dp[*it][0];
        if (dp[u][0]>tmp){
            dp[u][0]=tmp;
            satu[u]=*it;
        }
    }
    if (dp[u][0]==oo) dp[u][0]=0;
    //type 1
    dp[u][1]=oo;
    int mini1,mini2,idx1,idx2;
    mini1=mini2=oo;
    idx1=idx2=0;
    for (vi::iterator it=g[u].begin();it!=g[u].end();it++){
        if (*it==par) continue;
        tmp=-(min(dp[*it][0],dp[*it][1])+1)+dp[*it][0];
        if (mini1>=tmp){
            mini2=mini1;
            idx2=idx1;
            mini1=tmp;
            idx1=*it;
        }
        else if (mini2>tmp){
            mini2=tmp;
            idx2=*it;
        }
    }
    tmp=tot+mini1+mini2;
    if (dp[u][1]>tmp){
        dp[u][1]=tmp;
        dua[u][0]=idx1;
        dua[u][1]=idx2;
    }
}

void trace(int u,int par,int com,bool type){
    nilai[u]=com;
    next[u]=par;
    if (type==0){
        if (satu[u]==-1){
            v1.pb(u);
            return;
        }
        trace(satu[u],u,com,0);
        for (vi::iterator it=g[u].begin();it!=g[u].end();it++){
            if (*it==par) continue;
            if (*it==satu[u]) continue;
            if (dp[*it][0]<=dp[*it][1]){
                trace(*it,u,++cnt,0);
            }
            else trace(*it,u,++cnt,1);
        }
    }
    else {
        if (dua[u][0]==-1 || dua[u][1]==-1){
            v1.pb(u);
            return;
        }
        trace(dua[u][0],u,com,0);
        trace(dua[u][1],u,com,0);
        for (vi::iterator it=g[u].begin();it!=g[u].end();it++){
            if (*it==dua[u][0]) continue;
            if (*it==dua[u][1]) continue;
            if (*it==par) continue;
            if (dp[*it][0]<=dp[*it][1]){
                trace(*it,u,++cnt,0);
            }
            else trace(*it,u,++cnt,1);
        }
    }
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
    scanf("%d",&t);
    while (t--){
        scanf("%d",&n);
        for (int i=1;i<=n;i++){
            g[i].clear();
        }
        for (int i=1;i<n;i++){
            scanf("%d%d",&a,&b);
            g[a].pb(b);
            g[b].pb(a);
        }
        memset(satu,-1,sizeof(satu));
        memset(dua,-1,sizeof(dua));
        dfs(1,-1);
        printf("%d\n",min(dp[1][0],dp[1][1])+1);

        continue;

        cnt=0;
        v1.clear();
        if (dp[1][0]<=dp[1][1]) trace(1,-1,cnt,0);
        else trace(1,-1,cnt,1);
        memset(used,0,sizeof(used));
        for (vi::iterator it=v1.begin();it!=v1.end();it++){
            if (used[*it]) continue;
            used[*it]=1;
            printf("%d",*it);
            int now=*it;
            while (next[now]!=-1){
                int tmp=next[now];
                if (nilai[tmp]==nilai[*it]){
                    printf(" %d",tmp);
                    used[tmp]=1;
                }
                else {
                    break;
                }
                now=tmp;
            }
            if (dp[now][1]<dp[now][0]){
                if (!used[dua[now][0]]){
                    now=dua[now][0];
                    printf(" %d",now);
                    used[now]=1;
                    while (satu[now]!=-1){
                        int tmp=satu[now];
                        now=tmp;
                        printf(" %d",tmp);
                        used[tmp]=1;
                    }
                }
                if (!used[dua[now][1]]){
                    now=dua[now][1];
                    printf(" %d",now);
                    used[now]=1;
                    while (satu[now]!=-1){
                        int tmp=satu[now];
                        now=tmp;
                        printf(" %d",tmp);
                        used[tmp]=1;
                    }
                }
            }
            printf("\n");
        }
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <math.h>
#include <stack>
#include <map>
#include <algorithm>
#include <string>
#include <queue>
#include <string.h>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn =  100000 + 500;
const int inf = 999999999;

int n;
vector< int > g[maxn];

int dp[maxn][2];
int dir[maxn][2][2];
int pre[maxn];

int solve( int node , int lanac , int dad ){
    pre[node] = dad;

    int &ref = dp[node][lanac];
    int *dire = &dir[node][lanac][0];

    if( ref != -1 ) return ref;

    dire[0] = -1;
    dire[1] = -1;

    int F = 99999999;
    vector< int > da_lanac;
    vector< int > ne_lanac;

    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( nxt == dad ){
            F = i;
            continue;
        }

        da_lanac.push_back( solve( nxt , true , node ) );
        ne_lanac.push_back( solve( nxt , false , node ) );
    }

    int sz = da_lanac.size();

    if( ( lanac && sz >= 1 ) || sz == 1 ){
        int dx = -1, now = 9999999;
        for( int i = 0; i < da_lanac.size(); ++i ){
            int c = da_lanac[i] - ne_lanac[i];
            if( c < now ) dx = i , now = c;
        }

        int sum = 0;

        for( int i = 0; i < da_lanac.size(); ++i ){
            if( i == dx ) continue;
            sum += ne_lanac[i];
        }

        int add = 0;
        if( !lanac ) add = 1;

        dire[0] = dx; if( dire[0] >= F ) dire[0]++;
        return ref = sum + da_lanac[dx] + add;
    }else if( sz >= 2 ){

            int dx1=-1,dx2=-1,now=999999;
            for( int i = 0; i < sz; ++i ){
                for( int j = i+1; j  < sz; ++j ){
                    int c = da_lanac[i] - ne_lanac[i];
                    c += da_lanac[j] - ne_lanac[j];

                    if( c < now ) now = c , dx1 = i , dx2 = j;
                }
            }

        int sum = 0;

        for( int i = 0; i < da_lanac.size(); ++i ){
            if( i == dx1 || i == dx2 ) continue;
            sum += ne_lanac[i];
        }

        dire[0] = dx1; if( dire[0] >= F ) dire[0]++;
        dire[1] = dx2; if( dire[1] >= F ) dire[1]++;
        return ref = sum + da_lanac[dx1] + da_lanac[dx2] + 1;
    }

    if( lanac ) return ref = 0;
    else return ref = 1;
}

int sol;
queue< pii > q;

inline void proces( int node , bool mode ){
    for( int k = 0; k < g[node].size(); ++k ){
        int nxt = g[node][k];
        if( nxt == pre[node] || k == dir[node][mode][0] || k == dir[node][mode][1] ) continue;
        q.push( mk(nxt,0) );
    }
}


inline void backtrace( int node ){
    if( dir[node][1][0] != -1 ) backtrace( g[node][ dir[node][1][0] ] );
    printf("%d ",node+1);
    proces(node,1);
}


void print_solution(){
    printf("%d\n",sol);

    q.push( mk(0,0) );

    while( !q.empty() ){
        pii u = q.front(); q.pop();

        int node = u.f;
        int mode = u.s;

        if( dir[node][mode][0] == -1 )
            printf("%d\n",node+1);
        else{
            bool mod = false;

            if( dir[node][mode][1] != -1 ){
                backtrace( g[node][ dir[node][mode][0] ] );
                mod = true;
            }

            int now = node;
            proces( node , false);
            printf("%d ",now+1);
            now = g[now][ dir[now][mode][mod] ];

            while( 1 ){
                printf("%d",now+1 );

                proces(now,true);
                if( dir[now][1][0] == -1 ) break;
                printf(" ");
                now = g[ now ][ dir[now][1][0] ];
            }
            printf("\n");

        }

    }

}

void init(){
    for( int i = 0; i < n; ++i ){
        g[i].clear();
        dp[i][0] = dp[i][1] = -1;
        dir[i][0][0] = dir[i][0][1] = dir[i][1][0] = dir[i][1][1] = -1;
        pre[i] = -1;
    }
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        scanf("%d",&n);
        init();

        for( int i = 0; i < n - 1; ++i ){
            int a,b; scanf("%d%d",&a,&b); a--,b--;
            g[a].push_back(b);
            g[b].push_back(a);
        }

        sol = solve( 0 , 0 , -1 );

        print_solution();


    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <math.h>
#include <stack>
#include <map>
#include <algorithm>
#include <string>
#include <queue>
#include <string.h>
using namespace std;

bool ok[15000];

int main(){
    srand((unsigned)time(0));

    freopen("Ulaz.txt","w",stdout);

    int tests;
    tests = 1+rand()%100;
    cout<<tests<<endl;

    while( tests-- ){
        memset( ok , false , sizeof(ok));


    int n = 1+rand()%100;
    printf("%d\n",n);

    ok[1] = 1;

    for( int i = 0; i < n-1; ++i ){

        int a,b;
        while(1){
            a = 1 + rand()%n;
            b = 1 + rand()%n;

            if( ok[a] && !ok[b] ) break;
        }

        ok[b] = ok[a];
        printf("%d %d\n",a,b);

    }


    }


    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <math.h>
#include <stack>
#include <map>
#include <algorithm>
#include <string>
#include <queue>
#include <string.h>
#include <fstream>
#include <sstream>
#include "CHK.h"
#include "PT07F_MK.h"
using namespace std;


int main(){
    for( int i = 0; i < 1999999; ++i ){

        cout<<"A..";
        system("PT07F_MK.exe");
        cout<<"B..";
        system("harta.exe");
        cout<<"C..";
        system("PT07F.exe");
        cout<<"D..";

        if( IsOk() ){
            cout<<"CASE: "<<i<<" = ok"<<endl;
        }else{
            cout<<"NOT OK"<<endl;
            system("Pause");
        }
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <stack>
#include <map>
#include <algorithm>
#include <set>
#include <string>
#include <string.h>
using namespace std;

struct point{
    int x,y;
    point(){};
    point( int p1, int p2 ):x(p1),y(p2){};
    bool operator<( const point &p ) const {
        return x < p.x || ( x == p.x && y < p.y );
    }
};

int n;
vector< point > w;
vector< int > x,y;

map<int,int>lef;
map<int,int>righ;
map<int,int>up;
map<int,int>down;

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        w.clear();
        x.clear();
        y.clear();
        lef.clear();
        righ.clear();
        up.clear();
        down.clear();

        scanf("%d",&n);
        for( int i = 0; i < n; ++i ){
            int a,b; scanf("%d%d",&a,&b);
            w.push_back( point(a,b) );
            x.push_back( a );
            y.push_back( b );
        }

        sort( w.begin() , w.end() );
        sort( x.begin() , x.end() );
        sort( y.begin() , y.end() );

        int cnt,k;

        cnt = 0;
        for( int i = 0; i < n; ++i ){
            if(i) cnt += i*(x[i]-x[i-1]);
            lef[ x[i] ] = cnt;
        }

        cnt = 0;
        for( int i = 0; i < n; ++i ){
            if(i) cnt += i*(y[i]-y[i-1]);
            up[ y[i] ] = cnt;
        }

        cnt = 0,k = 0;
        for( int i = n-1; i >= 0; --i ){
            if( i != n-1 ) cnt += k*(x[i+1]-x[i]);
            righ[ x[i] ] = cnt;
            ++k;
        }

        cnt = 0,k = 0;
        for( int i = n-1; i >= 0; --i ){
            if( i != n-1 ) cnt += k*(y[i+1]-y[i]);
            down[ y[i] ] = cnt;
            ++k;
        }

        int mx = 10000*100000;

        for( int i = 0; i < n; ++i ){
            int sol = down[ w[i].y ];
            sol += up[ w[i].y ];
            sol += lef[ w[i].x ];
            sol += righ[ w[i].x ];
            mx = min( sol , mx );
        }

        printf("%d\n",mx);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <iomanip>
#include <set>
#include <queue>
#include <iomanip>
using namespace std;

const int maxn = 10005;

struct edge{
    int a,b,c;
    edge(){};
    edge( int p1, int p2, int p3 ):a(p1),b(p2),c(p3){};

    const bool operator<( const edge &e ) const {
        return c < e.c;
    }
};

int n;
vector< edge > e;
char txt[20];

int id[maxn];
int sz[maxn];


void init(){
    e.clear();

    for( int i = 0; i <= n; ++i ){
        id[i] = i;
        sz[i] = 1;
    }

}


int find( int v ){
    if( v == id[v] ) return v;
    id[v] = find( id[v] );
}

bool merge( int a, int b ){
    int x = find(a) , y = find(b);

    if( x == y ) return true;

    if( sz[x] < sz[y] )
        id[x] = y , sz[y] += sz[x];
    else
        id[y] = x , sz[x] += sz[y];

    return false;
}


int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d",&n);

        init();

        for( int i = 0; i < n; ++i ){
            scanf("%s",txt);

            int m; scanf("%d",&m);
            for( int j = 0; j < m; ++j ){
                int b,c; scanf("%d%d",&b,&c);
                --b;
                e.push_back( edge(i,b,c) );
            }
        }

        int sol = 0;
        sort( e.begin() , e.end() );
        for( int i = 0; i < e.size(); ++i ){
            bool b = merge( e[i].a , e[i].b );
            if( b == false )
                sol += e[i].c;
        }

        printf("%d\n",sol);



    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
using namespace std;

typedef long long ll;

const int maxn = 100050;
const ll inf = 99999999999999999LL;

int n;
ll s[maxn];
ll e[maxn];

ll dp[maxn];

inline ll calc( ll a , ll b ){
    if( a > b ) return a - b;
    else return b - a;
}

ll solve( int dx ){
    if( dx == n ) return 0;

    ll &ref = dp[dx];

    if( ref != -1 ) return ref;


    ref = inf;

    if( s[dx] != e[dx] ) ref = solve( dx + 1 ) + abs( s[dx] - e[dx] );

    if( dx + 1 < n )ref = min( ref , solve( dx + 2 ) +  abs(s[dx]-e[dx+1]) + abs(s[dx+1]-e[dx])  );
    if( dx + 2 < n ){
        if( s[dx+1] != e[dx] && s[dx+2] != e[dx+1] && s[dx+0] != e[dx+2] ) ref = min( ref , solve( dx + 3 ) + calc(s[dx+1],e[dx]) + calc(s[dx+2],e[dx+1]) + calc(s[dx+0],e[dx+2]) );
        if( s[dx+2] != e[dx] && s[dx+1] != e[dx+1] && s[dx+0] != e[dx+2] ) ref = min( ref , solve( dx + 3 ) + calc(s[dx+2],e[dx]) + calc(s[dx+1],e[dx+1]) + calc(s[dx+0],e[dx+2]) );

        if( s[dx+0] != e[dx] && s[dx+2] != e[dx+1] && s[dx+1] != e[dx+2] ) ref = min( ref , solve( dx + 3 ) + calc(s[dx+0],e[dx]) + calc(s[dx+2],e[dx+1]) + calc(s[dx+1],e[dx+2]) );
        if( s[dx+2] != e[dx] && s[dx+0] != e[dx+1] && s[dx+1] != e[dx+2] ) ref = min( ref , solve( dx + 3 ) + calc(s[dx+2],e[dx]) + calc(s[dx+0],e[dx+1]) + calc(s[dx+1],e[dx+2]) );
    }

    return ref;
}


int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d",&n);
        for( int i = 0; i < n; ++i )
            scanf("%lld%lld",&s[i],&e[i]);

        sort( s , s + n );
        sort( e , e + n );

        memset( dp , -1 , sizeof(dp));

        ll sol = solve( 0 );
        printf("%lld\n",sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <stack>
#include <map>
#include <algorithm>
#include <iomanip>
#include <queue>
#include <string>
#include <string.h>
using namespace std;

typedef unsigned long long ll;

int v;

vector< string > temps;

bool was[20005];
int prv[20005];
bool isone[20005];

int main(){


    //freopen("Izlaz2.txt","w",stdout);

    int n;
    scanf("%d",&n);

    for( ; n ; --n ){

        scanf("%d",&v);
        if( v == 1 ){
            cout<<1<<endl;
            continue;
        }

        for( int i = 0; i <= v; ++i ){
            isone[i] = false;
            was[i] = false;
            prv[i] = -1;
        }

        queue< int > q;
        q.push( 1 );
        was[1] = true;
        isone[1] = true;

        while( !q.empty() ){
            int u = q.front(); q.pop();



            int r = (u * 10)%v;
            if( was[r] == false ){
                prv[r] = u;
                was[r] = true;
                isone[r] = false;
                q.push( r );
            }

            r = (u * 10 + 1 ) % v;
            if( was[r] == false ){
                prv[r] = u;
                was[r] = true;
                isone[r] = true;
                q.push( r );
            }
        }

        string sol = "";

        int now  = 0;
        while( now != -1 ){
            if( isone[now] ) sol += "1";
            else sol += "0";
            now = prv[now];
        }

        reverse( sol.begin() , sol.end() );
        cout<<sol<<endl;

    }


    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <string.h>
#include <iomanip>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define mk make_pair
#define f first
#define s second

int d[][2] = { {1,0} , {-1,0} , {0,1} , {0,-1} };

const int inf = 9999999;

int h,w;
int mx[105][105];
int ds[105][105];

void clear(){
    for( int i = 0; i < 105; ++i )
        for( int j = 0; j < 105; ++j )
            ds[i][j] = inf;
}

int xh,yh,T;

int main(){
   // freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        clear();

        scanf("%d%d",&h,&w);
        for( int i = 0; i < h; ++i )
            for( int j = 0; j < w; ++j ){
                char c;
                while( (c=getchar())<'0' || c >'9' );

                mx[i][j] = c - '0';
            }

        scanf("%d%d%d",&yh,&xh,&T);

        priority_queue< pair< int , pii > > pq;
        pq.push( mk( inf - mx[0][0] , mk(0,0) ) );

        pair< int , pii > u;

        while( !pq.empty() ){
            u = pq.top(); pq.pop();

            if( u.s.f == yh - 1 && u.s.s == xh-1 ) break;


            for( int k = 0; k < 4; ++k ){
                int r = u.s.f + d[k][0];
                int c = u.s.s + d[k][1];

                if( r < 0 || c < 0 || r >= h || c >= w ) continue;

                int nwd = inf - u.f + mx[r][c];
                if( nwd > T || ds[r][c] <= nwd ) continue;

                ds[r][c] = nwd;
                pq.push( mk( inf - nwd , mk(r,c) )  );
            }
        }
        int q =  inf - u.f;

        if( q <= T &&  u.s.f == yh - 1 && u.s.s == xh-1 )
            printf("YES\n%d\n",T-q);
        else
            printf("NO\n");

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <string>
#include <string.h>
#include <map>
#include <cstdio>
#include <map>
#include <algorithm>
#include <set>
using namespace std;

struct edge{
    int b,c;
    edge(){};
    edge( int p1, int p2 ):b(p1),c(p2){};
};

typedef long long ll;

const int maxn = 100005;
const int mod = 1000000007;

int n;
vector< edge > g[maxn];
int mem[maxn];
int solu = 0;

int solve( int node , int dad ){

    int sol = 0;

    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i].b;
        int w = g[node][i].c;
        if( nxt == dad ) continue;

        int solret = (solve( nxt , node ) * (ll)w + w)%mod;
        solu = (solu + sol * (ll)solret)%mod;
        sol = (sol+solret)%mod;
    }

    solu = (solu+sol)%mod;
    return mem[node] = sol;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);

    for( int i = 0; i < n-1; ++i ){
        int a,b,c; scanf("%d%d%d",&a,&b,&c);
        g[a].push_back( edge(b,c) );
        g[b].push_back( edge(a,c) );
    }

    solve( 1 , -1 );
    printf("%d\n",solu);

    return 0;
}



#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <set>
#include <map>
#include <string>
#include <string.h>
#include <assert.h>
using namespace std;

const int maxn = 100000 + 55;
const int inf = 999999999;

int tests,n;
int v[maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d",&tests);
    for( int t = 1; t <= tests; ++t ){

        int a = -1, b = inf, mx = 0;
        int sum = -1,s;

        scanf("%d",&n);
        for( int i = 0; i < n - 1; ++i ){
            scanf("%d",&v[i]);

            if( sum < 0 ) sum = 0, s = i + 1;
            sum += v[i];

            if( sum > mx || sum == mx && (i-s+2) > (b-a) ){
                a = s , b  = i + 2;
                mx = sum;
            }
        }

        if( b == inf ) printf("Route %d has no nice parts\n",t);
        else printf("The nicest part of route %d is between stops %d and %d\n",t,a,b);


    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <iomanip>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
using namespace std;

int n;
char txt[1005];

bool cnt[10];

vector< int > digs;
vector< int > mod[3];

string tryw( vector<int> &w , int lst , int rem1 , int rem2 ){
    sort( w.rbegin() , w.rend() );

    string L = string(1,'0'+lst);
    string q = "";

    for( int i = 0; i < n; ++i ){
        if( w[i] == lst ){ lst = -1; continue; }
        if( w[i] == rem1){ rem1 = -1; continue; }
        if( w[i] == rem2){ rem2 = -1; continue; }

        if( q.size() == 0 && w[i] == 0 ) continue;

        q += string(1,'0'+w[i]);
    }
    if( lst != -1 || rem1 != -1 || rem2 != -1 ) return "";
    q += L;
    return q ;
}

bool cmp( string a , string b ){
    if( a.size() < b.size() ) return true;
    else if( a.size() > b.size() ) return false;

    for( int i = 0; i < a.size(); ++i )
        if( a[i] < b[i] ) return true;
        else if( a[i] > b[i] ) return false;
    return false;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        digs.clear();
        memset( cnt , 0 , sizeof(cnt));
        for( int i = 0; i < 3; ++i )mod[i].clear();

        scanf("%s",txt);
        n = strlen(txt);


        int ss = 0;

        for( int i = 0; i < n; ++i ){
            int d = txt[i] - '0';
            cnt[ d ] ++;
            digs.push_back( d );
            mod[ d % 3 ].push_back( d );
            ss += d;
        }

        for( int i = 0; i < 3; ++i )
            sort( mod[i].begin() , mod[i].end() );

        vector< string > sols;

        if( ss % 3 == 0 ){
            sols.push_back( tryw( digs, 0, -1, -1 ) );
            sols.push_back( tryw( digs, 5, -1, -1 ) );
        }else if( ss % 3 == 1 ){

            for( int i = 1; i < 10; i += 3 ){
                sols.push_back( tryw( digs, 0, i, -1 ));
                sols.push_back( tryw( digs, 5, i, -1 ));
            }

            for( int i = 2; i < 10; i += 3 ){
                for( int j = i; j < 10; j += 3 ){
                    sols.push_back( tryw( digs, 0, i, j ) );
                    sols.push_back( tryw( digs, 5, i, j ) );
                }
            }

        }else{

            for( int i = 2; i < 10; i += 3 ){
                sols.push_back( tryw( digs, 0, i, -1 ));
                sols.push_back( tryw( digs, 5, i, -1 ));
            }

            for( int i = 1; i < 10; i += 3 ){
                for( int j = i; j < 10; j += 3 ){
                    sols.push_back( tryw( digs, 0, i, j ) );
                    sols.push_back( tryw( digs, 5, i, j ) );
                }
            }
        }

        sort( sols.begin() , sols.end() , cmp );

        int m = sols.size() - 1;

        if( sols[m].size() == 0 ){
            printf("impossible\n");
        }else{
            cout<<sols[m]<<endl;
        }
    }

    return 0;
}

#include <iostream>
#include <math.h>
#include <stack>
#include <map>
#include <string.h>
#include <string>
#include <iomanip>
#include <vector>
#include <set>
#include <queue>
using namespace std;

int memo[255];
int *code = memo + 128;

char givech(){
	char c;
	while( c = getchar() ){
		int q = code[c];
		if( q != -1 ) break;
	}
	return c;
}

int getv(){
	char c;
	while( (c=getchar())<'0' || c > '9' );
	int v = c - '0';
	while( (c=getchar())>='0' && c <='9' ) v = v * 10 + c - '0';
	if( code[c] != 63 ) while( c = getchar() ) if( code[c] == 63 ) break;
	return v;
}

string gstr(  ){
	
	string w = "";
	char c;
	
	while( c = givech() ){
		if( code[c] == 63 ) break;
		w += string(1,c);
	}
	return w;
}

int n;
string txt;
string image[5005];

int bits[5005];


int main(){
	//freopen("Ulaz.txt","r",stdin);

	
	memset( memo , -1 , sizeof(memo));
	
	code[' '] = 0;
	for( int i = 'A'; i <= 'Z'; ++i ) code[i] = i - 'A' + 1;
	for( int i = 'a'; i <= 'z'; ++i ) code[i] = i - 'a' + 27;
	for( int i = '0'; i <= '9'; ++i ) code[i] = i - '0' + 53;
	code['\n'] = code[EOF] = 63;
	
	int tests;
	tests = getv();
	
	for( ; tests; --tests ){
		txt = gstr();
		n = getv();
		
		int cnt = 0;
		for( int i = 0; i < txt.size(); ++i ){
			txt[i] = code[ txt[i] ];
			bits[cnt++] = txt[i]&3; txt[i] >>= 2;
			bits[cnt++] = txt[i]&3; txt[i] >>= 2;
			bits[cnt++] = txt[i]&3;
		}
		
		int now = 0;
		
		for( int i = 0; i < n; ++i ){
			string w = gstr();
			for( int k = 0; k+2 < w.size(); k += 3 ){
				w[k] -= '0' , w[k+1] -= '0' , w[k+2] -= '0';
				int d = w[k] * 100 + w[k+1] * 10 + w[k+2];
				
				
				int pix = 3;;
				if( now < cnt ) pix = bits[now++];
				
				pix = (d&252) + pix;
				
				printf("%03d",pix);
				
			}putchar('\n');
			
		}
		
	}
	
	return 0;
}

#include <iostream>
#include <math.h>
#include <cstdlib>
#include <cstdio>
#include <string>
#include <string.h>
#include <vector>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int inf = 999999999;
const int maxn = 1000000 + 55;

struct edge{
    int b,cost;
    edge(){};
    edge( int p1, int p2 ):b(p1),cost(p2){};
};

int n,m;
vector< edge > g[maxn] , rg[maxn];

int dp[maxn];
int rdp[maxn];

void dijkstra( int start , int *dp , vector< edge > g[maxn] ){

    pii u;
    dp[start] = 0;
    priority_queue< pii > pq;
    pq.push( mk(inf,0) );

    while( !pq.empty() ){
        u = pq.top(); pq.pop();

        int prev = inf - u.f;

        for( int i = 0; i < g[u.s].size(); ++i ){
            int nxt = g[u.s][i].b;
            int now = prev + g[u.s][i].cost;

            if( dp[nxt] <= now ) continue;
            dp[nxt] = now;
            pq.push( mk(inf-now,nxt) );
        }
    }
}

void init(){
    for( int i = 0; i < n; ++i ){
        dp[i] = rdp[i] = inf;
        g[i].clear();
        rg[i].clear();
    }
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&n,&m);

        init();

        for( int i = 0; i < m; ++i ){
            int a,b,c; scanf("%d%d%d",&a,&b,&c); a-- , b--;
            g[a].push_back( edge(b,c) );
            rg[b].push_back( edge(a,c) );
        }

        dijkstra( 0 , dp , g );
        dijkstra( 0 , rdp , rg );

        int sol = 0;
        for( int i = 0; i < n; ++i )
            sol += dp[i] + rdp[i];

        printf("%d\n",sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <string>
#include <string.h>
#include <math.h>
#include <cstdio>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <map>
using namespace std;

const int maxn = 1005;
const int prime = 8819;
const int mod = 100000;

int n;
char disease[maxn][25];
bool mps[maxn][mod];

inline int getkey( char *txt ){
    int ret = 0;
    int len = strlen(txt);
    for( int i = 0 ; i < len; ++i )
        ret = (ret * prime + txt[i])%mod;
    return ret;
}

int cnt[maxn];
char cause[25];

int main(){
   // freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%s",disease[i]);

        int m;
        scanf("%d",&m);
        for( int j = 0; j < m; ++j ){
            scanf("%s",cause);
            mps[i][ getkey(cause) ] = true;
        }
    }

    int tests;
    scanf("%d",&tests);
    for( int t = 1; t <= tests; ++t ){
        int m,mx(0);
        scanf("%d",&m);
        for( int i = 0; i < m; ++i ){
            scanf("%s",cause);
            int ky = getkey(cause);
            for( int k = 0; k < n; ++k ){
                if( i == 0 ) cnt[k] = 0;
                cnt[k] += mps[k][ky];
                if( mx < cnt[k] ) mx = cnt[k];
            }
        }

        printf("Diagnosis #%d:\n",t);
        for( int i = 0; i < n; ++i )
            if( cnt[i] == mx ) printf("%s\n",disease[i]);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <map>
#include <set>
#include <math.h>
#include <queue>
#include <string>
using namespace std;

const int maxn = 20000;

int n;
int dx,cnt,sol,mx;
char txt[maxn+55];

void cut( int cuts ){
    if( mx < cuts ){
        mx = cuts;
        sol = cnt;
    }

    if( n == dx ) return;

    if( txt[dx++] == '1' ){
        cnt ++;
        cut( cuts + 1 );
        cut( cuts + 1 );
    }
}

int main(){
    int tests = 10;
    for( ; tests ; --tests ){
        scanf("%d",&n);
        scanf("%s",txt);

        dx = 0, cnt = 0, mx = 0, sol = 0;
        cut( 0 );

        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 100500;

int tree[maxn+500];

void update( int dx , int val ){
    for( dx += 5; dx <= maxn; dx += dx & -dx )
        tree[dx] = max( tree[dx] , val );
}

int read( int dx ){
    int ret = 0;
    for( dx += 5; dx >= 1; dx -= dx & -dx )
        ret = max( ret , tree[dx] );
    return ret;
}

int n;
int v[maxn];
int dp[maxn];

bool inc[maxn];
int maxx[maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests = 10;
    for( ; tests; --tests ){
        memset( maxx , -1 , sizeof(maxx));
        memset( inc , false , sizeof(inc));
        memset( dp , 0 , sizeof(dp));
        memset( tree , 0 , sizeof(tree));

        int sol = 0;
        scanf("%d",&n);
        for( int i = 0; i < n; ++i ){
            scanf("%d",&v[i]);
            int x = read( v[i] - 1 );

            sol = max( sol , x + 1 );
            dp[i] = x + 1;
            update( v[i] , x + 1 );
        }

        memset( maxx , -1 , sizeof(maxx));

        for( int i = n-1; i >= 0; --i ){
            if( dp[i] == sol ){
                inc[ v[i] ] = true;
                maxx[ sol ] = max( maxx[sol] , v[i] );
            }else{
                int r = dp[i];
                int mx = maxx[ r + 1 ];

                if( mx <= v[i] ) continue;

                maxx[ r ] = max( maxx[ r ] , v[i] );
                inc[ v[i] ] = true;
            }
        }

        int cnt = 0;
        for( int i = 1; i <= n; ++i ) if( inc[i] )cnt++;

        printf("%d\n",cnt);
        for( int i = 1; i <= n; ++i )
            if( inc[i] )printf("%d ",i);

        printf("\n");

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <string>
#include <string.h>
#include <stack>
#include <map>
using namespace std;

const int maxn = 100005;
const int inf = 999999999;

int n;
int a[maxn];

int main(){
	//freopen("Ulaz.txt","r",stdin);
   
	int tests;
	scanf("%d",&tests);   

	for( ; tests; --tests ){
		
		scanf("%d",&n);
		for( int i = 0; i < n; ++i )
			scanf("%d",&a[i]);
			
		int mx = -inf;
		int sum = 0;
		for( int i = 0; i < n; ++i ){
			if( sum < 0 ) sum = 0;
			sum += a[i];
			mx = max( mx , sum );
		}
		
			
		int prev = 0;
		int cprev = 0;
		long long sol = 0;
		
		for( int i = n-1; i >= 0; --i ){
			int now = a[i];
			int cnow = 1;
			
			if( prev >= 0 ) cnow += cprev - 1, now += prev;
			if( a[i] == a[i] + prev ) cnow ++;
			
			if( now == mx ) sol += cnow;
			cprev = cnow;
			prev = now;
			
		}
		
		printf("%d %lld\n",mx,sol);
		
	}
   
	return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <stack>
#include <map>
#include <algorithm>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

int h,w;

int main(){
    freopen("Ulaz.txt","r",stdin);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&h,&w);

        if( h < w ){
            if( h % 2 == 0 )printf("L\n");
            else printf("R\n");
        }else if( h > w ){
            if( w % 2 == 0 )printf("U\n");
            else printf("D\n");
        }else{
            if( w % 2 == 0 )printf("L\n");
            else printf("R\n");
        }

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 100000 + 500;
const int maxc = 100000 + 5;
const int inf  = 999999999;

int n;
int v[maxn];
int sz[maxn];
int lvl[maxn];
int prv[maxn];
vector< int > g[maxn];

inline void readi( int &v ){
    char c;
    while( (c=getchar())<'0' || c > '9' ) if( c == '-' ) break;
    int minus = 1;
    if( c == '-' ) minus = -1;
    int w = 0;
    while( (c=getchar())>='0' && c <
}

struct cvor{
    int maxx,lsum,rsum,tot;
    cvor(){};
    cvor( int val ){ maxx = lsum = rsum = tot = val; }
    cvor( int maxx_, int lsum_, int rsum_, int tot_ )
        :maxx(maxx_),lsum(lsum_),rsum(rsum_),tot(tot_){};
};

bool overlap( int f, int s, int f1, int s1 ){
    if( f <= f1 && f1 <= s ) return true;
    if( f <= s1 && s1 <= s ) return true;
    if( f1 < f  && s < s1  ) return true;
    return false;
}


struct segment_tree{
    int begin;
    vector< cvor > tree;
    vector< int > mem;

    void init( int n ){
        int sz = 1;
        while( sz < n ) sz <<= 1;
        begin = sz;
        sz <<= 1;
        tree.resize(sz,0);
        mem.resize(sz,-inf);
    }


    segment_tree(){};

    segment_tree( int n ){ init( n ); }

    int L,R,val;

    cvor _query( int node, int lo, int hi ){

        //cout<<node<<" "<<lo<<" "<<hi<<" [ "<<mem[node]<<" ] "<<endl;
         //cout<<node<<" = "<<tree[node].maxx<<","<<tree[node].lsum<<","<<tree[node].rsum<<","<<tree[node].tot<<endl;
        if( L <= lo && hi <= R )return tree[node];

        if( node >= begin || hi < L || R < lo  )return cvor(0);

        int mid = (lo+hi)>>1;


        if( mem[node] != -inf ){
            tree[node*2] = tree[node*2+1] = mem[node]*(mid-lo+1);
            mem[node*2] = mem[node*2+1] = mem[node];
            mem[node] = -inf;
        }

        cvor LE(0),RI(0);
        if( overlap(lo,mid,L,R) ) LE = _query( node*2 , lo , mid );
        if( overlap(mid+1,hi,L,R) ) RI = _query( node*2+1 , mid+1 , hi );

        tree[node].maxx = max( tree[node*2].rsum+tree[node*2+1].lsum , max( tree[node*2].maxx , tree[node*2+1].maxx ));
        tree[node].lsum = max( tree[node*2].lsum , tree[node*2].tot + tree[node*2+1].lsum );
        tree[node].rsum = max( tree[node*2+1].rsum , tree[node*2+1].tot + tree[node*2].rsum );
        tree[node].tot = tree[node*2].tot + tree[node*2+1].tot;

        cvor ret;
        ret.maxx = max( LE.rsum+RI.lsum , max( LE.maxx , RI.maxx ));
        ret.lsum = max( LE.lsum , LE.tot + RI.lsum );
        ret.rsum = max( RI.rsum , RI.tot + LE.rsum );
        ret.tot =  RI.tot + LE.tot;

     //   cout<<" RETURN: "<<RI.tot<<" "<<LE.tot<<endl;

        return ret;
    }

    void _update( int node, int lo , int hi ){

        //cout<<node<<" "<<lo<<" "<<hi<<endl;

        if( L <= lo && hi <= R ){
            //cout<<"SET!"<<endl;
            mem[node] = val;
            tree[node] = val * (hi-lo+1);
            return;
        }

        if( node >= begin || hi < L || R < lo  ) return;

        int mid = (lo+hi)>>1;


        if( mem[node] != -inf ){
            tree[node*2] = tree[node*2+1] = mem[node]*(mid-lo+1);
            mem[node*2] = mem[node*2+1] = mem[node];
            mem[node] = -inf;
        }

        if( overlap(lo,mid,L,R) ) _update( node*2 , lo , mid );
        if( overlap(mid+1,hi,L,R) ) _update( node*2+1 , mid+1 , hi );

        tree[node].maxx = max( tree[node*2].rsum+tree[node*2+1].lsum , max( tree[node*2].maxx , tree[node*2+1].maxx ));
        tree[node].lsum = max( tree[node*2].lsum , tree[node*2].tot + tree[node*2+1].lsum );
        tree[node].rsum = max( tree[node*2+1].rsum , tree[node*2+1].tot + tree[node*2].rsum );
        tree[node].tot = tree[node*2].tot + tree[node*2+1].tot;

        //cout<<node<<" = "<<tree[node].maxx<<","<<tree[node].lsum<<","<<tree[node].rsum<<","<<tree[node].tot<<endl;
        //cout<<" L:"<<node*2<<" = "<<tree[node*2].maxx<<","<<tree[node*2].lsum<<","<<tree[node*2].rsum<<","<<tree[node*2].tot<<endl;
        //cout<<" R:"<<node*2+1<<" = "<<tree[node*2+1].maxx<<","<<tree[node*2+1].lsum<<","<<tree[node*2+1].rsum<<","<<tree[node*2+1].tot<<endl;
    }

    cvor query( int l , int r ){
        L = l + begin , R = r + begin;
        if( r < l ) return cvor(0);
        //cout<<"RANGE: "<<L<<","<<R<<endl;
        return _query( 1 , begin , (begin<<1)-1 );
    }

    void update( int l , int r , int v ){
        L = l + begin , R = r + begin;
        val = v;
        if( r < l ) return;
        _update( 1 , begin , (begin<<1)-1 );
    }

};



void input(){
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ) scanf("%d",&v[i]);

    for( int i = 0; i < n-1; ++i ){
        int a,b; scanf("%d%d",&a,&b); a--,b--;
        g[a].push_back(b);
        g[b].push_back(a);
    }
}

int dfs( int node , int dad , int L ){

    prv[node] = dad;
    lvl[node] = L;
    sz[node] = 1;

    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( nxt == dad ) continue;
        sz[node] += dfs( nxt , node , ++L );
    }

    return sz[node];
}

int hld_sz[maxc];
int root[maxc];
int map_node[maxn];
int dx[maxn];

int cnt_color = 1;

void hld( int node, int dad , int C ){
    map_node[node] = C;
    dx[node] = hld_sz[C];
    hld_sz[C]++;

    int mx = -1;
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( nxt == dad ) continue;
        if( mx == -1 || sz[mx] < sz[nxt] ) mx = nxt;
    }

    if( mx != -1 ) hld( mx , node , C );

    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( nxt == mx || nxt == dad ) continue;

        root[cnt_color] = nxt;
        hld( nxt , node , cnt_color ++ );
    }
}

segment_tree mxsum[maxc];

void filter(){
    for( int i = 0; i < cnt_color; ++i )
        mxsum[i].init( hld_sz[i] );
}

int LCA( int n1 , int n2 ){
    while( map_node[n1] != map_node[n2] ){
        int d1 = root[ map_node[n1] ];
        int d2 = root[ map_node[n2] ];

        if( lvl[d1] > lvl[d2] ){
            if( n1 == root[ map_node[n1] ] ) n1 = prv[ root[ map_node[n1] ] ];
            else n1 = root[ map_node[n1] ];
        }
        else{
            if( n2 == root[ map_node[n2] ] ) n2 = prv[ root[ map_node[n2] ] ];
            else n2 = root[ map_node[n2] ];
        }
    }
    if( lvl[n1] > lvl[n2] ) return n2;
    else return n1;
}

int set_val( int f, int t , int val ){
    //cout<<"SET_VAL "<<f<<","<<t<<","<<val<<endl;

    while( lvl[f] >=  lvl[t] ){
        int key = map_node[f];
        int i1 = root[ key ];
        if( lvl[i1] < lvl[t] ) i1 = t;

        //cout<<"UPDATE [ "<<key<<" ] from "<<dx[i1]<<" to "<<dx[f]<<" | "<<i1<<" to "<<f<<endl;
        mxsum[key].update( dx[i1] , dx[f] , val );

        if( i1 == t ) break;
        f = prv[i1];
    }
}

cvor get_val( int f , int t , bool allow_root ){
    //cout<<" ----------------------------- \n";
    cvor now(0);
    //cout<<allow_root<<" , "<<f<<" "<<t<<" | "<<lvl[f]<<" "<<lvl[t]<<endl;

    while( ( allow_root && lvl[f] >= lvl[t]) || lvl[f] > lvl[t] ){
        int key = map_node[f];
        int i1 = root[ key ];
        if( lvl[i1] < lvl[t] ) i1 = t;

        int F = dx[i1];
        if( i1 == t && allow_root == 0 ) F++;

        cvor Q = mxsum[key].query( F , dx[f] );
        cvor nxt;
        //cout<<"QUERY [ "<<key<<" ] from "<<F<<" to "<<dx[f]<<" char:     ("<<i1<<","<<f<<")"<<endl;
        //cout<<Q.maxx<<" "<<Q.lsum<<" "<<Q.rsum<<" "<<Q.tot<<endl;
        nxt.maxx = max( Q.rsum+now.lsum , max( now.maxx , Q.maxx ));
        nxt.lsum = max( Q.lsum , Q.tot + now.lsum );
        nxt.rsum = max( now.rsum , now.tot + Q.rsum );
        nxt.tot = Q.tot + now.tot;

        now = nxt;

        if( i1 == t ) break;
        f = prv[i1];
    }
    return now;
}

void do_queries(){

    int m;
    scanf("%d",&m);

    for( int i = 0; i < m; ++i ){
        int cm,a,b,c; scanf("%d",&cm);

        if( cm == 1 ){
            scanf("%d%d",&a,&b); a-- , b--;

            int common = LCA(a,b);
            //cout<<"QUERY: "<<a<<" "<<b<<" "<<common<<endl;

            cvor A = get_val( a , common , 0 ) , B = get_val( b , common , 1 );

           // cout<<A.maxx<<" "<<A.lsum<<" "<<A.rsum<<" "<<A.tot<<endl;
           //cout<<B.maxx<<" "<<B.lsum<<" "<<B.rsum<<" "<<B.tot<<endl;

            int sol = max( A.lsum+B.lsum , max( A.maxx , B.maxx ));

            printf("%d\n",sol);
        }else{
            scanf("%d%d%d",&a,&b,&c); a-- , b--;

            int common = LCA(a,b);
            //cout<<"UPDATE "<<a<<" "<<b<<" "<<c<<" , "<<common<<endl;

            set_val( a , common , c );
            set_val( b , common , c );
        }
    }
}

void map_values(){
    for( int i = 0; i < n; ++i )
        set_val( i , i , v[i] );
}

int main(){


    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    input();            //cout<<"INPUT OK"<<endl;

    dfs( 0 , -1 , 0 );  //cout<<"GETTING_SIZE OK"<<endl;

    hld( 0 , -1 , 0 );  //cout<<"HLD OK"<<endl;

    filter();           //cout<<"FILTER OK"<<endl;

    map_values();       //cout<<"MAPING VALUES OK"<<endl;

    do_queries();       //cout<<"QUERIES OK"<<endl;

    //for( int i = 0; i < n; ++i )
    //    cout<<map_node[i]<<" ";cout<<endl;
    //for( int i = 0; i < n; ++i )
    //    cout<<sz[i]<<" ";cout<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <assert.h>
using namespace std;

const int maxx = 2000;

struct bignum{
	int sz;
	short c[1000];
	
	void operator=( const bignum &b )  {
		sz = b.sz;
		for( int i = 0; i < sz; ++i )
			c[i] = b.c[i];
	}
	
	bignum(){};
	
	bignum( int v ){
		sz = 0;
		while( v ) c[sz++] = v % 10 , v /= 10;
	}
	
	bool operator>( bignum &b ){
		if( sz > b.sz ) return true;
		else if( sz < b.sz ) return false;
		
		for( int i = sz-1; i >= 0; --i )
			if( c[i] > b.c[i] ) return true;
			else if( c[i] < b.c[i] ) return false;
		
		return false;
	}
	
	void operator+( bignum &b ){
		int mx = sz;
		int mem = 0;
		if( mx < b.sz ) mx = b.sz;
		
		
		for( int i = 0; i < mx; ++i ){
			int v1 = 0 , v2 = 0;
			if( i < sz ) v1 = c[i];
			if( i < b.sz ) v2 = b.c[i];
			
			c[i] = ( mem + v1 + v2 ) % 10;
			mem  = ( mem + v1 + v2 ) / 10;
		}

		sz = mx;
		
		while( mem ){
			c[sz++] = mem % 10;
			mem /= 10;
		}
	}
	
	void write(){
		if( sz == 0 )printf("0");
		for( int i = sz-1; i >= 0; --i )
			printf("%d",c[i]);
		putchar('\n');
	}
	
};


int n,x;
char buff[5];
bignum dp[maxx+50];

bignum pw[3005];
bool was[3005];

int main(){

	bignum a = 1;
	for( int i = 0; i <= 3000; ++i ){
		pw[i] = a;
		a + a ;
	}

	//freopen("Ulaz.txt","r",stdin);

	scanf("%d",&n);
	
	bignum now = 0;
	
	
	for( int i = 0; i < n; ++i ){
		scanf("%s%d",buff,&x);
		
		if( buff[0] == 's' ){
			if( !was[x] ) continue;
			bignum q = dp[x];
			q + pw[x];
			if( q > now ) now = q;
		}else if( now > dp[x] ) dp[x] = now;
		was[x] = true;
	}
	
	now.write();
	return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
using namespace std;

typedef long long ll;

const int maxn = 100000 + 55;
const int mod = 10007;

int ss[maxn];

inline int sumatory_s1( int a , int b ){
    a--;
    return ((b*(ll)(b+1)>>1) - (a*(ll)(a+1)>>1))%mod;
}
inline int sumatory_s2( ll a , ll b ){
    int take = 0;
    if( a ) take = ss[a-1];
    return (ss[b] - take+2*mod)%mod;
}

struct segment_tree{
    int begin;
    vector< int > sum;
    vector< int > ap , bp, cp ;

    void init( int n ){
        int sz = 1;
        while( sz < n ) sz <<= 1;
        begin = sz;
        sz <<= 1;
        sum.resize(sz), ap.resize(sz), bp.resize(sz), cp.resize(sz);
    }

    segment_tree(){};
    segment_tree( int n ){ init(n); };

    int f,s,a,b,c;

    int _update( int node , int lo ,int hi ){
        int xa = lo - begin , xb = hi - begin;

        if( f <= lo && hi <= s ){
           // cout<<"NODE: "<<node<<" , "<<sumatory_s2( xa , xb )<<" ||| "<<xa<<"-"<<xb<<endl;
            ap[node] += a , bp[node] += b, cp[node] += c;
            ap[node]%=mod; bp[node]%=mod; cp[node]%=mod;
            int sseq1 = sumatory_s1( xa , xb );
            int sseq2 = sumatory_s2( xa , xb );
            int add;
            sum[node] += add=(sseq2*a + sseq1 * b + (xb-xa+1)*c)%mod;
            sum[node] %= mod;
            return add;
        }

        if( hi < f || s < lo || node >= begin ) return 0;

        int mid = (lo+hi)>>1;
        int L = node * 2 , R = node * 2 + 1;

        int add;
        sum[node] += add=(_update( L , lo   , mid ) + _update( R , mid+1, hi  ))%mod;
        sum[node] %= mod;
        return add;
    }

    int _query( int node , int lo , int hi ){
        int mid = (lo+hi)>>1;

        if( f <= lo && hi <= s )return sum[node];
        if( hi < f || s < lo || node >= begin ) return 0;

        int L = node * 2 , R = node * 2 + 1;


        int sol = 0;

        if( f <= mid && mid <= s || f <= lo && lo <= s || lo < f && s < mid ){
            int xa = max( lo , f ) - begin;
            int xb = min( mid , s ) - begin;
            int sum1 = sumatory_s1( xa , xb );
            int sum2 = sumatory_s2( xa , xb );
            sol = (sol + _query( L , lo , mid ) + sum2*ap[node] + sum1*bp[node] + (xb-xa+1)*cp[node] ) % mod;
        }

        if( f <= mid+1 && mid+1 <= s || f <= hi && hi <= s || mid+1 < f && s < hi ){
            int xa = max( mid+1 , f ) - begin;
            int xb = min( hi , s ) - begin;
            int sum1 = sumatory_s1( xa , xb );
            int sum2 = sumatory_s2( xa , xb );
            sol = (sol + _query( R , mid+1 , hi ) + sum2*ap[node] + sum1*bp[node] + (xb-xa+1)*cp[node] ) % mod;
        }

        return sol;

    }

    void update( int x0, int x1, int p1, int p2, int p3 ){
        f = begin + x0 , s = begin + x1;
        a = p1, b = p2 , c = p3;
        _update( 1 , begin , begin * 2 - 1 );
    }

    int query( int x0, int x1 ){
        f = begin + x0 , s = begin + x1;
        return _query( 1 , begin , begin * 2 - 1 );
    }

};

int n,m;
segment_tree tree;

void init(){
    tree.init(n);
    for( int i = 1; i < maxn; ++i ) ss[i] = (ss[i-1] + i*(ll)i)%mod;
}

inline void readi( int &v ){
    char c;
    while( (c=getchar())<'0' || c >'9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v= v*10+c-'0';
}

int main(){
   // freopen("Ulaz.txt","r",stdin);

    readi(n);readi(m);

    init();

    for( int i = 0; i < m; ++i ){
        int cmd; readi(cmd);

        if( !cmd ){
            int x0,x1,a,b,c; readi(x0),readi(x1),readi(a),readi(b),readi(c);
            tree.update( x0,x1,a,b,c );
        }else{
            int x0,x1; readi(x0),readi(x1);
            int sol = tree.query( x0 , x1 );
            printf("%d\n",sol);
        }

    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <math.h>
#include <string>
#include <string.h>
#include <map>
#include <algorithm>
#include <stack>
using namespace std;

const int x = 36;

int sz;
char allow[100];
int hash[255];

int n,D;
char txt[50005][5];
int h[36][36][36][36];

int d[4];
int d1[4][4][4][36][36][36];
int d2[4][4][36][36];
int d3[4][36];


int take[4][50005];

int take1[50005][4][4];
int take2[50005][4];

bool param[4];


inline int C( int dx , bool p[4] ){
    d[0] = hash[txt[dx][0]] , d[1] = hash[txt[dx][1]] , d[2] = hash[txt[dx][2]] , d[3]= hash[txt[dx][3]];

    int xa,xb,xc,xd=3;
    for( xa = 0; xa < 4; ++xa ) if( p[xa] ) break;
    for( xb = xa+1; xb < 4; ++xb ) if( p[xb] ) break;
    for( xc = xb+1; xc < 4; ++xc ) if( p[xc] ) break;

    int s = p[0] + p[1] + p[2] + p[3];

    if( s == 4 )
        return h[d[0]][d[1]][d[2]][d[3]];
    else if( s == 3 )
        return d1[xa][xb][xc][ d[xa] ][ d[xb] ][ d[xc] ];
    else if( s == 2 )
        return d2[xa][xb][ d[xa] ][ d[xb] ];
    else if( s == 1 )
        return d3[xa][ d[xa] ];
    else
        return n;
}
inline int C( int dx , bool a , bool b , bool c , bool d ){
    bool q[4];
    q[0] = a, q[1] = b, q[2] = c, q[3] = d;
    return C(dx,q);
}


int main(){
   // freopen("Ulaz.txt","r",stdin);

    for( int i = '0'; i <= '9'; ++i ){ allow[sz] = i; hash[i] = sz; sz++; }
    for( int i = 'a'; i <= 'z'; ++i ){ allow[sz] = i; hash[i] = sz; sz++; }
    allow[sz] = '.';

    scanf("%d%d",&n,&D);

    for( int i = 0; i < n; ++i ){
        scanf("%s",txt[i]);

        d[0] = hash[txt[i][0]] , d[1] = hash[txt[i][1]] , d[2] = hash[txt[i][2]] , d[3]= hash[txt[i][3]];
        h[d[0]][d[1]][d[2]][d[3]] ++;

        for( int i1 = 0; i1 < 4; ++i1 )
            for( int i2 = i1+1; i2 < 4; ++i2 )
                for( int i3 = i2+1; i3 < 4; ++i3 )
                    d1[i1][i2][i3][d[i1]][d[i2]][d[i3]]++;

        for( int i1 = 0; i1 < 4; ++i1 )
            for( int i2 = i1+1; i2 < 4; ++i2 )
                d2[i1][i2][d[i1]][d[i2]]++;

        for( int i1 = 0; i1 < 4; ++i1 )
            d3[i1][d[i1]]++;

    }


        unsigned int sol1,sol2,sol3,sol4;
        sol1 = sol2 = sol3 = sol4 = 0;

        for( int i = 0; i < n; ++i ){
            int cnt = 0;
            for( int i1 = 0; i1 < 4; ++i1 )
                for( int i2 = i1+1; i2 < 4; ++i2 )
                    for( int i3 = i2+1; i3 < 4; ++i3 ){
                        d[0] = hash[txt[i][i1]] , d[1] = hash[txt[i][i2]] , d[2] = hash[txt[i][i3]];

                        int add = d1[ i1 ][ i2 ][ i3 ][ d[0] ][ d[1] ][ d[2] ]; // svi stringovi jednaki u pozicijiama i1 i2 i3
                        add -= h[ hash[txt[i][0]] ][  hash[txt[i][1]]  ][  hash[txt[i][2]]  ][ hash[txt[i][3]] ]; // oduzmi jednake u 1 2 3 4

                        cnt += add;

                        take1[i][i1][i2] += add; // stringovi jednaki u i1 i i2 imaju add stringova gdje se poklapa i i3
                        take1[i][i1][i3] += add;
                        take1[i][i2][i3] += add;
                    }
            take[0][i] = cnt;
            sol1 += cnt;
        }


        for( int i = 0; i < n; ++i ){
            int cnt = 0;
            for( int i1 = 0; i1 < 4; ++i1 )
                for( int i2 = i1+1; i2 < 4; ++i2 ){
                    d[0] = hash[txt[i][i1]] , d[1] = hash[txt[i][i2]];

                    int add = d2[i1][i2][ d[0] ][ d[1] ];
                    add -= h[ hash[txt[i][0]] ][  hash[txt[i][1]]  ][  hash[txt[i][2]]  ][ hash[txt[i][3]] ];
                    add -= take1[i][i1][i2];

                    cnt += add;

                    take2[i][i1] += add; // rzlikukuju se po dva znaka
                    take2[i][i2] += add;
                }
            take[1][i] = cnt;
            sol2 += cnt;
        }

        bool b[4];
        b[0] = b[1] = b[2] = b[3] = false;

        for( int i = 0; i < n; ++i ){
            int cnt = 0;
            //cout<<i<<"th  =  "<<endl;
            for( int i1 = 0; i1 < 4; ++i1 ){

                b[0] = b[1] = b[2] = b[3] = false;
                b[i1] = 1;
                cnt += C(i,b[0],b[1],b[2],b[3]);
                cnt -= C(i,1,1,1,1);

                //cout<<cnt<<" ||| "<<b[0]<<" "<<b[1]<<" "<<b[2]<<" "<<b[3]<<" = "<<C(i,b[0],b[1],b[2],b[3])<<endl;

                for( int i2 = 0; i2 < 4; ++i2 ){
                    for( int i3 = i2+1; i3 < 4; ++i3 ){
                        if( i2 == i1 || i3 == i1 ) continue;
                        b[0] = b[1] = b[2] = b[3] = false;
                        b[i1] = b[i2] = b[i3] = 1;

                        //cout<<" ==> "<<C(i,b[0],b[1],b[2],b[3]) <<" , "<<C(i,1,1,1,1)<<" , "<<cnt<<endl;

                        cnt = cnt - C(i,b[0],b[1],b[2],b[3]) + C(i,1,1,1,1);
                    }
                }
                //cout<<"STAGE2: "<<cnt<<endl;

                for( int i2 = 0; i2 < 4; ++i2 ){
                    if( i2 == i1 ) continue;
                    b[0] = b[1] = b[2] = b[3] = false;
                    b[i1] = b[i2] = 1;

                    //cout<<" [[[[ "<<cnt <<" ]]]] "<<endl;
                    cnt = cnt - C(i,b[0],b[1],b[2],b[3]) + C(i,1,1,1,1);
                    //cout<<i2<<" ==== "<<cnt<<endl;
                    if( i1 != 0 && i2 != 0 ) cnt += C(i,1,b[1],b[2],b[3]) - C(1,1,1,1,1);
                    if( i1 != 1 && i2 != 1 ) cnt += C(i,b[0],1,b[2],b[3]) - C(1,1,1,1,1);
                    if( i1 != 2 && i2 != 2 ) cnt += C(i,b[0],b[1],1,b[3]) - C(1,1,1,1,1);
                    if( i1 != 3 && i2 != 3 ) cnt += C(i,b[0],b[1],b[2],1) - C(1,1,1,1,1);
                }
               // cout<<"END: "<<cnt<<endl;
            }
            take[2][i] = cnt;
            //cout<<cnt<<endl;
            sol3 += cnt;
        }

        for( int i = 0; i < n; ++i ){
            int cnt = 0;
            cnt = n;
            cnt -= h[ hash[txt[i][0]] ][  hash[txt[i][1]]  ][  hash[txt[i][2]]  ][ hash[txt[i][3]] ];
            cnt -= take[0][i];
            cnt -= take[1][i];
            cnt -= take[2][i];
            sol4 += cnt;

        }

    //cout<<sol1/2<<" "<<sol2/2<<" "<<sol3/2<<" "<<sol4/2<<endl;


    if( D == 1 ) printf("%d\n",sol1/2);
    if( D == 2 ) printf("%d\n",sol2/2);
    if( D == 3 ) printf("%d\n",sol3/2);
    if( D == 4 ) printf("%d\n",sol4/2);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
using namespace std;

typedef long long ll;

const int maxn = 2000000;
const int mod = 1000000009;

int n,d;
int *block;

int solve( int dx , int can ){
    if( dx == 0 ) return 1;

    while( can >= 0 && block[can] + d >= block[dx] ) can --;


    int sol = solve(dx-1,can);
    sol = ( sol + sol*(ll)(dx-can-1) ) % mod;

    return sol;
}

int main(){

    scanf("%d%d",&n,&d);
    for( int i = 0; i < n; ++i )
        scanf("%d",&block[i]);

    sort( block , block + n );

    printf("%d\n",solve(n-1,n-1));

    return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<vector>
#include<cstdlib>
#include<math.h>
#include<algorithm>
#include<queue>
#include<string.h>
using namespace std;

#define f first
#define s second

struct duo{
   int x,y;
   duo( int &p1, int &p2):x(p1),y(p2){};
   duo(){};
};

int d[4][2] = { 1,0  ,-1,0,  0,1,  0,-1 };

int N,S;
char mx[805][805];
int bees[805][805];
bool visited[805][805];
duo mecho,fin,u;


bool OK( int H ){
   int i,j,xt,yt,xv;
   memset(visited,false,sizeof(visited));
   pair<int,duo> u;
   queue< pair<int,duo> >Q;
   Q.push( make_pair(H*S, duo(mecho.x , mecho.y) ) );
   visited[ mecho.y ] [ mecho.x] = true;
   while(!Q.empty() ){
      u = Q.front();Q.pop();
      if( fin.x == u.s.x && fin.y == u.s.y )return true;
      for(i=0;i<4;i++){
         xt = u.s.x + d[i][0] , yt = u.s.y + d[i][1];
         if( xt>=0 && xt<N && yt>=0 && yt<N && mx[yt][xt]!='T' && visited[yt][xt]==false && u.f+1<bees[yt][xt]  ){
             visited[ yt ][ xt ] = true;
             Q.push( make_pair(u.f+1,duo(xt,yt) ) );
         }
      }
   }
   return false;
}

int main(){
   int tests;
   scanf("%d",&tests);

   for( ; tests; --tests ){
        memset( visited, false , sizeof(visited));
        memset( bees, 0 , sizeof(bees));

   int i,j,xt,yt;
   scanf("%d%d",&N,&S);

   queue< duo>Q;
   for( i=0;i<N;i++ ){
      scanf("%s",&mx[i]);
      for(j=0;j<N;j++){
         bees[i][j] = -1;
         if( mx[i][j] == 'H' ){
            bees[i][j]=0;
            Q.push( duo(j,i) );
         }else if( mx[i][j] == 'M' ){
            mecho = duo(j,i);
            mx[i][j] = 'G';
         }else if( mx[i][j] == 'D' )
            fin = duo(j,i);
      }
   }
   while( !Q.empty() ){
      u = Q.front();Q.pop();
      for(i=0;i<4;i++){
         xt = u.x + d[i][0] , yt = u.y + d[i][1];
         if( xt>=0 && xt<N && yt>=0 && yt<N && mx[yt][xt]=='G' && bees[yt][xt] == -1 ){
            bees[yt][xt] = bees[ u.y ] [ u.x ] + S;
            Q.push( duo(xt,yt) );
         }
      }
   }
   bees[fin.y][fin.x] = 99999999;
   int lo = 0 , hi = N*N , sol=-1;
   while(lo<=hi){
      int mid = (lo+hi)>>1;
      if( mid*S < bees[mecho.y][mecho.x] && OK(mid) ){
         sol = mid;
         lo = mid+1;
      }else
         hi = mid-1;
   }
   cout<<sol<<endl;

   }

  // cout<<"TIME: "<<double(clock()-T)/CLOCKS_PER_SEC<<endl;
   return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <stack>
#include <map>
#include <iomanip>
#include <string>
#include <string.h>
#include <set>
using namespace std;

typedef long long ll;
typedef long double ld;

const int maxn = 35;

int lchild[maxn], rchild[maxn];

struct node{
    int v;
    node *L,*R;
    node(){ L = NULL , R = NULL; };
    node( int w ){ v = w, L = NULL , R = NULL; };


    void insert( int val ){
        if( val > v ){
            if( R == NULL )R = new node(val), rchild[v] = val;
            else R->insert(val);
        }else{
            if( L == NULL )L = new node(val), lchild[v] = val;
            else L->insert(val);
        }
    }

};

int n;
node tree;

map<int,ld>m;

ld solve( int mask ){

    if( mask == 0 ) return 1;
    if( m.find(mask) != m.end() ) return m[mask];

    ld sol = 0;

    for( int i = 0; i < n; ++i ){
        if( mask&(1<<i) ){
            int nw = mask;
            if( lchild[i] > -1 )nw |= 1<<lchild[i];
            if( rchild[i] > -1 )nw |= 1<<rchild[i];
            nw ^= 1<<i;
            sol += solve( nw );
        }
    }
    return m[mask] = sol;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);

    int tests,root;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        m.clear();
        for( int i = 0; i < maxn; ++i ) lchild[i] = rchild[i] = -1;

        scanf("%d",&n);
        for( int i = 0; i < n; ++i ){
            int v; scanf("%d",&v); v --;

            if(!i) root = v, tree = node(v);
            else tree.insert(v);
        }

        ld sol = solve( 1<<root );
        printf("%.0llf\n",sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <string.h>
#include <vector>
#include <set>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

int w,h;
char txt[20][20];
bool mat[20][20];

void flip( int r, int c ){
    if( r  >  0 ) mat[r-1][c] = !mat[r-1][c];
    if( c  >  0 ) mat[r][c-1] = !mat[r][c-1];
    if( r+1 < h ) mat[r+1][c] = !mat[r+1][c];
    if( c+1 < w ) mat[r][c+1] = !mat[r][c+1];
    mat[r][c] = !mat[r][c];
}

vector< pii > mov;

bool solve( int r, int c ){
    if( c == w ) r ++ , c = 0;
    if( r == h ){
        bool ok = true;
        for( int i = 0; i < w && ok; ++i ) if( mat[r-1][i] == false ) ok = false;
        return ok;
    }

    if( r == 0 ||  mat[r-1][c]  ){
        if( solve( r , c + 1 ) ) return true;
    }

    if( r == 0 || !mat[r-1][c]  ){

        flip(r,c);
        if( solve( r , c + 1 ) ){
            mov.push_back( mk(c+1,r+1) );
            return true;
        }
        flip(r,c);

    }
    return false;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    while( scanf("%d%d",&w,&h) == 2 ){
        if( h == 0 && w == 0 ) continue;

        for( int i = 0; i < h; ++i )scanf("%s",txt[i]);

        for( int i = 0; i < h; ++i )
            for( int j = 0; j < w; ++j )
                mat[i][j] = txt[i][j] - '0';

        mov.clear();

        if( solve( 0 , 0 ) ){

            printf("%d\n",mov.size());
            for( int i = 0; i < mov.size(); ++i )
                printf("%d %d\n",mov[i].f,mov[i].s);
        }else{
            printf("-1\n");
        }

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <string>
#include <string.h>
#include <math.h>
#include <stack>
#include <map>
#include <algorithm>
#include <cstdio>
using namespace std;


int n;
int mat[105][105];

int solve( int now , int prev ){
    int first = prev;
    int cost = 0;

    while( now != first ){
        for( int k = 0; k < n; ++k ){
            if( mat[now][k] == -1 || k == prev ) continue;

            cost += mat[now][k];

            prev = now;
            now = k;
            break;
        }
    }
    return cost;
}


int main(){
    scanf("%d",&n);

    memset( mat , -1 , sizeof(mat));

    for( int i = 0; i < n; ++i ){
        int a,b,c; scanf("%d%d%d",&a,&b,&c); a-- , b--;
        mat[a][b] = 0 , mat[b][a] = c;

    }
    int sol = 999999;

    for( int i = 0; i < n; ++i ){
        if( mat[0][i] == -1 ) continue;
        sol = min( sol , solve( i , 0 ) + mat[0][i] );
    }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <set>
#include <iomanip>
#include <queue>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <cstdio>
using namespace std;

string w;

int main(){

    cin >> w;

    int sol = 0;
    int len = w.size();

    for( int i = 0; i < len; ++i ){
        for( int k = 1; i+k <= len; ++k ){
            int cnt = 0;
            string q = "";

            for( int j = 0; j < k; ++j )
                q += w[i+j];

            for( int j = 0; j < len; ++j )
                if( w.substr( j , k ) == q ) cnt ++;
            if( cnt >= 2 ) sol = max( sol , k );

        }
    }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <string>
#include <string.h>
#include <math.h>
#include <cstdio>
#include <stack>
#include <map>
#include <algorithm>
using namespace std;

int p[] = { 25, 18, 15, 12, 10, 8, 6, 4, 2, 1 };

map<string,int>points;
map<string,int>wins[100];

bool better1( string f , string s ){
    if( points[f] > points[s] ) return true;
    else if( points[f] < points[s] ) return false;

    for( int i = 0; i < 50; ++i ){
        if( wins[i][f] > wins[i][s] ) return true;
        else if( wins[i][f] < wins[i][s] ) return false;
    }
    return false;
}

bool better2( string f , string s ){
    if( wins[0][f] > wins[0][s] ) return true;
    else if( wins[0][f] < wins[0][s] ) return false;


    if( points[f] > points[s] ) return true;
    else if( points[f] < points[s] ) return false;

    for( int i = 1; i < 50; ++i ){
        if( wins[i][f] > wins[i][s] ) return true;
        else if( wins[i][f] < wins[i][s] ) return false;
    }
    return false;
}


int main(){
    //freopen("Ulaz.txt","r",stdin);

    int n; scanf("%d",&n);
    vector< string > s;
    for( int i = 0; i < n; ++i ){
        int m; scanf("%d",&m);
        for( int j = 0; j < m; ++j ){

            string name;
            cin >> name;
            s.push_back(name);

            wins[j][name] ++;
            if( j < 10 ) points[name] += p[j];
        }
    }

    sort( s.begin() , s.end() );
    s.erase( unique(s.begin(),s.end()),s.end());


    string win1 , win2;
    win1 = s[0] , win2 = s[0];

    for( int i = 1; i < s.size(); ++i ){
        if( better1( s[i] , win1 ) )win1 = s[i];
        if( better2( s[i] , win2 ) )win2 = s[i];
    }

    cout<<win1<<endl;
    cout<<win2<<endl;


    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <set>
#include <iomanip>
#include <queue>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <cstdio>
using namespace std;

int solve(){

}

int main(){

    int tests;
    scanf("%d",&tests);


    for( ; tests; --tests ){

        int n;
        scanf("%d",&n);


        printf("%d\n",max(0,n-2));
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <map>
#include <vector>

using namespace std;

const long long max_n = 1000001;

long long n, j, mx, my, ax[max_n], ay[max_n];

int main() {
    freopen("Ulaz.txt","r",stdin);
	cin >> n >> j >> mx >> my;
	for (long long i = 0;i < n;i++)
		cin >> ax[i] >> ay[i];
	if (j % 2 == 1) {
		mx = -mx;
		my = -my;
	}
	long long k = j % n, r = j / n;
	for (long long i = 0;i < n;i++) {
		if ((i + 1) % 2 == k % 2) {
			if (r % 2 == 1) {
				mx -= 2 * ax[i];
				my -= 2 * ay[i];
			}
			if (i < k) {
				mx += 2 * ax[i];
				my += 2 * ay[i];
			}
		}
		else {
			if (r % 2 == 1) {
				mx += 2 * ax[i];
				my += 2 * ay[i];
			}
			if (i < k) {
				mx -= 2 * ax[i];
				my -= 2 * ay[i];
			}
		}
	}
	cout << mx << " " << my << endl;
	return 0;
}

#include <iostream>
#include <vector>
#include <stack>
#include <map>
#include <algorithm>
#include <iomanip>
#include <string>
#include <string.h>
#include <fstream>
#include <queue>
#include <vector>
using namespace std;

typedef long long ll;

const int maxn = 1000000 +55;
const ll inf = 999999999999999LL;

struct edge{
    int b,cost;
    edge(){};
    edge( int p1, int p2 ):b(p1),cost(p2){};
};

int n;
edge nxt[maxn];

vector< edge > g[maxn];

bool cyc[maxn];

bool visi[maxn];
bool cvisi[maxn];


int heart;
void get_cycle( int node ){
    cvisi[node] = true;
    int next = nxt[node].b;
    if( cvisi[next] ){ heart = next; return; }
    get_cycle( next );
}

void visit_all( int node ){
    visi[node] = true;
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i].b;
        if( visi[nxt] == false ) visit_all( nxt );
    }
}

short colvisi[maxn] , color;
int wa1,wa2,nmaxi;
ll mxds;
void getmaxi( int node , ll dst ){
    if( mxds < dst ) mxds = dst, nmaxi = node;

    colvisi[node] = color;
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i].b;
        if( colvisi[nxt] != color && nxt != wa1 && nxt != wa2 ) getmaxi( nxt , dst + g[node][i].cost );
    }
}

ll treesol[maxn] , pathsol[maxn];
void longest_path( int node , int dont1 , int dont2 , int key ){
    wa1 = dont1, wa2 = dont2;

    color = 1, nmaxi = -1, mxds = -1;
    getmaxi( node , 0 );
    pathsol[key] = mxds;

    color = 2, mxds = -1;
    getmaxi( nmaxi , 0 );
    treesol[key] = mxds;
}

ll sums[maxn];

ll call_one( int node ){
    vector< int > w;
    w.push_back( heart );

    cyc[node] = true, sums[0] = 0;

    int prev = heart , now = nxt[heart].b;
    while( now != heart ){
        w.push_back( now ); int sz = w.size();

        sums[sz-1] = sums[sz-2] + nxt[ prev ].cost;
        cyc[now] = true;

        prev = now;
        now = nxt[now].b;
    }

    ll sol = 0;
    int m = w.size(), spoj = nxt[prev].cost;

    ll tot = sums[ w.size() - 1 ] + spoj;
    ll pmax = -inf;
    ll pmax2 = -inf;
    sol = 0;

    for( int i = 0; i < m; ++i ){
        int pdx = ((i-1)+m)%m;
        int fdx = (i+1)%m;
        longest_path( w[i] , w[pdx] , w[fdx] , i );
        sol = max( sol , treesol[i] );

        sol = max( sol , pmax + pathsol[i] + sums[i] );
        sol = max( sol , pmax2+ pathsol[i] - sums[i] + tot );

        pmax = max( pmax , pathsol[i] - sums[i] );
        pmax2= max( pmax2, pathsol[i] + sums[i] );
    }

    return sol;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        int b,c; scanf("%d%d",&b,&c);--b;   nxt[i].b = b; nxt[i].cost = c;
        g[i].push_back( edge(b,c) );
        g[b].push_back( edge(i,c) );
    }

    ll sol = 0;

    for( int i = 0; i < n; ++i ){
        if( g[i].size() == 1 && visi[i] == false ){
            get_cycle( i );
            visit_all( i );
            sol += call_one ( i );
        }
    }

    for( int i = 0; i < n; ++i ){
        if( visi[i] == false ){
            get_cycle( i );
            visit_all( i );
            sol += call_one( i );
        }
    }

    printf("%lld\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <map>
#include <iomanip>
#include <string>
#include <algorithm>
#include <string.h>
#include <cstdio>
using namespace std;


const int maxn = 600055;
const int inf = 99999999;


struct fenwick{
    int*arr,sz;

    fenwick(){};

    fenwick( int n ){
        sz = n;
        arr = new int[n];
    }

    void init( int val ){
        for( int i = 0; i < sz; ++i ) arr[i] = val;
    }

    void update( int idx , int val ){
        for( idx += 5; idx < sz; idx += idx & -idx )
            arr[idx] = max( arr[idx], val );
    }

    int read( int idx ){
        int ret = -inf;
        for( idx += 5; idx >= 1; idx -= idx & -idx )
            ret = max( ret , arr[idx] );
        return ret;
    }

};

struct market{
    int t,l,m;
    market(){};
    market( int p1, int p2, int p3 ):t(p1),l(p2),m(p3){};

    bool operator<( const market &m2 ) const {
        return t < m2.t || ( t == m2.t && l < m2.l );
    }
};


int n,d,u,s;

int t[maxn+50];
int l[maxn+50];
int m[maxn+50];
int ss[maxn+50];

vector< market > shed;

fenwick gore,dole;


int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    scanf("%d%d%d%d",&n,&d,&u,&s);

    for( int i = 0; i < n; ++i ){
        ss[i] = -inf;
        scanf("%d%d%d",&t[i],&l[i],&m[i]);
        shed.push_back( market( t[i] , l[i] , m[i] ) );
    }

    gore = fenwick( maxn );
    dole = fenwick( maxn );
    gore.init( -inf );
    dole.init( -inf );

    sort( shed.begin() , shed.end() );

    int mxg = 600000;
    int solution = 0;

    gore.update( mxg - s , - d*s );
    dole.update( s , + u*s );

    for( int i = 0; i < n; ++i ){
        int hi = gore.read( mxg-shed[i].l );
        int lo = dole.read( shed[i].l );


        int sol = -inf;
        hi = hi + shed[i].m + d*shed[i].l;
        lo = lo + shed[i].m - u*shed[i].l;
        sol = max( hi , lo );

        ss[i] = sol;

        if( shed[i].l < s ) solution = max(  solution , sol - (s-shed[i].l)*u );
        else solution = max( solution , sol - (shed[i].l-s)*d );


        if( i+1 == n || shed[i+1].t != shed[i].t ){
            int now = -inf;
            int k;
            for( k = i; k >= 0 && shed[i].t == shed[k].t; --k ){
                int yprev = inf;
                if( k + 1 <= i ) yprev = shed[k+1].l;

                now = max(  ss[k] , now + shed[k].m - (yprev-shed[k].l)*d  );

                if( shed[k].l < s ) solution = max(  solution , now - (s-shed[k].l)*u );
                else solution = max( solution , now - (shed[k].l-s)*d );

                gore.update( mxg-shed[k].l , now - d*shed[k].l );
                dole.update( shed[k].l , now + u*shed[k].l );
            }
            ++k;
            now = -inf;

            for( ; k <= i ; ++k ){
                int yprev = -inf;
                if( k-1>= 0 && shed[k - 1].t == shed[k].t ) yprev = shed[k-1].l;

                now += shed[k].m - (shed[k].l-yprev)*u;
                now = max(  ss[k] , now  );

                if( shed[k].l < s ) solution = max(  solution , now - (s-shed[k].l)*u );
                else solution = max( solution , now - (shed[k].l-s)*d );

                gore.update( mxg-shed[k].l , now - d*shed[k].l );
                dole.update( shed[k].l , now + u*shed[k].l );
            }
        }
    }


    printf("%d\n",solution);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <map>
#include <iomanip>
#include <string>
#include <algorithm>
#include <string.h>
#include <cstdio>
using namespace std;


const int maxn = 600055;
const int inf = 999999999;


struct fenwick{
    int*arr,sz;

    fenwick(){};

    fenwick( int n ){
        sz = n;
        arr = new int[n];
    }

    void init( int val ){
        for( int i = 0; i < sz; ++i ) arr[i] = val;
    }

    void update( int idx , int val ){
        for( idx += 5; idx < sz; idx += idx & -idx )
            arr[idx] = max( arr[idx], val );
    }

    int read( int idx ){
        int ret = -inf;
        for( idx += 5; idx >= 1; idx -= idx & -idx )
            ret = max( ret , arr[idx] );
        return ret;
    }

};

struct market{
    int t,l,m;
    market(){};
    market( int p1, int p2, int p3 ):t(p1),l(p2),m(p3){};

    bool operator<( const market &m2 ) const {
        return t < m2.t || ( t == m2.t && l < m2.l );
    }
};


int n,d,u,s;

int t[maxn+50];
int l[maxn+50];
int m[maxn+50];
int ss[maxn+50];

vector< market > shed;
vector< market > she;

fenwick gore,dole;


int main(){
    freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    scanf("%d%d%d%d",&n,&d,&u,&s);

    for( int i = 0; i < n; ++i ){
        ss[i] = -inf;
        scanf("%d%d%d",&t[i],&l[i],&m[i]);
        shed.push_back( market( t[i] , l[i] , m[i] ) );
    }

    int tren = -1;

    do{
        for( int i = 1; i < (1<<n); ++i ){

            bool ok = true;
            she.clear();
            for( int k = 0; k < n; ++k ){
                if( k && shed[k].t < shed[k-1].t ) ok = false;
                if( i & (1<<k) )
                    she.push_back( shed[k] );
            }

            int m = she.size();

            if( !ok ) continue;

            int sol = 0;
            if( she[0].l > s ) sol -= (she[0].l - s )*u;
            else sol -= (s-she[0].l)*d;

            sol += she[0].m;

            for( int i = 0; i < m-1; ++i ){
                sol += she[i+1].m;
                if( she[i].l > she[i+1].l ) sol -= (she[i].l - she[i+1].l )*d;
                else sol -= (she[i+1].l-she[i].l)*u;
            }

            if( she[m-1].l > s ) sol -= (she[m-1].l - s )*d;
            else sol -= (s-she[m-1].l)*u;

            if( sol == 8148 ){
                tren = sol;
                cout<<"  "<<sol<<endl;
                for( int k = 0; k < m; ++k )
                    cout<<"     "<<shed[k].t<<" "<<shed[k].l<<endl;
            }
        }

    }while( next_permutation( shed.begin() , shed.end())  );

    //printf("%d\n",solution);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <fstream>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <iomanip>
#include <map>
#include <algorithm>
#include <assert.h>
using namespace std;

const int maxn = 2000000+55;

int n,m;
int mp[maxn];
bool x[maxn];
int rx[maxn];


int g[maxn];


int cnt;
bool visi[maxn];


inline void readi( int &v ){
    char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
}

int ss[maxn];

int main(){
   // freopen("Ulaz.txt","r",stdin);

    scanf("%d%d",&n,&m);


    for( int i = 0; i < n; ++i ){
        int a,b; readi(a); readi(b);
        mp[a] = b, mp[b] = a;
        x[a] = x[b] = true;
    }

    int n2 = maxn , ccnt = 0;
    for( int i = 0; i <= n2; ++i ){
        if( x[i] == false )continue;
        ccnt ++;
        rx[i] = ccnt;
    }

    ccnt = -1;
    for( int i = 0; i <= n2; ++i ){
        if( x[i] == 0 ) continue;
        ccnt ++;
        int key = rx[ mp[i] ];
        g[ccnt] = key;
    }

    int sol = 0;

    for( int i = 0; i <= (n<<1); ++i ){
        if( visi[i] ) continue;
        cnt = 0;

        int node = i;
        visi[node] = true;

        while( 1 ){
            int nxt = g[node];
            cnt++;
            if( visi[nxt] ) break;
            visi[nxt]  = 1;
            node = nxt;
        }

        if( !i ) sol = cnt - 1;
        else ss[ cnt ] ++;
    }

    for( int i = maxn; i >= 1 && m; --i ){
        for( int k = 0; k < ss[i] && m; ++k ){
            sol += i + 2;
            m--;
        }
    }

    sol += 2 * m;
    sol -= m % 2 ;

    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <fstream>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <iomanip>
#include <map>
#include <algorithm>
#include <assert.h>
using namespace std;

const int maxn = 2000000;

bool used[maxn];

int main(){
    ofstream cout("Ulaz.txt");

    int n = 1000000;
    int m = 1000000;

    cout<<n<<" "<<m<<endl;

    for( int i = 0; i < n; ++i ){
        int a = 1 , b = 1;

        while(1){
            a = 1+rand()%maxn;
            if( used[a] == false ) break;
        }
        used[a] = true;

        while(1){
            b = 1+rand()%maxn;
            if( used[b] == false ) break;
        }
        used[b] = true;

        cout<<min(a,b)<<" "<<max(a,b)<<endl;

    }


    return 0;
}


#include <iostream>

#include <queue>

#include <cstring>
#include <string>
#include <cstdlib>
#include <string.h>
#include <algorithm>
#include <vector>
#include <fstream>

using namespace std;

#define MAXK 2000003

#define MAXN 1000001



typedef pair<int,int>pii;

typedef vector<pii>vii;



int n;

int B[MAXN],out[MAXK],res,x,st,c,cnt[MAXK],k,A[MAXN],mini,maxi,m,tmpa,tmpb;

bool vis[MAXK];

string s;



inline int max(int a,int b){

    if (a>b) return a;

    return b;

}



inline int min(int a,int b){

    if (a<b) return a;

    return b;

}



inline void rename(){

    int st=1;

    for (int i=mini;i<=maxi;i++){

        if (vis[i]){

            out[i]=st++;

            vis[i]=0;

        }

    }

    for (int i=0;i<n;i++){

        A[i]=out[A[i]]-1;

        B[i]=out[B[i]]-1;

    }

}



int main(){
    freopen("Ulaz.txt","r",stdin);

    scanf("%d %d",&n,&m);

    mini=2*(int)1e9;

    getline(cin,s);

    for (int i=0;i<n;i++){

        getline(cin,s);

        bool flip=0;

      for (int j=0;s[j];j++){

        if (s[j]==' ') flip=1;

        else if (!flip) A[i]=A[i]*10+(s[j]-'0');

        else B[i]=B[i]*10+(s[j]-'0');

      }

        vis[A[i]]=vis[B[i]]=1;

        mini=min(mini,A[i]);

        maxi=max(maxi,B[i]);

    }

    //cout<<mini<<' '<<maxi<<endl;

    rename();

    for (int i=0;i<n;i++){

        out[A[i]]=B[i]+1;

        out[B[i]]=A[i]+1;

    }

    /*cout<<"Z"<<endl;

    for (int i=0;i<n;i++){

      cout<<A[i]<<' '<<B[i]<<' '<<out[A[i]]<<' '<<out[B[i]]<<endl;

    }

    cout<<"BLA"<<endl;*/

    x=0;

    res=0;

    //count+simulate the teleporters

    //cout<<endl;

    while (x<2*n){

        res++;

        vis[x]=1;

        //cout<<x<<' '<<out[x]<<endl;

        x=out[x];

    }

    //cout<<endl;

    priority_queue<pii,vii,less<pii> >pq;

    maxi=0;

    for (int i=0;i<2*n;i++){

        if (vis[i]) continue;

        //find inner loop

        x=i;

        st=x;

        c=0;

        do {

            c++;

            vis[x]=1;

            x=out[x];

        } while (x!=st);

        cnt[c+2]++;

        maxi=max(maxi,c+2);

        //pq.push(pii(c+2,cnt[c+2]));

    }

    for (int i=0;i<=maxi;i++) pq.push(pii(i,cnt[i]));

    while (!pq.empty()){

        pii top=pq.top();

        pq.pop();

        if (m>=top.second){

            m-=top.second;

            res+=top.first*top.second;

        }

        else {

            res+=m*top.first;

            m=0;

        }

        if (m==0) break;

    }

    res+=2*m;

    res-=(m%2);

    printf("%d\n",res);


    return 0;

}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <map>
#include <algorithm>
#include <string.h>
#include <string>
#include <iomanip>
using namespace std;

const int lg = 17;
const int maxn = 50000;
const int inf = 999999999;

struct node{
    int maxx,left,right,tot;
    node(){};
    node( int p1, int p2, int p3, int p4 ):maxx(p1),left(p2),right(p3),tot(p4){};
};

struct segment_tree{
    int begin,lq,rq;
    vector< node > tree;

    segment_tree(){};

    segment_tree( int n ){
        int sz = 1;
        while( sz < n ) sz <<= 1;

        begin = sz;
        sz <<= 1;

        tree.resize( sz );
    }

    void init( int *arr , int n ){
        for( int i = 0; i < n; ++i )
            tree[begin+i].maxx = tree[begin+i].left =
            tree[begin+i].right= tree[begin+i].tot  = arr[i];

        for( int i = begin-1; i >= 1; --i ){
            int L = i<<1;
            int R = (i<<1)+1;

            tree[i].left  = max( tree[L].left , tree[L].tot + tree[R].left );
            tree[i].right = max( tree[R].right , tree[R].tot + tree[L].right );
            tree[i].tot   = tree[L].tot + tree[R].tot;
            tree[i].maxx  = max( tree[L].maxx , tree[R].maxx );
            tree[i].maxx  = max( tree[i].maxx , tree[L].right + tree[R].left );
        }
    }

    node _query( int dx , int lo , int hi ){

        if( lo >= (begin<<1) ) return node(-inf,-inf,-inf,-inf);
        if( lq <= lo && hi <= rq ) return tree[dx];

        int mid = (lo+hi)>>1;
        if( lq <= mid && mid < rq ){
            node n1,n2;
            n1 = _query( dx*2, lo , mid );
            n2 = _query( dx*2+1, mid+1, hi );

            node ret = node(-inf,-inf,-inf,-inf);

            ret.left  = max( n1.left , n1.tot + n2.left );
            ret.right = max( n2.right , n2.tot + n1.right );
            ret.tot   = n1.tot + n2.tot;
            ret.maxx  = max( n1.maxx , n2.maxx );
            ret.maxx  = max( ret.maxx , n1.right + n2.left );

            return ret;
        }

        if( lq <= mid ) return _query( dx*2 , lo , mid );
        else  if( mid < rq )return _query( dx*2+1, mid + 1 , hi );

        return node(-inf,-inf,-inf,-inf);
    }

    node query( int L , int R ){
        lq = L + begin;
        rq = R + begin;
        return _query( 1 , begin , begin * 2 - 1 );
    }


    void modify( int dx , int val ){
        dx += begin;
        tree[dx] = node(val,val,val,val);

        while( dx != 1 ){
            dx >>= 1;

            int L = dx<<1;
            int R = (dx<<1)+1;

            tree[dx].left  = max( tree[L].left , tree[L].tot + tree[R].left );
            tree[dx].right = max( tree[R].right , tree[R].tot + tree[L].right );
            tree[dx].tot   = tree[L].tot + tree[R].tot;
            tree[dx].maxx  = max( tree[L].maxx , tree[R].maxx );
            tree[dx].maxx  = max( tree[dx].maxx , tree[L].right + tree[R].left );
        }

    }

};


int n , arr[maxn];
segment_tree T;

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int i = 0; i < n; ++i )
        scanf("%d",&arr[i]);

    T = segment_tree( n );
    T.init( arr , n );

    int m;scanf("%d",&m);

    for( int i = 0; i < m; ++i ){
        int c,a,b;
        scanf("%d%d%d",&c,&a,&b);

        if( c == 0 ){
            a--;
            T.modify( a , b );
        }else{
            a--,b--;
            printf("%d\n",T.query(a,b).maxx);
        }

    }


    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <iomanip>
#include <set>
#include <vector>
using namespace std;

int n,s;

int ef( int n ){return n * (n-1) >> 1; }

int main(){
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        scanf("%d%d",&n,&s);
        int as = abs(s);

        int ss = ef( n );
        if( as > ss ){
            printf("No\n");
            continue;
        }

        if( ss % 2 != as % 2 ){
            printf("No\n");
            continue;
        }

        int now = 0;
        printf("%d\n",now);

        while( 1 ){
            n --;
            if( !n ) break;
            now --;
            ss = now*n + ef(n);
            if( ss < s ) now += 2;
            s -= now;
            printf("%d\n",now);
        }

        if( tests >= 2 ) printf("\n");

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <string>
#include <string.h>
#include <map>
#include <stack>
using namespace std;

char txt[1000];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);

    while( scanf("%s",txt) == 1 ){
        printf("300 420 moveto\n");
        printf("310 420 lineto\n");

        int state = 0;
        // 0 - right
        // 1 - up
        // 2 - lef
        // 3 - down

        int x = 310, y = 420;

        for( int i = 0; i < strlen(txt); ++i ){
            if( state == 0 ){
                if( txt[i] == 'A' ) y -= 10, state = 3;
                else y += 10, state = 1;
            }else if( state == 1 ){
                if( txt[i] == 'A' ) x += 10, state = 0;
                else x -= 10, state = 2;
            }else if( state == 2 ){
                if( txt[i] == 'A' ) y += 10, state = 1;
                else y -= 10, state = 3;
            }else{
                if( txt[i] == 'A' ) x -= 10, state = 2;
                else x += 10, state = 0;
            }

            printf("%d %d lineto\n",x,y);
        }

        printf("stroke\n");
        printf("showpage\n");

    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <set>
#include <queue>
#include <math.h>
#include <map>
#include <algorithm>
#include <vector>
#include <string>
#include <string.h>
using namespace std;

#define pii pair<int,int
#define f first
#define s second
#define mk make_pair

const int maxn = 100;
const int inf = 99999999;

int n,e,t,m;
int mat[maxn+50][maxn+50];

void init(){
    for( int i = 0; i <= n; ++i )
        for( int j = 0; j <= n; ++j )
            mat[i][j] = inf;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d%d%d%d",&n,&e,&t,&m);
    init();

    for( int i = 0; i < m; ++i ){
        int a,b,c; scanf("%d%d%d",&a,&b,&c); a-- , b--;
        mat[a][b] = c;
    }

    for( int i = 0; i < n; ++i )
        mat[i][i] = 0;

    for( int k = 0; k < n; ++k )
        for( int i = 0; i < n; ++i )
            for( int j = 0; j < n; ++j )
                mat[i][j] = min( mat[i][j] , mat[i][k] + mat[k][j] );

    int sol = 0;

    for( int i = 0; i < n; ++i ){
        int dst = mat[i][e-1];
        if( dst <= t ) sol ++;
    }

    printf("%d\n",sol);


    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
using namespace std;

typedef long long ll;

int tests,n;

int main(){
    int t = 0;

   while( scanf("%d",&n) ){
        if( n == 0 ) break;

        if( n == 1 ){
            printf("%d\n",1);
            continue;
        }

        ll s = (ll)round( pow(n,n-2) );

        t++;
        printf("Case %d, N = %d, # of different labelings = %lld\n",t,n,s);
    }

    return 0;
}

#include <iostream>
#include <fstream>
#include <math.h>
#include <algorithm>
#include <stack>
#include <map>
#include <vector>
#include <set>
#include <string>
#include <string.h>
using namespace std;

typedef unsigned int ui;
typedef long long ll;

const int mod = 65536;

int n;

int x;
char buff[5];

int main(){
   while( scanf("%d",&n) == 1 ){
      if( n == 0 ) break;
      
      
      ll k = 1 , m = 0;
      
      for( int i = 0; i < n; ++i ){
         scanf("%s%d",buff,&x);
         
         if( strcmp(buff,"ADD") == 0 )
            m = (m+x)%mod;
         else
            k = (k*x)%mod , m = (m*x)%mod;
          
      }
      
      
      vector< int > fin;
      for( int i = 0; i < mod; ++i )
         fin.push_back( (i*k + m )%mod );
      
      sort( fin.begin() , fin.end() );
      fin.erase( unique(fin.begin(),fin.end()),fin.end() );
      
      printf("%d\n",(int)fin.size());
      
   }
   
   return 0;
}

#include <iostream>
#include <vector>
#include <string>
#include <string.h>
#include <map>
#include <cstdio>
#include <map>
#include <algorithm>
#include <set>
#include <assert.h>
using namespace std;

const int maxn = 10000 + 55;

struct answer{
    int id;
    bool ans;
    answer(){};
    answer( int p1, bool p2 ):id(p1),ans(p2){};
};

int n,m;
int a[maxn],b[maxn],c[maxn],d[maxn];
vector< answer > g[2][205];

int state[205];
bool noinf;

void dfs( int node , bool istrue ){

    state[node] = istrue;

    for( int i = 0; i < g[1][node].size() && !noinf; ++i ){
        int w = g[1][node][i].id;
        bool nxt;

        if( istrue ) nxt = !g[1][node][i].ans;
        else nxt = g[1][node][i].ans;

        if( state[w] != -1 ){
            if( state[w] != nxt ) noinf = true;
            continue;
        }

        dfs( w , nxt );
    }

    for( int i = 0; i < g[0][node].size() && !noinf; ++i ){
        int w = g[0][node][i].id;
        bool nxt;

        if( istrue ) nxt = g[0][node][i].ans;
        else nxt = !g[0][node][i].ans;

        if( state[w] != -1 ){
            if( state[w] != nxt ) noinf = true;
            continue;
        }

        dfs( w ,  nxt );
    }
}

int digs[50000],sz=0;

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz2.txt","w",stdout);
    int tests;
    scanf("%d",&tests);

    for( ;tests; --tests ){

        scanf("%d%d",&n,&m);

        for( int i = 0; i <= 204; ++i ){
                g[0][i].clear(); g[1][i].clear();
        }


        for( int i = 0; i < n; ++i ){
            int a,b,c,d;scanf("%d%d%d%d",&a,&b,&c,&d); a--,c--;
            ::a[i] = a, ::b[i] = b, ::c[i] = c, ::d[i] = d;

            g[b][a].push_back( answer(c,d) );
            g[d][c].push_back( answer(a,b) );
        }

        noinf = false;

        int cnt = 0;
        memset( state , -1 , sizeof(state));

        for( int i = 0; i < n; ++i ){
            bool ok1(0),ok2(0);
            if( state[a[i]] != -1 ) continue;
            dfs( a[i] , b[i] );
            cnt ++;
        }
        for( int i = 0; i < m; ++i ) if( state[i] == -1 ) cnt ++;

        if( noinf || cnt == 0 ) printf("No Inference\n");
        else{
            digs[0] = sz = 1;
            for( int i = 0; i < cnt; ++i ){
                int mem = 0;
                for( int k = 0; k < sz; ++k ){
                    int d = digs[k]*2 + mem;
                    digs[k] = d % 10;
                    mem = d / 10;
                }
                while( mem ) digs[sz++] = mem % 10 , mem /= 10;
            }

            for( int k = sz-1; k >= 0; --k )
                printf("%d",digs[k]);putchar('\n');
        }

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <map>
#include <algorithm>
#include <iomanip>
#include <set>
#include <string>
#include <string.h>
#include <queue>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

const int inf = 999999;
const int maxn = 550+5;

int source,sink,n;
vector< int > g[maxn];

int cap[maxn][maxn];
bool visi[maxn];
int dad[maxn];

void add_edge( int a, int b, int c , bool be ){
    cap[a][b] += c;
    g[a].push_back(b);
    if( be ) g[b].push_back(a);
}

int flow(){
    memset( dad, -1, sizeof(dad));
    memset( visi , false , sizeof(visi));

    int mincap = -inf;
    pair< int, pii> u;
    priority_queue< pair< int, pii>  >pq;

    pq.push( mk( inf , mk(-1,source)  ) );

    while(!pq.empty()){
        u = pq.top(); pq.pop();
        if( visi[u.s.s] ) continue;

        visi[u.s.s] = true;
        dad[u.s.s] = u.s.f;

        if( u.s.s == sink ){
            mincap = u.f;
            break;
        }

        int now = u.f;
        int node = u.s.s;

        for( int i = 0; i < g[node].size(); ++i ){
            int nxt = g[node][i];
            int flw = min( now , cap[node][nxt] );
            if( flw <= 0 ) continue;
            pq.push( mk( flw, mk(node,nxt) ) );
        }
    }

    if( mincap == -inf ) return 0;

    int now = sink;
    while( now != source ){
        int prv = dad[now];
        cap[prv][now] -= mincap;
        cap[now][prv] += mincap;
        now = prv;
    }


    return mincap;
}


int main(){
   // freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d",&n);

        source = 0, sink = n-1;
        memset( cap , 0 , sizeof(cap));
        for( int i = 0; i < 555; ++i ) g[i].clear();


        for( int i = 0; i < n-1; ++i ){
            int m; scanf("%d",&m);
            for( int j = 0; j < m; ++j ){
                int nxt; scanf("%d",&nxt); nxt --;
                if( i == 0 || nxt == n-1 )add_edge( i, nxt, 1 , 1 );
                else add_edge( i, nxt, 9999 , 1 );
            }
        }


        int sol = 0;
        while(1){
            int f = flow();
            if( f == 0 )break;
            sol += f;
        }

        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <string>
#include <string.h>
#include <math.h>
#include <fstream>
#include <map>
#include <set>
#include <stack>
using namespace std;

int h;

int beg = 131072;
int state[1<<18];

bool query( int node ){
    int s1 = state[node*2];
    int s2 = state[node*2+1];

    if( s1 == -1 && s2 == -1 ) return 1;
    else if( s1 == 1 || s2 == 1 ){
        state[node] = query(node/2);
        return !state[node];
    }

}

int main(){

    memset( state , -1 , sizeof(state));
    scanf("%d",&h);

    for( int i = 1; i <= (1<<h); ++i ){
        if( i > 1 && i < (1<<h) )putchar(' ');
        else if( i != 1 ) break;

        int q; scanf("%d",&q); q --;
        bool ch = query( (beg+q)/2 );
        state[beg+q] = ch;
        putchar('0'+ch);
    }


    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <string.h>
using namespace std;

typedef long long ll;

ll mod = 1;
ll m[2][2];
ll a[2][2];
ll c[2][2];
ll s[2][2];

void init(){
	memset( a , 0 , sizeof(a));
	memset( m , 0 , sizeof(m));
	memset( c , 0 , sizeof(c));
	

	m[0][0] = 1;
	m[0][1] = 1;
	
	a[0][1] = a[1][0] = a[1][1] = 1;
	c[0][1] = c[1][0] = c[1][1] = 1;
}

void mul( ll a[2][2] , ll b[2][2] ){
	s[0][0] = s[0][1] = s[1][0] = s[1][1] = 0;
	
	for( int i = 0; i < 2; ++i )
		for( int j = 0; j < 2; ++j )
			for( int k = 0; k < 2; ++k )
				s[i][j] = ( s[i][j] + a[i][k]*(ll)b[k][j] ) % mod;
	
	for( int i = 0; i < 2; ++i )
		for( int j = 0; j < 2; ++j )
			a[i][j] = s[i][j];
}

ll nth( ll n ){
	stack< int > s;
	while( n > 1 ){
		if( n % 2 == 0 ) s.push( 0 ) , n >>= 1;
		else s.push( 1 ) , n --;
	}
	
	while( s.empty() == false ){
		int u = s.top(); s.pop();
		if( u == 0 ) mul( a , a );
		else mul( a , c );
		
	}
	return a[0][0];
	
}


ll n,k;

int main(){
	//freopen("Ulaz.txt","r",stdin);
	
	int tests;
	scanf("%d",&tests);
	
	for( ; tests; --tests ){
		init();
		cin >> n >> k;
		mod = 1 << k;
		
		cout<<nth(n+2)<<endl;
		
	}
	
	return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <set>
#include <iomanip>
#include <queue>
#include <stack>
#include <map>
#include <string>
#include <string.h>
using namespace std;

const int inf = 999999999;
const int maxn = 200550;

struct point{
    int x,y,key,ylo;
    inline bool operator<( const point &w ) const {
        return x < w.x || ( x == w.x && y < w.y );
    }
};

struct elem{
    int v,key;
    elem(){};
    elem( int p1, int p2 ):v(p1),key(p2){};
};

struct segment_tree{
    int begin,lq,rq,sz;
    int *treev;//[maxn*2];
    int *treek;//[maxn*2];

    segment_tree(){};

    segment_tree( int n ){
        sz = 1;
        while( sz < n ) sz <<= 1;

        begin = sz;
        sz <<= 1;

        treev = new int[sz];
        treek = new int[sz];
    }

    inline void init(){ for( int i = 0; i < sz; ++i ) treev[i] = -inf; }

    int mx,mxdx;

    void _query( int dx , int lo , int hi ){

        if( treev[dx] <= mx ) return;

        if( lq <= lo && hi <= rq ){
            if( mx < treev[dx] ) mx = treev[dx] , mxdx = treek[dx];
            return;
        }

        int mid = (lo+hi)>>1;
        if( lq <= mid && mid < rq ){
            _query( dx<<1, lo , mid );
            _query( (dx<<1)+1, mid+1, hi );
            return;
        }

        if( lq <= mid )  _query( dx<<1 , lo , mid );
        else  if( mid < rq ) _query( (dx<<1)+1, mid + 1 , hi );
    }


    inline elem query( int L , int R ){
        lq = L + begin;
        rq = R + begin;

        mxdx = -1;
        mx = -inf;

        _query( 1 , begin , begin * 2 - 1 );

        return elem( mx , mxdx );
    }


    inline void update( int dx , elem val ){
        dx += begin;
        treev[dx] = val.v;
        treek[dx] = val.key;

        while( dx ){
            dx >>= 1;
            int L = dx<<1 , R = 1+(dx<<1);
            treev[dx] = treev[L];
            treek[dx] = treek[L];
            if( treev[dx] < treev[R] ) treev[dx] = treev[R] , treek[dx] = treek[R];
        }

    }

};

struct fenwick{
    int *arr,sz;

    fenwick(){};

    fenwick( int n ){
        sz = n + 50;
        arr= new int[sz+50];
    }

    void update( int idx , int val ){
        for( idx += 5; idx <= sz; idx += idx & -idx )
            arr[idx] = max( arr[idx] , val );
    }

    int read( int idx ){
        int ret = -inf;
        for( idx += 5; idx >= 1; idx -= idx & -idx )
            ret = max( ret , arr[idx] );
        return ret;
    }

    void init(){
        for( int i = 0; i < sz; ++i ) arr[i] = -inf;
    }

};


int n;
point p[maxn];
int low[maxn];

fenwick t1 , t2;

int sol[maxn];

char c;
inline void readi( int &v ){
    while( (c=getchar())<'0' || c > '9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
}


int main(){
    //double q = clock();

    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    readi(n);

    t1 = fenwick( n*2 );
    t2 = fenwick( n*2 );
    t1.init();
    t2.init();

    for( int i = 0; i < n; ++i ){
        readi( p[i].x );
        readi( p[i].y );
        p[i].key = i;
        low[i] = p[i].y;
        sol[i] = inf;
    }

    sort( low , low + n );
    sort( p , p + n );


     int mxlo = 0;

    for( int i = 0; i < n; ++i ){
        p[i].ylo = lower_bound( low , low + n , p[i].y ) - low;
        mxlo = max( mxlo , p[i].ylo );
    }

    for( int i = 0; i < n; ++i ){
        int dx = p[i].ylo;

        int v1 = t1.read( dx );
        int v2 = t2.read( mxlo - dx );

        if( v1 != -inf || v2 != -inf ){

            v1 = -v1 + (p[i].x + p[i].y);
            v2 = -v2 + (p[i].x - p[i].y);

            int s = v1;
            if( s > v2 ) s = v2;


            sol[ p[i].key ] = min( sol[ p[i].key ] , s );
        }

        t1.update( dx , p[i].x + p[i].y );
        t2.update( mxlo-dx , p[i].x - p[i].y );
    }

    t1.init();
    t2.init();

    for( int i = n-1; i >= 0; --i ){
        int dx = p[i].ylo;

        int v1 = t1.read( dx );
        int v2 = t2.read( mxlo - dx );

        if( v1 != -inf || v2 != -inf ){

            v1 = -v1 + (-p[i].x + p[i].y);
            v2 = -v2 + (-p[i].x - p[i].y);

            int s = v1;
            if( s > v2 ) s = v2;


            if( sol[ p[i].key ] > s ) sol[ p[i].key ] = s;
        }

        t1.update( dx , -p[i].x + p[i].y );
        t2.update( mxlo-dx , -p[i].x - p[i].y );
    }



    for( int i = 0; i < n; ++i )
        printf("%d\n",sol[i]);

//    printf("%.10lf\n",(clock()-q)/CLOCKS_PER_SEC);

    return 0;
}


#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <set>
#include <iomanip>
#include <queue>
#include <stack>
#include <map>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 2005;

int n;
int x[maxn];
int y[maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    scanf("%d",&n);

    for( int i = 0; i < n; ++i )
        scanf("%d%d",&x[i],&y[i]);

    for( int i = 0; i < n; ++i ){
        int sol = 999999999;
        for( int j = 0; j < n; ++j ){
            if( i == j ) continue;
            sol = min( sol , abs( x[i] - x[j] ) + abs( y[i] - y[j] ) );
        }
        printf("%d\n",sol);
    }


    return 0;
}

#include <iostream>
#include <cstdio>
#include <math.h>
using namespace std;

double a,b,c,d;

int main(){
    int tests;
    scanf("%d",&tests);

    for( ; tests ; --tests ){
        scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
        double s = (a+b+c+d) / 2;
        double p = sqrt( (s-a)*(s-b)*(s-c)*(s-d) );

        printf("%.2lf\n",p);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <stack>
#include <map>
#include <string.h>
#include <string>
using namespace std;

const int maxn = 200050;

struct Query{
    int a,c;
    Query(){};
    Query( int p1, int p2 ):c(p1),a(p2){};
};

int bit[maxn];
map<int,int> added;

int query( int dx ){
    int ret = 0;
    for( dx += 2; dx >= 1; dx -= dx & -dx )
        ret += bit[dx];
    return ret;
}

void update( int dx , int v ){
    for( dx += 2; dx <= maxn; dx += dx & -dx )
        bit[dx] += v;
}

int lower( int v ){
    return query( v );
}

vector< int > e;
int kth( int k ){
    int lo = 0, hi = e.size();
    int sol = -1;

    while( lo <= hi ){
        int mid = (lo+hi)>>1;
        int beh = query( mid );

        if( beh < k ) lo = mid + 1;
        else sol = mid , hi = mid - 1;
    }
    return sol;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);

    int m;
    scanf("%d",&m);

    vector< Query > q;

    for( int i = 0; i < m; ++i ){
        int v;char c;
        while( c=getchar() )if( c == 'I' || c == 'C' || c == 'D'|| c == 'K' ) break;
        scanf("%d",&v);

        q.push_back( Query( c , v ) );
        e.push_back( v );
    }

    sort( e.begin() , e.end() );
    e.erase( unique(e.begin(),e.end()),e.end());

    for( int i = 0; i < m; ++i ){
        if( q[i].c != 'K' )q[i].a = lower_bound( e.begin() , e.end() , q[i].a ) - e.begin();
    }

    for( int i = 0; i < m; ++i ){
        if( q[i].c == 'I' ){
            if( added[ q[i].a ] == 0 ) update( q[i].a , 1 );
            added[ q[i].a ] = 1;
        }else if( q[i].c == 'D' ){
            if( added[ q[i].a ] == 1 ) update( q[i].a , -1 );
            added[ q[i].a ] = 0;
        }else if( q[i].c == 'C' ){
            printf("%d\n", lower( q[i].a-1 ) );
        }else if( q[i].c == 'K' ){
            int s = kth( q[i].a );
            if( s == -1 ) printf("invalid\n");
            else printf("%d\n",e[s]);
        }
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
#include <stack>
using namespace std;

const int inf = 116216598;

struct node{
    node *l,*r;
    int rank,val;
    int sz;
    node(){ l = r = NULL; };
};

struct treap{
    node *tree , *dummy;


    treap(){
        dummy = new node();
        dummy->rank = -1;
        dummy->l = dummy->r = dummy;
        dummy->sz = 0;
        tree = dummy;
    }

    void update( node *n ){
        if( n == dummy ) return;
        n->sz = 1 + (n->l->sz) + (n->r->sz);
    }

    node *make( int v ){
        node *ret = new node();
        ret->val = v;
        ret->rank = rand();
        ret->l = ret->r = dummy;
        ret->sz = 1;
        return ret;
    }

    node *rotate( node *child , node *dad ){
        if( child == dad->l ){
            dad->l = child->r, child->r = dad;
        }else{
            dad->r = child->l, child->l = dad;
        }
        return child;
    }

    node *insert( node *n , int v ){
        if( n == dummy ) return make(v);
        else if( n->val > v ){
            n->l = insert( n->l , v );
            if( n->l->rank > n->rank ) n = rotate( n->l , n );
        }else if( n->val < v ){
            n->r = insert( n->r , v );
            if( n->r->rank > n->rank ) n = rotate( n->r , n );
        }
        update(n->r);update(n->l);
        update(n);
        //printf("UPDATED %d , [%d,%d] [%d,%d]",n->val,n->l->val,n->r->val , n->l->sz,n->r->sz);
        return n;
    }

    node *erase( node *n, int v ){
        if( n == dummy ) return dummy;
        if( n->val > v )
            n->l = erase( n->l , v );
        else if( n->val < v )
            n->r = erase( n->r , v );
        else{
            if( n->r == dummy && n->l == dummy ) return dummy;
            else if( n->r == dummy || ( n->l != dummy && n->l->rank > n->r->rank )  ){
                n = rotate( n->l , n );
                n->r = erase( n->r , v );
            }else{
                n = rotate( n->r , n );
                n->l = erase( n->l , v );
            }
        }
        update(n);
        return n;
    }

    int kth( node *n , int k ){
        if( n == dummy ) return -inf;
        if( k-(n->l->sz)-1 == 0  )return n->val;

        if( n->l->sz+1 <= k ) return kth( n->r , k - (n->l->sz) - 1 );
        else return kth( n->l , k );
    }

    int cnt( node *n , int v ){
        if( n == dummy ) return 0;
        if( v > n->val ) return (n->l->sz)+1 + cnt( n->r , v );
        else return cnt( n->l , v );
    }


    void traverse( node *n ){
        if( n == dummy ) return;
        traverse( n->l );
        printf("node %d , %d  [%d,%d]\n",n->val,n->sz,n->l->val,n->r->val);
        traverse( n->r );
    }

    void Traverse(){
        printf("\n");
        traverse( tree );
        printf("\n");
    }

    void Insert( int v ){ tree = insert( tree , v ); }
    void Erase ( int v ){ tree = erase( tree , v ); }
    int KTH( int k ){ return kth( tree , k ); }
    int CNT( int v ){ return cnt( tree , v ); }
};

treap A;

int main(){
    srand((unsigned)time(0));
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz2.txt","w",stdout);

    int m;
    scanf("%d",&m);

    for( int i = 0; i < m; ++i ){
        char c;

        while( c=getchar() )if( c == 'I' || c == 'C' || c == 'D'|| c == 'K' ) break;

        int v; scanf("%d",&v);

        if( c == 'I' ){
            A.Insert(v);
        }else if( c == 'D' ){
            A.Erase(v);
        }else if( c == 'K' ){
            int q = A.KTH(v);
            if( q == -inf ) printf("invalid\n");
            else printf("%d\n",q);
        }else if( c == 'C' ){
            int q = A.CNT(v);
            if( q == -inf ) printf("invalid\n");
            else printf("%d\n",q);
        }
    }
   // A.Traverse();

    return 0;
}

#include <iostream>
#include <cstdio>
#include <map>
#include <queue>
using namespace std;

const int maxn = 100000+55;
const int inf = 999999999;

struct segment_tree{
    int begin;
    vector< int > tree;

    segment_tree(){};

    void init( int n ){
        int sz = 1;
        while( sz < n ) sz <<= 1;
        begin = sz;
        sz <<= 1;
        tree.resize( sz );
        for( int i = 0; i < sz; ++i ) tree[i] = inf;
    }

    int L,R;
    int mini;

    void _query( int node , int lo ,int hi ){

        if( L <= lo && hi <= R ){ mini = min(mini,tree[node]); return; }
        if( node >= begin || hi < L || R < lo ) return;

        int mid = (lo+hi)>>1;
        _query( node * 2 , lo , mid  );
        _query( node*2+1 , mid+1, hi );
    }

    void update( int dx , int val ){
        dx = dx + begin - 1;
        tree[dx] = val;
        while( dx > 1 ){
            dx >>= 1;
            tree[dx] = min(tree[dx<<1],tree[(dx<<1)+1] );
        }
    }

    int query( int Lq , int Rq ){
        L = Lq + begin - 1;
        R = Rq + begin - 1;
        mini = inf;
        _query( 1 , begin , begin*2-1 );
        return mini;
    }
};

inline void readi ( int &v ){
    char c;
    while( (c=getchar())<'0' || c >'9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' )
         v = v * 10 + c - '0';
}


int n;
int v[maxn];
int prv[maxn],nxt[maxn];

segment_tree drvo;

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        int mini = inf;
        readi(n);

        drvo.init(n);

        for( int i = 0; i < n; ++i ){
            prv[i] = mini;
            readi(v[i]);
            if( mini > v[i] ) mini = v[i];
        }

        int maxi = -inf;
        for( int i = n-1; i >= 0; --i ){
            nxt[i] = maxi;
            if( maxi < v[i] ) maxi = v[i];
        }

        bool yes = false;

        for( int i = 0; i < n && !yes; ++i ){
            int w = drvo.query( v[i] , nxt[i] );

            if( w < v[i] ){ yes = true; break; }
            if( prv[i] < v[i] ) drvo.update( v[i] , prv[i] );
        }

        if( yes ) printf("yes\n");
        else printf("no\n");

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <map>
#include <string.h>
#include <string>
using namespace std;

typedef long long ll;

const int maxn = 1000050;

int sub[maxn];
int vis[maxn];
int p[maxn],sz=0;


void gprimes(){

    for( int i = 2; i < maxn; ++i ){
        if( vis[i] ) continue;
        p[sz++] = i;
        for( int k = i+i; k < maxn; k += i )
            vis[k] = 1;
    }

}

int n;
ll ss = 0;

ll trio[maxn];
ll duo[maxn];

void ggcd( int dx , int now , bool mod ){
    if( dx == sz ) return;

    if( now*(ll)p[dx] <= n ){
        ggcd( dx+1 , now , mod );

        int w = n / (now*p[dx]);

        if( mod == 0 ) ss = ss - trio[w] - duo[w];
        else ss = ss + trio[w] + duo[w];

        ggcd( dx+1 , now*p[dx] , !mod );
    }
}



int main(){

    for( ll i = 1; i < maxn; ++i ) trio[i] = i*i*i, duo[i] = 3*i*i;

    gprimes();

    int tests;
    scanf("%d",&tests);

    while( tests -- ){
        scanf("%d",&n);

        ss = n*(ll)n*n + 3*n*(ll)n;
        ggcd( 0 , 1 , 0);

        printf("%lld\n",ss+3);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <math.h>
#include <algorithm>
#include <cstdio>
#include <stack>
using namespace std;

typedef long long ll;


#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 100000 + 55;

int n;
int v[maxn];
int L[maxn],R[maxn];

ll sum[maxn];
ll sumDX[maxn], sumH[maxn];

void readi( int &v ){
    char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c-'0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
}


int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    readi(n);
    for( ll i = 0; i < n; ++i )
        readi(v[i]);

    stack< pii >stk;
    for( ll i = 0; i < n; ++i ){
        while( stk.empty() == false && stk.top().f > v[i] ) stk.pop();

        if( stk.empty() )L[i] = -1;
        else L[i] = stk.top().s;

        stk.push( mk(v[i],i) );
    }

    while( stk.empty() == false ) stk.pop();
    for( int i = n-1; i >= 0; --i ){
        while( stk.empty() == false && stk.top().f >= v[i] ) stk.pop();

        if( stk.empty() )R[i] = n;
        else R[i] = stk.top().s;

        stk.push( mk(v[i],i) );
    }

    for( int i = 0; i < n; ++i ){
        ll l = L[i] + 1;
        ll d = R[i] - 1;
        ll h = v[i];

        if( i+1 <= d ){
            sumDX[i+1] += (-h +l*h  -i*h);
            sumH[i+1] += h*(d +1 + i*d +i -l*d -l );

            sumDX[d+1] +=  -(-h +l*h  -i*h);
            sumH[d+1] += -h*(d +1 + i*d +i -l*d -l );
        }


        sumDX[l] += (h*d -i*h +h);
        sumH[l] += h*( d -i +1 -d*l + i*l - l );

        sumDX[i+1] += - (h*d -i*h +h);
        sumH[i+1] += -h*( d -i +1 -d*l + i*l - l );
    }

    ll sdx(0),ss(0);

    for( int i = 0; i < n; ++i ){
        sdx += sumDX[i];
        ss += sumH[i];

        printf("%lld ",sum[i] + ss + i*sdx);
    }


    return 0;
}

#include <cstdio>

void readi( int &v ){
    char c;
    while( (c=getchar())<'0' || c >'9' );
    v = c-'0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
}

int main(){

    int tests;readi(tests);

    for( ; tests; --tests ){
        int n;readi(n);
        if( n - 2 <= 0 ) printf("0\n");
        else printf("%d\n",n-2);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <algorithm>
#include <math.h>
#include <string>
#include <string.h>
using namespace std;

typedef long long ll;

ll h,w;

ll calc( ll diag ){
    ll cnt = 0;

    ll m = min(h,w);
    m = min(diag,m);
    cnt += m*(m+1)>>1;
    diag -= m;

    m = min(diag,abs(h-w));
    cnt += m*min(h,w);
    diag -= m;

    m = min(h,w);
    m--;
    ll add = m*(m+1)>>1; m -= diag;
    add -= m*(m+1)>>1;

    cnt += add;
    return cnt;
}


ll getkth( ll y , ll x ){
    ll d = x + y - 2;
    ll prv = calc( d );
    ll nxt = calc( d + 1  );


    if( x + y - 1 >= h ){
        if( d % 2 == 0 ) return prv + (x-(d-h+1));
        else return prv + (y-(d-h+1));
    }

    if( d % 2 == 0 ) return prv + x;
    else return prv + y;

    cout<<prv<<endl;
}

char txt[300005];


int main(){
    int k;
    cin >> h >> k;
    w = h;

    int x = 1 , y = 1;
    ll sol = 0;

    scanf("%s",txt);
    for( int i = 0; i < k; ++i ){
        if( txt[i] == 'D' ) y++;
        else if( txt[i] == 'R' ) x ++;
        else if( txt[i] == 'U' ) y --;
        else x --;
        sol += getkth( y , x );
    }

    cout<<sol+1<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <map>
#include <string>
#include <algorithm>
#include <string.h>
using namespace std;

typedef long long ll;

const int maxn = 2*100005;
const int maxm = 25005;
const int prime = 124777;



int n,m,spot;
int cow[maxn];
int ord[maxn];
int ppow[maxn];

int save[maxn][30];
int mask[30];

int cnt[30];
int colcnt[30];

int TO[maxn];

void add_keys(){
    int *now = new int[26];
    for( int i = 0; i < 26; ++i )now[i] = cnt[i] = 0;


    for( int i = 0; i < m; ++i ){
        cnt[ ord[i] ] ++;
        colcnt[ ord[i] ]++;
        int c = 0;
        for( int k = 0; k < ord[i]; ++k )
            c += cnt[ k ];

        for( int k = 1; k <= spot; ++k ){
            int ch;
            if( ord[i] == k ) ch = 55;
            else ch = 88;

            now[k] = (now[k]*(ll)prime + ch);
        }
    }

    for( int i = 0; i < 26; ++i ){ mask[i] = now[i]; now[i] = 0; cnt[i] = 0; }

    int deep = 0;
    for( int i = 0; i < m; ++i ){

        for( int k = 1; k <= spot; ++k ){
            int ch;
            if( cow[i] == k ) ch = 55;
            else ch = 88;

            now[k] = (now[k]*(ll)prime + ch);
            save[i][k] = now[k];
        }
    }

    for( int i = m; i < n; ++i ){


        for( int k = 1; k <= spot; ++k ){
            int chn,chp;
            if( cow[i] == k ) chn = 55;
            else chn = 88;

            if( cow[i-m] == k ) chp = 55;
            else chp = 88;


            int &ref = now[k];

            ref = (ref - ppow[m-1]*(ll)chp );
            ref = (ref*(ll)prime);
            ref += chn;

            save[i][k] = now[k];
        }
    }
}

int H[30];
int chg[30];
int mem[30];

vector< int > sol;

void chk( int dx ){


    bool ok = true;
    for( int i = 1; i <= spot && ok; ++i ){
        int x = H[i];
        int colup = cow[x];
        int y = H[i] - (dx-m) - 1;
        int collo = ord[y];

        chg[ collo ] = colup;

        if( mask[collo] != save[dx][colup] ) ok = false;
    }

    if( ok ){
        memset( cnt , 0 , sizeof(cnt));

        for( int i = 1; i < 30; ++i ){
            if( colcnt[i] == 0 ) continue;
            int c = 0,c1 = 0;
            for( int k = 0; k < i; ++k ) c += colcnt[k];
            for( int k = 0; k < chg[i]; ++k ) c1 += cnt[k];

            cnt[ chg[i] ] = colcnt[i];

            if( c != c1 ) ok = false;

        }


        if( ok )sol.push_back( dx - m + 2 );
    }
}


int main(){
    ppow[0] = 1;
    for( int i = 1; i <= maxm; ++i )ppow[i] = (ppow[i-1] * (ll)prime);


    //freopen("Ulaz.txt","r",stdin);

    scanf("%d%d%d",&n,&m,&spot);
    for( int i = 0; i < n; ++i ) scanf("%d",&cow[i]);
    for( int i = 0; i < m; ++i ) scanf("%d",&ord[i]);

    add_keys();



    memset( H , -1 , sizeof(H));

    for( int i = 0; i < m; ++i ) H[ cow[i] ] = i;


    chk( m-1 );

    for( int i = m; i < n; ++i ){
        if( H[ cow[i-m] ] == i-m ) H[ cow[i-m] ] = -1;
        H[ cow[i] ] = i;
        chk(i);
    }

    printf("%d\n",sol.size());

    sort( sol.begin() , sol.end() );
    for( int i = 0; i < sol.size(); ++i )
        printf("%d\n",sol[i] );

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <map>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 20005;
const int inf = 999999999;

int n;
vector< int > g[maxn];


int sz[maxn];
int F[maxn];

int dfs( int node , int dad ){

    F[node] = dad;

    sz[node] = 1;
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( nxt == dad  ) continue;
        sz[node] += dfs( nxt , node );
    }
    return sz[node];
}


int main(){
        freopen("Ulaz.txt","r",stdin);
        
        int t; scanf("%d",&t);

        scanf("%d",&n);
        for( int i = 0; i < n-1; ++i ){
            int a,b; scanf("%d%d",&a,&b); a--, b--;
            g[a].push_back(b);
            g[b].push_back(a);
        }

        dfs( 0 , -1 );

        int sol = inf;
        int dx = 0;

        for( int i = 0; i < n; ++i ){
            int mini_sub = 0;
            int ss = 0;
            
            for( int k = 0; k < g[i].size(); ++k ){
                int nxt = g[i][k];

                if( nxt == F[i] ) continue;

                int w = sz[nxt];
                mini_sub = max( mini_sub , w );
                ss += w;
            }

            int del = n - ss;
            mini_sub = max( mini_sub , del );



            if( mini_sub < sol ){
                sol = mini_sub;
                dx = i;
            }
        }
		printf("FILE balance %d\n",t);
        printf("%d\n",dx+1);
        printf("%d\n",sol);


    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <map>
#include <stack>
#include <string.h>
#include <string>
using namespace std;

typedef long long ll;

ll a,b;
int s;

int ln;
int A[20],B[20];

ll dp[20][140][2][2];

ll smallest = -1;
ll T = 0;

ll solve( int dx , int sum , bool da, bool db ){


    if( dx == ln ){
        if( sum != s ) return 0;
        if( smallest == -1 )smallest = T;
        return 1;
    }

    ll &ref = dp[dx][sum][da][db];
    if( ref != -1 ) return ref;

    ref = 0;

    for( int i = 0; i <= 9; ++i ){
        bool na=da,nb=db;
        if( (da&&i<A[dx]) || (db&&i>B[dx]) ) continue;
        if( da == 1 && i > A[dx] ) na = 0;
        if( db == 1 && i < B[dx] ) nb = 0;

        T = T * 10 + i;
        ref += solve( dx + 1 , sum + i , na , nb );
        T /= 10;
    }
    return ref;

}

int main(){

    scanf("%lld%lld%d",&a,&b,&s);

    ll x=a,y=b;
    vector< int > d1,d2;

    while( x ){ d1.push_back( x % 10 ); x /= 10; }
    while( y ){ d2.push_back( y % 10 ); y /= 10; }

    ln = max( d1.size() , d2.size() );
    for( int i = 0; i < d1.size(); ++i )
        A[ln-i-1] = d1[i];

    for( int i = 0; i < d2.size(); ++i )
        B[ln-i-1] = d2[i];

    memset( dp , -1 , sizeof(dp));
    ll sol = solve( 0 , 0 , 1 , 1 );


    printf("%lld\n",sol);
    printf("%lld\n",smallest);

    return 0;
}


#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <algorithm>
#include <string.h>
using namespace std;

int n;
int cntx[100005];
int cnty[100005];

int xs[100005];
int ys[100005];

int main(){
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        int x,y; scanf("%d%d",&x,&y);
        cntx[x]++;
        cnty[y]++;
        xs[i] = x;
        ys[i] = y;
    }

    int sol = 0;
    for( int i = 0; i < n; ++i ){
        int x = cntx[ xs[i] ];
        int y = cnty[ ys[i] ];
        y --,
        x --;
        sol += x*y;
    }
    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <algorithm>
#include <math.h>
#include <string>
#include <string.h>
using namespace std;

typedef long long ll;

ll h,w;
ll k;

ll calc( ll diag ){
    ll cnt = 0;

    ll m = min(h,w);
    m = min(diag,m);
    cnt += m*(m+1)>>1;
    diag -= m;

    m = min(diag,abs(h-w));
    cnt += m*min(h,w);
    diag -= m;

    m = min(h,w);
    m--;
    ll add = m*(m+1)>>1; m -= diag;
    add -= m*(m+1)>>1;

    cnt += add;
    return cnt;
}

ll bsearch( ll K ){
    ll sol = 0;
    ll lo = 1 , hi = min(h,w)+max(h,w)-1;
    while( lo <= hi ){
        ll mid = (lo+hi)>>1;
        ll w = calc(mid);

        if( w <= K ) sol = mid , lo = mid + 1;
        else hi = mid - 1;
    }
    return sol;
}

ll f( ll a , ll b ){
    ll cnt = 0;
    ll sol = 0;
    ll mask = b;
    for( ll i = 0; i < 30; ++i ){
        if( mask & (1<<i) )mask ^= 1 << i;

        if( (b&(1<<i))){
            if( a & mask ) ;
            else sol += 1<<cnt;
        }
        if( (a&(1<<i)) == 0 ) cnt ++;
    }
    if( (a&b)==0 ) sol ++;

    return sol;
}

int main(){
    freopen("jez.in.10","r",stdin);
    freopen("jez.me.10","w",stdout);

    scanf("%lld%lld",&h,&w);
    scanf("%lld",&k);

    ll sol = 0;

    ll final = bsearch(k);
    for( int i = 0; i < h; ++i ){
        ll col = w;
        if( col+i > final ) col = col-abs((col+i)-final);
        if( col >= 1 )sol += f(i,col-1);
    }

    int ah,aw;
    int r,c;
    h--,w--;
    if( final%2 == 0 ){
        ah = -1, aw = 1;
        r = min(h,final);
        c = max(0LL,final-w);
    }else{
        ah = 1, aw = -1;
        r = max(0LL,final-h);
        c = min(w,final);
    }
    h++,w++;

    k -= calc(final);
    for( int i = 0; i < k; ++i ){
        if( (r&c) == 0 )sol ++;
        r += ah , c += aw;
    }
    cout<<sol<<endl;
    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <string>
#include <string.h>
#include <map>
#include <queue>
#include <stack>
using namespace std;

int h,w;
char txt[1000][1000];

int main(){


    scanf("%d%d",&h,&w);

    for( int i = 0; i < h; ++i )
        scanf("%s",txt[i]);

    int xr,xc;
    scanf("%d%d",&xr,&xc);
    xr--,xc--;


    for( int i = 0; i < 2*h; ++i ){
        for( int j = 0; j < 2*w; ++j ){
            int r = i , c = j;
            if( r >= h ) r = h - (r-h) - 1;
            if( c >= w ) c = w - (c-w) - 1;

            bool x = txt[r][c] == '#';

            if( i ==  xr && j == xc ) x = !x;

            if( x ) printf("#");
            else printf(".");
        }
        printf("\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <fstream>
#include <stack>
#include <map>
#include <string>
#include <algorithm>
#include <string.h>
using namespace std;

const int inf = 2147483613;



struct segment_tree{
    int begin;
    vector<int>L;
    vector<int>R;
    vector<int>H;
    vector<int>sum;
    vector<int>prefix;

    segment_tree(){};

    void init( int n ){
        int sz = 1;
        while( sz < n ) sz <<= 1;
        begin = sz;
        sz <<= 1;

        L.resize(sz);
        R.resize(sz);
        sum.resize(sz);
        prefix.resize(sz);
        H.resize(sz);

        for( int i = 0; i < sz; ++i ){
            L[i] = inf;
            R[i] = -inf;
            H[i] = -inf;
            sum[i] = prefix[i] = 0;
        }

    }

    void bound( int dx , int val ){
        dx += begin;
        L[dx] = min( L[dx] , val );
        R[dx] = max( R[dx] , val );
        while( dx > 1 ){
            dx >>= 1;
            L[dx] = min( L[dx] , val );
            R[dx] = max( R[dx] , val );
        }
    }

    int LQ,RQ,val;

    void _update( int node ){

        int l = L[node] , r = R[node];
        if( l > r ) return;

        if( LQ <= l && r <= RQ ){
            H[node] = val;
            sum[node] = val * (r-l+1);
            prefix[node] = max( 0 , sum[node] );
            return;
        }

        if( node >= begin || LQ > r || RQ < l ) return;


        if( H[node] != -inf ){
            H[node*2] = H[node];
            sum[node*2] = H[node] * ( R[node*2] - L[node*2] + 1 );
            prefix[node*2] = max( 0 , sum[node*2] );

            H[node*2+1] = H[node];
            sum[node*2+1] = H[node] * ( R[node*2+1] - L[node*2+1] + 1 );
            prefix[node*2+1] = max( 0 , sum[node*2+1] );
        }

        _update( node * 2 );
        _update( node * 2 + 1 );


        H[node] = -inf;
        sum[node] = sum[node*2] + sum[node*2+1];
        prefix[node] = max( prefix[node*2] , sum[node*2] + prefix[node*2+1] );
    }

    int hq;
    int _query( int node , int prev ){
        int l = L[node], r = R[node];
        if( l > r ) return 0;

        if( prev+prefix[node] <= hq ) return (r-l+1);
        if( H[node] != -inf ){ return (hq-prev) / H[node]; }

        if( node >= begin  ) return 0;

        int sol = 0;

        if( H[node] != -inf ){
            H[node*2] = H[node];
            sum[node*2] = H[node] * ( R[node*2] - L[node*2] + 1 );
            prefix[node*2] = max( 0 , sum[node*2] );

            H[node*2+1] = H[node];
            sum[node*2+1] = H[node] * ( R[node*2+1] - L[node*2+1] + 1 );
            prefix[node*2+1] = max( 0 , sum[node*2+1] );

        }

        H[node] = -inf;
        if( prev+prefix[node*2] > hq )sol = _query(node*2 , prev );
        else sol = R[node*2]-L[node*2]+1 + _query(node*2+1, prev + sum[node*2] );

        return sol;
    }


    int query( int h ){
        hq = h;
        return _query( 1 , 0 );
    }

    void update( int l , int r , int v ){
        LQ = l ,RQ = r;
        val = v;
        _update( 1 );
    }

};

struct query{
    int type , a,b,c;
    query(){};
    query( int p1 , int p2 ):type(p1),a(p2){ b = c = 0; };
    query( int p1, int p2, int p3, int p4 ):
        type(p1),a(p2),b(p3),c(p4){};
};

int n;
vector< query > q;

inline void readi( int &v ){
    char c;
    while( (c=getchar())<'0' || c > '9' )if( c == '-' ) break;

    int f = 1;
    if( c == '-' ){ f = -1;c=getchar();}

    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
    v *= f;
}

int main(){

   // freopen("mou24.in","r",stdin);
   // freopen("mee24.out","w",stdout);

    scanf("%d",&n);

    vector< int > dots;

    char c;
    while(1){
        while( c=getchar() )if( c == 'I' || c == 'Q' || c == 'E' ) break;
        if( c == 'E' ) break;

        if( c == 'I' ){
            int a,b,c; readi(a),readi(b),readi(c);
            q.push_back( query(0,a,b,c) );
            dots.push_back(a);
            dots.push_back(b);
        }else{
            int a; readi(a);
            q.push_back( query(1,a) );
        }
    }

    sort( dots.begin() , dots.end() );
    dots.erase( unique(dots.begin(),dots.end()) , dots.end() );

    vector< pair<int,int> > x;
    if( dots.size() != 0 && dots[0] != 1 ) x.push_back( make_pair(1,dots[0]-1) );

    for( int i = 0; i < dots.size(); ++i ){
        x.push_back( make_pair(dots[i],dots[i]) );

        int nxt = n;
        if( i + 1 < dots.size() )nxt = dots[i+1]-1;
        if( dots[i]+1 <= nxt )x.push_back( make_pair(dots[i]+1,nxt) );
    }

    if( dots.size() == 0 ) x.push_back( make_pair(1,n) );


    segment_tree T;
    T.init( x.size()  );

    for( int i = 0; i < x.size(); ++i ){
        T.bound( i , x[i].first );
        T.bound( i , x[i].second );
    }


    for( int i = 0; i < q.size(); ++i ){
        if( q[i].type == 0 ){
            T.update( q[i].a, q[i].b , q[i].c );
        }else{;
            int s = T.query( q[i].a );
            printf("%d\n",s);
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <algorithm>
#include <math.h>
#include <string>
#include <string.h>
using namespace std;

#define pii pair<int,int>
#define r first
#define c second
#define mk make_pair

int h,w;
char mat[105][105];

int sz;
pii C,Q;

int dp[105][105];

int cnt( int r1, int c1, int r2 , int c2 ){
    int s = dp[r2][c2];
    if( r1 ) s -= dp[r1-1][c2];
    if( c1 ) s -= dp[r2][c1-1];
    if( r1 && c1 ) s += dp[r1-1][c1-1];
    return s;
}

int overlap( int r1 , int c1, int r2, int c2 ){
    int r,c,r_,c_;
    r = max( r1 , C.r );
    c = max( c1 , C.c );

    r_ = min( r2 , C.r + sz - 1 );
    c_ = min( c2 , C.c + sz - 1 );

    if( r > r_ ) return 0;
    if( c > c_ ) return 0;

    return (r_-r+1)*(c_-c+1);
}

int main(){
    freopen("mravojed.in.9","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    scanf("%d%d",&h,&w);

    int xs = 0;

    for( int i = 0; i < h; ++i ){
        scanf("%s",mat[i]);
        for( int j = 0; j < w; ++j ){
            xs += mat[i][j] == 'x';
            dp[i][j] = mat[i][j] == 'x';
            if( j ) dp[i][j] += dp[i][j-1];
        }

        if( i )
        for( int j = 0; j < w; ++j )
            dp[i][j] += dp[i-1][j];
    }

    C.r = -1;

    for( int i = 0; i < h && C.r == -1; ++i ){
        for( int j = 0; j < w; ++j ){
            if( mat[i][j] == '.' ) continue;

            bool p1(0),p2(0),p3(0);
            if( j ) p1 = mat[i][j-1] == 'x';
            if( i&&j ) p2 = mat[i-1][j-1] == 'x';
            if( i ) p3 = mat[i-1][j] == 'x';

            if( !p1 && !p2 && !p3 ){ C = mk(i,j); break; }
        }
    }

    sz = 1;
    int m = min(h,w);

    for( int i = 1; i <= m; ++i ){
        if( C.r + i  > h || C.c + i  > w ) break;

        bool ok = true;
        for( int k = 0; k < i && ok; ++k ){
            if( mat[C.r+i-1][C.c+k] == '.' ) ok = false;
            if( mat[C.r+k][C.c+i-1] == '.' ) ok = false;
        }

        if( !ok ) break;
        sz = i;
    }

    printf("%d %d %d\n",C.r+1,C.c+1,sz);

    bool found = false;
    for( int i = 0; i < h && !found; ++i ){
        for( int j = 0; j < w && !found; ++j ){
            for( int k = 1; k <= m && !found; ++k ){
                int c = cnt(i,j,i+k-1,j+k-1);
                int v = k*k;
                if( c == v ){
                    int D = -overlap( i , j , i+k-1, j+k-1 );
                    D += sz*sz;
                    D += k*k;

                    if( D == xs ){
                        printf("%d %d %d\n",i+1,j+1,k);
                        found = true;
                    }
                }
            }
        }
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <string.h>
using namespace std;

int t,n;
int v[505];

int all;
int vis[5005];

int F[505];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);

    scanf("%d%d",&t,&n);
    for( int i = 0; i < n; ++i ){
        scanf("%d",&v[i]);
        all += v[i];
    }

    vis[0] = 1;

    for( int i = 0; i < n; ++i )
        for( int j = t; j >= v[i]; --j )
            if( vis[j] == false && vis[j-v[i]] )
                vis[j] = i;

    int q;
    for( q = t; !vis[q]; --q );


    memset( F , -1 , sizeof(F));
    while( q != 0 ){
        F[ vis[q] ] = q - v[ vis[q] ];
        q -= v[ vis[q] ];
    }

    int now = 0;
    for( int i = 0; i < n; ++i ){
        if( F[i] != -1 ) printf("%d ",F[i]);
        else{
            printf("%d ",now);
            now += v[i];
        }
    }


    return 0;
}

#include <iostream>
#include <cstdio>
#include <string.h>
#include <fstream>
#include <vector>
#include <algorithm>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

vector< pii > w;

bool cmp( pii a , pii b ){
    if( a.f < b.f ) return 1;
    if( a.f == b.f && a.s > b.s ) return 1;
    return 0;
}

struct segment_tree{
    vector< pii > T;
    int begin;

    segment_tree(){};

    void init( int n ){
        int sz = 1;
        while( sz < n ) sz <<= 1;
        begin = sz;
        sz <<= 1;
        T.resize(sz);
    }

    int L,R;

    pii _query( int node , int lo , int hi ){

        if( L <= lo && hi <= R ) return T[node];
        if( node >= begin || R < lo || L > hi ) return mk(0,0);

        int mid = (lo+hi)>>1;
        pii ret = _query(node*2,lo,mid);
        ret = max( ret , _query(node*2+1,mid+1,hi) );
        return ret;
    }

    pii query( int l , int r ){
        L = l + begin;
        R = r + begin;
        return _query( 1 , begin , begin*2-1);
    }

    void update( int dx , int val , int val2 ){
        dx += begin;
        T[dx] = max( T[dx] , mk(val,val2) );
        while( dx != 1 ){
            dx >>= 1;
            T[dx] = max( T[dx*2] , T[dx*2+1] );
        }
    }


};

int prv[100005];
segment_tree tree;

void backtrace( int dx ){
    if( prv[dx] != -1 ) backtrace( prv[dx] );
    printf("%d %d\n",w[dx].f,w[dx].s);
}

int main(){
    freopen("Ulaz.txt","r",stdin);

    int n;
    scanf("%d",&n);

    tree.init( 1000000 );

    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        w.push_back( mk(a,b) );
    }

    memset( prv , -1 , sizeof(prv));
    sort( w.begin() , w.end() , cmp );

    int mx=0,dx=0;

    for( int i = 0; i < n; ++i ){

        pii sol = tree.query( w[i].s , 1000000 );
        sol.f ++;

        prv[i] = sol.s;
        if( sol.f == 1 ) prv[i] = -1;

        if( sol.f > mx ) mx = sol.f , dx = i;

        tree.update( w[i].s , sol.f , i );
    }

    printf("%d\n",mx);
    backtrace( dx );

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <map>
#include <string.h>
#include <string>
#include <set>
#include <iomanip>
#include <assert.h>
using namespace std;

const int maxn = 100055;
const int inf = 1000400000;

struct quest{
    int c,v,w;
    quest(){};
    quest( int p1 , int p2 , int p3 ):c(p1),v(p2),w(p3){};
};

vector< quest > q;

struct fenwick{
    int maxn;
    vector<int>bit;

    fenwick(){};
    fenwick( int n ){
        maxn = n + 555;
        bit.resize(maxn);
        for( int i = 0; i < maxn; ++i ) bit[i] = 0;
    }

    void clear(){
        for( int i = 0; i < maxn; ++i ) bit[i] = 0;
    }

    void update( int dx , int val ){
        for( dx += 5; dx < maxn; dx += dx & -dx )
            bit[dx] += val;
    }

    int read( int dx ){
        int ret = 0;
        for( dx += 5; dx >= 1; dx -= dx & -dx )
            ret += bit[dx];
        return ret;
    }

    int kth( int k ){
        int lo = 1 , hi = maxn - 5;
        int sol = -inf;
        while( lo <= hi ){
            int mid = (lo+hi)>>1;

            int w = read(mid);
            if( w >= k ) sol = mid , hi = mid - 1;
            else lo = mid + 1;
        }
        return sol;
    }
};

struct segment_tree{
    int begin;
    vector< int > tree;

    segment_tree(){};
    segment_tree( int n ){
        n += 5;
        int sz = 1;
        while( sz < n ) sz <<= 1;
        sz <<= 1;
        tree.resize(sz,-inf);
        sz >>= 1;
        begin = sz;
    }

    int l,r;

    int _query( int node , int lo , int hi ){
        if( l <= lo && hi <= r ) return tree[node];
        if( node >= begin || lo > r || hi < l ) return -inf;

        int mid = (lo+hi)>>1;

        return max( _query(node*2,lo,mid) , _query(node*2+1,mid+1,hi) );
    }

    int query( int lo , int hi ){
        l = begin + lo;
        r = begin + hi;
        return _query( 1 , begin , begin*2-1 );
    }

    void update( int dx , int v ){
        dx += begin;
        tree[dx] = v;
        while( dx > 1 ){
            dx >>= 1;
            tree[dx] = max( tree[dx*2] , tree[dx*2+1] );
        }
    }
};

int final[maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    int n; scanf("%d",&n);
    fenwick kum(n);

    for( int i = 0; i < n; ++i ){
        char c; while( c = getchar() ) if ( c == 'A' || c == 'Q' ) break;
        int v,w; scanf("%d%d",&v,&w);
        q.push_back( quest(c,v,w) );
    }

    for( int i = 1; i < n; ++i )
        kum.update( i , 1 );

    for( int i = n-1; i >= 0; --i ){
        if( q[i].c == 'A' ){
            int pos = kum.kth( q[i].w );
            final[ i ] = pos;
            kum.update( pos , -1 );
        }
    }

   // for( int i = 0; i < n; ++i )
     //   cout<<final[i]<<" ";cout<<endl;

    kum.clear();
    segment_tree seg(n);

    for( int i = 0; i < n; ++i ){
        if( q[i].c == 'A' ){
            kum.update( final[i] , 1 );
            seg.update( final[i] , q[i].v );
        }else{
            int a = kum.kth( q[i].v );
            int b = kum.kth( q[i].w );
            int sol = seg.query( a , b );
            printf("%d\n",sol);
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <map>
#include <string.h>
#include <string>
#include <set>
#include <iomanip>
#include <assert.h>
using namespace std;

int main(){
    srand((unsigned)time(0));
    freopen("Ulaz.txt","w",stdout);

    int m = 500 +1;

    cout<<m<<endl;
    cout<<"A 1 1\n";
    int cnt = 1;

    for( int i = 0; i < m-1; ++i ){
        int r = rand()%2;

        if( r == 0 ){
            printf("A %d %d\n",-10000+rand()%10000,1+rand()%(cnt+1));
            cnt ++;
        }else{
            int a = 1+rand()%cnt, b;
            while(1){
                b = 1+rand()%cnt;
                if( b >= a ) break;
            }
            printf("Q %d %d\n",a,b);
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <map>
#include <string.h>
#include <string>
#include <set>
#include <iomanip>
#include <assert.h>
using namespace std;

int main(){

    for( int t = 1; t <= 10000; ++t ){
        system("./Q_MK");
        system("./BRUTE_BRUTE_BRUTE");
        system("./BRUTE_QMAX3VN");

        if( system("diff -qb Izlaz2.txt Izlaz3.txt")  ){
            printf("WA %d\n",t);
            while(1);
        }else{
            printf("AC %d\n",t);
        }

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
#include <queue>
#include <iomanip>
using namespace std;

const int inf = 1004000000;

struct treap{
    struct node{
        node *l,*r;
        int val;
        int rank;
        int sz;
        int maxe;

        node(){ l = r = 0; val = maxe = -inf , sz = 0; };
        node( int v ){ l = r = 0; val = maxe = v , sz = 0; };
    };

    node *root,*dummy;

    treap(){
        dummy = new node(-inf);
        dummy->l = dummy->r = dummy;
        dummy->rank = -1;
        dummy->sz = 0;
        root = dummy;
    }

    node *make( int val ){
        node *ret = new node(val);
        ret->sz = 1;
        ret->rank = rand();
        ret->l = ret->r = dummy;
        return ret;
    }

    node *rotate( node *child , node *dad ){
        if( child == dad->l )dad->l = child->r, child->r = dad;
        else dad->r = child->l, child->l = dad;
        update(dad);
        return child;
    }

    void update( node *n ){
        n->sz = n->l->sz + n->r->sz + 1;
        n->maxe = max( n->val , max(n->l->maxe , n->r->maxe) );
    }

    node *_insert( node *n , int val , int dx ){
        if( n == dummy ) return make(val);

        if( dx - 1 - (n->l->sz) >= 0 ){
            n->r = _insert( n->r , val , dx - 1 - (n->l->sz) );
            if( n->r->rank > n->rank ) n = rotate( n->r , n );
        }else{
            n->l = _insert( n->l , val , dx );
            if( n->l->rank > n->rank ) n = rotate( n->l , n );
        }
        update(n);
        return n;
    }

    int l , r;
    int _query( node *n , int behind ){
        if( n == dummy ) return -inf;
        int from = behind;
        int to = behind + n->sz - 1;

       // cout<<n->val<<" [ "<<from<<" , "<<to<<" ] "<<endl;

        if( from >= l && to <= r ) return n->maxe;
        if( from > r || to < l ) return -inf;

        int w = -inf;
        if( behind+n->l->sz >= l && from+n->l->sz <= r ) w = n->val;

        return max( w , max( _query(n->l,behind) , _query(n->r,behind+n->l->sz+1) ) );
    }

    void _traverse( node *n ){
        if( n == dummy ) return;
        _traverse( n->l );
        printf("%d ",n->val );
        _traverse( n->r );
    }
    void traverse(){ _traverse(root); printf("\n"); };
    void insert( int v , int dx ){  root = _insert( root , v , dx ); }

    int query( int lo , int hi ){
        l = lo , r = hi;
        return _query( root , 0 );
    }
};

treap t;

int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    int n;
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        char c;
        while( c = getchar() ) if ( c == 'A' || c == 'Q' ) break;

        int v1,v2;
        scanf("%d%d",&v1,&v2);

        if( c == 'A' ){
            t.insert( v1 , v2 - 1 );
        }else{
            int s = t.query( v1-1,v2-1);
            printf("%d\n",s);
        }
        //t.traverse();
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <map>
#include <stack>
#include <string.h>
#include <string>
#include <cstdio>
using namespace std;

const int maxn = 250005;

struct node{
    int shift;
    int v[10];

    node(){ shift = 0; memset(v,0,sizeof(v)); };

    int sum(){
        int ret = 0;
        for( int i = 0; i < 10; ++i )
            ret += v[i]*((i+shift)%10);
        return ret;
    }
};

const int md = 10000000;

struct segment_tree{
    int begin;
    vector< node > tree;

    segment_tree(){}

    void init( int n ){
        int sz = 1;
        while( sz < n ) sz <<= 1;
        begin = sz;
        sz <<= 1;
        tree.resize(sz);
    }

    int l,r;
    bool add;

    void _update( int node , int lo , int hi ){

        if( l <= lo && hi <= r ){
            tree[node].shift += add;
            return;
        }

        if( node >= begin || lo > r || hi < l ) return;

        tree[node*2].shift += tree[node].shift;
        tree[node*2+1].shift += tree[node].shift;

        int mid = (lo+hi)>>1;
        _update( node*2 , lo , mid  );
        _update( node*2+1 , mid+1, hi );

        tree[node].shift = 0;
        for( int i = 0; i < 10; ++i ){
            int s1 = tree[node*2].shift;
            int s2 = tree[node*2+1].shift;
            tree[node].v[i] = tree[node*2].v[(i-s1+md)%10] + tree[node*2+1].v[(i-s2+md)%10];
        }

    }

    int _query( int node , int lo , int hi ){
        if( l <= lo && hi <= r )
            return tree[node].sum();

        if( node >= begin || lo > r || hi < l ) return 0;

        int ret = 0;
        int mid = (lo+hi)>>1;
        ret += _query( node*2 , lo , mid  );
        ret += _query( node*2+1 , mid+1, hi );

        return ret;
    }

    void update( int lo , int hi ){
        l = lo + begin;
        r = hi + begin;
        _update( 1 , begin , begin*2-1 );
    }

    int query( int lo , int hi ){
        l = lo + begin;
        r = hi + begin;
        return _query( 1 , begin , begin*2-1 );
    }

    void init_vals( ){
        int row = begin;

        while( row != 1 ){
            row >>= 1;
            for( int node = row; node < row*2; ++node ){
                for( int i = 0; i < 10; ++i ){
                    int s1 = tree[node*2].shift;
                    int s2 = tree[node*2+1].shift;
                    tree[node].v[i] = tree[node*2].v[(i+s1)%10] + tree[node*2+1].v[(i+s2)%10];
                }
            }
        }
    }

};

char txt[250005];

int n,m;
segment_tree T;

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
    scanf("%d%d",&n,&m);

    T.init( n );
    scanf("%s",txt);

    for( int i = 0; i < n; ++i )
        T.tree[T.begin+i].v[ txt[i] - '0' ] ++;

    T.init_vals();

    for( int i = 0; i < m; ++i ){
        int a,b; scanf("%d%d",&a,&b); a-- , b--;
        T.add = 0;
        T.update(a,b);
        T.add = 1;

        printf("%d\n",T.query(a,b));
        T.update(a,b);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <math.h>
#include <string>
#include <string.h>
#include <map>
#include <stack>
#include <queue>
#include <cmath>
using namespace std;

typedef long long ll;

const int maxn = 1000005;
ll sub[maxn+55];
ll con[maxn+55];

int main(){
    int n; scanf("%d",&n);


    for( int i = 2; i <= n; ++i ){
        ll s = con[i];
        if( con[i] == 0 ){
            for( int k = i; k <= n; k += i ){
                con[k] ++;
                sub[k] += (k / i);
            }
        }else{
            for( int k = i; k <= n; k += i ){
                con[k] -= s - 1;
                sub[k] -= (s-1)*(k / i);
            }
        }
    }

    ll sol = 0;
    for( int i = 1; i <= n; ++i )
        sol += (i - sub[i])*2;
    cout<<sol-1<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <string>
#include <string.h>
#include <map>
#include <queue>
#include <stack>
using namespace std;

typedef long long ll;

const ll maxn = 100000000000LL;
const int maxq = 316227+55;

int ln;
ll x,A,B;

char digs[10];
bool use[10];

int LO[20];
int HI[20];

int N;
void make(){
    ll a(A),b(B);
    vector< int >d1,d2;

    while(a){
        d1.push_back( a % 10 );
        a /= 10;
    }

    while(b){
        d2.push_back( b % 10 );
        b /= 10;
    }

    N = max( d1.size() , d2.size() );

    for( int i = 0; i < d1.size(); ++i )
        LO[ N-i-1 ] = d1[i];

    for( int i = 0; i < d2.size(); ++i )
        HI[ N-i-1 ] = d2[i];
}

ll dp[15][2][2][2][maxq];

ll solve( int dx , bool da , bool db , int m , bool zero ){

    if( dx == N )return m == 0;

    ll &ref = dp[dx][da][db][zero][m];
    if( ref != -1 ) return ref;


    ref = 0;

    for( int i = 0; i <= 9; ++i ){
        if( use[i] == false && ( i != 0 || zero == false ) ) continue;
        bool da1=da,db1=db;
        bool ze = zero;

        if( i != 0 ) ze = false;
        if( i > LO[dx] ) da1 = false;
        if( i < HI[dx] ) db1 = false;
        if( i < LO[dx] && da || i > HI[dx] && db ) continue;

        ref += solve( dx + 1 , da1, db1 , (m*10+i)%x , ze );
    }

    return ref;
}


int main(){
    freopen("v.in.14","r",stdin);

    cin >> x >> A >> B;
    cin >> digs;

    ln = strlen(digs);
    for( int i = 0; i < ln; ++i ) use[ digs[i]-'0' ] = 1;

    if( x >= maxq ){

        ll sol = 0;
        for( ll i = x; i <= B; i += x ){
            if( i < A ) continue;
            ll w = i;
            bool ok = true;
            while( w && ok ){
                int d = w % 10; w /= 10;
                if( use[d] == false ) ok = false;
            }
            sol += ok;
        }

        printf("%lld\n",sol);
    }else{
        make();
        memset( dp , -1 , sizeof(dp));
        ll sol = solve( 0 , 1 , 1 , 0 , 1 );
        cout<<sol<<endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <string>
#include <string.h>
#include <algorithm>
#include <map>
#include <set>
#include <math.h>
#include <iomanip>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 100000 + 555;
const int maxm = 10000 + 55;
const int inf = 1003000000;

struct node{
        node *l,*r;
        int val,rank,sz;
        node(){};
        node( int v ){ val = v; sz = 0; }
};

node *dummy;

struct treap{
    node *root;
    treap(){ root = dummy; }

    inline node *make( int val ){
        node *ret = new node( val );
        ret->l = ret->r = dummy;
        ret->rank = rand();
        ret->sz = 1;
        return ret;
    }

    inline node *rotate( node *child , node *dad ){
        if( dad->l == child ) dad->l = child->r , child->r = dad;
        else dad->r = child->l , child->l = dad;
        dad->sz = 1 + dad->l->sz + dad->r->sz;
        return child;
    }

    node *_insert( node *n, int val ){
        if( n == dummy ) return make( val );
        else if( n->val >= val ){
            n->l = _insert( n->l , val );
            if( n->l->rank > n->rank ) n = rotate( n->l , n );
        }else{
            n->r = _insert( n->r , val );
            if( n->r->rank > n->rank ) n = rotate( n->r , n );
        }
        n->sz = 1 + n->l->sz + n->r->sz;
        return n;
    }

    int kth( int K ){
        K --;
        node *pok = root;

        while(1){
            if( pok->l->sz <= K ){
                K -= pok->l->sz + 1;
                if( K == -1 ) return pok->val;
                pok = pok->r;
            }else pok = pok->l;
        }
    }

    inline void insert( int val ){ root = _insert( root , val );  };

    void go_over( node *n ){
        if( n == dummy ) return;
        go_over( n->l );
        insert( n->val );
        go_over( n->r );
    }

    inline void link_treap( node *root2 ){
        go_over( root2 );
    }
};


int n;
int label[maxn];
vector< int > quest[maxn];
treap ts[maxn];

int ans[maxn];

int nedge = 1;
int point[maxn<<1] , nxt[maxn<<1] , head[maxn<<1];

inline void add_edge( int a, int b ){
    nxt[nedge] = head[a] , point[nedge] = b, head[a] = nedge++;
    nxt[nedge] = head[b] , point[nedge] = a, head[b] = nedge++;
}

int s[maxn],sz=0;
int p[maxn];
int rev[maxn];
vector<int>sols[maxn];


void dfs( int node , int dad ){
    int sz = -1,dx = -1;
    for( int i = head[node]; i > 0; i = nxt[i] ){
        int nxt = point[i];
        if( nxt == dad ) continue;
        dfs( nxt , node );

        if( sz < ts[nxt].root->sz ){
            sz = ts[nxt].root->sz;
            ts[node].root = ts[nxt].root;
            dx = nxt;
        }
    }
    ts[node].insert( label[node] );

    for( int i = head[node]; i > 0; i = nxt[i] ){
        int nxt = point[i];
        if( nxt == dad || nxt == dx ) continue;
        ts[node].link_treap( ts[nxt].root );
    }

    for( int i = 0; i < quest[node].size(); ++i ){
        int k = quest[node][i];
        sols[node].push_back( rev[ts[node].kth( k )] );
    }
}


const int MaxBuff = 500000;

char buff[ MaxBuff ];
int pos = MaxBuff;

inline char readch () {
  if ( pos == MaxBuff ) {
    fread( buff, 1, MaxBuff, stdin );
    pos = 0;
  }
  return buff[pos++];
}

inline int readint () {
  char c;
  int ret;
  while ( !isdigit( c = readch() ) );
  ret = c - '0';
  while ( isdigit( c = readch() ) ) {
    ret *= 10;
    ret += c - '0';
  }
  return ret;
}

int x[maxn],k[maxn],sr[maxn];
int dxs[maxm];

int main(){ srand((unsigned)time(0));
    dummy = new node(); dummy->l = dummy->r = dummy; dummy->rank = -1; dummy->sz = 0;

  //  double w = clock();
    freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);

    n = readint();
    for( int i = 0; i < n; ++i ) label[i] = readint(), sr[i] = label[i] , ts[i].root = dummy;

    sort( sr ,sr+n);
    for( int i = 0; i < n; ++i ) label[i] = lower_bound( sr , sr + n , label[i] ) - sr , rev[ label[i] ] = i;

    for( int i = 0; i < n-1; ++i ){
        int a,b; a = readint(); b = readint(); a--, b--;
        add_edge(a,b);
    }

    int m; m = readint();

    for( int i = 0; i < m; ++i ){
        x[i] = readint(); k[i] = readint();
        x[i]--;
        dxs[i] = quest[ x[i] ].size();
        quest[x[i]].push_back( k[i] );
    }

    dfs( 0 , -1 );

    for( int i = 0; i < m; ++i )
       printf("%d\n",sols[x[i]][ dxs[i] ]+1);

    //printf("%.10lf\n",(clock()-w)/CLOCKS_PER_SEC);
    return 0;
}

#include <iostream>
#include <vector>
#include <string>
#include <string.h>
#include <algorithm>
#include <map>
#include <set>
#include <math.h>
#include <iomanip>
#include <queue>
using namespace std;

const int inf = 1000300000;
const int maxn = 100000 + 555;

inline void readi( int &v ){
    char c;
    while( (c=getchar())<'0' || c >'9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
}

struct segment_tree{
    int begin;
    vector< vector<int> > tree;

    void init( int n ){
        int sz = 1;
        while( sz < n ) sz <<= 1;
        begin = sz;
        sz <<= 1;
        tree.resize(sz);
    }

    segment_tree(){};
    segment_tree( int n ){ init(n); }


    void build( int *f , int n ){
        int cnt = 0;
        for( int i = begin; i < begin+n; ++i )
            tree[i].push_back( f[i-begin] ),cnt++;

        for( int lvl = begin>>1; lvl >= 1; lvl >>= 1 ){
            for( int i = lvl; i < (lvl<<1); ++i ){
                int l = i*2;
                int r = i*2+1;

                int n = tree[l].size();
                int m = tree[r].size();

                int xl = 0 , xr = 0;
                while( xl < n || xr < m ){cnt++;
                    if( xr == m || xl != n && tree[l][xl] < tree[r][xr] )
                         tree[i].push_back( tree[l][xl] ) , xl ++;
                    else tree[i].push_back( tree[r][xr] ) , xr ++;
                }
            }
        }
    }

    int l,r,val;

    int _query( int node , int lo , int hi ){
        if( l <= lo && hi <= r ) return upper_bound( tree[node].begin() , tree[node].end() , val ) - tree[node].begin();
        if( node >= begin || r < lo || hi < l ) return 0;

        int mid = (lo+hi)>>1;
        return _query( node<<1 , lo , mid ) + _query( (node<<1)+1 , mid+1 , hi );
    }

    int kth( int L , int R , int k ){
        l = L + begin;
        r = R + begin;

        int lo = 0, hi = tree[1][ tree[1].size() - 1 ];
        int sol = -1;
        while( lo <= hi ){
            val = (lo+hi)>>1;
            int lw = _query( 1 , begin , begin*2-1 );
            if( lw >= k ) sol = val , hi = val - 1;
            else lo = val + 1;
        }

        return sol;
    }
};

segment_tree t;

int cnte = 1;
int point[maxn*2] , nxt[maxn*2] , head[maxn*2];

inline void add_edge( int a, int b ){
    nxt[cnte] = head[a] , point[cnte] = b , head[a] = cnte ++;
    nxt[cnte] = head[b] , point[cnte] = a , head[b] = cnte ++;
}

int n;
int label[maxn];

int lo[maxn] , hi[maxn];
int dxcnt = 0;

void dfs( int node , int dad ){
    lo[node] = dxcnt ++;
    for( int i = head[node]; i > 0; i = nxt[i] ){
        int nxt = point[i];
        if( nxt == dad ) continue;
        dfs( nxt , node );
    }
    hi[node] = dxcnt - 1;
}

int mem[maxn];
map<int,int> mp;

int main(){
    double w = clock();
    freopen("Ulaz.txt","r",stdin);

    readi(n);
    for( int i = 0; i < n; ++i ){
        readi(label[i]);
        mp[label[i]] = i+1;
    }

    for( int i = 0; i < n-1; ++i ){
        int a,b; readi(a);readi(b); a-- , b--;
        add_edge( a , b );
    }

    dfs( 0 , -1 );

    for( int i = 0; i < n; ++i ) mem[ lo[i] ] = label[i];

    t.init(n);
    t.build( mem , n );

    int m; readi(m);
    for( int i = 0; i < m; ++i ){
        int x,k;
        readi(x);readi(k); x--;
        int s = t.kth( lo[x] , hi[x] , k );
        printf("%d\n",mp[s]);
    }
    printf("%.10lf\n",(clock()-w)/CLOCKS_PER_SEC);

    return 0;
}

#include <iostream>
#include <vector>
#include <string>
#include <string.h>
#include <algorithm>
#include <map>
#include <set>
#include <math.h>
#include <iomanip>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 100000 + 555;
const int inf = 1003000000;

int n;
int label[maxn];
vector< int > quest[maxn];
vector< int > *ts[maxn];

int ans[maxn];

int nedge = 1;
int point[maxn<<1] , nxt[maxn<<1] , head[maxn<<1];

inline void add_edge( int a, int b ){
    nxt[nedge] = head[a] , point[nedge] = b, head[a] = nedge++;
    nxt[nedge] = head[b] , point[nedge] = a, head[b] = nedge++;
}

int s[maxn],sz=0;
int p[maxn];
int rev[maxn];
map<int,int> sols[maxn];


void dfs( int node , int dad ){
    int sz = -1,dx = -1;
    for( int i = head[node]; i > 0; i = nxt[i] ){
        int nxt = point[i];
        if( nxt == dad ) continue;
        dfs( nxt , node );

        if( sz < ts[nxt]->size() ){
            sz = ts[nxt]->size();
            dx = nxt;
        }
    }
    if( dx != -1 )ts[node] = ts[dx];
    else ts[node] = new vector<int>;
    ts[node]->push_back( label[node] );

    for( int i = head[node]; i > 0; i = nxt[i] ){
        int nxt = point[i];
        if( nxt == dad || nxt == dx ) continue;
        for( int i = 0; i < ts[nxt]->size(); ++i )
            ts[node]->push_back( ts[nxt]->at(i) );
    }

    sort( ts[node]->begin() , ts[node]->end() );

    for( int i = 0; i < quest[node].size(); ++i ){
        int k = quest[node][i];
        if( sols[node][k] ) continue;
        sols[node][k] = rev[ (*ts[node])[k-1] ];
    }
}

inline void readi( int &v ){
    char c;
    while( (c=getchar())<'0' || c >'9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
}

int x[maxn],k[maxn],sr[maxn];

int main(){

   // double w = clock();
    freopen("Ulaz.txt","r",stdin);

    readi(n);
    for( int i = 0; i < n; ++i ) readi( label[i] ) , sr[i] = label[i];

    sort( sr ,sr+n);
    for( int i = 0; i < n; ++i ) label[i] = lower_bound( sr , sr + n , label[i] ) - sr , rev[ label[i] ] = i;

    for( int i = 0; i < n-1; ++i ){
        int a,b; readi(a);readi(b); a--, b--;
        add_edge(a,b);
    }

    int m; readi(m);
    for( int i = 0; i < m; ++i ){
        readi(x[i]);readi(k[i]); x[i]--;
        quest[x[i]].push_back( k[i] );
    }

    dfs( 0 , -1 );

    for( int i = 0; i < m; ++i )
       printf("%d\n",sols[x[i]][k[i]]+1);

    //printf("%.10lf\n",(clock()-w)/CLOCKS_PER_SEC);
    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <map>
#include <set>
#include <iomanip>
#include <queue>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

const int maxn = 100000 + 555;
const int maxq = 350;

int cnte = 1;
int point[maxn*2] , nxt[maxn*2] , head[maxn*2];

inline void readi( int &v ){
    char c;
    while( (c=getchar())<'0' || c >'9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
}

inline void add_edge( int a, int b ){
    nxt[cnte] = head[a] , point[cnte] = b , head[a] = cnte ++;
    nxt[cnte] = head[b] , point[cnte] = a , head[b] = cnte ++;
}

int n;
int label[maxn];

int rev[maxn];
int lo[maxn] , hi[maxn];
int dxcnt = 0;

void dfs( int node , int dad ){
    rev[dxcnt] = node;
    lo[node] = dxcnt ++;
    for( int i = head[node]; i > 0; i = nxt[i] ){
        int nxt = point[i];
        if( nxt == dad ) continue;
        dfs( nxt , node );
    }
    hi[node] = dxcnt - 1;
}

int mem[maxn] , pack[maxn];
map<int,int> mp;

inline int solve( int lo , int hi , int K ){
    for( int i = 0; i < n; i += maxq ){
        int inrange = 1 / 2 + 500 / 3;
        for( int i = 0; i < 5; ++i );
      //  inrange -= upper_bound( pack+i , pack + min(i+maxq,n) , lo-1 ) - (pack+i);

//        if( K <= inrange ){
//            int to = min(n,i+maxq);
//            for( int k = i; k < to; ++k ){
//                if( lo <= pack[k] && pack[k] <= hi ) K --;
//                if( K == 0 ) return rev[ pack[k] ];
//            }
//
//        }else K -= inrange;
    }
}

int main(){
    double w = clock();
    freopen("Ulaz.txt","r",stdin);

    readi(n);
    for( int i = 0; i < n; ++i ){
        readi(label[i]);
        mp[label[i]] = i+1;
    }

    for( int i = 0; i < n-1; ++i ){
        int a,b; readi(a);readi(b); a-- , b--;
        add_edge( a , b );
    }

    dfs( 0 , -1 );
    vector<pii> s;

    for( int i = 0; i < n; ++i ) s.push_back( mk(label[i],lo[i]) );
    sort( s.begin() , s.end() );
    for( int i = 0; i < n; ++i ) pack[i]  = s[i].s;

    for( int i = 0; i < n; i += maxq ) sort( pack + i , pack + min(i+maxq,n) );

    int m; scanf("%d",&m);
    for( int i = 0; i < m; ++i ){
        int x,k;
        scanf("%d%d",&x,&k);
        printf("%d\n",solve(lo[x],hi[x],k));
    }


    printf("%.10lf\n",(clock()-w)/CLOCKS_PER_SEC);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <map>
#include <stack>
#include <string.h>
#include <iomanip>
using namespace std;

const int maxn = 100000 + 555;
const int inf = 1003000000;

struct segment_tree{
    int begin;
    vector< int > tree;

    void init( int n ){
        int sz = 1;
        while( sz < n ) sz <<= 1;
        begin = sz;
        sz <<= 1;
        tree.resize(sz);
    }

    segment_tree(){}
    segment_tree( int n ){ init(n); }

    int update( int dx ){
        dx += begin;
        tree[dx] ++;
        while( dx > 1 ){ dx >>= 1; tree[dx] ++; }
    }

    int take( int dx ){
        dx += begin;
        tree[dx] --;
        while( dx > 1 ){ dx >>= 1; tree[dx] --; }
    }

    int kth( int k ){
        int now = 1;
        while(1){
            if( now >= begin ) return now - begin;;
            if( tree[now*2] >= k ) now *= 2;
            else k -= tree[now*2] , now = now * 2 + 1;
        }
    }
};

int n;
int label[maxn];
vector< int > quest[maxn];

int ans[maxn];

int nedge = 1;
int point[maxn<<1] , nxt[maxn<<1] , head[maxn<<1];

inline void add_edge( int a, int b ){
    nxt[nedge] = head[a] , point[nedge] = b, head[a] = nedge++;
    nxt[nedge] = head[b] , point[nedge] = a, head[b] = nedge++;
}

int s[maxn],sz=0;
int p[maxn];
int rev[maxn];
vector<int > sols[maxn];


int subsz[maxn];
segment_tree ts;

int subsize( int node , int dad ){
    subsz[node] = 1;
    for( int i = head[node]; i > 0; i = nxt[i] ){
        int w = point[i];
        if( w == dad ) continue;
        subsz[node] += subsize( w , node );
    }
    return subsz[node];
}

int mem[maxn] , ss = 0;

void dfs( int node , int dad , bool erase_back ){
    int last = -1 , mx = -1;;
    for( int i = head[node]; i > 0; i = nxt[i] ){
        int w = point[i];
        if( w == dad ) continue;
        if( mx < subsz[w] ) mx = subsz[w] , last = w;
    }

    for( int i = head[node]; i > 0; i = nxt[i] ){
        int w = point[i];
        if( w == dad || w == last ) continue;
        dfs( w , node , 1 );
    }

    if( last != -1 )dfs( last , node , 0 );

    ss = 0;

    ts.update( label[node] );
    for( int i = head[node]; i > 0; i = nxt[i] ){
        int nxt = point[i];
        if( nxt == dad || nxt == last ) continue;
        sz = 0;
        s[sz] = nxt;
        p[sz++] = node;
        while( sz > 0 ){
            int u = s[sz-1];
            ts.update( label[u]);
            mem[ss++] = label[u];
            int d = p[sz-1]; sz--;
            for( int j = head[u]; j > 0; j = ::nxt[j] ){
                if( point[j] == d )  continue;
                s[sz] = point[j];
                p[sz++] = u;
            }
        }
    }

    for( int i = 0; i < quest[node].size(); ++i ){
        int k = quest[node][i];
        sols[node].push_back( rev[ts.kth(k)] );
    }

    if( erase_back ){
        ts.take( label[node] );
        for( int i = head[node]; i > 0; i = nxt[i] ){
            int nxt = point[i];
            if( nxt == dad || nxt != last  ) continue;
            sz = 0;
            s[sz] = nxt;
            p[sz++] = node;
            while( sz > 0 ){
                int u = s[sz-1];
                ts.take( label[u]);
                int d = p[sz-1]; sz--;
                for( int j = head[u]; j > 0; j = ::nxt[j] ){
                    if( point[j] == d )  continue;
                    s[sz] = point[j];
                    p[sz++] = u;
                }
            }
        }
        for( int i = 0; i < ss; ++i )
            ts.take( mem[i] );
    }
}


const int MaxBuff = 500000;

char buff[ MaxBuff ];
int pos = MaxBuff;

inline char readch () {
  if ( pos == MaxBuff ) {
    fread( buff, 1, MaxBuff, stdin );
    pos = 0;
  }
  return buff[pos++];
}

inline int readint () {
  char c;
  int ret;
  while ( !isdigit( c = readch() ) );
  ret = c - '0';
  while ( isdigit( c = readch() ) ) {
    ret *= 10;
    ret += c - '0';
  }
  return ret;
}

int x[maxn],k[maxn],sr[maxn];
int dxs[10055];

int main(){ double w = clock();
    //freopen("Ulaz.txt","r",stdin);

    n = readint(); ts.init(n);
    for( int i = 0; i < n; ++i ) label[i] = readint() , sr[i] = label[i];

    sort( sr ,sr+n);
    for( int i = 0; i < n; ++i ) label[i] = lower_bound( sr , sr + n , label[i] ) - sr , rev[ label[i] ] = i;
    for( int i = 0; i < n-1; ++i ){ int a,b; a = readint();b = readint(); a--, b--; add_edge(a,b); }

    int m; m = readint();
    for( int i = 0; i < m; ++i ){
        x[i] = readint(); k[i] = readint();x[i]--;
        dxs[i] = quest[x[i]].size();
        quest[x[i]].push_back( k[i] );
    }

    subsize( 0 , -1 );
    dfs( 0 , -1 , 0 );
    for( int i = 0; i < m; ++i ) printf("%d\n",sols[x[i]][ dxs[i] ]+1);

   // printf("%.10lf\n",(clock()-w)/CLOCKS_PER_SEC);
    return 0;
}


#include <iostream>
#include <cstdio>
#include <vector>
#include <math.h>
#include <algorithm>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 1005;

#define ok(r,c) (r>=0&&c>=0&&r<n&&c<m)

int dirQ[][2] = { -1,0 , 1,0 , 0,1, 0,-1 , 1,1 , -1,-1, 1,-1 , -1,1 };
int dirK[][2] = { -2,1 , 2,-1, -2,-1 , 2,1 , 1,-2, -1,2, -1,-2, 1,2 };

int n,m;
int mat[maxn][maxn];
bool ok[maxn][maxn];

int main(){
    int t = 1;
    //freopen("Ulaz.txt","r",stdin);
    while( scanf("%d%d",&n,&m) == 2 ){
        if( n == 0 && m == 0 ) break;

        memset( mat , 0 , sizeof(mat));
        memset( ok , 0 , sizeof(ok));

        for( int i = 0; i < 3; ++i ){
            int d; scanf("%d",&d);
            for( int j = 0; j < d; ++j ){
                int r,c; scanf("%d%d",&r,&c);
                mat[r-1][c-1] = i+1;
                ok[r-1][c-1] = 1;
            }
        }

        for( int i = 0; i < n; ++i ){
            for( int j = 0; j < m; ++j ){
                if( mat[i][j] == 1 ){
                    for( int k = 0; k < 8; ++k ){
                        int r = i , c = j;
                        while(1){
                            r += dirQ[k][0];
                            c += dirQ[k][1];
                            if( ok(r,c) == false || mat[r][c] ) break;
                            ok[r][c] = 1;
                        }
                    }
                }else if( mat[i][j] == 2 ){
                    for( int k = 0; k < 8; ++k ){
                        int r = i + dirK[k][0];
                        int c = j + dirK[k][1];
                        if( ok(r,c) ) ok[r][c] = 1;
                    }
                }
            }
        }

        int sol = 0;
        for( int i = 0; i < n; ++i )
            for( int j = 0; j < m; ++j )
                sol += ok[i][j] == 0;
        printf("Board %d has %d safe squares.\n",t++,sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <algorithm>
using namespace std;

const int maxn = 1000 + 55;

int n;
int niz[maxn];
int dp[maxn][maxn][2];

int clever( int f , int s , bool player ){
    if( f > s ) return 0;
    int &ref = dp[f][s][player];
    if( ref > 0 ) return ref;

    if( !player ) ref = max( clever(f+1,s,!player)+niz[f] , clever(f,s-1,!player)+niz[s] );
    else if( niz[f] >= niz[s] ) ref = clever(f+1,s,!player);
    else ref = clever(f,s-1,!player);

    return ref;
}

int main(){

    int t = 1;
    while( scanf("%d",&n) == 1 ){
        if( n == 0 ) break;

        int sum = 0;
        for( int i = 0; i < n; ++i ) scanf("%d",&niz[i]) , sum += niz[i];

        memset( dp , 0 , sizeof(dp));
        int v = clever( 0 , n-1 , 0 );

        printf("In game %d, the greedy strategy might lose by as many as %d points.\n",t++,2*v-sum);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string.h>
#include <string>
#include <math.h>
using namespace std;

int main(){
    double w;

    while( scanf("%lf",&w) == 1 ){
        if( w < 1 ) break;

        double f=1,cnt=1;
        bool overf = 1;

        while( w > 1 ){

            if( fmod(w,2) == 0 ){
                if( overf ) w = floor(w / 2);
                else w /= 2 , overf = 0 , f += cnt;
            }else{
                if( overf ) w = ceil(w/2) , overf = 0;
                else w = floor(w / 2) , overf = 1 , f += cnt;
            }
            cnt *= 2;
        }
        printf("%.0lf\n",f);
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
using namespace std;

const int maxn = 100000000;

int n;
int niz[maxn];

int main(){


    scanf("%d",&n);
    for( int i = 1; i <= n; ++i ) niz[i-1] = i;

    int cnt = 0;
    while( n > 1 ){
        int k = 0;
        //9cout<<n<<endl;
        for( int i = 0; i < n; ++i ){
            if( cnt % 2 == 0 )niz[k++] = niz[i];
            cnt ++;
        }
        n = k;
       // for( int i = 0; i < n; ++i )
        //    cout<<niz[i]<<" ";cout<<endl;
    }

    for( int i = 0; i < n; ++i )
            cout<<niz[i]<<" ";cout<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string.h>
#include <string>
#include <vector>
using namespace std;

const int maxn = 3000 + 55;
const int inf = 99999999;

int n,m;
int pop[maxn];
int ss[maxn];

int dp[3015][15];

int solve( int dx , int col ){
    if( dx == n ) return 0;
    if( col == m ) return inf;

    int &sol = dp[dx][col];
    if( sol != -1 ) return sol;

    sol = inf;

    for( int i = dx; i < n; ++i ){
        int mid = (i+dx) >> 1;
        int lsum = ss[mid] - (dx?ss[dx-1]:0);
        int rsum = ss[i] - (mid?ss[mid-1]:0);
        int cl = mid - dx + 1;
        int cr = i - mid + 1;

        int sum = cl*pop[mid] - lsum;
        sum += -cr*pop[mid] + rsum;

        sol = min( sol , sum + solve( i+1 , col+1 ) );
    }
    return sol;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    while( tests -- ){

        scanf("%d%d",&n,&m);
        for( int i = 0; i < n; ++i ){
            scanf("%d",&pop[i]);
        }
        sort( pop , pop + n );
        for( int i = 0; i < n; ++i ){
            ss[i] = pop[i];
            if( i ) ss[i] += ss[i-1];
        }

        memset( dp, -1, sizeof(dp));
        int sol = solve( 0 , 0 );
        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <string>
#include <vector>
using namespace std;

char txt[100000];
int n,v;

int main(){
   // freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    while( tests-- ){
        long long sol = 0;
        scanf("%d",&n);

        vector< int > w;

        for( int i = 1; i <= n; ++i ){
            scanf("%s%d",txt,&v);
            w.push_back(v);
        }

        sort(w.begin(),w.end());
        for( int i = 1; i <= n; ++i )
            sol += abs(i-w[i-1]);

        printf("%lld\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <stack>
#include <map>
#include <string.h>
#include <algorithm>
using namespace std;

int n,m;
int mov[100];
char txt[100];
char mem[100];

int movs[30][100];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
    while( scanf("%d%d",&n,&m) == 2 ){
        if( n + m == 0 ) break;

        for( int i = 0; i < n; ++i ){
            scanf("%d",&mov[i]);
            mov[i]--;
            movs[0][i] = mov[i];
        }
        gets(txt);
        gets(txt);

        for( int i = 1; i < 30; ++i )
            for( int k = 0; k < n; ++k )
                movs[i][k] = movs[i-1][ movs[i-1][k] ];

        for( int i = 30; i >= 0; --i ){
            if( (1<<i) <= m ){
                m -= 1 << i;
                for( int k = 0; k < n; ++k )
                    mem[ movs[i][k] ] = txt[k];

                memcpy( txt , mem , sizeof txt );
            }
        }

        for( int i = 0; i < n; ++i )
            printf("%c",txt[i]);
        putchar('\n');

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
using namespace std;

const int inf = 999;

int n,m;
char txt[100];

bool mat[55][55];
vector< int > g[55];

bool vis[55];
void dfs( int node ){
    vis[node] = 1;
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( vis[nxt] == false ) dfs( nxt );
    }
}

int del( int a, int b ){
    for( int i = 0; i < g[a].size(); ++i )
        if( g[a][i] == b ) return inf;

    int sol = 0;
    bool reachB[55];
    for( int i = 0; i < 55; ++i ) reachB[i] = 0;

    for( int i = 0; i < g[a].size(); ++i ){
        int w = g[a][i];
        memset( vis, false, sizeof(vis));
        for( int k = 0; k < g[a].size(); ++k ) vis[ g[a][k] ] = 1;

        dfs( w );
        if( vis[b] ) sol ++;
    }
    return sol;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&n,&m);

        memset( mat, 0, sizeof(mat));
        for( int i = 0; i <= n; ++i ) g[i].clear();

        for( int i = 0; i < m; ++i ){
            scanf("%s",txt);
            int a,b;
            sscanf(txt,"(%d,%d)",&a,&b);

            if( mat[a][b] ) continue;
            mat[a][b] = 1;

            g[a].push_back(b);
            g[b].push_back(a);
        }
        int sol = 9999;

        bool complete = true;
        for( int i = 0; i < n; ++i ) if( g[i].size() != n-1 ) complete = false;
        if( complete ){ printf("%d\n",n); continue; }

        for( int i = 0; i < n; ++i )
            for( int j = 0; j < n; ++j )
                for( int k = j+1; k < n; ++k )
                    if( mat[j][i] && mat[i][k] ) mat[j][k] = 1;


        for( int i = 0; i < n; ++i ){
            for( int j = i+1; j < n; ++j ){
                sol = min( sol , del(i,j));
            }
        }
        printf("%d\n",sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <stack>
#include <map>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

const int inf = 1000000000;

struct coord{
    double x,y;
    coord(){};
    coord( double p1, double p2 ):x(p1),y(p2){};
    double dist( coord &c2 ){
        return sqrt( (x-c2.x)*(x-c2.x) + (y-c2.y)*(y-c2.y) );
    }
};

struct segment{
    int x,y;
    segment(){};
    segment( int p1, int p2 ):x(p1),y(p2){};
};


int n;
coord points[30];
segment seg[15];
double dst[30][30];

double dp[1<<14][30];

double solve( int mask , int a ){
    if( mask == (1<<n)-1 ) return 0;

    double &ret = dp[mask][a];
    if( ret < -1 ) return ret;

    ret = inf;

    for( int i = 0; i < n; ++i ){
        if( mask&(1<<i) )continue;

        ret = min( ret , solve( mask+(1<<i) , seg[i].y  ) + dst[a][ seg[i].x ] );
        ret = min( ret , solve( mask+(1<<i) , seg[i].x  ) + dst[a][ seg[i].y ] );
    }
    return ret;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int t = 1;
    while( scanf("%d",&n) == 1 ){
        if( n == 0 ) break;

        double add = 0;

        for( int i = 0; i < n; ++i ){
            int f = i*2 , s = i*2+1;
            scanf("%lf%lf%lf%lf",&points[f].x,&points[f].y,&points[s].x,&points[s].y);
            seg[i] = segment(f,s);
            add += points[f].dist( points[s] );
        }
        int n2 = n << 1;

        for( int i = 0; i < n2; ++i )
            for( int j = 0; j < n2; ++j )
                dst[i][j] = points[i].dist( points[j] );

        for( int i = 0; i < (1<<n); ++i )
            for( int j = 0; j < n2; ++j )
                    dp[i][j] = inf;

        double sol = inf;
//        for( int i = 0; i < n; ++i ){
//            double ret = solve( 1<<i , seg[i].x );
//            ret = min( ret , solve( i<<i , seg[i].y ) );
//            sol = min( ret , sol );
//        }

        for( int i = 0; i < n2; ++i ) dp[1<<(i>>1)][i] = dp[0][0] = 0;

        for( int i = 1; i < (1<<n)-1; ++i ){
            for( int x = 0; x < n; ++x ){
                if( i&(1<<x) ) continue;

                int m = i+(1<<x);

                for( int y = 0; y < n; ++y ){
                    if( ~i&(1<<y) ) continue;

                    dp[m][ seg[x].x ] = min( dp[m][ seg[x].x ] , dp[i][ seg[y].x ] + dst[seg[y].x][seg[x].y]  );
                    dp[m][ seg[x].x ] = min( dp[m][ seg[x].x ] , dp[i][ seg[y].y ] + dst[seg[y].y][seg[x].y]  );

                    dp[m][ seg[x].y ] = min( dp[m][ seg[x].y ] , dp[i][ seg[y].x ] + dst[seg[y].x][seg[x].x]  );
                    dp[m][ seg[x].y ] = min( dp[m][ seg[x].y ] , dp[i][ seg[y].y ] + dst[seg[y].y][seg[x].x]  );
                }
            }
        }

        for( int i = 0; i < n2; ++i ) sol = min( sol , dp[(1<<n)-1][i] );

        printf("Case %d: %.5lf\n",t,sol+add); t++;
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <math.h>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

char txt[30];

bool ok( string w ){
    int len = w.size();
    for( int i = 0; i < len; ++i ){
        for( int c = 'A'; c <= 'Z'; ++c ){
            char tmp = w[i];
            w[i] = c;
            bool ok = 1;
            for( int k = 0; k < len; ++k )
                if( w[k] != w[ len-k-1 ] ) ok = 0;
            w[i] = tmp;
            if( ok ) return 1;
        }
    }
    return false;
}

int main(){

    while( scanf("%s",txt) == 1 ){
        if( strcmp(txt,"*END*") == 0 ) break;

        bool isok = 0;
        int len = strlen(txt);
        string f = "";

        for( int i = 0; i < len && !isok; ++i ){
            string s = "";
            f += string(1,txt[i]);
            for( int j = i+1; j < len; ++j ) s += string(1,txt[j]);

            if( ok(f) && ok(s) ) isok = 1;
        }

        if( isok ) printf("%s is a double near palindrome.\n",txt);
        else printf("%s is not a double near palindrome.\n",txt);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
using namespace std;

typedef long long ll;

int p,n;

int pow( int a , int e , int mod ){
    if( e == 1 ) return a;
    else if( e%2 ) return (a*(ll)pow(a,e-1,mod))%mod;
    else{
        int w = pow( a , e / 2 , mod );
        return (w*(ll)w)%mod;
    }
}

int main(){

    while( scanf("%d%d",&p,&n) == 2 ){
        if( p == 0 && n == 0 ) break;
        while( n -- ){

            int r; scanf("%d",&r);
            if( pow(r,p-1,p) == 1 ){
                bool ok = 1;
                int to = (int)sqrt(p-1);
                for( int i = 2; i <= to && ok; ++i ){
                    if( (p-1)%i == 0){
                        if( pow(r,(p-1)/i,p) == 1 ) ok = 0;
                        if( pow(r,i,p) == 1 ) ok = 0;
                    }
                }
                if( ok ) printf("YES\n");
                else printf("NO\n");
            }
            else printf("NO\n");
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <set>
#include <algorithm>
#include <string.h>
#include <iomanip>
#include <string>
#include <stack>
using namespace std;

const int inf = 99999999;
const int maxn = 205;

int n,m;
int mat[maxn][maxn];

int row[maxn][maxn];
int col[maxn][maxn];
int mxx[maxn][maxn][maxn];
int cc[maxn][maxn][maxn];
int tak[maxn][maxn];

int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&n,&m);

        int isone = 0;
        int iszero = 0;
        for( int i = 0; i < n; ++i ){
            for( int j = 0; j < m; ++j ){
                scanf("%d",&mat[i][j]);
                isone += mat[i][j];
                iszero += mat[i][j] == 0;
                if( mat[i][j] == 0 ) mat[i][j] = -1;

                row[i][j] = mat[i][j] + (j?row[i][j-1]:0);
                col[i][j] = mat[i][j] + (i?col[i-1][j]:0);
            }
        }
       // if( isone == 0 ){
       //     printf("%d %d\n",-1,iszero);
       //     continue;
        //}

        for( int i = 0; i < m; ++i )
            for( int j = 0; j < m; ++j )
                mxx[n][i][j] = -inf, cc[n][i][j] = 1;

        for( int i = n-1; i >= 0; --i ){
            for( int k1 = 0; k1 < m; ++k1 ){
                for( int k2 = k1; k2 < m; ++k2 ){
                    int sum = row[i][k2];
                    if( k1 ) sum -= row[i][k1-1];
                    if( k1 != k2 ) sum += col[i][k2] - mat[i][k2];
                    sum += col[i][k1] - mat[i][k1];

                    int w = mxx[i+1][k1][k2];
                    if( w >= sum ) mxx[i][k1][k2] = w , cc[i][k1][k2] = cc[i+1][k1][k2] + (w == sum);
                    else if( w < sum ) mxx[i][k1][k2] = sum, cc[i][k1][k2] = 1;

                    //printf("%d [%d,%d] = %d\n",i,k1,k2,mxx[i][k1][k2]);
                }
            }
        }

        int solu = -5, cnt = 0;

        for( int i = 0; i < n; ++i ){
            for( int k1 = 0; k1 < m; ++k1 ){
                for( int k2 = k1; k2 < m; ++k2 ){
                    if( !i ) tak[k1][k2] = 0;
                    tak[k1][k2] += mat[i][k1];
                    if( k1 != k2 ) tak[k1][k2] += mat[i][k2];

                    int rsum = row[i][k2];
                    if( k1 ) rsum -= row[i][k1-1];

                    int sol = mxx[i+1][k1][k2] - tak[k1][k2] + rsum;

                    if( sol > solu ) solu = sol , cnt = 0;
                    if( sol == solu ) cnt += cc[i+1][k1][k2];


                    if( rsum > solu ) solu = rsum , cnt = 0;
                    if( rsum == solu ) cnt ++;
                    //if( sol == 1 ) printf("%d %d %d , %d\n",i,k1,k2,cc[i][k1][k2],mxx[i+1][k1][k2]);
                  //  printf("%d %d %d = %d (%d)\n",i,k1,k2,sol,mxx[i+1][k1][k2]);

                }
            }
        }
        printf("%d %d\n",solu,cnt);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <set>
#include <algorithm>
#include <string.h>
#include <iomanip>
#include <string>
#include <stack>
using namespace std;

const int maxn = 205;
const int inf = 999999;

int n,m;
int mat[maxn][maxn];
int row[maxn][maxn];
int col[maxn][maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&n,&m);

        for( int i = 0; i < n; ++i )
            for( int j =0 ; j < m; ++j ){
                scanf("%d",&mat[i][j]);
                if( mat[i][j] == 0 ) mat[i][j] = -1;

                row[i][j] = mat[i][j] + (j?row[i][j-1]:0);
                col[i][j] = mat[i][j] + (i?col[i-1][j]:0);
            }

        int solu = 0, cnt = 0;

        for( int r1 = 0; r1 < n; ++r1 ){
            for( int c1 = 0; c1 < m; ++c1 ){
                for( int c2 = c1; c2 < m; ++c2 ){
                    for( int r2 = r1; r2 < n; ++r2 ){
                        int sol = row[r1][c2];
                        if( c1 ) sol -= row[r1][c1-1];

                        if( r1 != r2 ){
                            sol += row[r2][c2];
                            if( c1 ) sol -= row[r2][c1-1];
                        }
                        int mem = sol;

                        if( r1 != r2 ){
                            if( r2 )sol = sol + col[r2-1][c1] - col[r1][c1];
                            if( c1 != c2 ) sol = sol + (r2?col[r2-1][c2]:0) - col[r1][c2];
                        }

                        if( sol > solu ) solu = sol , cnt = 0;
                        if( sol == solu ) cnt ++;

                       // printf("%d %d ; %d %d = %d [%d,%d]\n",r1,r2,c1,c2,sol,mem,col[r1][c1]);

                    }
                }
            }
        }
        printf("%d %d\n",solu,cnt);
    }
    return 0;
}

#include <iostream>
#include <fstream>
using namespace std;

int main(){
    srand((unsigned)time(0));
    freopen("Ulaz.txt","w",stdout);
    int t = 100;
    cout<<t<<endl;

    while( t-- ){

    int r = 0;
    int n = 1+rand()%10 , m = 1+rand()%10;
    cout<<n<<" "<<m<<endl;
    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < m; ++j ){
            int r = rand()%2;
            cout<<r<<" ";
        }cout<<endl;
    }

    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <fstream>
using namespace std;

int main(){

    for( int t = 1; t <= 100000; ++t ){
        system("MATRIX_MAKER");
        system("MATRIX_BRUTE");
        system("MATRIX");

        if( system("diff -qb Izlaz.txt Izlaz2.txt") ){
            printf("WA on %d\n",t);
            while(1);
        }else{
            printf("AC on %d\n",t);
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <iomanip>
#include <set>
using namespace std;

typedef long long ll;

const int maxn = 2000005;

bool ok[maxn];
int tot[maxn];

void proces(){
    int i = 3;
    while( i < maxn ){
        if( ok[i] ){i+=2; continue;}
        int k = i; while( k < maxn ) tot[k] -= tot[k] / i, ok[k] = 1 , k += i;
        i += 2;
    }

    for( int i = 2; i < maxn; i += 2 )
        tot[i] -= tot[i] >> 1;
}


inline void readi( int &v ){
    char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v*10 + c - '0';
}

ll ss[maxn];
ll dp[maxn];
ll suma[maxn];
ll mem[maxn];

int main(){
    //double a = clock();
    //freopen("Ulaz.txt","r",stdin);

    for( int i = 1; i < maxn; ++i ) tot[i] = i , suma[i] = suma[i-1] + i;
    proces(); for( int i = 1; i < maxn; ++i ) dp[i] = dp[i-1] + tot[i];


    int t = 0;

    int n;
    while( 1 ){
        readi(n);
        if( n == 0 ) break;
        if( mem[n] != 0 ){
            printf("%lld\n",mem[n]);
            continue;
        }

        long long sol = 0;

        ll w = 0;
        int k = 1, i = n;
        int cnt = 0;

        while( i > 1 ){
            cnt ++;
            int from = k;
            int to = (n / i);
            w += suma[to] - suma[from-1];
            k = to+1;

            int nxt = n / k;
            sol += (dp[i-1] - dp[nxt] + tot[i])*w;
            i = nxt;
        }
        cout<<cnt<<endl;
        mem[n] = sol;
        printf("%lld\n",sol);
    }

  // double b = clock();
   //printf("%.20lf\n",(b-a)/CLOCKS_PER_SEC);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <iomanip>
#include <set>
using namespace std;

int gcd( int a , int b ){
    if( b%a == 0 ) return a;
    else return gcd( b%a , a );
}

int main(){

    int n; scanf("%d",&n);
    int sol = 0;

    for( int i = 1; i <= n; ++i )
        for( int j = i+1; j <= n; ++j ){
            sol += gcd(i,j);
            cout<<gcd
        }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <iomanip>
#include <set>
using namespace std;

typedef long long ll;

const int maxn = 2000005;

bool ok[maxn];
int tot[maxn];

int gcd( int a , int b ){
    if( b % a == 0 ) return a;
    else return gcd( b%a , a );
}

void proces(){
    int i = 3;
    while( i < maxn ){
        if( ok[i] ){i+=2; continue;}
        int k = i; while( k < maxn ) tot[k] -= tot[k] / i, ok[k] = 1 , k += i;
        i += 2;
    }
    for( int i = 2; i < maxn; i += 2 ) tot[i] -= tot[i] >> 1;
}


inline void readi( int &v ){
    char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v*10 + c - '0';
}

ll ss[maxn];
ll dp[maxn];
ll suma[maxn];

int main(){
    //double a = clock();
    //freopen("Ulaz.txt","r",stdin);

    for( int i = 1; i < maxn; ++i ) tot[i] = i , suma[i] = suma[i-1] + i;
    proces(); //for( int i = 2; i < maxn; ++i ) dp[i] = dp[i-1] + tot[i];

    for ( int g = 1; g < maxn; ++g )
        for ( int n = g + g , t = 2; n < maxn; n+=g, ++t )
            dp[n] += g * (ll)tot[t];

    for( int i = 1; i <= 10; ++i ) cout<<dp[i]<<" ";cout<<endl;

    for( int i = 0; i < maxn; ++i ) dp[i] = 0;
    for( int i = 1; i < 110; ++i )
        for( int k = 1; k <= i; ++k )
            if( i % k == 0 ){
                dp[i] += k * tot[i/k];
            }

    cout<<dp[4]<<" "<<dp[2]<<endl;

    cout<<dp[25]<<" == ";
    int tmp = 0;
    for( int i = 1; i <= 25; ++i )
        tmp += gcd(25,i);
    cout<<tmp<<endl;


    int s = 0;
    for( int i = 1; i <= 10; ++i ) cout<<dp[i]<<" ";cout<<endl;
    int t = 0;

    int n;
    while( 1 ){
        readi(n);
        if( n == 0 ) break;

        long long sol = 0;

        int g = 1;

        for( int g = 1; g <= n; ++g ){
            sol += dp[ n / g ] * g;
        }

        printf("%lld\n",sol);
    }

  // double b = clock();
   //printf("%.20lf\n",(b-a)/CLOCKS_PER_SEC);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string.h>
#include <string>
#include <iomanip>
#include <math.h>
using namespace std;

typedef long long ll;

const int maxn = 2000000 + 55;

int gcd( int a, int b ){
    if( b % a == 0 ) return a;
    else return gcd( b%a , a );
}

bool ok[maxn];
int primes[maxn] , sz = 0;

void sieve(){
    for( int i = 2; i < maxn; ++i ){
        if( ok[i] ) continue;
        primes[sz++] = i;
        for( int k = i+i; k < maxn; k += i )
            ok[k] = 1;
    }
}

int fastpow( int b, int e ){
    if( e == 1 ) return b;
    else if(e&1) return fastpow( b , e - 1 ) * b;
    else{
        int w = fastpow( b , e >> 1 );
        return w*w;
    }
}

ll dp[maxn];

ll calc( int n ){
    if( ok[n] == false ) return dp[n];
    if( dp[n] != 0 ) return dp[n];

    int p = n , e = 1;
    int N = n;

    for( int i = 0; ; ++i ){
        int w = primes[i];
        if( w*w > n ) break;
        if( n % w == 0 ){
            p = w;
            e = 0;
            while( n % w == 0 ) n /= w , e++;
            break;
        }
    }
   // p = max( p , n );
    n = N;
    int m = fastpow( p , e );

    dp[n] = dp[ m ] * calc( n / m );

    return dp[n];
}

ll sum[maxn];

int main(){
    double a = clock();

    sieve();

    dp[1] = 1;
    for( int i = 0; i < sz; ++i ){
        int p = primes[i];
        if( dp[p] ) continue;

        ll sum = p;
        for( ll k = p, t = 1; k < maxn; k *= p , ++t ){
            sum = 0;
            for( ll l = 1; l < k; l *= p ){
                int c = k / l;
                sum += c*l;
                if( l != 1 ) sum -= (ll)c * (l/p);
            }
            sum += -(k/p) + k;
            dp[k] = sum;
        }
    }


    for( int i = 1; i < maxn; ++i ) calc( i );
    for( int i = 1; i < maxn; ++i ) sum[i] = sum[i-1] + dp[i] - i;

    int n;
    while( scanf("%d",&n) == 1 ){
        if( n == 0 ) break;
        printf("%lld\n",sum[n]);
    }

    return 0;
}

#include <iostream>
#include <map>
using namespace std;

const int maxn = 500005;

int seq[maxn];
map<int,int> ok;

int main(){

    for( int i = 1; i < maxn; ++i ){
        int s1 = seq[i-1] - i;
        int s2 = seq[i-1] + i;
        int s = s1;

        if( s1 <= 0 || ok[s1] ) s = s2;
        ok[ seq[i] = s ] = 1;
    }


    int n;
    while( scanf("%d",&n) == 1 ){
        if( n == -1 ) break;
        printf("%d\n",seq[n]);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <string>
#include <string.h>
#include <algorithm>
#include <map>
#include <queue>
#include <stack>
using namespace std;

const int inf = 1003003003;

int cnt = 0;

struct orthogonal{
    int begin;
    vector< vector<int> > tree;

    int lower_range( int dx , int val ){
        vector< int > :: iterator it = lower_bound( tree[dx].begin() , tree[dx].end() , val );
        int ret = it - tree[dx].begin();
        if( *it == val ) ret ++;

        return ret;
    }

    void init( int n ){
        int sz = 1;
        while( sz < n ) sz <<= 1;
        begin = sz;
        sz <<= 1;
        tree.clear();
        tree.resize( sz );
    }

    orthogonal(){};
    orthogonal( int n ){ init( n ); }

    inline int kth( int lo, int hi, int to ){
        int cnt = to;
        int node = 1;

        while(1){
            if( node >= begin ) return node - begin + 1;
            int c = lower_range( node*2 , hi ) - lower_range( node*2 , lo-1 );
            if( c < cnt ) cnt -= c , node = node * 2 + 1;
            else node *= 2;
        }

        return -1;
    }

    void srt(){
        for( int i = 1; i < tree.size(); ++i ) sort( tree[i].begin() , tree[i].end() );
    }

};

orthogonal t;
int v[130000];
int srt[130000];

map<int,int> key;

inline void geti( int &v ){
    int minus = 1; char c;
    while( (c=getchar())<'0' || c > '9' ) if ( c == '-' ) break;

    if( c == '-' ){ minus = -1; c = getchar();}

    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
    v *= minus;
}

int main(){
    double w = clock();
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    int n,m;
    scanf("%d%d",&n,&m);

    t.init( n + 2 );

    for( int i = 0; i < n; ++i ){
        geti( v[i] );
        srt[i]  = v[i];
    }

    sort( srt , srt + n );

    for( int i = 0; i < n; ++i ){
        int nw = lower_bound( srt , srt + n , v[i] ) - srt + 1;
        key[ nw ] = v[i];
        v[i] = nw;
    }

    for( int i = 0; i < n; ++i ){
        int dx = v[i] - 1 + t.begin;

        t.tree[dx].push_back( i+1 );
        while( dx > 1 ){
            dx >>= 1;
            cnt ++;
            t.tree[dx].push_back( i+1 );
        }
    }
    t.srt();

    for( int i = 0; i < m; ++i ){
        int a,b,c;
        geti(a); geti(b); geti(c);
        int sol = t.kth(a,b,c);
        printf("%d\n",key[sol]);
    }

   // printf("%.10lf\n",(clock()-w)/CLOCKS_PER_SEC);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <string>
#include <string.h>
#include <algorithm>
#include <map>
#include <queue>
#include <stack>
using namespace std;

const int inf = 1003003003;

struct treap{
    struct node{
        node *l,*r;
        int rank;
        int val;
        int sz;

        node(){ l = r = 0; sz = 0; }
        node( int v ){ l = r = 0; val = v; sz = 0; };
    };

    node *root , *dummy;

    void _erase_all( node *n ){
        if( n == dummy ) return;
        _erase_all( n->l );
        _erase_all( n->r );
        delete n;
    }

    ~treap(){
        _erase_all( root );
    }

    treap(){
        dummy = new node();
        dummy->l = dummy->r = dummy;
        dummy->rank = -1;
        root = dummy;
    }

    void update( node *n ){
        n->sz = n->l->sz + n->r->sz +1;
    }

    node *make( int v ){
        node *ret = new node(v);
        ret->rank = rand();
        ret->l = ret->r = dummy;
        ret->sz = 1;
        return ret;
    }

    node *rotate( node *child , node *dad ){
        if( child == dad->l )dad->l = child->r , child->r = dad;
        else dad->r = child->l , child->l = dad;
        return child;
    }

    node *_insert( node *n , int val ){
        if( n == dummy ) return make(val);
        if( n->val >= val ){
            n->l = _insert( n->l , val );
            if( n->l->rank > n->rank ) n = rotate( n->l , n );
        }else{
            n->r = _insert( n->r , val );
            if( n->r->rank > n->rank ) n = rotate( n->r , n );
        }
        update(n);
        return n;
    }

    int g;
    int cnt( node *n ){
        if( n == dummy ) return 0;
        if( n->val <= g ) return n->l->sz + cnt( n->r ) + 1 ;
        else return cnt( n->l );
    }

    int lower_range( int lo , int hi ){
        int b,a;
        g = hi ,b = cnt( root );
        g = lo - 1 , a = cnt( root );
        return b - a;
    }

    inline void insert( int v ){ root = _insert( root , v ); }
};

struct orthogonal{
    int begin;
    vector< treap > tree;

    void init( int n ){
        int sz = 1;
        while( sz < n ) sz <<= 1;
        begin = sz;
        sz <<= 1;
        tree.clear();
        tree.resize( sz );
    }

    orthogonal(){};
    orthogonal( int n ){ init( n ); }

    inline void update( int dx , int val ){
        dx += begin;
        tree[dx].insert( val );
        while( dx > 1 ){
            dx >>= 1;
            tree[dx].insert( val );
        }
    }

    inline int kth( int lo, int hi, int to ){
        int cnt = to;
        int node = 1;

        while(1){
            if( node >= begin ) return node - begin + 1;
            int c = tree[node*2].lower_range( lo , hi );
            if( c < cnt ) cnt -= c , node = node * 2 + 1;
            else node *= 2;
        }

        return -1;
    }

};

orthogonal t;
int v[130000];
int srt[130000];

map<int,int> key;

inline void geti( int &v ){
    int minus = 1; char c;
    while( (c=getchar())<'0' || c > '9' ) if ( c == '-' ) break;

    if( c == '-' ){ minus = -1; c = getchar();}

    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
    v *= minus;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    int n,m;
    scanf("%d%d",&n,&m);

    t.init( n + 55 );

    for( int i = 0; i < n; ++i ){
        geti( v[i] );
        srt[i]  = v[i];
    }

    sort( srt , srt + n );

    for( int i = 0; i < n; ++i ){
        int nw = lower_bound( srt , srt + n , v[i] ) - srt + 1;
        key[ nw ] = v[i];
        v[i] = nw;
    }

    for( int i = 0; i < n; ++i ) t.update( v[i]-1 , i+1 );

    for( int i = 0; i < m; ++i ){
        int a,b,c;
        geti(a); geti(b); geti(c);
        int sol = t.kth(a,b,c);
        printf("%d\n",key[sol]);
    }


    return 0;
}

#include <iostream>
using namespace std;

const int maxn = 1000005;

int sol[maxn];

int gcd( int a, int b ){
    if( b%a == 0 ) return a;
    else return gcd(b%a , a );
}

int main(){

    for( int i = 1; i < maxn; ++i ) sol[i] = i;

    for( int i = 2; i < maxn; ++i ){
        if( sol[i] != i ) continue;
        for( int k = i; k < maxn; k += i ){
            sol[k] -= sol[k] / i;
        }
    }

    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        int a; scanf("%d",&a);
        printf("%d\n",sol[a]);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
using namespace std;

//typedef  long long int;

const int inf = 1001032340;

struct treap{
    struct node{
        node *l,*r;
        int val, sz, rank;
        int left,right,tot,maxx;

        node(){ l = r = 0; }
        node( int v ){ l = r = 0; val = left = right = tot = maxx = v; }
    };

    node *dummy , *root, *data;

    treap(){
        dummy = new node();
        dummy->l = dummy->r = dummy;
        dummy->rank = -1;
        dummy->sz = 0;
        dummy->left = dummy->right = dummy->tot = dummy->maxx = 0;

        root = dummy;
    }

    void update_val( node *n , node *l , node *r ){
        n->tot = l->tot + r->tot + n->val;
        n->maxx = n->val;

        int incl = 0, lrank = l->rank, rrank = r->rank;
        if( n->val != -inf ) incl = n->val;

        if( lrank != -1 ){
            int v1 = l->tot + n->val , v2 = l->tot + n->val + r->left;
            n->left = l->left;
            if( n->maxx < l->maxx ) n->maxx = l->maxx;
            if( n->val != -inf ){
                if( n->left < v1 )n->left = v1;
                if( rrank != -1 && n->left < v2 )n->left = v2;
            }
        }else{
            int v1 = incl + r->left;
            n->left = n->val;
            if( rrank != -1 && n->left < v1 ) n->left = v1;
        }

        if( rrank != -1 ){
            int v1 = r->tot + n->val , v2 = r->tot + n->val + l->right;
            n->right = r->right;
            if( n->maxx < r->maxx ) n->maxx = r->maxx;
            if( n->val != -inf ){
                if( n->right < v1 )n->right = v1;
                if( lrank != -1 && n->right < v2 )n->right = v2;
            }
        }else{
            if( n->val != -inf )n->right = n->val;
            if( lrank != -1 ) n->right = max( n->right , incl + l->right );
        }

        int ls = 0 , rs = 0;
        if( ls < l->right ) ls = l->right;
        if( rs < r->left  ) rs = r->left;

        int v = rs + n->val + ls;
        if( n->maxx < v && n->val != -inf ) n->maxx = v;
    }

    inline void update( node *n ){
        n->sz = 1 + n->l->sz + n->r->sz;
        update_val( n , n->l , n->r );
    }


    inline node *rotate( node *child , node *dad ){
        if( dad->l == child ) dad->l = child->r , child->r = dad;
        else dad->r = child->l , child->l = dad;
        update(dad);
        return child;
    }

    node *make( int val ){
        node *ret = new node(val);
        ret->rank = rand();
        ret->sz = 1;
        ret->l = ret->r = dummy;
        ret->left = ret->right = ret->tot = ret->maxx = val;

        return ret;
    }

    node *_insert( node *n , int dx , int val){
        if( n == dummy ) return make(val);

        if( n->l->sz >= dx ){
            n->l = _insert( n-> l , dx , val );
            if( n->l->rank > n->rank ) n = rotate( n->l , n );
        }else{
            n->r = _insert( n->r , dx - n->l->sz - 1 , val );
            if( n->r->rank > n->rank ) n = rotate( n->r , n );
        }
        update(n);
        return n;
    }

    node *_erase( node *n , int dx , bool EraseMode ){
        if( n == dummy ) return dummy;

        if( dx - n->l->sz == 1 || EraseMode ){
            if( n->l == dummy && n->r == dummy ) return dummy;

            if( n->l == dummy || ( n->r != dummy && n->r->rank > n->l->rank ) ){
                n = rotate( n->r , n );
                n->l = _erase( n->l , 1 , 1 );
            }else{
                n = rotate( n->l , n );
                n->r = _erase( n->r , 1 , 1 );
            }

        }else if( n->l->sz >= dx ){
            n->l = _erase( n->l , dx , 0 );
            if( n->l->rank > n->rank ) n = rotate( n->l , n  );
        }else{
            n->r = _erase( n->r , dx - n->l->sz - 1 , 0 );
            if( n->r->rank > n->rank ) n = rotate( n->r , n  );
        }
        update(n);
        return n;
    }

    int l,r;
    node _query( node *n , int behind ){
        if( n == dummy ) return *dummy;
        int lo = behind + 1, hi = behind + n->sz;
        int mid = behind + (n->l->sz) + 1;

        if( l <= lo && hi <= r )return *n;
        if( lo > r || hi < l ) return *dummy;

        node left = _query( n->l , behind );
        node right = _query( n->r , behind + n->l->sz + 1 );
        node ret = *n;

        if( !(l <= mid && mid <= r) ) ret.val = -inf;

        update_val( &ret , &left , &right );
        return ret;
    }

    inline int query( int lo , int hi ){
        l = lo , r = hi;
        node ret = _query( root , 0 );
        return ret.maxx;
    }

    inline void erase( int dx ){
        root = _erase( root , dx , 0 );
    }

    inline void insert( int dx , int val ){
        root = _insert( root , dx , val );
    }

};

treap t;

inline void geti( int &v ){
int minus = 1; char c;
while( (c=getchar())<'0' || c > '9' ) if ( c == '-' ) break;
if( c == '-' ){ minus = -1; c = getchar();}
v = c - '0';
while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
v *= minus;
}

int main(){// double w = clock();
  // freopen("Ulaz.txt","r",stdin);
   //freopen("Izlaz.txt","w",stdout);

    int n;
    geti(n);
    for( int i = 0; i < n; ++i ){
        int w; geti(w);
        t.insert( 10000000 , w );
    }

    int m,v1,v2,v3;
    geti(m);
    for( ; m ; m-- ){
        char c;
        while( c = getchar() ) if ( c == 'I' || c == 'Q' || c == 'R' || c == 'D' )break;

        if( c != 'D' )geti(v1),geti(v2);
        else geti(v1);

        if( c == 'I' ){
            t.insert( v1 - 1 , v2 );
        }else if( c == 'Q' ){
            printf("%d\n",(int)t.query(v1,v2));
        }else if( c == 'R' ){
            t.erase( v1 );
            t.insert( v1 - 1 , v2 );
        }else if( c == 'D' ){
            t.erase( v1 );
        }
    }

    //printf("%.10lf\n",(clock()-w)/CLOCKS_PER_SEC);

    return 0;
}

#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;

const int maxn = 1000000 + 55;

int d[maxn];
bool ok[maxn];

int main(){
    for( int i = 1; i < maxn; ++i )
        for( int k = i; k < maxn; k += i )
            d[k] ++;

    for( int m = 1; m < maxn; ++m )
        for( int n = m; n < maxn; n += m )
            if( d[n] % d[m] ) ok[n] = 1;

    vector< int > sol;

    for( int i = 1; i < maxn; ++i )
        if( !ok[i] && d[i] > 3) sol.push_back(i);

    for( int i = 107; i < sol.size(); i += 108 )
        printf("%d\n",sol[i]);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <math.h>
#include <set>
#include <iomanip>
using namespace std;

typedef long long ll;

const int maxn = 100000 + 55;
const int maxv = 1000 + 55;

struct test{
    int v,a,b,dx;
    test(){};
    test( int p1, int p2, int p3, int p4 ):v(p1),a(p2),b(p3),dx(p4){};

    const bool operator<( const test &t ) const {
        return v > t.v;
    }
};

struct fenwick{
    int sz;
    vector< ll > tree;

    void init( int n ){
        sz = n + 20;
        tree.resize( n + 55  );
        for( int i = 0; i < tree.size(); ++i ) tree[i] = 0;
    }

    fenwick(){};
    fenwick( int n ){ init( n ); }

    void update( int dx , ll v ){
        for( dx += 5; dx < sz; dx += dx & -dx ) tree[dx] += v;
    }

    ll read( int dx ){
        ll ret = 0;
        for( dx += 5; dx >= 1; dx -= dx & -dx ) ret += tree[dx];
        return ret;
    }
};

struct dis_set{
    vector< int > sz;
    vector< int > id;

    void init( int n ){
        n += 55;
        sz.resize(n);
        id.resize(n);

        for( int i = 0; i < n; ++i ) sz[i] = 1 ,  id[i] = i;
    }

    dis_set(){};
    dis_set( int n ){ init(n); }

    int get_root( int x ){
        if( x == id[x] ) return x;
        return id[x] = get_root( id[x] );
    }

    int subtree_sz( int x ){
        return sz[ get_root(x) ];
    }

    bool merge( int a, int b ){
        int x = get_root( a ) , y = get_root( b );
        if( x == y ) return 1;

        if( sz[x] < sz[y] ) id[x] = y , sz[y] += sz[x];
        else id[y] = x , sz[x] += sz[y];

        return 0;
    }
};

int n,m;
int v[maxn];

ll parts[maxn];
fenwick sum(maxn);
fenwick cnt(maxn);
fenwick ss(maxn);

ll sol[maxn];
vector< int > cols[maxv];
dis_set joint(maxn);

void preproces(){ for( int i = 0; i < maxn; ++i ) parts[i] = (i*(ll)(i+1))>>1; }


void add( int sz ){
    sum.update( sz , parts[sz] );
    cnt.update( sz , 1 );
    ss.update( sz , sz );
}

void take( int sz ){
    sum.update( sz , -parts[sz] );
    cnt.update( sz , -1 );
    ss.update( sz , -sz );
}

ll query( ll h , ll a , ll b ){
    ll d = b - a + 1;

    ll sol = sum.read(b) - sum.read(a-1);
    ll c = cnt.read(b) - cnt.read(a-1);
    ll srange = ss.read(b) - ss.read(a-1);

    sol -= (a-1)*srange - c*( (a-1) * (a-2)>>1);

    srange = ss.read(maxn) - ss.read(b);
    c = cnt.read(maxn) - cnt.read(b);
    sol += (srange-(c*b)) * (b-a+1) + c * (d * (d+1)>>1);

    return sol;
}


int main(){
    preproces();

    freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    scanf("%d%d",&n,&m);
    for( int i = 0; i < n; ++i ){
        scanf("%d",&v[i]);
        cols[ v[i] ].push_back( i );
    }

    vector< test > q;

    for( int i = 0; i < m; ++i ){
        int h,a,b; scanf("%d%d%d",&h,&a,&b);
        q.push_back( test(h,a,b,i) );
    }

    int t = 0;
    sort( q.begin() , q.end() );


    for( int i = 1000; i >= 0 && t < m; --i ){
        for( int j = 0; j < cols[i].size(); ++j ){
            int w = cols[i][j];

            int lchain = -1 , rchain = -1;
            if( w-1 >= 0 && v[w-1] >= i ) lchain = joint.get_root(w-1);
            if( w+1 < n  && v[w+1] > i ) rchain = joint.get_root(w+1);

            if( lchain == -1 && rchain == -1 ) add( 1 );
            else{
                int sz1 = 0  , sz2 = 0;
                if( lchain != -1 ) take( sz1 = joint.subtree_sz( lchain ) ) , joint.merge( w , lchain );
                if( rchain != -1 ) take( sz2 = joint.subtree_sz( rchain ) ) , joint.merge( w , rchain );
                int nw = 1 + sz1 + sz2;
                //printf("%d [%d,%d] ==> %d\n",w,sz1,sz2,nw);
                add( nw );
            }
        }

        while( t < m && q[t].v >= i ){
            //printf("case: %d [%d,%d,%d]\n",q[t].dx,q[t].v,q[t].a,q[t].b);
            sol[ q[t].dx ] = query(q[t].v,q[t].a,q[t].b);
            t++;
        }
    }

    for( int i = 0; i < m; ++i )
        printf("%lld\n",sol[i]);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string>
#include <string.h>
#include <math.h>
#include <set>
#include <iomanip>
using namespace std;

const int maxn = 100000 + 55;
const int maxv = 1000 + 55;

struct test{
    int v,a,b;
    test(){};
    test( int p1, int p2, int p3 ):v(p1),a(p2),b(p3){};
};

int n,m;
int v[maxn];


int main(){

    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    scanf("%d%d",&n,&m);
    for( int i = 0; i < n; ++i ) scanf("%d",&v[i]);

    for( int i = 0; i < m; ++i ){
        int h,a,b; scanf("%d%d%d",&h,&a,&b);
        int sol = 0;
        for( int i = 0; i < n; ++i )
            for( int j = i; j < n; ++j ){
                if( v[j] < h || (j-i+1) > b ) break;
                if( j-i+1 >= a )sol++;
            }

        cout<<sol<<endl;
    }


    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <vector>
#include <stack>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

int n,m,f;
char txt[4005][4005];
int h[4006];
int l[4006];

int main(){
    //freopen("Ulaz.txt","r",stdin);

    while( scanf("%d%d%d",&n,&m,&f) == 3 ){
        if( n ==0 && m == 0 && f == 0 ) break;
        for( int i = 0; i < n; ++i )
            scanf("%s",txt[i]);

        for( int i = 0; i < m; ++i ) h[i] = 0;

        ll sol = -1;

        for( int i = 0; i < n; ++i ){
            for( int j = 0; j < m; ++j ) if( txt[i][j] == 'H' ) h[j] ++; else h[j] = 0;

            stack<pii> stk;
            for( int j = 0; j < m; ++j ){
                while( stk.empty() == false && stk.top().f >= h[j] ) stk.pop();
                if( stk.empty() ) l[j] = -1;
                else l[j] = stk.top().s;
                stk.push( mk(h[j],j) );
            }

            while(!stk.empty())stk.pop();

            for( int j = m-1; j >= 0; --j ){
                while( stk.empty() == false && stk.top().f >= h[j] ) stk.pop();

                int r;
                if( stk.empty() ) r = m;
                else r = stk.top().s;
                stk.push( mk(h[j],j) );

                ll area = (r-l[j]-1)*(ll)h[j]*(ll)f;
                sol = max( sol , area );
            }
        }

        printf("%lld\n",sol);

    }

    return 0;
}

#include <iostream>
#include <algorithm>
#include <math.h>
#include <string.h>
#include <string>
#include <stack>
#include <vector>
#include <map>
using namespace std;

const int inf = 1999999999;
const int maxn = 1000 + 55;

int n,m;
int mat[maxn][maxn];
int query[1015];

int dp[1015][215][215];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&n,&m);

        for( int i = 0; i < n; ++i )
            for( int j = 0; j < n; ++j )
                scanf("%d",&mat[i][j]);

        m += 3;

        for( int i = 3; i < m; ++i ){
            scanf("%d",&query[i]);
            query[i] --;
        }

        query[0] = 0;
        query[1] = 1;
        query[2] = 2;

        for( int i = 0; i < m+5; ++i )
            for( int j = 0; j < n+5; ++j )
                for( int k = 0; k < n+5; ++k )
                    dp[i][j][k] = 54654654;

        dp[3][0][1] = 0;

        for( int i = 3; i < m; ++i ){
            for( int c1 = 0; c1 < n; ++c1 ){
                for( int c2 = c1+1; c2 < n; ++c2 ){
                    int c3 = query[i-1];

                    if( c1 != query[i] && c2 != query[i] ) dp[i+1][c1][c2] = min( dp[i+1][c1][c2] , dp[i][c1][c2] + mat[c3][ query[i] ] );

                    int l = min(c2,c3) , r = max(c2,c3);
                    if( c2 != query[i] && c3 != query[i] )dp[i+1][l][r]  = min( dp[i+1][l][r]  , dp[i][c1][c2] + mat[c1][ query[i] ] );

                    l = min(c1,c3) , r = max(c1,c3);
                    if( c1 != query[i] && c3 != query[i] )dp[i+1][l][r]  = min( dp[i+1][l][r]  , dp[i][c1][c2] + mat[c2][ query[i] ] );
                }
            }
        }
        int ss = inf;
        for( int i = 0; i < n; ++i )
            for( int j = 0; j < n; ++j )
                ss = min( ss , dp[m][i][j] );


        printf("%d\n",ss); // 9493


    }
    return 0;
}

#include<iostream>
#include<string>
#include<cstdlib>
#include<fstream>
using namespace std;
int S[3];


int main()
{
    int n,i;
    cin>>n;
    string a;
    for(i=0;i<n;i++)
    {
       cin>>a;
       if(a=="3/4")
          S[0]++;
       else if(a=="1/2")
          S[1]++;
       else if(a=="1/4")
          S[2]++;
    }
    int p=0;
    while(S[0]>0 || S[1]>0 || S[2]>0)
    {
       if(S[0]>0)
       {
          p++;
          S[0]--;
          S[2]--;
       }else if(S[1]>0){
          p++;
          S[1]--;
          if(S[1]>0)
             S[1]--;
          else
             S[2]-=2;
       }else if(S[2]>0){
          S[2] -=4;
          p++;
       }
    }
    cout<<p+1<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <string.h>
#include <string>
#include <map>
#include <cstdlib>
#include <math.h>
#include <fstream>
#include <queue>
#include <stack>
#include <iomanip>
#include <assert.h>
using namespace std;


char txt[1000];

int main(){
    scanf("%s",txt);
    int pos = 0;
    string find = "hello";

    for( int i = 0; i <strlen(txt); ++i ){
        if( pos == find.size() ) break;
        if( txt[i] == find[pos] ) pos ++;
    }
    if( pos == find.size() )printf("YES\n");
    else printf("NO\n");
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <fstream>
#include <iomanip>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef unsigned int ui;
typedef long long ll;

const int maxn = 405*5;

int n;
int mat[maxn][maxn];
int dst[maxn];

vector< pii > eq;

int dummy = 1800;

int ok( int r ){
    for( int i = 0; i < n; ++i ) mat[ eq[i].f ][ eq[i].s ] = r;

    memset( dst , 1 , sizeof(dst));
    dst[dummy] = 0;

    for( int i = 0; i < 3000; ++i ){
        bool done = 1;
        for( int j = 0; j < eq.size(); ++j ){
            int d = mat[ eq[j].f ][ eq[j].s ];
            if(  dst[ eq[j].s ] > dst[ eq[j].f ] + d ){
                dst[ eq[j].s ] = dst[ eq[j].f ] + d;
                done = 0;
            }
        }
        if( done ) break;
    }

    for( int j = 0; j < eq.size(); ++j ){
        int d = mat[ eq[j].f ][ eq[j].s ];
        if(  dst[ eq[j].s ] > dst[ eq[j].f ] + d ){
            return 0;
        }
    }
    return 1;
}

double p[maxn][2];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    vector< double > low;
    for( int i = 0; i < n; ++i ){
        double a,b,c; cin>>a>>b>>c;  b -= 0.1;
        low.push_back(a);
        low.push_back(b);
        p[i][0] = a, p[i][1] = b;
    }
    sort( low.begin(), low.end() );

    int cnt = 1;
    vector< int > dx;
    for( int i = 0; i < n; ++i ){
        int a = lower_bound( low.begin() , low.end() , p[i][0] ) - low.begin();
        int b = lower_bound( low.begin() , low.end() , p[i][1] ) - low.begin();

        eq.push_back( mk(a,b) );
        mat[b][a] = -1;

        dx.push_back( a ), dx.push_back( b );
    }
    for( int i = 0; i < dx.size(); i += 2 ) eq.push_back( mk(dx[i+1],dx[i]) );

    sort( dx.begin() , dx.end() );

    for( int i = 0; i < dx.size() - 1; ++i ) eq.push_back( mk(dx[i+1] , dx[i]) );
    for( int i = 0; i < dx.size(); i++ ) eq.push_back( mk(dummy,dx[i]) );


    int lo = 1, hi = 100000, sol = -1;
    while( lo <= hi ){
        int mid = (lo+hi)>>1;
        if( ok(mid) ) sol = mid , hi = mid - 1;
        else lo = mid + 1;
    }
    cout<<sol<<endl;
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <fstream>
#include <iomanip>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef unsigned int ui;
typedef long long ll;

const int maxn = 405*5;

int n;
int mat[maxn][maxn];
int dst[maxn];

vector< pii > eq;

int dummy = 406;

int ok( int r ){
 //   for( int i = 0; i < n; ++i ) mat[ eq[i].f ][ eq[i].s ] = 0;
    for( int i = 0; i < n; ++i ) mat[ eq[i].f ][ eq[i].s ] = r;

    memset( dst , 1 , sizeof(dst));
    dst[dummy] = 0;

    for( int i = 0; i < 2000; ++i ){
        bool done = 1;
        for( int j = 0; j < eq.size(); ++j ){
            int d = mat[ eq[j].f ][ eq[j].s ];
            if(  dst[ eq[j].s ] > dst[ eq[j].f ] + d ){
                dst[ eq[j].s ] = dst[ eq[j].f ] + d;
                done = 0;
            }
        }
        if( done ) break;
    }

    for( int j = 0; j < eq.size(); ++j ){
        int d = mat[ eq[j].f ][ eq[j].s ];
        if(  dst[ eq[j].s ] > dst[ eq[j].f ] + d ){
            return 0;
        }
    }
    return 1;
}

ll p[maxn][2];

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    vector< ll > low;
    for( int i = 0; i < n; ++i ){
        ll a,b,c; cin>>a>>b>>c; a *= 2 , b = b*2 - 1;
        low.push_back(a);
        low.push_back(b);
        p[i][0] = a, p[i][1] = b;
    }
    sort( low.begin(), low.end() );

    int cnt = 1;
    vector< int > dx;
    for( int i = 0; i < n; ++i ){
        int a = lower_bound( low.begin() , low.end() , p[i][0] ) - low.begin();
        int b = lower_bound( low.begin() , low.end() , p[i][1] ) - low.begin();
     //   cout<<a<<" "<<b<<endl;

        if( a == dummy ) dummy ++;
        if( b == dummy ) dummy ++;

        eq.push_back( mk(a,b) );
        mat[b][a] += -1;

        dx.push_back( a ), dx.push_back( b );
    }
    for( int i = 0; i < dx.size(); i += 2 ) eq.push_back( mk(dx[i+1],dx[i]) );

    sort( dx.begin() , dx.end() );

    for( int i = 0; i < dx.size() - 1; ++i ) eq.push_back( mk(dx[i+1] , dx[i]) );
    for( int i = 0; i < dx.size(); ++i ) eq.push_back( mk(dummy,dx[i]) );

    for( int i = 0; i < 100; ++i ) cout<<ok(i)<<" ";cout<<endl;

    int lo = 1, hi = 10000, sol = -1;
    while( lo <= hi ){
        int mid = (lo+hi)>>1;
        if( ok(mid) ) sol = mid , hi = mid - 1;
        else lo = mid + 1;
    }
    cout<<sol<<endl;
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string.h>
#include <string>
#include <iomanip>
#include <math.h>
#include <queue>
using namespace std;

int source = 401;
int sink = 402;
const int inf = 999999999;

int n;
vector< int > x;

bool mat[405][405];
bool visi[405];
int cap[405][405];

int dfs( int node, int mincap ){
   // cout<<node<<" "<<mincap<<endl;
    if( node == sink ) return mincap;
    visi[node] = 1;
    int sol = 0;
    for( int i = n+n+1; i >= 0; --i ){
        if( mat[node][i] == false || visi[i] || cap[node][i] == 0 ) continue;

        int x = dfs( i , min( mincap , cap[node][i] ) );
        sol += x;

        cap[node][i] -= x;
        cap[i][node] += x;
        mincap -= x;
    }
    return sol;
}

int flow(){
    int f, sol = 0;
    while( ( f = dfs(source , inf)) ) sol += f , memset( visi , 0 , sizeof(visi));
    return sol;
}

int nxt[205];
int color[205];
vector< int > g[205], rg[205];
vector< int > sol;
vector< int > mem[205];
bool mark[205];
int cnt[205];

int c;
bool isok( int node ){
    memset( visi , 0 , sizeof(visi));
    memset( cnt , 0 , sizeof(cnt));
    queue< int > q;


    q.push( node );
    visi[node] = 1;
    while( !q.empty() ){
        int u = q.front(); q.pop();
        cnt[ color[u] ] ++;
        if( mark[u] ) return 0;
        for( int i = 0; i < g[u].size(); ++i )
            if( visi[ g[u][i] ] == false ){
                visi[ g[u][i] ] = 1;
                q.push( g[u][i] );
            }
    }
    q.push( node );
     while( !q.empty() ){
        int u = q.front(); q.pop();
        cnt[ color[u] ] ++;
        if( mark[u] ) return 0;
        for( int i = 0; i < rg[u].size(); ++i )
            if( visi[ rg[u][i] ] == false ){
                visi[ rg[u][i] ] = 1;
                q.push( rg[u][i] );
            }
    }

    for( int i = 1; i < c; ++i )
        if( cnt[i] == mem[i].size() ) return 0;
    return 1;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        int a; scanf("%d",&a);
        x.push_back( a );
    }
    sort( x.begin() , x.end() );
    x.erase( unique(x.begin(),x.end()) , x.end() );
    n = x.size();

    for( int i = 0; i < n; ++i )
        for( int j = 0; j < n; ++j )
            if( i != j && x[j] % x[i] == 0 )
                mat[i][n+j] = 1, cap[i][n+j] = 1, mat[n+j][i] = 1,
                g[i].push_back( j ) , rg[j].push_back( i ) ;

    source = n+n;
    sink = n+n+1;

    for( int i = 0; i < n; ++i )
        mat[source][i] = 1 , cap[source][i] = 1, mat[i][source] = 1,
        mat[i+n][sink] = 1 , cap[i+n][sink] = 1, mat[sink][i+n] = 1;

    int s = flow();
    memset( nxt, -1 , sizeof(nxt));

    for( int i = 0; i < n; ++i )
        for( int j = 0; j < n; ++j )
            if( i != j && x[j] % x[i] == 0 && cap[i][j+n] == 0 )
                nxt[i] = j;



    c = 1;
    for( int i = 0; i < n; ++i ){
        if( color[i] ) continue;
        int y = i;
        while( y != -1 ){
            color[y] = c;
            //cout<<x[y]<<" ";
            mem[c].push_back( y );
            y = nxt[y];
        } c++;//cout<<endl;
    }//cout<<endl;

    for( int i = 1; i < c; ++i ){

        for( int j = mem[i].size()-1; j >= 0; --j ){
            int w = mem[i][j];
            if( isok(w) ){ sol.push_back(x[w]); mark[w] = 1; break; }
        }
    }




    bool ok = 1;
    for( int i = 0; i < sol.size(); ++i )
            for( int j = 0; j < sol.size(); ++j )
                if( sol[i] % sol[j] == 0 && i != j ) ok = 0;

    if( ok == 0 ) printf("-1\n");


    sort( sol.begin() , sol.end() );
    printf("%d\n",(int)sol.size());
    for( int i = 0; i < sol.size(); ++i )
        printf("%d ",sol[i]);
    printf("\n");
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string.h>
#include <string>
#include <iomanip>
#include <math.h>
using namespace std;

int x[20];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
    int n; cin >> n;
    for( int i = 0; i < n; ++i ) cin >> x[i];

    int sol = 0;

    for( int m = 0; m < (1<<n); ++m ){
        vector< int >  w;
        for( int i = 0; i < n; ++i )
            if( m & (1<<i)) w.push_back( x[i] );

        bool ok = 1;
        for( int i = 0; i < w.size(); ++i )
            for( int j = 0; j < w.size(); ++j )
                if( w[i] % w[j] == 0 && i != j ) ok = 0;

        if( ok ) sol = max( sol , (int)w.size() );
    }
    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <string.h>
#include <string>
#include <iomanip>
#include <math.h>
#include <fstream>
using namespace std;

int main(){
    srand((unsigned)time(0));

    while( 1 ) {
        ofstream out("Ulaz.txt");

        int n = 1 + rand()%15;
        out<<n<<endl;
        for( int i = 0; i < n; ++i )
            out<<1+rand()%20<<" ";out<<endl;

        out.close();

        system("DIVREL.exe");
        system("DIVREL_BRUTE.exe");

        ifstream in1("Izlaz.txt");
        ifstream in2("Izlaz2.txt");

        int v1,v2;
        in1 >> v1;
        in2 >> v2;
        in1.close();
        in2.close();;
        if( v1 != v2 ) {
            cout<<"WA"<<endl;
            while( 1){};
        }else cout<<"AC"<<endl;

    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <set>
#include <queue>
#include <math.h>
#include <algorithm>
#include <iomanip>
#include <string.h>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int inf = 999999999;

int n,m;
int a,b,diff,gcnt;

struct edge{
    int dest,dst,g;
    edge(){};
    edge( int p1, int p2, int p3 ):dest(p1),dst(p2),g(p3){};

    const bool operator<( const edge &e ) const {
        return dest < e.dest;
    }
};


int geo[1005];
vector< edge > g[1005];

int gvisi[1005];
int dpq[1005];
int block[1005][1005];
int dst[1005][1005];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);
    scanf("%d%d%d%d",&a,&b,&diff,&gcnt); a -- , b --;

    for( int i = 0; i < gcnt; ++i ) scanf("%d",&geo[i] ), geo[i]--;

    for( int i = 0; i < m; ++i ){
        int a,b,c; scanf("%d%d%d",&a,&b,&c); a-- , b--;
        dst[a][b] = dst[b][a] = c;
    }

    for( int i = 0; i < n; ++i ) sort( g[i].begin() , g[i].end() );

    int x = 0, now = geo[0];
    for( int i = 1; i < gcnt; ++i ){
        block[now][ geo[i] ] = block[ geo[i] ][ now ] = x;
        x += dst[now][ geo[i] ];
        now = geo[i];
    }

    memset( dpq, 1 , sizeof(dpq));
    priority_queue< pii > pq;
    dpq[a] = diff;

    pq.push( mk(inf-diff,a) );
    while( !pq.empty() ){
        pii u = pq.top(); pq.pop();
        x = inf - u.f;

        for( int nxt = 0; nxt < n; ++nxt ){
            if( dst[u.s][nxt] == 0 ) continue;
            int nw = x + dst[u.s][nxt];

            if( x >= block[u.s][nxt] ) nw += max( 0, dst[u.s][nxt] - x + block[u.s][nxt] );

            if( dpq[nxt] > nw ){
                dpq[nxt] = nw;
                pq.push( mk(inf-nw,nxt) );
            }
        }
    }

    cout<<dpq[b]-diff<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <set>
#include <queue>
#include <string.h>
#include <algorithm>
using namespace std;

#define P 1
#define N 2

const int maxn = 1000 + 5;

bool visi[maxn];
int mex[maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    mex[0] = 1;

    for( int i = 1; i <= 1000; ++i ){
        memset( visi, false , sizeof(visi));
        for( int j = 1; j <= i; ++j )
            visi[ mex[i-j] ] = 1;
        int now = 0;
        while( visi[now] ) now ++;
        mex[i] = now;
    }

    int tests; scanf("%d",&tests);
    for( ; tests; --tests ){
        int n; scanf("%d",&n);
        int sol = 0;
        int s = 0;
        for( int i = 0; i < n; ++i ){
            int a; scanf("%d",&a);
            sol ^= a;
            s += a;
        }
        if( s == n && s % 2 == 0 ) printf("John\n");
        else if( s == n || sol == 0 ) printf("Brother\n");
        else printf("John\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <set>
#include <queue>
#include <map>
using namespace std;

#define pii pair<int,int>
#define x first
#define y second
#define mk make_pair

const double eps = 0.000000001;
const int maxn = 105;

int n,m;
double d;
pii p[maxn];
vector< pii > e;
vector< int > g[maxn];

double heron( double a, double b, double c ){
    double s = (a+b+c) / 2;
    return sqrt( s*(s-a)*(s-b)*(s-c) );
}

double dst( pii a, pii b ){
    return sqrt( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) );
}

double visina( pii a, pii b, pii p ){
    double x = dst(a,b), y = dst(a,p) , z = dst(b,p);
    double A = heron( x, y, z );
    if( z*z + x*x <= y*y ) return z;
    if( x*x + y*y <= z*z ) return y;
    return (2*A) / x;
}

bool visi[3006][3006];
bool town[105];

void dfs( int a, int b ){
    if( visi[a][b] ) return;
    visi[a][b] = 1;

    int ax = e[a].x;
    int ay = e[a].y;
    int bx = e[b].x;
    int by = e[b].y;

    if( visina( p[ax] , p[ay] , p[bx] )-d <= eps ){ town[ bx ] = 1;
        for( int i = 0; i < g[bx].size(); ++i )
            dfs( a , g[bx][i] );}

    if( visina( p[ax] , p[ay] , p[by] )-d <= eps ){ town[ by ] = 1;
        for( int i = 0; i < g[by].size(); ++i )
            dfs( a , g[by][i] );
    }

    if( visina( p[bx] , p[by] , p[ax] )-d <= eps )
        for( int i = 0; i < g[ax].size(); ++i )
            dfs( g[ax][i] , b );

    if( visina( p[bx] , p[by] , p[ay] )-d <= eps )
        for( int i = 0; i < g[ay].size(); ++i )
            dfs( g[ay][i] , b );
}

int main(){
 //   freopen("Ulaz.txt","r",stdin);
    scanf("%d%d%lf",&n,&m,&d);

    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        p[i] = mk(a,b);
    }

    for( int i = 0; i < m; ++i ){
        int a,b; scanf("%d%d",&a,&b); a--, b--;
        e.push_back( mk(a,b) );
        g[a].push_back(i);
        g[b].push_back(i);
    }
    int a,b; scanf("%d%d",&a,&b); a-- , b--;
    e.push_back( mk(a,a) );
    e.push_back( mk(b,b) );
    int sz = e.size();
    dfs( sz - 2 , sz - 1 );

    int sol = 0;
    for( int i = 0; i < n; ++i ) if( town[i] ) cout<<i+1<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
using namespace std;

const int maxn = 105;

int len;
char txt[maxn];

bool ok(){
    int state = 0;
    for( int i = 0; i < len; ++i ){
        if( state == 0 && txt[i] == 1 ) state ++;
        if( state == 1 && txt[i] == 0 ) state ++;
        if( state == 2 && txt[i] == 1 ) return 0;
    }
    return 1;
}

int sol;

void solve( int f , int mov ){
    if( mov >= 10 ) return;

    if( ok() ){
        if( sol == -1 || sol > mov ) sol = mov;
        return;
    }

    if( f + 1 < len ){
        swap( txt[f] , txt[f+1] );
        solve( f + 1 , mov + 1 );
        swap( txt[f] , txt[f+1] );
    }

    if( f - 1 >= 0 ){
        swap( txt[f] , txt[f-1] );
        solve( f - 1 , mov + 1 );
        swap( txt[f] , txt[f-1] );
    }

    if( f + 2 < len ){
        swap( txt[f] , txt[f+2] );
        txt[f] = !txt[f];
        solve( f + 2 , mov + 1 );
        txt[f] = !txt[f];
        swap( txt[f] , txt[f+2] );
    }

    if( f - 2 >= 0 ){
        swap( txt[f] , txt[f-2] );
        txt[f] = !txt[f];
        solve( f - 2 , mov + 1 );
        txt[f] = !txt[f];
        swap( txt[f] , txt[f-2] );
    }
}

int main(){
    int t = 1;
    //freopen("Ulaz.txt","r",stdin);
    while( scanf("%s",txt) == 1 ){
        if( txt[0] == '-' ) continue;
        len = strlen(txt);

        int fpos = -1;
        for( int i = 0; i < len; ++i ){
            if( txt[i] == 'F' ) fpos = i;
            else txt[i] = txt[i] == 'B';
        }

        sol = -1;
        solve( fpos , 0 );

        printf("%d. %d\n",t++,sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <stack>
#include <map>
using namespace std;

const int maxn = 1005;
const int inf = 999999999;

int n;
int p[maxn][2];
vector< int > x[maxn];

int ls[maxn],rs[maxn];

bool debug = false;

int check(){
    int brenda = 0, annie = 0;
    for( int i = 0; i <= n; ++i ) brenda += ls[i], annie += rs[i];

    int sol = brenda, ret = annie;

    for( int i = 0; i < n; ++i ){
        annie += ls[i] - rs[i], brenda += rs[i] - ls[i];
        if( brenda > sol )ret = annie,sol = brenda;
    }
    return ret;
}

int lox[maxn] , sx;
int loy[maxn] , sy;

inline void erase( int *niz, int &sz ){
    int cnt = 0;
    niz[ cnt ++ ] = niz[0];
    for( int i = 1; i < sz; ++i )
        if( niz[i] == niz[i-1] );
        else niz[cnt++] = niz[i];
    sz = cnt;
}

inline void readi( int &v ){
    static char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        readi( n );

        for( int i = 0; i < n; ++i ){
            x[i].clear();
            rs[i] = ls[i] = 0;
        }

        sx = sy = 0;
        for( int i = 0; i < n; ++i ){
            readi( p[i][0] ) , readi( p[i][1] );
            lox[ sx ++ ] = p[i][0];
            loy[ sy ++ ] = p[i][1];
        }

        sort( lox, lox + n );
        sort( loy, loy + n );

        erase( lox , sx );
        erase( loy , sy );

        for( int i = 0; i < n; ++i ){
            p[i][0] = lower_bound( lox , lox + sx , p[i][0] ) - lox;
            p[i][1] = lower_bound( loy , loy + sy , p[i][1] ) - loy;

            x[ p[i][0] ].push_back( p[i][1] );
            rs[p[i][1]] ++;
        }

        for( int i = 0; i < n; ++i ) sort( x[i].begin(), x[i].end() );

        int sol = check();

        for( int i = 0; i < n; ++i ){

            for( int j = 0; j < x[i].size(); ++j ) rs[ x[i][j] ]--;
            sol = max( sol , check() );

            for( int j = 0; j < x[i].size(); ++j ) ls[ x[i][j] ]++;
            sol = max( sol , check() );
        }

        printf("%d\n",sol);
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <stack>
#include <map>
using namespace std;

const int maxn = 1005;
const int inf = 999999999;

struct segment_tree{
    vector< int > tree;
    int begin;

    void init( int n ){
        int sz = 1;
        while( sz < n ) sz <<= 1;
        begin = sz;
        sz <<= 1;
        tree.resize( sz );
        for( int i = 0; i < sz; ++i ) tree[i] = 0;
    }

    segment_tree(){};

    segment_tree( int n ){ init(n); };

    int query( int lo, int hi ){
        int sol = -inf;
        int ret = lo;
        for( int i = lo; i <= hi; ++i ) if( sol < tree[i] ) ret = i , sol = tree[i];
        return ret;
    }

    void update( int lo, int hi, int v ){
        for( int i = lo; i <= hi; ++i ) tree[i] += v;
    }
};



int n;
int p[maxn][2];
vector< int > x[maxn];

int lox[maxn] , sx;
int loy[maxn] , sy;

inline void erase( int *niz, int &sz ){
    int cnt = 0;
    niz[ cnt ++ ] = niz[0];
    for( int i = 1; i < sz; ++i )
        if( niz[i] == niz[i-1] );
        else niz[cnt++] = niz[i];
    sz = cnt;
}

inline void readi( int &v ){
    static char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    segment_tree t(2005);
    segment_tree annie(2005);

    for( ; tests; --tests ){
        readi( n );

        t.init(2005);
        annie.init(2005);

        for( int i = 0; i < 1000; ++i ) x[i].clear();

        sx = sy = 0;
        for( int i = 0; i < n; ++i ){
            readi( p[i][0] ) , readi( p[i][1] );
            lox[ sx ++ ] = p[i][0];
            loy[ sy ++ ] = p[i][1];
        }

        sort( lox, lox + n );
        sort( loy, loy + n );

        erase( lox , sx );
        erase( loy , sy );

        for( int i = 0; i < n; ++i ){
           // p[i][0] = 1+lower_bound( lox , lox + sx , p[i][0] ) - lox;
           // p[i][1] = 1+lower_bound( loy , loy + sy , p[i][1] ) - loy;

            x[ p[i][0] ].push_back( p[i][1] );
            t.update( p[i][1] * 2 + 1, 2001, +1 );
            annie.update( 0, p[i][1]*2-1, +1 );
        }

        int sol = 0;

        for( int i = 0; i < 10; ++i ){
            for( int j = 0; j < x[i].size(); ++j ){
                t.update( x[i][j]*2+1 , 2001, -1 ) ;
                annie.update( 0 , x[i][j]*2-1, -1 );
            }
            sol = max( sol , annie.tree[t.query( 0 , 2001 )] );

            for( int j = 0; j < x[i].size(); ++j ){
                t.update( 0, x[i][j]*2-1, +1 );
                annie.update( x[i][j]*2+1 , 2001, +1 );
            }
           sol = max( sol , annie.tree[t.query( 0 , 2001 )] );
        }
        cout << sol << endl;

    }
    return 0;
}

#include <cstdio>
#include <iostream>
using namespace std;

const short maxn = 1005;
const short inf = 30000;

struct pii{
    short f,s;
    pii(){};
    pii( short a, short b ):f(a),s(b){};

    const inline void operator+=( const pii &p )  {
        f += p.f;
        s += p.s;
    }
};


struct segment_tree{
    pii *tree;

    short begin;

    void init( short n ){
        short sz = 1;
        while( sz < n ) sz <<= 1;
        begin = sz;
        sz <<= 1;
        tree = new pii[sz];

        for( short i = 0; i < sz; ++i ) tree[i].f = tree[i].s = 0;
    }

    inline void clear(){
        short sz = begin * 2;
        for( short i = 0; i < sz; ++i ) tree[i].f = tree[i].s = 0;
    }

    segment_tree(){};

    segment_tree( short n ){ init(n); };

    short l,r;
    pii val;


    void _update( short node, short lo, short hi ){
        if( lo >= l && hi <= r ){ tree[node] += val; return; }
        if( node >= begin )return;
        short nxt = node * 2;

        pii curr =  tree[nxt+1];
        if( curr.f < tree[nxt].f ) curr = tree[nxt];
        curr.f = tree[node].f - curr.f;
        curr.s = tree[node].s - curr.s;

        if( curr.f != 0 || curr.s != 0 ){
            tree[nxt] += curr;
            tree[nxt+1] += curr;
        }
        short mid = (lo+hi)>>1;
        if( l <= mid )_update( nxt , lo , mid );
        if( r > mid )_update( nxt + 1 , mid + 1, hi );

        if( tree[nxt+1].f < tree[nxt].f ) tree[node] = tree[nxt];
        else tree[node] = tree[nxt+1];
    }

    inline void update( short lo, short hi, pii v ){
        l = lo + begin;
        r = hi + begin;

        val = v;
        _update( 1, begin , begin * 2 - 1 );
    }
};

short n;
short p[maxn][2];
short x[maxn][maxn] , szx[maxn];


const int MaxBuff = 500000;

char buff[ MaxBuff ];
int pos = MaxBuff;

inline char readch () {
  if ( pos == MaxBuff ) {
    fread( buff, 1, MaxBuff, stdin );
    pos = 0;
  }
  return buff[pos++];
}

inline void readi ( short &ret ) {
  char c;
  while ( (c=readch()) < '0' || c > '9' );
  ret = c - '0';
  while ( (c = readch())>='0' && c <='9' ) {
    ret *= 10;
    ret += c - '0';
  }
}



int main(){
  //  freopen("Ulaz.txt","r",stdin);
 //   freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);

    segment_tree t(maxn);

    for( ; tests; --tests ){
        readi( n );

        t.clear();

        for( int i = 0; i < maxn; ++i ) szx[i] = 0;

        for( int i = 0; i < n; ++i )
            readi( p[i][0] ) , readi( p[i][1] );


        for( short i = 0; i < n; ++i ){
            x[ p[i][0] ][ szx[p[i][0]]++ ] = p[i][1];
            t.update( p[i][1] , 1001, pii(+1,0) );
            t.update( 0, p[i][1]-1, pii(0,+1) );
        }


        short sol = 0;

        for( short i = 0; i <= 1001; ++i ){

            for( short j = 0; j < szx[i]; ++j ){
                t.update( x[i][j], 1001, pii(-1,+1) ) ;
                t.update( 0 , x[i][j]-1, pii(+1,-1) );
            }
            if( t.tree[1].s > sol ) sol = t.tree[1].s;
        }
        printf("%d\n",sol);
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <stack>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
using namespace std;

const int mod = 1000000007;

vector< int > msk[10]; // S == 1 , O == 2

int h,w;
char mat[10][10];

int mark[10][10][6562] , clr = 1;
int dp[10][10][6562];
int stp[10], e;

int ok( int m , int e ){
    m /= stp[e-3];
    return m != 10 && m != 16;
}

int solve( int r, int c, int mask ){
    if( c >= 3  && ( r && !ok(mask,w) || !r && !ok(mask,min(w,c)) ) ) return 0;
    if( c == w ) c = 0 , r ++;
    if( r == h ) return 1;

    int &sol = dp[r][c][mask];
    if( mark[r][c][mask] == clr ) return sol;
    mark[r][c][mask] = clr;

    sol = 0;

    int e = stp[c];
    if( r ) e = stp[w - 1];

    int nxt = mask;
    if( r ) nxt /= 3;

    int s = mask%3;
    if( r == 0 ) s = 0;

    if( mat[r][c] == 'S' || mat[r][c] == '.' ){
        int add = 0;
        if( s == 0 ) add = e;
        else if( s == 1 ) add = e;
        else if( s == 2 ) add = -1;

        if( add != -1 ) sol += solve( r, c + 1, nxt + add );
        if( sol >= mod ) sol -= mod;
    }

    if( mat[r][c] == 'O' || mat[r][c] == '.' ){
        int add = 0;
        if( s == 1 ) add = 2*e;

        sol += solve( r, c + 1 , nxt + add );
        if( sol >= mod ) sol -= mod;
    }

    return sol;
}

int main(){
    stp[0] = 1;
    for( int i = 1; i < 10; ++i ) stp[i] = stp[i-1] * 3;

   // freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){

        scanf("%d%d",&h,&w);
        for( int i = 0; i < h; ++i ) scanf("%s",mat[i]);

        int s3 = 1;
        for( int k = 1; k <= w; ++k ) s3 *= 3;

        int sol = solve( 0 , 0 , 0 );
        printf("%d\n",sol);
        clr ++;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
using namespace std;

int h,w;
char txt[10][10];

int u;
int dp[10][10][1<<16];

const int mod = 1000000007;

inline bool sos( char a, char b , char c ){
    if( a == 'S' && b == 'O' && c == 'S' ) return 1;
    return 0;
}

int solve( int r, int c, int mask ){
    if( c == w ) c = 0 , r++;
    if( r == h )
        return 1;

    int &ref = dp[r][c][mask&u];
    if( ref != -1 ) return ref;

    int nxt = mask<<1;
    ref = 0;
    if( txt[r][c] != '.' ){
        if( txt[r][c] == 'S' ){
            nxt++;
            if( c >= 2 && sos( txt[r][c] , txt[r][c-1] , txt[r][c-2] ) ) return ref=0;
            if( r >= 2 && sos( txt[r][c] , txt[r-1][c] , txt[r-2][c] ) ) return ref=0;
        }

        return ref = solve( r , c + 1 , nxt );
    }

    nxt = mask<<1;
    txt[r][c] = 'O';
    ref = solve( r , c+1 , nxt );

    txt[r][c] = 'S'; nxt++;
    if( (c < 2 || !sos( txt[r][c] , txt[r][c-1] , txt[r][c-2] )) && (r < 2 || !sos( txt[r][c] , txt[r-1][c] , txt[r-2][c] )) )
        ref = (ref+solve( r , c+1 , nxt ))%mod;

    txt[r][c] = '.';
    return ref;

}

int main(){
    freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){

        scanf("%d%d",&h,&w);
        for( int i = 0; i < h; ++i ) scanf("%s",txt[i]);

        bool weiter = false;

        for( int i = 0; i < h && !weiter; ++i )
            for( int j = 0; j < w && !weiter; ++j ){
                if( i-2 >= 0 && txt[i-2][j] == 'S' && txt[i][j] == 'S' && txt[i-1][j] == 'O' ) weiter = 1;
                if( j-2 >= 0 && txt[i][j-2] == 'S' && txt[i][j] == 'S' && txt[i][j-1] == 'O' ) weiter = 1;

                if( i-2 >= 0 && txt[i-2][j] == 'S' && txt[i][j] == 'S' ) txt[i-1][j] = 'S';
                if( j-2 >= 0 && txt[i][j-2] == 'S' && txt[i][j] == 'S' ) txt[i][j-1] = 'S';
            }

        if( weiter ){
            printf("0\n");
            continue;
        }

        u = 1<<(2*w);
        --u;

        for( int i = 0; i < h; ++i )
            for( int j = 0; j < w; ++j )
                for( int k = 0; k <= u; ++k )
                    dp[i][j][k] = -1;

        int sol = solve( 0 , 0 , 0 );
        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <algorithm>
#include <map>
#include <iomanip>
using namespace std;

const int inf = 999999999;
const int maxn = 100000 + 55;

int n,m,mx,my,mxy;
int p[maxn][2];
int x[maxn], y[maxn];
int xs[maxn] , ys[maxn];

void clear(){
    for( int i = 0; i < n; ++i ){
        x[ p[i][0] ] --;
        y[ p[i][1] ] --;
    }
}

int *f;

int dp[maxn][11];

int solve( int x, int dx ){
    if( x == mxy+1 )
        return (m-dx) * n;
    if( dx >= m ) return inf;

    int &sol = dp[x][dx];
    if( sol != -1 ) return sol;
    sol = inf;

    int lo = x , hi = mxy , s = x;
    while( lo <= hi ){
        int mid = (lo+hi)>>1;
        int w = f[mid]; if( x ) w -= f[x-1];
      //  cout<<" | "<<mid<<" , "<<m*w<<" "<<n<<" [ "<<lo<<" "<<hi<<" ] "<<endl;
        if( m*w <= n ) lo = mid + 1, s = mid;
        else hi = mid - 1;
    }

    for( int k = -30; k <= 30; ++k ){
        int i = s + k;
        if( i < x || i > mxy ) continue;
        int w = f[i]; if( x ) w -= f[x-1];
        sol = min( sol , solve( i + 1 , dx + 1 ) + abs( n - m*w ) );
    }
    return sol;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    int t = 1;
    while( scanf("%d%d",&n,&m) == 2 ){
        if( n == 0 && m == 0 ) break;

        mx = 0;
        for( int i = 0; i < n; ++i ){
            scanf("%d%d",&p[i][0],&p[i][1]);
            x[ p[i][0] ] ++ , y[ p[i][1] ] ++;
            mx = max( mx , p[i][0] );
            my = max( my , p[i][1] );
        }

        mxy = max( mx , my );
        xs[0] = x[0] , ys[0] = y[0];
        for( int i = 1; i <= mxy; ++i ){
            xs[i] = xs[i-1] + x[i];
            ys[i] = ys[i-1] + y[i];
        }

        int sol = inf;

        f = xs, mxy = mx;
        for( int i = 0; i <= mxy+2; ++i )
            for( int j = 0; j <= m; ++j )
                dp[i][j] = -1;
        sol = min( sol , solve( 0 , 0 ) );

        f = ys, mxy = my;
        for( int i = 0; i <= mxy+2; ++i )
            for( int j = 0; j <= m; ++j )
                dp[i][j] = -1;
        sol = min( sol , solve( 0 , 0 ) );

        int naz = m * m;
        int g = __gcd( sol , naz );
        printf("%d. %d/%d\n",t++,sol/g,naz/g);

        clear();
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <stack>
#include <set>
#include <string.h>
#include <string>
#include <map>
#include <iomanip>
#include <math.h>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

const int maxn = 200000 + 55;
const double z = 1000;

struct coord{
    int x,y;

    coord(){};
    coord( int p1, int p2 ):x(p1),y(p2){};
};

int n;
vector< coord > crds, mem;
vector< pair<double,double> > origin;

bool byY1( coord a, coord b ){ return a.x < b.x || ( a.x == b.x && a.y < b.y ); }
bool byY2( coord a, coord b ){ return a.x < b.x || ( a.x == b.x && a.y > b.y ); }

int sz = 0;
coord hull[maxn];

ll ccw( coord n, coord a, coord b ){
    return (a.x-n.x)*(ll)(b.y-n.y) - (a.y-n.y)*(ll)(b.x-n.x);
}

void insert1( coord x ){
    while( sz >= 2 && ccw( hull[sz-2] , hull[sz-1] , x ) >= 0 ) sz --;
    hull[sz++] = x;
}

void insert2( coord x ){
    while( sz >= 2 && ccw( hull[sz-2] , hull[sz-1] , x ) <= 0 ) sz --;
    hull[sz++] = x;
}

ll get( coord p , int idx ){
    return (p.x*(ll)hull[idx].x) + (p.y*(ll)hull[idx].y);
}

ll binary( coord v ){
    int lo = 0 , hi = sz - 1;
    while( lo < hi ){
        int mid = (lo+hi) / 2;

        if( get( v , mid ) < get( v , mid + 1 )  ) lo = mid+1;
        else hi = mid;
    }
    return get( v , lo );
}

ll sol[maxn];


int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        double a,b; scanf("%lf%lf",&a,&b);
        int x = int(round(a * 1000));
        int y = int(round(b * 1000));
        mem.push_back( coord(x,y) );
    }
    crds = mem;


    sz = 0;
    sort( crds.begin(), crds.end() , byY1 );
    for( int i = 0; i < n; ++i ) insert1( crds[i] );
    for( int i = 0; i < n; ++i ) sol[i] = max( sol[i] , binary(  mem[i] )  );


    sz = 0;
    sort( crds.begin(), crds.end() , byY2 );
    for( int i = 0; i < n; ++i ) insert2( crds[i] );
    for( int i = 0; i < n; ++i ) sol[i] = max( sol[i] , binary(  mem[i] )  );


    for( int i = 0; i < n; ++i )
        printf("%.3lf\n", round(sol[i]/z)/z  );

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <stack>
#include <set>
#include <string.h>
#include <string>
#include <map>
#include <math.h>
#include <iomanip>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

int n;
vector< pii > w;
vector< pair<double,double> > origin;


const double z = 1000;

ll mx( pii p ){
    ll sol = -1;
    for( int i = 0; i < n; ++i ){
        ll s = (p.f*(ll)w[i].f) + (p.s*(ll)w[i].s);
        if( sol < s ) sol = s;
    }
    return sol;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        double a,b; scanf("%lf%lf",&a,&b);
        int x = int(round(a * 1000));
        int y = int(round(b * 1000));
        w.push_back( mk(x,y) );
    }

    for( int i = 0; i < n; ++i ){
        printf("%.3lf\n",round(mx(w[i])/z)/z  );
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
using namespace std;

typedef long long ll;

const int maxn = 1000 + 55;

int n;
int mat[maxn][maxn];
int ra,rb,ca,cb;
int a,b,c;

bool visi[maxn][maxn];

int d[][2] = { -1,0, +1,0, 0,+1, 0,-1 };

int rq[maxn*maxn],sz;
int cq[maxn*maxn];

bool ok( int allow ){
    for( int i = 1; i <= n; ++i )
        for( int j = 1; j <= n; ++j )
            visi[i][j] = 0;

    if( mat[ra][ca] < allow ) return 0;
    visi[ra][ca] = 1;
    sz = 0;
    rq[sz] = ra, cq[sz++] = ca;

    while( sz > 0 ){
        int rn = rq[sz-1];
        int cn = cq[sz-1];
        sz--;

        if( visi[rb][cb] ) return 1;

        for( int i = 0; i < 4; ++i ){
            int rx = rn + d[i][0];
            int cx = cn + d[i][1];

            if( rx <= 0 || cx <= 0 || cx > n || rx > n ) continue;
            if( visi[rx][cx] ) continue;
            if( mat[rx][cx] < allow ) continue;

            visi[rx][cx] = 1;
            rq[sz] = rx , cq[sz++] = cx;
        }
    }
    return 0;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    srand((unsigned)time(0));
    //scanf("%d",&n);
    //scanf("%d%d%d%d",&ca,&ra,&cb,&rb);
    //scanf("%d%d%d",&a,&b,&c);

    n = 900 + rand()%100;
    ca = 1+rand()%n;
    ra = 1+rand()%n;
    cb = 1 + rand()%n;
    rb = 1 + rand()%n;
    a = 5461561 , b = 3242423 , c = 123423477;

    if( ca == cb && ra == rb ){
        printf("0\n");
        return 0;
    }

    for( int i = 1; i <= n; ++i )
        for( int j = 1; j <= n; ++j )
            mat[j][i] = (((i-1)*n+j-1)*(ll)a+b)%c;


    int lo = 0 , hi = 1000000000,s;
    while( lo <= hi ){
        int mid = (lo+hi)>>1;
        bool sol = ok( mid );

        if( sol ){
            s = mid;
            lo = mid + 1;
        }else hi = mid - 1;
   }
   cout<<(mat[ra][ca]-s) + (mat[rb][cb]-s)<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 1000 + 55;
const int inf = 2000000000;

int n;
int mat[maxn][maxn];
int ra,rb,ca,cb;
int a,b,c;

bool visi[maxn][maxn];

int d[][2] = { -1,0, +1,0, 0,+1, 0,-1 };

int main(){
    //freopen("Ulaz.txt","r",stdin);
    srand((unsigned)time(0));
    scanf("%d",&n);
    scanf("%d%d%d%d",&ca,&ra,&cb,&rb);
    scanf("%d%d%d",&a,&b,&c);
//    n = 900 + rand()%100;
//    ca = 1+rand()%n;
//    ra = 1+rand()%n;
//    cb = 1 + rand()%n;
//    rb = 1 + rand()%n;
//    a = 5461561 , b = 3242423 , c = 123423477;

    if( ca == cb && ra == rb ){
        printf("0\n");
        return 0;
    }

    for( int i = 1; i <= n; ++i )
        for( int j = 1; j <= n; ++j )
            mat[j][i] = (((i-1)*n+j-1)*(ll)a+b)%c;

    priority_queue< pair< int , pii > > pq;
    pq.push( mk( mat[ra][ca] , mk(ra,ca) ) );

    visi[ra][ca] = 1;
    pair<int,pii> u;
    int low = inf;

    while( !pq.empty() ){
        u = pq.top(); pq.pop();

        low = min( low , u.f );

        if( u.s.f == rb && u.s.s == cb ) break;

        for( int i = 0; i < 4; ++i ){
            int rn = u.s.f + d[i][0];
            int cn = u.s.s + d[i][1];

            if( rn <= 0 || cn <= 0 || rn > n || cn > n || visi[rn][cn] ) continue;
            visi[rn][cn] = 1;

            pq.push( mk(mat[rn][cn],mk(rn,cn)));
        }
    }

    cout<<(mat[ra][ca]-low) + (mat[rb][cb]-low)<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <math.h>
using namespace std;

const int mod = 1000000003;

int n,m;
int dp[1005][1005];

int bit[1005][1005];

void update( int r, int c, int v ){
    for( c += 2; c < 1005; c += c & -c )
        bit[r][c] = (bit[r][c]+v)%mod;
}

int read( int r, int c ){
    int ret =0 ;
    for( c += 2; c >= 1; c -= c & -c )
        ret = (bit[r][c]+ret)%mod;
    return ret;
}

int main(){
    scanf("%d%d",&n,&m);

    if( m == 1 ){
        printf("%d\n",n);
        return 0;
    }

    for( int i = 0; i < n; ++i ){
        dp[i][0] = 1;
        update( 0, i, 1 );
        for( int j = 1; j < m; ++j ){
            dp[i][j] = read( j-1 , i-2 );
            update( j , i , dp[i][j] );
        }
    }


    int s = 0;
    for( int i = 0; i < n-3; ++i )
        s = ( s + dp[i][m-2] ) % mod;

    int sol = (s * 2)%mod;

    for( int i = 0; i < n-2; ++i )
        sol = (sol + dp[i][m-1] ) % mod;
    cout<< sol << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <math.h>
using namespace std;

const int mod = 1000000003;

int n,m;
int dp[1005][1005];

int solve( int dx, int k ){
    if( k == m ) return 1;
    if( dx >= n ) return 0;

    int &sol = dp[dx][k];
    if( sol != -1 ) return sol;
    sol = 0;

    for( int i = dx; i < n; ++i )
        sol = ( sol + solve( i + 2 , k + 1 ) ) % mod;

    return sol;
}

int calc( int n, int m ){
    memset( dp , -1 , sizeof(dp));
    ::n = n , ::m = m;
    return solve( 0 , 0 );
}

int main(){
    int n,m; scanf("%d%d",&n,&m);

    int sol = ((calc( n - 3 , m - 1 )*2)%mod + calc( n - 2 , m ))%mod;
    cout<< sol <<endl;

    return 0;
}

#include <cstdio>
#include <iostream>
using namespace std;

typedef long long ll;

const int maxn = 100000 + 55;

int n;
ll x[maxn];

int mode[maxn];
bool done[maxn];

void readi( ll &v ){
    static char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
}

int main(){
   // freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i )
        readi( x[i] );

    ll sol = 0;
    for( int i = 63; i >= 0; --i ){
        int f = -1;
        for( int k = 0; k < n && f < 0; ++k ){
            if( done[k] ) continue;
            bool v = (x[k] & (1LL<<i)) != 0;
            if( v ) f = k;
        }

        if( f == -1 ){
            if( mode[i] ) sol |= 1LL << i;
            continue;
        }

        sol |= 1LL << i;
        done[f] = 1;


        for( int j = 0; j < 63; ++j ){
            if( j == i ) continue;
            if( ~x[f]&(1LL<<j) ) continue;
            if( mode[i]%2 == 0 ) mode[j] ^= 1;
        }
        ll b = x[f];

        for( int k = 0; k < n; ++k )
            if( x[k]&(1LL<<i) )
                x[k] = ((x[k]&b)^b)  | (x[k]&(~b));
    }

    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <cstdio>
#include <set>
#include <queue>
#include <math.h>
#include <string.h>
#include <algorithm>
#include <iomanip>
#include <vector>
#include <stack>
#include <map>
using namespace std;

typedef long long ll;

const int inf = 999999999;

int s1,p1;
int s2,p2;

ll r[200];
ll q[200][2];

string days[] = { "Saturday" , "Sunday", "Monday", "Tuesday", "Wednesday",
"Thursday", "Friday" };

int main(){
    int a,b;
    scanf("%d:%d",&a,&b);
    s1 = a*60 + b;

    scanf("%d:%d",&a,&b);
    s2 = a*60 + b;

    scanf("%d:%d",&a,&b);
    p1 = a*60 + b;

    scanf("%d:%d",&a,&b);
    p2 = a*60 + b;


    p2 *= -1;
    int diff = s2 - s1;
    int g = __gcd(p1,p2);


    if( diff % g ) {
        printf("Never\n");
        return 0;
    }

    if( p1 >= p2 ){
        r[0] = p1 , q[0][0] = 1, q[0][1] = 0;
        r[1] = p2 , q[1][1] = 1, q[1][0] = 0;
    }else{
        r[0] = p2 , q[0][1] = 1, q[0][0] = 0;
        r[1] = p1 , q[1][0] = 1, q[1][1] = 0;
    }

    int dx = 1;
    do{
        dx++;
        r[dx] = r[dx-2] % r[dx-1];

        q[dx][0] = q[dx-2][0];
        q[dx][1] = q[dx-2][1];

        int d = r[dx-2] / r[dx-1];
        q[dx][0] -= d*q[dx-1][0];
        q[dx][1] -= d*q[dx-1][1];

    }while( r[dx] != 0 ); dx--;

    if( r[dx] < 0 && diff < 0 ) q[dx][0] *= -1 , q[dx][1] *= -1 , r[dx] *= -1;
    int t = diff / r[dx];
    q[dx][0] *= t;
    q[dx][1] *= t;
    r[dx] *= t;

    ll period = abs(p1*p2 / __gcd(p1,p2));
    ll w1 = q[dx][0]*p1 + s1;
    ll w2 = -q[dx][1]*p2 + s2;
    ll w = w1;

    if( w > 0 ) w -= period*( w/period);
    while( w < s1 || w < s2 ) w += (period)*( abs(w)/period) + period;

    ll c = w / 1440;
    w -= c*1440;

    cout<<days[c%7]<<endl;
    printf("%.2d:%.2d\n",w/60,w%60);



    return 0;
}

#include <iostream>
#include <cstdio>
#include <set>
#include <queue>
#include <math.h>
#include <string.h>
#include <algorithm>
#include <iomanip>
#include <vector>
#include <stack>
#include <map>
using namespace std;

const int inf = 999999999;

char buff[11];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int cnt = 0;
    for( int i = 0; i < 5; ++i ){
        scanf("%s",buff);
        int len = strlen(buff);
        for( int k = 0; k < len-2; ++k ){
            if( buff[k] == 'F' && buff[k+1] == 'B' && buff[k+2] == 'I' ){
                cnt ++;
                printf("%d ",i+1);
                break;
            }
        }
    }
    if( cnt == 0 ) printf("HE GOT AWAY!\n");
    else printf("\n");

    return 0;
}

#include <iostream>
#include <cstdio>
#include <set>
#include <queue>
#include <math.h>
#include <algorithm>
#include <iomanip>
using namespace std;

typedef long long ll;

int main(){
    int n,m,a;
    cin >> n >> m >> a;
    cout<< (ll)ceil(n/(double)a) * (ll)ceil(m/(double)a)<<endl;
    return 0;
}

#include <iostream>
#include <set>
#include <string.h>
#include <math.h>
#include <string>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <cstdio>
#include <stack>
#include <map>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

char buff[4];

struct amulet{
    int v[4];
    amulet(){};
    amulet( int a, int b, int c, int d ){
        v[0] = a , v[1] = b, v[2] = c, v[3] = d;
    }
    const bool operator<( const amulet &a ) const{
        if( v[0] != a.v[0] ) return v[0] < a.v[0];
        if( v[1] != a.v[1] ) return v[1] < a.v[1];
        if( v[2] != a.v[2] ) return v[2] < a.v[2];
        return v[3] < a.v[3];
    }
};

amulet rotate( amulet a ){
    int tmp = a.v[0];
    a.v[0] = a.v[1];
    a.v[1] = a.v[2];
    a.v[2] = a.v[3];
    a.v[3] = tmp;
    return a;
}

vector< amulet > w;

bool eq( amulet a, amulet b ){
    return (a.v[0] == b.v[0] && a.v[1] == b.v[1] && a.v[2] == b.v[2] && a.v[3] == b.v[3]);
}

int main(){
    int n; scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        if( i ) scanf("%s",buff);
        scanf("%s",buff);
        int a = buff[0]-'0' , b = buff[1]-'0';

        scanf("%s",buff);
        int c = buff[1]-'0' , d = buff[0]-'0';
        w.push_back( amulet(a,b,c,d) );

        amulet r = rotate(w[i]);
        amulet q = rotate( rotate(w[i]));
        amulet z = rotate( rotate( rotate( w[i] ) ) );

        w[i] = min( w[i] , min( r , min(q,z) ) );
    }

    sort( w.begin() , w.end() );

    int sol = 1;

    for( int i = 1; i < n; ++i )
        if( !eq( w[i] , w[i-1] ) ) sol ++;

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <set>
#include <string.h>
#include <math.h>
#include <string>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <cstdio>
#include <stack>
#include <map>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

int n;
vector< int > x;

const int inf = 999999999;
const double eps = 1e-7;

bool ok( double d ){
    int from = inf , to = -1;
    int r = 2*d;
    for( int i = 0; i < x.size(); ++i ){
        if( x[i] > x[0]+r && from == inf ) from = i;
        if( x[i] < x[n-1]-r ) to = i;
    }
    if( from > to ) return 1;

    int range = x[to] - x[from];
    return range <= 2*d;
}

double middot( double d ){
    int from = inf , to = -1;
    for( int i = 0; i < x.size(); ++i ){
        if( x[i] > x[0]+2*d && from == inf ) from = i;
        if( x[i] < x[n-1]-2*d ) to = i;
    }
    if( from > to ) return 0;
    return (x[from] + x[to]) / 2.00;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
         int a;scanf("%d",&a);
         x.push_back(a);
    }
    sort( x.begin() , x.end() );

    if( n == 1 ) {
        printf("%.6lf\n",0);
        printf("%.6lf %.6lf %.6lf\n",(double)x[0],(double)x[0],(double)x[0]);
        return 0;
    }

    double lo = 0, hi = x[n-1] - x[0] + 5;
    double sol = -1;
    while( hi - lo >= eps ){
        double mid = (hi+lo)/2;
        if( ok(mid) ){
            sol = mid;
            hi = mid - eps;
        }else lo = mid + eps;
    }

    printf("%.6lf\n",sol);
    printf("%.6lf %.6lf %.6lf\n",x[0]+sol,middot(sol),x[n-1]-sol);

    return 0;
}

#include <iostream>
#include <set>
#include <string.h>
#include <math.h>
#include <string>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <cstdio>
#include <stack>
#include <map>
using namespace std;

const int maxn = 100000 + 55;
const double eps = 10e-10;

int n;
int x[maxn];

bool isgeo(){
    double d = x[1] / (double)x[0];
    for( int i = 1; i < n; ++i )
        if( fabs(d-(x[i]/(double)x[i-1])) > eps ) return 0;
    return 1;
}

bool erased( int dx ){
    double d;
    if( dx == 0 || dx == 1 ) d = x[3] / (double)x[2];
    else d = x[1] / (double)x[0];

    for( int i = 1; i < n; ++i ){
        int j = i-1;
        if( i == dx ) continue;
        while( j >= 0 && j == dx ) j --;
        if( j == -1 ) continue;

        if( fabs(d-(x[i]/(double)x[j])) > eps ) return 0;
    }
    return 1;
}

int err( double d ){
    for( int i = 1; i < n; ++i )
        if( fabs(d-(x[i]/(double)x[i-1])) > eps )
            return i;
    return -1;
}



int main(){
   // freopen("Ulaz.txt","r",stdin);
    int zero = 0;
    int ones = 0 , dxzero;
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%d",&x[i]);
       // cout<<x[i]<<" ";
        if( x[i] == 0 ) zero ++, dxzero = i;
        ones += x[i] == 1;
    }//cout<<endl;

    if( zero ){
        int cnt = 0;
        for( int i = 1; i < n; ++i ) cnt += x[i] != 0;
        if( cnt == 0 ) printf("0\n");
        else if( cnt == 1 || zero == 1 && erased(dxzero) ) printf("1\n");
        else printf("2\n");
        return 0;
    }


    if( n <= 2 || isgeo() ){
        printf("0\n");
        return 0;
    }

    if( n <= 3 ){
        printf("1\n");
        return 0;
    }

    for( int i = 0; i < min(10,n); ++i ){
        if( erased(i) ){
            printf("1\n");
            return 0;
        }
    }

    if( erased( err( x[1] / (double)x[0] ) ) ){
        printf("1\n");
        return 0;
    }


    printf("2\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <stack>
#include <map>
#include <cstdio>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

vector< pii > mov;

int n;
int a[305] , b[306];

int main(){
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ) scanf("%d",&a[i]);
    for( int i = 0; i < n; ++i ) scanf("%d",&b[i]);

    for( int i = 0; i < n; ++i ){
        int pos = -1;
        for( int j = i; j < n; ++j )
            if( a[i] == b[j] ) pos = j;

        while( pos > i ){
            mov.push_back( mk( pos-1 , pos ) );
            swap( b[pos], b[pos-1] ) , pos --;
        }
    }

    cout<< mov.size()<<endl;
    for( int i = 0; i <mov.size(); ++i )
        cout<<mov[i].f+1<<" "<<mov[i].s+1<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <string.h>
#include <string>
#include <map>
#include <cstdlib>
#include <math.h>
#include <fstream>
#include <queue>
#include <stack>
#include <iomanip>
#include <assert.h>
using namespace std;


int main(){
    int n;
    cin >> n;

    for( int i = 2; i*i <= n; ++i ){
        while( n % i == 0 ){
            printf("%d ",n);
            n /= i;
        }
    }
    if( n != 1 )printf("%d 1\n",n);
    else printf("1\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <string.h>
#include <string>
#include <map>
#include <cstdlib>
#include <math.h>
#include <fstream>
#include <queue>
#include <stack>
#include <iomanip>
#include <assert.h>
using namespace std;

const int maxn = 100000 + 55;

typedef long long ll;

int n;
int a[maxn];

int cnt[maxn];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i )
        scanf("%d",&a[i]);

    for( int i = 0; i < n/2; ++i )
        a[i] -= i;

    for( int i = n-1 , x = 0; i >= n/2; --i , x ++ )
        a[i] -= x;

    for( int i = 0; i < n; ++i )
        if( a[i] >= 1 ) cnt[ a[i] ] ++;


    int sol = n + 5;
    for( int i = 1; i <= 100000; ++i ) sol = min( sol , n - cnt[i] );
    cout<< sol << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <map>
#include <cstdio>
#include <math.h>
#include <set>
using namespace std;

#define pii pair<int,int>
#define x first
#define y second
#define mk make_pair

vector< pii > p;
pii hull[5]; int sz = 0;

inline int ccw( pii a, pii b, pii c ){
    return (a.x-c.x)*(b.y-c.y) - (a.y-c.y)*(b.x-c.x);
}

pii pivot;
inline bool srt( pii a, pii b ){
    return ccw( pivot , a , b ) > 0;
}

int main(){
 //   freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);
    while( tests -- ){
        p.clear();
        for( int i = 0; i < 4; ++i ){
            int a,b; scanf("%d%d",&a,&b);
            p.push_back( mk(a,b) );
        }
        sort( p.begin(), p.end() ); sz = 0;
        pivot = hull[sz++] = p[0];
        sort( p.begin() , p.end() , srt );

        bool N = 0;

        for( int i = 1; i < 4; ++i ){
            while( sz >= 2 && ccw( hull[sz-2], hull[sz-1] , p[i] ) <= 0 ) sz --, N = 1;
            hull[sz++] = p[i];
        }

        if( N ) putchar('N');
        else putchar('Y');
        putchar('\n');

    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <math.h>
#include <map>
using namespace std;

typedef long long ll;

map<int,int>mp;

int main(){
    freopen("Ulaz.txt","r",stdin);
 //   freopen("Izlaz2.txt","w",stdout);

    for( int i = 0; i*(ll)i < 2147483647; ++i )
        mp[i*i] = 1;

    int tests;
    scanf("%d",&tests);
    for( ; tests; --tests) {
        int n; scanf("%d",&n);
        int sol = 0;

        for( int i = 0; i*(ll)i <= n; ++i ){
            int s = n - i*i;
            if( i*i < s ) continue;
            if( mp[s] ) sol ++;
        }
        printf("%d\n",sol);
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <set>
#include <queue>
#include <math.h>
#include <string.h>
#include <algorithm>
#include <iomanip>
#include <vector>
#include <stack>
#include <map>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 200000 + 55;

int n;
int owes[maxn];
int cash[maxn];

int in[maxn];
int visi[maxn];
int has[maxn];
int e[maxn];
bool paid[maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%d%d",&owes[i],&cash[i]); owes[i] --;
        in[ owes[i] ] ++;
        e[i] = cash[i];
    }

    queue<int>q;
    int sol = 0;

    for( int i = 0; i < n; ++i )
        if( in[i] == 0 ) q.push( i );

    while( !q.empty() ){
        int u = q.front(); q.pop();
        visi[u] = 1;

        sol += max( 0 , cash[u]-has[u] );
        in[ owes[u] ] --;
        has[ owes[u] ] += cash[u];
        has[u] = 0;

        if( in[ owes[u] ] == 0 ) q.push( owes[u] );
    }


    for( int i = 0; i < n; ++i ){
        if( visi[i] ) continue;
        int dx = i;
        int cost = 999999999;

        while( visi[dx] != 1 ){
            visi[dx] ++;
            int nxt = owes[dx];

            sol += max( 0 , cash[nxt] - has[nxt] - cash[dx] );
            cost = min( cost , cash[dx] - has[dx] );

            dx = nxt;
        }
        sol += max( 0 , cost );
    }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <algorithm>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <iomanip>
#include <stack>
#include <math.h>
using namespace std;

typedef long long ll;

ll a[2][2];
ll b[2][2];
ll c[2][2];

ll s[4];

void mul( ll *a, ll *b ){
    memset(s,0,sizeof(s));

    for( int i = 0; i < 2; ++i )
        for( int j = 0; j < 2; ++j )
            for( int k = 0; k < 2; ++k )
                s[i*2+j] += a[i*2+k]*b[k*2+j];

    for( int i = 0; i < 4; ++i ) a[i] = s[i];

}

ll fib( int n ){
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    memset(c,0,sizeof(c));

    a[0][0] = 0, a[0][1] = 1;
    b[1][0] = 1;
    b[0][1] = b[1][1] = 1;

    stack<int>stk;
    while( n ){
        if( n % 2 == 0 ) stk.push(0),n/=2;
        else stk.push(1),n--;
    }

    c[0][0] = c[1][1] = 1;
    while( stk.empty() == false ){
        int u = stk.top(); stk.pop();
        if( u == 0 ) mul( c[0] , c[0] );
        else mul( c[0] , b[0] );
    }
    mul( a[0] , c[0] );
    return a[0][0];
}

bool isfib( ll n ){
    for( int i = 0; i <= 90; ++i )
        if( fib(i) == n ) return 1;
    return 0;
}

int main(){
    ll n;
    cin >> n;


    int i = 90;
    ll sol;
    while( n > 0 && i >= 0 ){
        ll x = fib(i);
        if( x <= n ) n -= x, i -= 2, sol = x;
        else i --;
    }

    cout<< sol << endl;

    return 0;
}

#include <iostream>
#include <cstdio>
#include <set>
#include <queue>
#include <math.h>
#include <string.h>
#include <algorithm>
#include <iomanip>
#include <vector>
#include <stack>
#include <map>
using namespace std;

const int inf = 999999999;

int main(){
    int r,c;
    cin >> r >> c;

    for( int a = 3; a <= 5000; ++a ){
        if( (r - 2*a + 4) % 2 ) continue;
        int b = (r - 2*a + 4) / 2;
        if( b <= 0 ) continue;

        int cnt = a*b - r;
        if( cnt == c ){
            printf("%d %d\n",max(a,b),min(a,b) );
            break;
        }
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <set>
#include <queue>
#include <math.h>
#include <string.h>
#include <algorithm>
using namespace std;

const int inf = 999999999;

typedef long long ll;

double p;
ll t = 1000000000LL;

ll sol[5];

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%lf",&p);
    ll x = (ll)round(t*p);
    x /= __gcd( x , t );

    ll cnt = (ll)round(x / p);
    ll c = 0;

    for( int i = 5; i >= 1; --i ){
        sol[i] = x / i;
        x -= sol[i]*i;
        c += sol[i];
    }

    for( int i = 5; i >= 1; --i ){
        ll m = sol[i];
        ll visak = cnt - c;

        ll a = min( visak , m );

        sol[i] -= a;
        sol[i-1] += a;
        sol[1] += a;
        c += a;
    }

    ll sum = 0;
    ll cx = 0;
    for( int i = 1; i <= 5; ++i ){
        cout<<sol[i]<<" ";
        sum += sol[i]*i , cx += sol[i];
    }cout<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <string>
using namespace std;

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        int n; scanf("%d",&n);
        vector< string > w;
        for( int i = 0; i < n; ++i ){
            string s; cin >> s;
            w.push_back( s );
        }
        sort( w.begin() , w.end() );
        string sol = "x";
        sol[0] = 'z' + 5;
        do{
            string h = "";
            for( int i = 0; i < n; ++i )
                h += w[i];

            sol = min( sol , h );

        }while( next_permutation( w.begin() , w.end() ) );
        cout<< sol <<endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <cstdio>
#include <algorithm>
#include <math.h>
#include <iomanip>
using namespace std;

#define pii pair<int,int>
#define x first
#define y second
#define mk make_pair

int x1,yu,x2,y2,x3,y3,x4,y4;

int xs[2][2];
int ys[2][2];
int a,b,c,d,e,f,g,h;

int main(){
    freopen("Ulaz.txt","r",stdin);
    int t; cin >> t;
    while(t--){
        scanf("%d%d%d%d%d%d%d%d",&x1,&yu,&x2,&y2,&x3,&y3,&x4,&y4);


        a = min(x1,x2);
        b = min(yu,y2);
        c = min(x3,x4);
        d = min(y3,y4);

        e = max(x1,x2);
        f = max(yu,y2);
        g = max(x3,x4);
        h = max(y3,y4);

        if( min(e,g) < max(a,c) || min(f,h) < max(b,d)  )
            printf("nothing\n");
        else if( min(f,h) == max(b,d) ){
            if( a == g || e == c ) printf("point\n");
            else printf("line\n");
        }else if( min(e,g) == max(a,c) ){
            if( b == h || f == d ) printf("point\n");
            else printf("line\n");
        }else printf("rectangle\n");


    }
    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <algorithm>
#include <math.h>
#include <map>
#include <iomanip>
#include <string>
#include <queue>
#include <cstdlib>
#include <cstdio>
#include <set>
using namespace std;

int n,m;
int cnt[105];

int main(){
    scanf("%d%d",&n,&m);

    for( int i = 0; i < n; ++i ){
        int a; scanf("%d",&a);
        cnt[a] ++;
    }

    int sol = 0;
    while( cnt[m] != n ){
        sol ++;
        for( int i = m-1; i >= 1; --i )
            if( cnt[i] ) cnt[i]--, cnt[i+1] ++;
    }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <math.h>
using namespace std;

typedef long long ll;

const int maxn = 100000 + 55;

int n;
ll eq[maxn][2];

int cnt[maxn][4];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    vector< ll > lox;

    ll mx = 0;
    for( int i = 0; i < n; ++i ){
       // cin >> eq[i][0] >> eq[i][1];
        scanf("%lld%lld",&eq[i][0],&eq[i][1]);
        eq[i][0] --;
        lox.push_back( eq[i][1] );
        mx = max( mx , eq[i][1] );
    }

    lox.push_back( 0 );
    lox.push_back( mx+1 );

    sort( lox.begin(), lox.end() );
    lox.erase( unique(lox.begin(),lox.end()),lox.end() );

    int curr = 0, sol = 0;
    ll val = 0;

    for( int i = 0; i < n; ++i ){
        eq[i][1] = lower_bound( lox.begin(), lox.end(), eq[i][1] ) - lox.begin();
        cnt[ eq[i][1] ][ eq[i][0] ] ++;

        if( eq[i][0] == 3 || eq[i][0] == 1 ) curr ++;
    }

    for( int i = 0; i < lox.size(); ++i ){
        curr += cnt[i][2];
        curr -= cnt[i][3];
        curr -= cnt[i][1];

        if( sol < curr )
            sol = curr , val = lox[i];

        curr += cnt[i][0];
        curr += cnt[i][3];
        curr -= cnt[i][2];
    }

    cout<< sol << " " << val << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <math.h>
using namespace std;

typedef long long ll;

const int maxn = 100000 + 55;

int n;
ll eq[maxn][2];

int cnt[maxn][4];

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        cin >> eq[i][0] >> eq[i][1];
    }

    int sol = 0 , val = 0;
    for( int i = 0; i <= 1000; ++i ){
        int cnt = 0;
        for( int j = 0; j < n; ++j ){
            int t = eq[j][0], v = eq[j][1];
            if( t == 1 && i > v ) cnt ++;
            if( t == 2 && i < v ) cnt ++;
            if( t == 3 && i == v ) cnt ++;
            if( t == 4 && i != v )  cnt ++;
        }

        if( cnt > sol ){
            sol = cnt;
            val = i;
        }
    }

    cout << sol << " "<<val<<endl;



    return 0;
}

#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <algorithm>
#include <string.h>
#include <string>
#include <map>
#include <iomanip>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

const int maxn = 1005;


int n,m;

bool implies[4005][4005];
vector< int > g[4005];

int target;

void bfs( int now ){
    implies[target][now] = 1;
    queue< int > q;
    q.push( now );

    while( !q.empty() ){
        int u = q.front(); q.pop();
        for( int i = 0; i < g[u].size(); ++i ){
            if( implies[now][ g[u][i] ] == 0 ){
                implies[now][ g[u][i] ] = 1;
                q.push( g[u][i] );
            }
        }
    }
}

inline void readi( int &v ){
    static char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
}

inline void imply( int a, int b ){ g[a].push_back(b); }

int rule[maxn][3];
vector< pii > bools;

int h[maxn][maxn];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);


    m = 0;
    for( int i = 0; i < n; ++i ){
        int a,b,c; readi(a),readi(b),readi(c); b--;
        bools.push_back( mk(i,a) );
        bools.push_back( mk(b,c) );
        rule[i][0] = a, rule[i][1] = b, rule[i][2] = c;
    }

    sort( bools.begin(), bools.end() );
    bools.erase( unique(bools.begin(),bools.end()), bools.end() );
    int sz = bools.size();

    for( int i = 0; i < sz; ++i ){
        h[ bools[i].f ][ bools[i].s ] = i;
        for( int j = 0; j < sz; ++j )
            if( i != j && bools[i].s == bools[j].s )
                imply( i*2, j*2+1 );
    }

    for( int i = 0; i < n; ++i ){
        int a = rule[i][0];
        int b = rule[i][1];
        int c = rule[i][2];

        int x = h[i][a];
        int y = h[b][c];


        // we asume that ith = 1
        imply( x*2, y*2+1 );
        imply( y*2+1, x*2 );

        // we asume 2
        imply( y*2, x*2+1 );
        imply( x*2+1, y*2 );

        for( int k = 0; k < sz; ++k ){
            if( bools[k].f != i || bools[k].s == a ) continue;
            imply( x*2, k*2+1 );
        }
    }

    for( int i = 0; i < sz*2; i += 2 ){
        target = i;
        bfs( i );
    }

    for( int i = 0; i < n; ++i ){
        int a = rule[i][0];
        int b = rule[i][1];
        int c = rule[i][2];

        int x = h[i][a];
        bool ok = 1;

        for( int i = 0; i < sz; ++i )
            if( implies[x*2][i*2] && implies[x*2][i*2+1] ) ok = 0;

        if( ok ) printf("1 ");
        else printf("2 ");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <algorithm>
#include <string.h>
#include <string>
#include <map>
#include <iomanip>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

const int maxn = 1005;


int n,m;

bool implies[4005][4005];
vector< int > g[4005];

int target;

void bfs( int now ){
    implies[target][now] = 1;
    queue< int > q;
    q.push( now );

    while( !q.empty() ){
        int u = q.front(); q.pop();
        for( int i = 0; i < g[u].size(); ++i ){
            if( implies[now][ g[u][i] ] == 0 ){
                implies[now][ g[u][i] ] = 1;
                q.push( g[u][i] );
            }
        }
    }
}

inline void readi( int &v ){
    static char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' ) v = v * 10 + c - '0';
}

inline void imply( int a, int b ){ g[a].push_back(b); }

int rule[maxn][3];
vector< pii > bools;

int h[maxn][maxn];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);


    m = 0;
    for( int i = 0; i < n; ++i ){
        int a,b,c; readi(a),readi(b),readi(c); b--;
        bools.push_back( mk(i,a) );
        bools.push_back( mk(b,c) );
        rule[i][0] = a, rule[i][1] = b, rule[i][2] = c;
    }

    sort( bools.begin(), bools.end() );
    bools.erase( unique(bools.begin(),bools.end()), bools.end() );
    int sz = bools.size();

    for( int i = 0; i < sz; ++i ){
        h[ bools[i].f ][ bools[i].s ] = i;
        for( int j = 0; j < sz; ++j )
            if( i != j && bools[i].s == bools[j].s )
                imply( i*2, j*2+1 );
    }

    for( int i = 0; i < n; ++i ){
        int a = rule[i][0];
        int b = rule[i][1];
        int c = rule[i][2];

        int x = h[i][a];
        int y = h[b][c];


        // we asume that ith = 1
        imply( x*2, y*2+1 );
        imply( y*2+1, x*2 );

        // we asume 2
        imply( y*2, x*2+1 );
        imply( x*2+1, y*2 );

        for( int k = 0; k < sz; ++k ){
            if( bools[k].f != i || bools[k].s == a ) continue;
            imply( x*2, k*2+1 );
        }
    }

    for( int i = 0; i < sz*2; i += 2 ){
        target = i;
        bfs( i );
    }

    for( int i = 0; i < n; ++i ){
        int a = rule[i][0];
        int b = rule[i][1];
        int c = rule[i][2];

        int x = h[i][a];
        bool ok = 1;

        for( int i = 0; i < sz; ++i )
            if( implies[x*2][i*2] && implies[x*2][i*2+1] ) ok = 0;

        if( ok ) printf("1 ");
        else printf("2 ");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
#include <math.h>
#include <string.h>
#include <string>
using namespace std;

int n,m;
char txt[305];

int hold[26];
int nxt[305][26];

short last[1<<20];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d%s",&n,&txt);
    m = strlen(txt);

    if( n >= 20 ){
        printf("NO\n");
        return 0;
    }

    for( int i = 0; i < m; ++i ) txt[i] -= 'a';

    memset( hold, -1, sizeof(hold));
    for( int i = m-1; i >= 0; --i ){
        for( int j = 0; j < 26; ++j ) nxt[i][j] = hold[j];
        hold[ txt[i] ] = i;
    }

    memset( last,-1, sizeof(last));


    for( int i = 1; i < (1<<n); ++i ){
        int nx = -1;

        for( int j = 0; j < n; ++j ){
            if( ~i&(1<<j) ) continue;
            int nw = i - (1<<j);

            int *arr = hold;
            if( nw != 0  ){
                if( last[nw] == -1 ){ nx = -1; break; }
                arr = nxt[ last[nw] ];
            }

            if( arr[j] == -1 ){ nx = -1; break; }
            nx = max( nx , arr[ j ] );
        }
        last[i] = nx;
    }

    if( last[(1<<n)-1] == -1 ) printf("NO\n");
    else printf("YES\n");


    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <string.h>
using namespace std;

struct domino{
    int x,y,id;
    domino(){};
    domino( int p1, int p2, int p3 ):x(p1),y(p2),id(p3){};
};

int n;
vector< domino > f,s,u;

bool byx( domino a, domino b ){
    return a.x < b.x || ( a.x == b.x && a.y > b.y );
}

bool byy( domino a, domino b ){
    return a.y > b.y || ( a.y == b.y && a.x < b.x );
}

bool used[100000 + 55];
int sx[100000 + 55];
int sy[100000 + 55];

int main(){
 //   freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);

        int t1 = a, t2 = b;
        a = min(t1,t2), b = max(t1,t2);

        f.push_back( domino(a,b,i) );
        s.push_back( domino(a,b,i) );
    }

    sort( f.begin(), f.end() , byx );
    sort( s.begin(), s.end() , byy );

   // for( int i = 0; i < n; ++i )
  //      cout<<s[i].x<<" "<<s[i].y<<endl;

    int b=0,e=n-1;
    int i = 0, j = 0;
    while( i < n && !used[ f[i].id ] || j < n && !used[ s[j].id ] ){

        if( b == 0   || sy[b-1]>= f[i].y ){
            sx[b] = f[i].x;
            sy[b] = f[i].y;
            b++;
            used[ f[i].id ] = 1;
        }else if( e == n-1 || sy[e+1] <= s[j].x ){
            sx[e] = s[j].y;
            sy[e] = s[j].x;
            e--;
            used[ s[j].id ] = 1;
        }else break;

        while( i < n && used[ f[i].id ] ) i ++;
        while( j < n && used[ s[j].id ] ) j ++;
    }

    bool NO = i < n || j < n;
    for( int i = 1; i < n; ++i ){
        if( sx[i] < sx[i-1] ) NO = 1;
        if( sy[i] > sy[i-1] ) NO = 1;
    }

    if( NO ){
        printf("NO\n");
        return 0;
    }

    printf("YES\n");


    for( int i = 0; i < n; ++i )
        printf("%d %d\n", sx[i], sy[i] );

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <math.h>
#include <iomanip>
#include <set>
#include <queue>
#include <map>
#include <string.h>
using namespace std;

const int mod = 1000000007;
const int maxm = 16*16*16*16*16*16;

typedef long long ll;

int n,m;
int c[16];
int cnt[6];

int dp[55000][6];
int valid[maxm];

int pre(){
    for( int i = 0; i < 6; ++i ) dp[valid[0]][i] = 1;

    for( int mask = 1; mask < maxm; ++mask ){
        if( !valid[mask] ) continue;
        for( int last = 0; last < 6; ++last ){
            int mins = 1, ms = mask;
            int &sol = dp[valid[mask]][last];

            for( int i = 1; i <= 6; ++i ){
                int c = ms&15;
                if( last == i ) c --;


                if( c > 0 )sol = ( sol + c*(ll)dp[  valid[mask - mins + (mins>>4)] ][i-1] ) % mod;
                ms >>= 4;
                mins <<= 4;
            }
        }
    }
}

int main(){
    int tests;

    int dx = 1;
    for( int x = 15; x >= 0; --x )
        for( int a = x; a >= 0; --a )
            for( int b = x-a; b >= 0; --b )
                for( int c = x-a-b; c >= 0; --c )
                    for( int d = x-a-b-c; d >= 0; --d )
                        for( int e = x-a-b-c-d; e >= 0; --e ){
                            int f = x -a-b-c-d-e;
                            int mask = a + b*(1<<4) + c*(1<<8) + d*(1<<12) + e*(1<<16) + f*(1<<20);
                            valid[mask] = dx++;
                        }

    scanf("%d",&tests);
    pre();

    while( tests -- ){
        cnt[1] = cnt[2] = cnt[3] = cnt[4] = cnt[5] = cnt[6] = 0;

        m = 0;
        int start = 0, stp16 = 1;
        scanf("%d",&n);
        for( int i = 0 ; i < n; ++i ){
            scanf("%d",&c[i]);
            m+=c[i];
            cnt[ c[i] ]++;
        }

        for( int i = 1; i <= 6; ++i ){
            start += cnt[i] * stp16;
            stp16 *= 16;
        }

        int sol = dp[valid[start]][0];
        printf("%d\n",sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
using namespace std;

const int maxv = 1000000 + 5;
int cnt[maxv];

vector< int > x[11];

int main(){
    for( int i = 2; i < maxv; ++i ){
        if( cnt[i] ) continue;
        cnt[i] = 1;
        for( int j = i+i; j < maxv; j += i ) cnt[j] ++;
    }

    for( int i = 1; i < maxv; ++i )
        x[ cnt[i] ].push_back( i );

    int tests; scanf("%d",&tests);
    while( tests -- ){
        int a,b,n; scanf("%d%d%d",&a,&b,&n);
        int sol = upper_bound( x[n].begin(), x[n].end() , b ) - lower_bound( x[n].begin(), x[n].end() , a );
        printf("%d\n",sol);
    }

    return 0;
}

#include <cstdio>

typedef long long ll;

const int maxn = 1000000 + 55;

int n;
ll a[maxn];
int main(){
    int tests; scanf("%d",&tests);
    for( ; tests; --tests ){

        ll sol = 0;
        scanf("%d",&n);
        for( int i = 0; i < n; ++i ){
            scanf("%lld",&a[i]);
            sol += (1+i)*a[i];
        }

        for( ll i = n-1, s = a[n-1]; i >= 1; --i, s += a[i] )
            if( s < 0 ) sol += -(i-1)*s, s = 0;
        printf("%lld\n",sol);
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <map>
#include <iostream>
#include <queue>
#include <math.h>
#include <cstdio>
#include <algorithm>
using namespace std;

#define pii pair<int,int>
#define mk make_pair
#define f first
#define s second

typedef long long ll;

const int maxn = 50000+55;

int n;
vector< pii > p;
vector< int > xs;

int bit[maxn];

inline void update( int x, int v ){
    for( x += 2; x < maxn; x += x & -x )
        bit[x] += v;
}

inline int read( int x ){
    int ret = 0;
    for( x += 2; x >= 1; x -= x & -x )
        ret += bit[x];
    return ret;
}

inline int read( int x, int y ){
    return read( y ) - read( x - 1 );
}

int q[maxn], sz;
int loleft[maxn],loright[maxn];
int hileft[maxn],hiright[maxn];

int hl[maxn],hr[maxn];
int vu[maxn],vd[maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d",&n);

        for( int i = 0; i < maxn; ++i ){
            loleft[i] = loright[i] = 0;
            hileft[i] = hiright[i] = 0;
            hl[i] = hr[i] = 0;
            vu[i] = vd[i] = 0;
            bit[i] = 0;
        }


        vector< int > lox,loy;
        p.clear();
        xs.clear();

        for( int i = 0; i < n; ++i ){
            int a,b; scanf("%d%d",&a,&b);
            p.push_back( mk(a,b) );
            lox.push_back(a);
            loy.push_back(b);
        }

        sort( lox.begin(), lox.end() );
        lox.erase( unique(lox.begin(),lox.end()),lox.end());

        sort( loy.begin(), loy.end() );
        loy.erase( unique(loy.begin(),loy.end()),loy.end());

        for( int i = 0; i < n; ++i ){
            p[i].f = lower_bound( lox.begin(), lox.end(), p[i].f ) - lox.begin();
            p[i].s = lower_bound( loy.begin(), loy.end(), p[i].s ) - loy.begin();
            xs.push_back( p[i].f );
        }

        sort( xs.begin(), xs.end() );
        sort( p.begin() , p.end() );

        int j = 0;
        for( int i = 0; i < n; ++i ){
            sz = 0;
            while( j < n && p[j].f == xs[i] ){
                update( p[j].s , 1 );
                vd[ j ] = sz;
                q[ sz ++ ] = j;
                j++;
            }

            for( int k = 0; k < sz; ++k ){
                int y = q[k];
                hl[y] = read( p[y].s, p[y].s ) - 1;
                loleft[ y ] = read( p[y].s ) - 1;
                hileft[ y ] = read( p[y].s , 50000 ) - 1;
            }
        }

        memset( bit, 0, sizeof(bit));

        j = n-1;
        for( int i = n-1; i >= 0; --i ){
            sz = 0;
            while( j >= 0 && p[j].f == xs[i] ){
                update( p[j].s , 1 );
                vu[ j ] = sz;
                q[ sz ++ ] = j;
                j--;
            }

            for( int k = 0; k < sz; ++k ){
                int y = q[k];
                hr[y] = read( p[y].s, p[y].s ) - 1;
                loright[ y ] = read( p[y].s ) - 1;
                hiright[ y ] = read( p[y].s , 50000 ) - 1;
            }
        }

        ll sol = 0;
        for( int i = 0; i < n; ++i ){
            sol += loleft[i] * (ll)hiright[i];
            sol += hileft[i] * (ll)loright[i];

            sol -= hl[i] * (ll)hr[i];
            sol -= vu[i] * (ll)vd[i];
        }

        printf("%lld\n",sol*2);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <map>
#include <iostream>
#include <queue>
#include <math.h>
#include <cstdio>
using namespace std;

int n;
int x[1000],y[1000];

int dst( int i, int j ){
    return abs(x[i]-x[j]) + abs(y[i]-y[j]);
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);
    for( ; tests; --tests ){
        scanf("%d",&n);
        for( int i = 0; i < n; ++i ) scanf("%d%d",&x[i],&y[i]);

        int sol = 0;
        for( int i = 0; i < n; ++i )
            for( int j = 0; j < n; ++j )
                for( int k = 0; k < n; ++k )
                    if( dst(i,j) + dst(j,k) == dst(i,k) && i != j && j != k && i != k ) sol ++;
        cout<<sol/2<<endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <cstdio>
#include <algorithm>
#include <string.h>
using namespace std;

typedef long long ll;

const int mod = 100000007;

int n;
char tmp[100];

int hash[255];
int cnt[30][30];

int dp[2][1<<21];
int e[22][1<<21];
int ss[22];

int main(){
    int g = 1<<21;
    for( int i = 0; i < g; ++i ){
        int x =  __builtin_popcount(i);
        e[x][ ss[x] ++ ] = i;
    }

    //freopen("Ulaz.txt","r",stdin);
    for( int i = 'a', j = 0; i <= 'z'; ++i ){
        if( i != 'a' && i != 'e' && i != 'i' && i != 'o' && i != 'u' ) hash[i] = j++;
    }

    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        scanf("%s",tmp); int len = strlen(tmp) - 1;
        if( tmp[0] >= 'A'   ) tmp[0] = 'a' + (tmp[0]-'A');
        if( tmp[len] >= 'A' ) tmp[len] = 'a' + (tmp[len]-'A');

        int a  = hash[ tmp[0] ], b = hash[ tmp[ len ] ];
        cnt[a][b] ++;
    }

    dp[0][0] = 1;

    bool flip = 1;
    for( int i = 1; i <= 21; ++i ){
        for( int j = 0; j < ss[i]; ++j ){
            int m = e[i][j];
            dp[flip][m] = 0;

            for( int k = 0; k < 21; ++k )
                if( m & (1<<k) ) dp[flip][m] = ( dp[flip][m] + cnt[i-1][k] * (ll)dp[!flip][m-(1<<k)] ) % mod;
        }
        flip = !flip;
    }

    printf("%d\n",dp[!flip][(1<<21)-1]);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
#include <vector>
#include <queue>
#include <algorithm>
#include <cstdlib>
using namespace std;

char c;
int n,m;

char num[100000];
int dig[100000];
int sz = 0,md;

const int x = 1 << 20;

inline void divx(){
    int tmp = 0; md = 0;
    for( int i = sz-1; i >= 0; --i ){
        tmp = tmp * 10 + dig[i];
        dig[i] = tmp / x;
        tmp %= x;
        md = (md*10+dig[i])%x;
    }
    while( sz && dig[sz-1] == 0 ) sz --;
}

inline void take(){
    dig[0] --;
    int i = 0;
    while( dig[i] == -1 && i < sz )
        dig[i] = 9, dig[++i]--;

    while( sz && dig[sz-1] == 0 ) sz --;
}

int cnt[1<<20];

int main(){
    for( int i = 0; i < x; ++i ) cnt[i] = __builtin_popcount(i);
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);
    for( ; tests; --tests ){
        while( c = getchar() ) if( c == 'a' || c == 'b' ) break; c -= 'a';
        scanf("%d%s",&n,num); sz = strlen(num);

        for( int i = 0; i < sz; ++i ) dig[i] = num[i]-'0';
        reverse( dig , dig + sz );

        take();

        int w = 0;
        md = 0;
        for( int i = sz-1; i >= 0; --i ) md = (md*10+dig[i])%x;

        while( sz ){
            w += cnt[md];
            divx();
        }

        printf("%c",((c+w)%2)+'a');
        if( tests > 1 ) printf("\n");
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
#include <vector>
#include <queue>
#include <algorithm>
#include <cstdlib>
using namespace std;

char c;
unsigned int n,m;

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
    int tests; scanf("%d",&tests);
    for( ; tests; --tests ){
        while( c = getchar() ) if( c == 'a' || c == 'b' ) break;
        scanf("%u%u",&n,&m);

        int x = __builtin_popcount(m-1);
        printf("%c",'a'+((c-'a')+x)%2);
        if( tests > 1 ) printf("\n");
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <string.h>
#include <string>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

int d[][2] = { {0,1} , {-1,0} , {0,-1}, {1,0} };
char txt[1000000];

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests; scanf("%d",&tests);
    for( ; tests; --tests ){
        scanf("%s",txt);

        int r = 0, c = 0;
        vector< pii > v;


        int len = strlen(txt);
        for( int i = 0; i < len; ++i ){
            int x = txt[i] - '0';
            r += d[x][0];
            c += d[x][1];
            v.push_back( mk(r,c) );
        }

        int m = v.size();
        sort( v.begin(), v.end() );
        v.erase( unique(v.begin(),v.end()),v.end() );

        if( m != v.size() || r != 0 || c != 0 ) printf("NO");
        else printf("YES");

        if( tests > 1 ) printf("\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <string.h>
#include <math.h>
#include <string>
using namespace std;

const int maxn = 500;



// DivBy2(bool) // divides the bignum with 2 , true for flooring , false for ceiling
// operator +
// operator -
// operator *
// operator ==
// operator >
// operator <
// operator =
// sqrt()

class BigNum{   // BIG_NUM_CLASS
   public:
      vector<char>digits;
      BigNum(){}
      BigNum( int v ){while( v ) digits.push_back(v%10) , v/=10; }
      BigNum( const BigNum &z ){ digits = z.digits; }
      void operator*( int v );
      int mod( int v );
      void div( int x );
      BigNum operator+(const BigNum&);
      inline void WriteLn();
      void operator=(BigNum);
};

int BigNum::mod( int v ){
    int sz = digits.size();
    int ret = 0;
    for( int i = sz-1; i >= 0; --i )ret = ( ret * 10 + digits[i] ) % v;
    return ret;
}

void BigNum::div( int x ){
    int tmp = 0;
    for( int i = (int)digits.size()-1; i >= 0; --i ){
        tmp = tmp * 10 + digits[i];
        digits[i] = tmp / x;
        tmp %= x;
    }
    int sz = digits.size();
    while( sz && digits[sz-1] == 0 ) digits.pop_back(), sz --;
}


void BigNum::operator=(BigNum b2 ){
   digits.clear();
   digits=b2.digits;
}

void BigNum::operator*( int v ){
    int tmp = 0, sz = digits.size();
    for( int i = 0; i < sz; ++i ){
        tmp = digits[i]*v + tmp;
        digits[i] = tmp % 10;
        tmp /= 10;
    }

    while( tmp ){
        digits.push_back(tmp%10);
        tmp /= 10;
    }
}

BigNum BigNum::operator+( const BigNum &b2 ){
   BigNum A = *this , B = b2;
   if( A.digits.size() < B.digits.size() )swap(A,B);
   BigNum sum = B;
   int tmp = 0;
   for( int i = 0; i < B.digits.size(); ++i ){
      int ss = B.digits[i] + A.digits[i] + tmp;
      sum.digits[i] = ss%10;
      tmp = ss / 10;
   }
   for( int i = B.digits.size(); i < A.digits.size(); ++i ){
      int ss = A.digits[i] + tmp;
      sum.digits.push_back( ss % 10 );
      tmp = ss/10;
   }
   while( tmp ){
      sum.digits.push_back( tmp % 10 );
      tmp /= 10;
   }
   return sum;
}

inline void BigNum::WriteLn(){
   if( digits.size() == 0 )printf("0");
   for( int i = digits.size()-1; i >=0; --i )
      printf("%d",digits[i]);
}



int n;
int hi[maxn];
int lo[maxn];
int d[maxn];

int hs[maxn][maxn];

void add( int v, int *arr, int inc = 1 ){
    for( int i = 2; i <= v; ++i ) arr[i] += inc;

    for( int i = maxn-1; i >= 2; --i ){
        if( arr[i] == 0 || i == d[i] ) continue;
        int x = d[i], y = i / d[i];
        arr[x] += arr[i];
        arr[y] += arr[i];
        arr[i] = 0;
    }
}

bool contains( int v ){
    int sum = 0;
    for( int i = 0; i <= n; ++i ){
        int x = 1;
        for( int k = 2; k <= n; ++k ){
            int t = hs[i][k];
            while( t -- ) x = (x*k)%v;
        }
        sum = ( sum + x ) % v;
    }
    return sum == 0;
}

int common[maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    for( int i = 2; i <= maxn; ++i )
        for( int j = 2; j <= i; ++j )
            if( i % j == 0 ){ d[i] = j; break; }

    int tests; scanf("%d",&tests);
    for( ; tests; --tests ){
        scanf("%d",&n);

        memset( lo, 0, sizeof(lo));
        memset( hs, 0 , sizeof(hs));
        memset( common, 0, sizeof(common));

        add( n , lo );
        for( int i = 0; i <= n; ++i ){
            add( i , hs[i]  );
            add( n-i, hs[i] );
        }

        for( int i = 2; i <= n; ++i ){
            int x = 99999;
            for( int j = 0; j <= n; ++j )
                x = min( x , hs[j][i] );
            common[i] = x;
            if( common[i] ) lo[i] -= common[i];

            for( int j = 0; j <= n; ++j )
                hs[j][i] -= x;
        }
        add( 0 , lo , 0 );

        BigNum sol = 0, x;

        for( int i = 0; i <= n; ++i ){
            x = 1;
            for( int j = 2; j <= n; ++j ){
                int t = hs[i][j];
                while( t -- ) x  * j;
            }
            sol = sol + x;
        }

        BigNum dole = 1;
        for( int i = 2; i <= n; ++i ){
            if( lo[i] == 0 ) continue;
            while( lo[i] && sol.mod(i) == 0 ) lo[i] -- , sol.div(i);
            while( lo[i] -- ) dole * i;
        }

        int sz = dole.digits.size();
        if( sz > 1 || (sz == 1 && dole.digits[0] != 1) ){
            sol.WriteLn();printf("/");
            dole.WriteLn();
        }else sol.WriteLn();
        printf("\n");
    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <set>
#include <map>
#include <cstdio>
using namespace std;

#define pii pair<int,int>
#define x first
#define y second
#define mk make_pair

typedef long long ll;

const int maxn = 100000 + 55;
const int inf = 60000 + 55;


int n,m;
pii p[maxn];
int pivot;

vector< pii > inc, decr;

bool comp( pii p1, pii p2 ){
    int a = p1.x;
    int b = p2.x;
    return p[a].y < p[b].y || ( p[a].y == p[b].y && p[a].x < p[b].x );
}

pii q[4];

double dst( pii a, pii b ){
    return sqrt( (a.x-b.x)*(ll)(a.x-b.x) + (a.y-b.y)*(ll)(a.y-b.y) );
}
double heron( double a, double b, double c ){
    double s =(a+b+c)/2;
    return sqrt( s*(s-a) ) * sqrt((s-b)*(s-c));
}

double area2( pii a, pii b, pii c ){
    return heron( dst(a,b), dst(b,c) , dst(c,a) );
}

double area( pii a, pii b, pii c ){
    return fabs(0.5 * (double)( a.x*(ll)b.y - b.x*(ll)a.y  + b.x*(ll)c.y - c.x*(ll)b.y + c.x*(ll)a.y - a.x*(ll)c.y ));
}

const double eps = 0.000000001;

pii h = mk(20499,5516);

int main(){
    freopen("bradonja.in","r",stdin); freopen("bradonja.out","w",stdout);
   // freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    scanf("%d%d",&n,&m);
    pivot = 0;
    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        p[i] = mk(a,b);
       // if( b < h.y ) cout<<i<<" ";
        if( p[i] < p[pivot] ) pivot = i;
    }//cout<<endl;
    //cout<<"PIVOT: "<<p[pivot].x<<" "<<p[pivot].y<<" [ "<<pivot<<" ] "<<endl;

    int it = pivot;
    while( p[it].x <= p[(it-1+n)%n].x ){
        int nxt = (it-1+n)%n;
        //cout<<p[it].x<<" "<<p[it].y<<endl;

        if( p[it].y < p[nxt].y ) inc.push_back( mk(it,nxt) );
        else if( p[it].y > p[nxt].y ) decr.push_back( mk(nxt,it) );

        it = nxt;
    }

    it = pivot;
    while( p[it].x < p[(it+1)%n].x ){
        int nxt = (it+1)%n;
       // cout<<p[it].x<<" "<<p[it].y<<endl;

        if( p[it].y > p[nxt].y ) inc.push_back( mk(nxt,it) );
        else if( p[it].y < p[nxt].y ) decr.push_back( mk(it,nxt) );

        it = nxt;
    }

    sort( inc.begin(), inc.end() , comp );
    sort( decr.begin(), decr.end() , comp );


    for( int i = 0; i < m; ++i ){
        int x,y; scanf("%d%d",&x,&y);
        //cout<<x<<" "<<y<<endl;
        p[n] = mk(x,y);
        vector< pii > :: iterator it = lower_bound( inc.begin(), inc.end(), mk(n,n), comp );

        if( it == inc.begin() ){
            printf("0\n");
            continue;
        }else if( it == inc.end() || it->y > y ) it --;


        q[0] = p[ it->x ];
        q[1] = p[ it->y ];

        it = lower_bound( decr.begin(), decr.end(), mk(n,n), comp );

        if( it == inc.begin() ){
            printf("0\n");
            continue;
        }else if( it == decr.end() || it->y > y ) it --;

        q[2] = p[ it->x ];
        q[3] = p[ it->y ];

        double A = area( q[1] , q[2], q[3] ) + area( q[2], q[0], q[1] );

        double a = area( p[n], q[0], q[1] );
        a += area( p[n] , q[2],q[3] );
        a += area( p[n] , q[1],q[3] );
        a += area( p[n] , q[0],q[2] );


        if( fabs(a-A) < eps ) printf("1\n");
        else printf("0\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <set>
#include <map>
#include <cstdio>
using namespace std;

#define pii pair<int,int>
#define x first
#define y second
#define mk make_pair

typedef long long ll;

const int maxn = 100000 + 55;
const int inf = 60000 + 55;
const double eps = 0.000000001;


int n,m;
double xa,ya;
int xd,yd;

inline double area( double a , double b, double c ){
    double s = (a+b+c)/2;
    return sqrt( s*(s-a)*(s-b)*(s-c) );
}


pii p[maxn*7];
pii x;

double area( pii a, pii b, pii c ){
    return fabs(0.5 * ( a.x*b.y - b.x*a.y  + b.x*c.y - c.x*b.y + c.x*a.y - a.y*c.y ));
}

double dst( pii a, pii b ){
    return sqrt( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) );
}
double heron( double a, double b, double c ){
    double s =(a+b+c)/2;
    return sqrt( s*(s-a)*(s-b)*(s-c) );
}

double area2( pii a, pii b, pii c ){
    return heron( dst(a,b), dst(b,c) , dst(c,a) );
}

int main(){
    freopen("bradonja.in","r",stdin);
    freopen("bradonja.out","w",stdout);
    scanf("%d%d",&n,&m);

    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        p[i] = mk(a,b);
    }

    double A = 0;

    for( int i = 0; i < n; ++i )
        A += area2( p[0], p[i], p[(i+1)%n] );


    for( int i = 0; i < m; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        x = mk(a,b);

        double ax = 0;
        for( int i = 0; i < n; ++i )
            ax += area2( x, p[i], p[(i+1)%n] );
        if( fabs(A-ax) < eps ) printf("1\n");
        else printf("0\n");
    }


    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
#include <string.h>
#include <string>
#include <math.h>
#include <stack>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 5000 + 55;

int n;
int v[maxn];
bool ok[maxn];

int main(){
  //  freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ) scanf("%d",&v[i]);

    int sol = 0;
    for( int i = 1; i < n; ++i ){
        if( ok[i] ) continue;
        int d = v[i] - 1;
        sol ++;
        for( int k = i+1; k < n; ++k )
            if( (v[k]-1) % d == 0 ) ok[k] = 1;
    }
    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <cstdio>
#include <stack>
#include <string.h>
#include <string>
#include <map>
#include <iomanip>
#include <fstream>
using namespace std;

char a[105],b[105];

int main(){
    scanf("%s",a);
    scanf("%s",b);

    for( int i = 0; i < strlen(a); ++i ){
        if( a[i] != b[i] ) printf("1");
        else printf("0");
    }
    printf("\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <cstdio>
#include <stack>
#include <string.h>
#include <string>
#include <map>
#include <iomanip>
#include <fstream>
using namespace std;

string clear( string x ){
    string ret = "";
    for( int i = 0; i < x.size(); ++i ){
        if( x[i] >= 'a' && x[i] <= 'z' ) ret += string(1,x[i]);
        if( x[i] >= 'A' && x[i] <= 'Z' ) ret += string(1,x[i]-'A'+'a');
    }
    return ret;
}

string s[3];

int main(){
  //  freopen("Ulaz.txt","r",stdin);
    cin >> s[0] >> s[1] >> s[2];
    s[0] = clear(s[0]);
    s[1] = clear(s[1]);
    s[2] = clear(s[2]);

    int m; scanf("%d",&m);
    for( int i = 0; i < m; ++i ){
        string w; cin >> w;
        w = clear(w);

        bool ok = 0;
        sort( s , s + 3 );
        do{
            if( s[0] + s[1] + s[2] == w ) ok = 1;
        }while( next_permutation(s,s+3) );

        if( ok ) printf("ACC\n");
        else printf("WA\n");
    }


    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <cstdio>
#include <stack>
#include <string.h>
#include <string>
#include <map>
#include <iomanip>
#include <fstream>
using namespace std;

typedef long long ll;

ll a,b,c;

string w[] = { "I" , "IV" , "V" , "IX" , "X" , "XL" , "L" , "XC" , "C" , "CD" , "D" , "CM" , "M" };
int    v[] = { 1   ,   4  ,  5  ,   9  ,  10 ,  40  , 50  ,  90  , 100 ,  400 , 500 ,  900 , 1000 , 9999 };


string rim( ll n ){
    string ret = "";
    while( n ){
        int i = 0;
        for( ; v[i+1] <= n; ++i );

        ret += w[i];
        n -= v[i];
    }
    return ret;
}

ll digit( char a ){
    if( a >= '0' && a <= '9' ) return a - '0';
    else return a - 'A' + 10;
}

char rev( int a ){
    if( a <= 9 ) return '0' + a;
    else return 'A' + (a - 10);
}

char basea[1000 + 55];

int main(){
    cin >> a;

    char c;
    while( c=getchar() ) if( c >= '0' && c <= '9' || c == 'R' ) break;

    b = c - '0';

    if( c != 'R' ) while( (c=getchar())>='0' && c <='9') b = b * 10 + c - '0';


    scanf("%s",basea);


    int len = strlen(basea);
    ll dec = 0;
    ll stp = 1;

    for( int i = len-1; i >= 0; --i ){
        dec += digit( basea[i] ) * stp;
        stp *= a;
    }


    if( b == 34 ) cout << rim( dec ) <<endl;
    else{
        string sol = "";
        while( dec ){
            sol += string(1,rev( dec % b ) );
            dec /= b;
        }
        reverse( sol.begin(),sol.end() );
        if( sol.size() == 0 ) printf("0\n");
        else cout<<sol<<endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <cstdio>
#include <stack>
#include <string.h>
#include <string>
#include <map>
#include <iomanip>
#include <fstream>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

const int maxn = 100050;
ll inf = 1000000000000000000LL;

int n;
vector< pii > g[maxn];

ll dfs( int node, int dad ){
    ll ret = 0;
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i].f;
        if( nxt == dad ) continue;
        ret = max( ret , dfs( nxt , node ) + g[node][i].s );
    }

    return ret;
}

int main(){
    scanf("%d",&n);

    ll sol = 0;

    for( int i = 0; i < n-1; ++i ){
        int a,b,c; scanf("%d%d%d",&a,&b,&c); a--,b--;
        g[a].push_back( mk(b,c) );
        g[b].push_back( mk(a,c) );
        sol += 2*c;
    }

    printf("%I64d\n",sol - dfs( 0 ,  -1 ) );

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <cstdio>
#include <stack>
#include <string.h>
#include <string>
#include <map>
#include <iomanip>
#include <fstream>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

const int maxn = 1000000 + 55;

int n;
int a[maxn];


void update( ll *bit, int dx, int v ){
    for( dx += 2; dx < maxn; dx += dx & -dx )
        bit[dx] += v;
}

ll read( ll *bit, int dx ){
    ll ret = 0;
    for( dx += 2; dx >= 1; dx -= dx & -dx )
        ret += bit[dx];
    return ret;
}

ll A[maxn];
ll B[maxn];
ll one[maxn];

int main(){
    scanf("%d",&n);

    vector< int > lox;

    for( int i = 0; i < n; ++i ){
        scanf("%d",&a[i]);
        lox.push_back(a[i]);
    }

    sort( lox.begin(), lox.end() );
    for( int i =0 ; i < n; ++i )
        a[i] = lower_bound( lox.begin(), lox.end() , a[i] ) - lox.begin();


    for( int i = 0; i < n; ++i ){
        ll x = read( A , maxn - 10 );
        x -= read( A , a[i] );

        one[i] = x;
        update( A, a[i], 1 );
    }


    ll sol = 0;
    for( int i =0 ; i < n; ++i ){
        ll x = read( B , maxn - 10 );
        x -= read( B , a[i] );

        sol += x;

        update( B, a[i], one[i] );
    }

    printf("%I64d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <math.h>
#include <set>
#include <algorithm>
#include <string>
#include <iomanip>
#include <queue>
#include <stack>
#include <iomanip>
#include <cstdio>
#include <cstdlib>
using namespace std;

int a[2];
int b[2];

int main(){
    scanf("%d%d",&a[0],&a[1]);
    scanf("%d%d",&b[0],&b[1]);

    if( (a[0]+1)*2 >= b[1] && a[0]-1 <= b[1] || (a[1]+1)*2 >= b[0] && a[1]-1 <= b[0] ) printf("YES\n");
    else printf("NO\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <math.h>
#include <set>
#include <algorithm>
#include <string>
#include <iomanip>
#include <queue>
#include <stack>
#include <iomanip>
#include <cstdio>
#include <cstdlib>
using namespace std;

const int maxm = 200000 + 55;

typedef long long ll;
const ll inf = 10000000000000LL;

int n,m;
char enter[maxm];
char txt[maxm];

int now[30];
int l[maxm][30];
int r[maxm][30];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);
    scanf("%s",enter);

    memset( now, -1, sizeof(now));
    for( int j = 0; j < maxm; ++j ){
        if( j < m ) now[ enter[j]-'a' ] = j;
        for( int k = 0; k < 30; ++k ) l[j][k] = now[k];
    }

    memset( now, -1, sizeof(now));
    for( int j = maxm; j >= 0; --j ){
        if( j < m ) now[ enter[j]-'a' ] = j;
        for( int k = 0; k < 30; ++k ) r[j][k] = now[k];
    }

    for( int i = 0; i < n; ++i ){
        scanf("%s",txt);
        int len = strlen(txt);

        ll sol = 0;

        for( int j = 0; j < len; ++j ){
            int lo = l[j][ txt[j]-'a' ];
            int hi = r[j][ txt[j]-'a' ];

            if( lo != -1 ) lo = abs(j - lo);
            if( hi != -1 ) hi = abs(hi - j);

            if( lo != -1 && hi != -1 ) sol += min( lo, hi );
            else if( lo != -1 ) sol += lo;
            else if( hi != -1 ) sol += hi;
            else sol += len;
        }
        printf("%I64d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <math.h>
#include <set>
#include <algorithm>
#include <string>
#include <iomanip>
#include <queue>
#include <stack>
#include <iomanip>
#include <cstdio>
#include <cstdlib>
using namespace std;

#define pii pair<int,int>
#define x first
#define y second
#define mk make_pair

typedef long long ll;

const int maxn = 105;
const double eps = 1e-9;

int n,m;
pii trokut[maxn][3];
pii lines[maxn*3][2];

double dst( pii a, pii b ){ return sqrt( (a.x-b.x)*(ll)(a.x-b.x) + (a.y-b.y)*(ll)(a.y-b.y) ); }
double dst( pii a, pair<double,double> b ){ return sqrt( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) ); }

double xs( int i, pii a, pii b ){
    ll a1 = lines[i][1].y - lines[i][0].y;
    ll b1 = lines[i][0].x - lines[i][1].x;
    ll c1 = a1*lines[i][0].x + b1*lines[i][0].y;

    ll a2 = b.y - a.y;
    ll b2 = a.x - b.x;
    ll c2 = a2*a.x + b2*a.y;

    ll det = a1*b2 - a2*b1;
    if( det == 0 ) return -1;

    double x = (b2*c1 - b1*c2) / (double)det;
    double y = (a1*c2 - a2*c1) / (double)det;

    if( x < min(lines[i][0].x,lines[i][1].x) || x > max(lines[i][0].x,lines[i][1].x ) ) return -1;
    if( y < min(lines[i][0].y,lines[i][1].y) || y > max(lines[i][0].y,lines[i][1].y ) ) return -1;

    if( x < min(a.x,b.x) || x > max(a.x,b.x) ) return -1;
    if( y < min(a.y,b.y) || y > max(a.y,b.y) ) return -1;

    return dst( lines[i][0] , mk(x,y)) / dst( lines[i][0] , lines[i][1] );
}

double area( pii a, pii b, pii c ){
    double s1 = dst( a, b );
    double s2 = dst( a, c );
    double s3 = dst( b, c );
    double s = (s1+s2+s3) / 2;

    return sqrt( s*(s-s1) ) * sqrt(s-s2) * sqrt(s-s3);
}

bool intri( int i, pii a ){
    double A = area( trokut[i][0], trokut[i][1], trokut[i][2] );
    double a1 = area( trokut[i][0], trokut[i][1], a );
    double a2 = area( trokut[i][0], trokut[i][2], a );
    double a3 = area( trokut[i][1], trokut[i][2], a );

    return fabs(A - (a1+a2+a3)) < 0.01;
}

vector< pair<double,double> > range;

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < 3; ++j ){
            int a,b; scanf("%d%d",&a,&b);
            trokut[i][j] = mk(a,b);

            for( int k = 0; k < j; ++k ) lines[m][0] = trokut[i][k], lines[m++][1] = trokut[i][j];
        }
    }

    double sol = 0;

    for( int i = 0; i < m; ++i ){
        range.clear();
        double x1 = lines[i][0].x, x2 = lines[i][1].x;

        for( int j = 0; j < n; ++j ){
            if( j*3 <= i && i < j*3+3 ) continue;

            double a = xs( i , trokut[j][0] , trokut[j][1] );
            double b = xs( i , trokut[j][1] , trokut[j][2] );
            double c = xs( i , trokut[j][0] , trokut[j][2] );


            if( a < 0 ) swap(a,c);
            if( a < 0 ) swap(a,b);
            if( b < 0 ) swap(b,c);

            double s=-1,e;
            int cnt = (a+eps >= 0) + (b+eps >= 0) + (c+eps >= 0);
            if( intri( j , lines[i][0] ) && intri( j , lines[i][1] ) ){
                s = 0, e = 1;
            }else if( cnt == 1 ){
                if( intri( j , lines[i][0] ) ) s = 0, e = a;
                else if( intri( j, lines[i][1] ) ) s = a, e = 1;
            }else if( cnt == 2 )
                s = min(a,b) , e = max(a,b);
            else if( cnt == 3 ) s = min(a,min(b,c)), e = max(a,max(b,c));

            if( s+eps >= 0 && e-s > eps ) range.push_back( mk(s,e) );
        }


        sort( range.begin(), range.end() );

        for( int j = 1; j < range.size(); ++j )
            if( range[j-1].y+eps >= range[j].x ){
                range[j-1].y = max( range[j-1].y, range[j].y );
                range.erase(range.begin()+j); j--;
            }

        double coef = 1;
        for( int j = 0; j < range.size(); ++j ) coef -= range[j].y - range[j].x;
        sol += coef * dst( lines[i][0], lines[i][1] );
    }

    printf("%.10lf\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <set>
#include <queue>
#include <algorithm>
#include <map>
#include <string.h>
#include <string>
#include <iomanip>
#include <math.h>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

#define sz(x) (int)x.size()

const int maxn = 105;
const int maxm = 2005;

int n,m;
vector< pii > e;
vector< int > g[maxn];

int order[maxm];
bool mat[maxn][maxn];


int up[maxn], lvl[maxn];
bool bridge[maxn][maxn];
bool visi[maxn];

void dfs( int node, int dad, int deep ){
    visi[node] = 1;
    up[node] = lvl[node] = deep;
    for( int i = 0; i < sz(g[node]); ++i ){
        int nxt = g[node][i];
        if( mat[node][nxt] == 0 || nxt == dad ) continue;

        if( visi[nxt] == false ){
            dfs( nxt , node, deep + 1 );
            up[node] = min( up[node], up[nxt] );

            if( up[nxt] > deep ) bridge[node][nxt] = bridge[nxt][node] = 1;
        }else up[node] = min( up[node], lvl[nxt] );
    }
}

void mark_bridges(){
    memset( bridge, 0, sizeof(bridge) );
    memset( visi, 0, sizeof(visi));
    for( int i = 0; i < n; ++i )
        if( visi[i] == false ) dfs( i , -1, 0 );
}

void add_edge( int a, int b ){
    e.push_back( mk(a,b) );
    mat[b][a] = mat[a][b] = 1;
    g[a].push_back(b);
    g[b].push_back(a);
}

void erase( int a, int b ){
    mat[a][b] = mat[b][a] = 0;
}
void add( int a, int b ){
    mat[a][b] = mat[b][a] = 1;
}

bool mem[105][maxn][maxn];

int path( int node ){
    mark_bridges();
    memcpy( mem[node], bridge, sizeof bridge );

    bool end = 1;

    cout<<node<<endl;

    for( int j = 0; j < sz(g[node]); ++j ){
        int nxt = g[node][j];
        if( mat[ node ][ nxt ] == 0 ) continue;
        if( mem[node][node][nxt] ) continue;

        erase( node , nxt );
        path( nxt );
        add( node , nxt );
    }

    for( int j = 0; j < sz(g[node]); ++j ){
        int nxt = g[node][j];
        if( mat[ node ][ nxt ] == 0 ) continue;
        if( !mem[node][node][nxt] ) continue;

        erase( node , nxt );
        path( nxt );
        add( node , nxt );
    }
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);

    for( int i = 0; i < m; ++i ){
        scanf("%d",&order[i] );
        order[i] --;
        if( i ) add_edge( order[i-1], order[i] );
    }

    for( int i = 1; i < m; ++i ){
        erase( order[i-1], order[i] );
        for( int j = order[i]+1; j < n; ++j )
            if( mat[ order[i-1] ][ j ] ){
                add( order[i-1], j );

                cout<<i<<" "<<j<<endl;
                path( j );

                erase( order[i-1], j );
            }
    }



    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <set>
#include <queue>
#include <algorithm>
#include <map>
#include <string.h>
#include <string>
#include <iomanip>
#include <math.h>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

#define sz(x) (int)x.size()

const int maxn = 105;
const int maxm = 2005;

int n,m;
vector< pii > e;
vector< int > g[maxn];

int order[maxm];
bool mat[maxn][maxn];

void add_edge( int a, int b ){
    e.push_back( mk(a,b) );
    g[a].push_back(b);
    g[b].push_back(a);
}


void on( int a, int b ){ mat[a][b] = mat[b][a] = 1; }
void off( int a, int b ){ mat[a][b] = mat[b][a] = 0; }

int degree[maxn];
bool visi[maxn];

bool ispath( int a, int b ){
    memset( visi,0,sizeof(visi));
    queue< int > q;
    q.push( a );
    visi[a] = 1;
    while(!q.empty()){
        int u = q.front(); q.pop();
        for( int i = 0; i < g[u].size(); ++i ){
            int nxt = g[u][i];
            if( visi[nxt] || mat[u][nxt] == 0 ) continue;
            visi[nxt] = 1;
            q.push(nxt);
        }
    }
    return visi[b];
}

bool iseuler( int a, int b ){
    memset(degree,0,sizeof(degree));
    for( int i = 0; i < e.size(); ++i )
        if( mat[ e[i].f ][ e[i].s ] )
            degree[ e[i].f ] ++, degree[ e[i].s ]++;

    if( a != b ) if( degree[a] % 2 == 0 || degree[b] % 2 == 0 ) return 0;


    bool ok = 1;
    if( a != b ) for( int i = 0; i < n; ++i ){ if( i != a && i != b && degree[i]%2 ) ok = 0; }
    else         for( int i = 0; i < n; ++i ){ if( degree[i]%2 ) ok = 0; }

    if( !ok || !ispath(a,b) ) return 0;


    for( int i = 0; i < e.size(); ++i ){
        if( mat[ e[i].f ][ e[i].s ] == 0 ) continue;
        if( visi[ e[i].f ] == 0 || visi[ e[i].s ] == 0 ) return 0;
    }

    return 1;
}


int main(){
    scanf("%d%d",&n,&m);

    for( int i = 0; i <= m; ++i ){
        scanf("%d",&order[i] );

        order[i] --;
        if( i ) add_edge(order[i],order[i-1]);
    }

    int x,y=-1;
    for( int i = m; i >= 1 && y == -1; --i ){
        on( order[i], order[i-1] );
        for( int k = order[i]+1; k < n && y == -1; ++k ){
            if( mat[order[i-1]][ k ] == false ) continue;
            off( order[i-1] , k );

            if( iseuler( k , order[0] ) ) x = i, y = k;

            on( order[i-1] , k );
        }
    }


    if( y == -1 ){
        printf("No solution\n");
        return 0;
    }
    order[x] = y;
    off( order[x-1] , y );
    for( int i = x+1; i <= m; ++i ){
        for( int j = 0; j < n; ++j ){
            if( mat[ order[i-1] ][ j ] == 0 ) continue;

            off( order[i-1] , j );
            if( iseuler( j , order[0] ) ){
                order[i] = j;
                break;
            }
            on( order[i-1], j );
        }
    }

    for( int i = 0; i <= m; ++i )
        printf("%d ",order[i]+1);
    printf("\n");

    return 0;
}

#pragma comment(linker, "/STACK:32000000")
#define _CRT_SECURE_NO_DEPRECATE


 #include "stdio.h"
 #include "math.h"
 #include "string.h"


 #include <algorithm>
 #include <set>
 #include <vector>
 #include <map>
 #include <queue>
 #include <stack>
 #include <string>
 #include <sstream>
 #include <iostream>


 using namespace std;


 #define pi 3.1415926535897932384626433832795
 #define ALL(x) x.begin(), x.end()
 #define LL long long
 #define MP make_pair
 #define PB push_back
 #define SZ(x) ((int)x.size())
 #define SQR(x) ((x) * (x))
 #define SS stringstream
 #define CLR(a,b) memset(a, b, sizeof(a))
 #define CLR0(a) CLR(a,0)


 #define maxn 105


 int n, m;
 bool g[maxn][maxn];
 bool bridge[maxn][maxn];
 vector<int> base;
 bool f[maxn];
 int d[maxn];
 int up[maxn];


 void dfs(int v, int depth, int p)
 {
     f[v] = true;
     d[v] = depth;
     up[v] = depth;
     for (int i = 0; i < n; i++) if (i != p && g[v][i])
     {
         if (!f[i])
         {
             dfs(i, depth+1, v);
             up[v] = min(up[v], up[i]);
             if (up[i] > depth)
             {
                 bridge[v][i] = bridge[i][v] = true;
             }
         }
         else
         {
             up[v] = min(up[v], d[i]);
         }
     }
 }
 void calc_bridges()
 {
     memset(bridge, 0, sizeof(bridge));
     memset(f, 0, sizeof(f));
     for (int i = 0; i < n; i++) if (!f[i]) dfs(i, 0, -1);
 }


 void mark(int i, bool f)
 {
     g[base[i]][base[i+1]] = f;
     g[base[i+1]][base[i]] = f;
 }


 void solve() {
     scanf("%d%d", &n, &m);
     for (int i = 0; i <= m; i++)
     {
         int t;
         scanf("%d", &t);
         base.push_back(t-1);
     }
     for (int i = 0; i < m; i++)
     {
         mark(i, true);
     }
     vector<int> res;
     int cur = base[0];
     int vv = -1;
     for (int i = 1; i <= m; i++)
     {
         calc_bridges();
         for (int j = base[i] + 1; j < n; j++) if (g[cur][j] && !bridge[cur][j])
         {
             vv = i;
         }
         cur = base[i];
         mark(i-1, false);
     }
     if (vv == -1)
     {
         printf("No solution");
         return;
     }
     for (int i = 0; i < m; i++)
     {
         mark(i, true);
     }
     cur = base[0];
     res.push_back(cur);
     for (int i = 1; i <= m; i++)
     {
         if (i < vv)
         {
             res.push_back(base[i]);
             mark(i-1, false);
             cur = base[i];
         }
         else
         {
             calc_bridges();
             int start = (i == vv ? base[i] + 1 : 0);
             int k = 0;
             for (int j = start; j < n; j++) if (g[cur][j]) k++;
             for (int j = start; j < n; j++) if (g[cur][j]) if (k == 1 || !bridge[cur][j])
             {
                 // go here
                 g[cur][j] = g[j][cur] = false;
                 res.push_back(j);
                 cur = j;
                 break;
             }
         }
     }
     for (int i = 0; i <= m; i++) printf("%d ", res[i]+1);
 }


 int main()
 {
     //freopen("input.txt", "r", stdin);
     //freopen("output.txt", "w", stdout);
     solve();
     return 0;
 }

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <algorithm>
#include <math.h>
#include <map>
#include <iomanip>
#include <string>
#include <queue>
#include <cstdlib>
#include <cstdio>
#include <set>
using namespace std;

int n;
vector< string > rat;
vector< string > wc;
vector< string > child;
vector< string > cap;
vector< string > man;

void print( vector< string > x ){
    for( int i =0 ; i < x.size(); ++i )
        cout<<x[i]<<endl;
}

int main(){
  //  freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        string a,b;
        cin >> a >> b;
        if( b == "man" ) man.push_back( a );
        else if( b == "captain" )  cap.push_back(a);
        else if( b == "rat" ) rat.push_back(a);
        else if( b == "woman" ) wc.push_back(a);
        else wc.push_back(a);
    }

    print( rat );
    print( wc );
    print( man );
    print( cap );

    return 0;
}

#include <algorithm>
#include <iostream>
#include <sstream>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include <vector>
#include <string>
#include <set>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstdlib>
#include <cstring>

#define sz(a) (int)a.size()
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define llong long long
#define zero(a) fabs(a) < 1e-9
#define resz(a, n) a.clear(), a.resize(n)
#define same(a, n) memset(a, n, sizeof(a))
#define make(a, b) make_pair(a, b)

#pragma comment(linker, "/STACK:120777216")

const int MAXN = 105;
const double eps = 10e-12;
const double ep = 10e-14;

using namespace std;

struct tri {
	double a, b;
	int row;
	tri() { };
	tri(double p1, double p2, int p3 ): a(p1), b(p2), row(p3) { };
	const bool operator < (const tri &t) const {
		return a < t.a;
	}
};

int n;
pair< double, int > v[MAXN];
vector< tri > w;

void err(double lo, double hi, int lvl) {
	if (hi - lo <= eps)
		return;
	double range = hi - lo;
	double a = lo + range / 3;
	double b = lo + (2 * range / 3);

	w.push_back(tri(a, b, lvl));

	err(lo, a  , lvl + 1);
	err(b , hi, lvl + 1);
}

bool byrank(pair< double, int > a, pair< double, int > b) {
	return a.second < b.second || (a.second == b.second && a.first < b.first );
}

int main() {
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
	err(0, 1, 0);
	sort(all(w));

	int test, m = sz(w);
	scanf("%d", &test);
	for (int t = 1; t <= test; ++t) {
		scanf("%d", &n);
		for (int i = 0; i < n; ++i)
			scanf("%lf", &v[i].first);
		sort(v, v + n);
		int j = 0;
		for (int i = 0; i < n; ++i){
			while (j < m && v[i].first - w[j].b > ep )
				j++;
			if (j < m && v[i].first - w[j].a > ep )
				v[i].second = w[j].row;
			else
				v[i].second = 999999999;
		}
		sort(v, v + n, byrank);
		printf("Case #%d:\n", t);
		for (int i = 0; i < n; ++i){
            double x = v[i].first;
            printf("0.");
            x++;
            llong a = (llong)round(x * 10000000000000.0);


            vector< int > tmp;
            while( a%10 == 0 ) a /= 10;
            while( a ) tmp.push_back( a%10 ), a /= 10;
            for( int j = sz(tmp)-2; j >= 0; --j )printf("%d",tmp[j]);
            printf("\n");
		}
	}
	return 0;
}

#include <algorithm>
#include <iostream>
#include <sstream>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include <vector>
#include <string>
#include <set>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstdlib>
#include <cstring>

#define sz(a) (int)a.size()
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define llong long long
#define zero(a) fabs(a) < 1e-9
#define resz(a, n) a.clear(), a.resize(n)
#define same(a, n) memset(a, n, sizeof(a))
#define make(a, b) make_pair(a, b)

#pragma comment(linker, "/STACK:120777216")

const int MAXN = 105;
const double eps = 10e-12;
const double ep = 10e-14;

using namespace std;

struct tri {
	double a, b;
	int row;
	tri() { };
	tri(double p1, double p2, int p3 ): a(p1), b(p2), row(p3) { };
	const bool operator < (const tri &t) const {
		return a < t.a;
	}
};

int n;
pair< double, int > v[MAXN];
vector< tri > w;

void err(double lo, double hi, int lvl) {
	if (hi - lo <= eps)
		return;
	double range = hi - lo;
	double a = lo + range / 3;
	double b = lo + (2 * range / 3);

	w.push_back(tri(a, b, lvl));

	err(lo, a  , lvl + 1);
	err(b , hi, lvl + 1);
}

bool byrank(pair< double, int > a, pair< double, int > b) {
	return a.second < b.second || (a.second == b.second && a.first < b.first );
}

int main() {
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
	err(0, 1, 0);
	sort(all(w));

	int test, m = sz(w);
	scanf("%d", &test);
	for (int t = 1; t <= test; ++t) {
		scanf("%d", &n);
		for (int i = 0; i < n; ++i)
			scanf("%lf", &v[i].first);
		sort(v, v + n);
		int j = 0;
		for (int i = 0; i < n; ++i){
			while (j < m && v[i].first - w[j].b > ep )
				j++;
			if (j < m && v[i].first - w[j].a > ep )
				v[i].second = w[j].row;
			else
				v[i].second = 999999999;
		}
		sort(v, v + n, byrank);
		printf("Case #%d:\n", t);
		for (int i = 0; i < n; ++i){
            double x = v[i].first;
            printf("0.");
            x++;
            llong a = (llong)round(x * 10000000000000.0);


            vector< int > tmp;
            while( a%10 == 0 ) a /= 10;
            while( a ) tmp.push_back( a%10 ), a /= 10;
            for( int j = sz(tmp)-2; j >= 0; --j )printf("%d",tmp[j]);
            printf("\n");
		}
	}
	return 0;
}

#include <algorithm>
#include <iostream>
#include <sstream>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include <vector>
#include <string>
#include <set>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstdlib>
#include <cstring>

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

#define sz(a) (int)a.size()
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define llong long long
#define zero(a) fabs(a) < 1e-9
#define resz(a, n) a.clear(), a.resize(n)
#define same(a, n) memset(a, n, sizeof(a))
#define make(a, b) make_pair(a, b)

using namespace std;

int n,m;
vector< pii > e;

int end,c;
int dp[30][1<<15];

int solve( int x, int mask ){
    if( mask == end ) return x != c;

    int &sol = dp[x][mask];
    if( sol != -1 ) return sol;

    sol = 999999;
    for( int i = 0; i < e.size(); ++i ){
        if( mask&(1<<i) ) continue;
        if( x == e[i].f )sol = min( sol, solve( e[i].s, mask|(1<<i)) );
        else if( x == e[i].s ) sol = min( sol, solve( e[i].f, mask|(1<<i)) );
        else{
            sol = min( sol , 1 + solve( e[i].f, mask|(1<<i) ) );
            sol = min( sol , 1 + solve( e[i].s, mask|(1<<i) ) );
        }
    }
    return sol;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);
    for( int t = 1; t <= tests; ++t ){
        scanf("%d%d",&n,&m);

        vector< int > lox;

        e.clear();
        for( int i = 0; i < m; ++i ){
            int a,b; scanf("%d%d",&a,&b);
            e.push_back( mk(a,b) );
            lox.push_back(a);
            lox.push_back(b);
        }

        sort( lox.begin(), lox.end() );
        lox.erase( unique(lox.begin(),lox.end()), lox.end() );

        for( int i = 0; i < m; ++i ){
            e[i].f = lower_bound( lox.begin(), lox.end(),e[i].f ) - lox.begin();
            e[i].s = lower_bound( lox.begin(), lox.end(), e[i].s ) - lox.begin();

        }

        end = (1<<m) - 1;
        int sol = 999999;
        for( int i = 0; i < lox.size(); ++i ){
            c = i;
            memset( dp, -1 , sizeof(dp));
            sol = min( sol , solve( i , 0 ) );
        }
        printf("%d\n",sol);

    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
#include <string.h>
#include <string>
#include <math.h>
#include <stack>
using namespace std;

int n;
int v[10];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    int sum = 0;
    int sol = 9999999,s=-1;
    for( int i = 0; i < 10; ++i ){
        scanf("%d",&v[i]);
        sum += v[i];
        if( abs(sum-100) <= sol  )
            s = sum , sol = abs(sum-100);
    }
    printf("%d\n",s);
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
#include <string.h>
#include <string>
#include <math.h>
#include <stack>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 100000 + 555;
const int mod = 1000000007;

typedef long long ll;

int n;
int fix[maxn];
int var[maxn];
ll dp[maxn][2];

ll solve( int x , bool trans ){
    if( x == n ) return 1;

    ll &sol = dp[x][trans];
    if( sol != -1 ) return sol;

    sol = 0;

    if( !trans ){
        sol = ((fix[x]+var[x]) * (ll)solve( x+1, 0 ))%mod;

        if( var[x] > 0 ){
            ll ret = solve( x + 1, 1 );
            sol = (sol + (var[x]*(ll)(fix[x]+var[x]-1)%mod)*ret ) % mod;
        }
    }else{
        sol = solve(x+1,0);
        if( var[x] > 0 ) sol = ( sol+ var[x]*solve( x + 1, 1 )   ) % mod;
    }
    return sol;
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ) scanf("%d",&fix[i]);
    for( int i = 0; i < n-1; ++i ) scanf("%d",&var[i]);

    memset( dp, -1, sizeof(dp));
    int sol = solve( 0, 0 );
    printf("%d\n",(int)sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
#include <string.h>
#include <string>
#include <math.h>
#include <stack>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

int n;
vector< pii > e;

int s[5];
int sol[2];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        int t,a,b;
        scanf("%d %d:%d",&t,&a,&b);
        int s = a*60 + b;
        e.push_back( mk(s,t) );
    }
    e.push_back( mk(0,-3) );
    e.push_back( mk(48*60,3) );
    sort( e.begin() , e.end() );

    for( int i = 1; i < e.size(); ++i ){
        if( s[0] > s[1] ) sol[0] += e[i].f - e[i-1].f;
        else if( s[0] < s[1] ) sol[1] += e[i].f - e[i-1].f;
        if( e[i].s-1 >= 0 )s[ e[i].s - 1 ] ++;
    }

    printf("%.2d:%.2d\n",sol[0]/60,sol[0]%60);
    printf("%.2d:%.2d\n",sol[1]/60,sol[1]%60);

    return 0;
}

#include <iostream>
#include <set>
#include <math.h>
#include <map>
#include <algorithm>
#include <stack>
using namespace std;

typedef long long ll;

ll h,w;
const int mod = 1000000007;

ll inv( ll v ){
   int stp = mod-2;
   stack<int>S;
   while(stp!=1 ){
      if( stp&1 ){
         stp--;
         S.push(1);
      }else{
         stp/=2;
         S.push(2);
      }
   }
   ll tmp = v;
   while(S.empty()==false ){
      if( S.top()==1 ){
         v  = (v*(ll)tmp)%mod;
      }else{
         v =  (v*(ll)v)%mod;
      }
      S.pop();
   }
   return v;
}

ll sump2( ll n ){
    ll x = 0;
    x = ( n * (n+1) ) % mod;
    x = ( x * (2*n+1) ) % mod;
    x = ( x * inv(6) ) % mod;
    return x;
}

ll sump3( ll n ){
    ll x = 0;
    x = (n*(n+1))%mod;
    x = (x*inv(2))%mod;
    x = (x*n)%mod;
    x = (x*(n+1))%mod;
    x = (x*inv(2))%mod;

    return x;
}



int main(){

     cin >> w >> h;
     ll m = min(h,w);
     h++,w++;


     ll s = 0;

     ll a = m*(m+1) % mod;
     a = (a*h)%mod;
     a = (a*w)%mod;
     a = (a*inv(2))%mod;


     s = a - h*sump2(m) - w*sump2(m) + sump3(m);
     cout<<((s%mod)+mod)%mod<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <map>
using namespace std;

const int inf = 9999;

int h,w,lo,hi;

int mat[30][30];
bool reach[30][30][2000];

void dfs( int r, int c, int s ){
    if( reach[r][c][s+625] ) return;
    reach[r][c][s+625] = 1;

    if( r == h-1 ) return;

    dfs( r+1, c, s + mat[r+1][c] );
    if( c ) dfs( r+1, c-1, s + mat[r+1][c-1] );
    if( c < w-1 ) dfs( r+1, c+1, s + mat[r+1][c+1] );
}

void reset(){
    for( int i = 0; i <= h; ++i )
        for( int j = 0; j <= w; ++j )
            for( int k = 0; k < 2000; ++k )
                reach[i][j][k] = 0;
}

int main(){
  //  freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);


    for( ; tests; --tests ){
        scanf("%d%d%d%d",&h,&w,&lo,&hi);

        reset();

        for( int i = 0; i < h; ++i )
            for( int j = 0; j < w; ++j )
                scanf("%d",&mat[i][j]);


        for( int i = 0; i < w; ++i )
            dfs( 0, i, mat[0][i] );


        int minx = inf,maxx = -inf;
        for( int i = 0; i < w; ++i )
            for( int j = lo+625; j <= hi+625; ++j )
                if( reach[h-1][i][j] ){
                    minx = min( minx, j - 625 );
                    maxx = max( maxx, j - 625 );
                }

        if( minx == inf ) printf("NO NO\n");
        else printf("%d %d\n",minx,maxx);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <set>
#include <map>
#include <cstdio>
using namespace std;

const int maxn = 200000 + 55;
const int inf = 2000000000 + 55;

int n;
int v[maxn];
int sz[maxn];
int sol[maxn];

int main(){
    freopen("lis.in","r",stdin);
    freopen("lis.out","w",stdout);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ) scanf("%d",&v[i]);

    for( int i = 0; i <= n; ++i ) sz[i] = inf, sol[i] = inf;

    int limit = 0;
    for( int i = 0; i < n; ++i ){
        int d = lower_bound( sz , sz+n , v[i] ) - sz;
        sz[d] = v[i];
        limit = max( limit , d + 1 );
    }
    vector< int > x;
    int mn = inf;
    for( int i = limit-1; i >= 0; --i ) mn = min( mn, sz[i] ), x.push_back( mn );
    for( int i = x.size()-1; i >= 0; --i ) printf("%d\n",x[i]);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <map>
using namespace std;

const int maxn = 105;

typedef long long ll;

int n,m;
int a[maxn][maxn];
int b[maxn][maxn];
int c[maxn][maxn];

void read( int x[maxn][maxn] ){
    for( int i = 0; i < n; ++i )
        for( int j = 0; j < m; ++j )
            scanf("%d",&x[i][j]);
}

int main(){
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&n,&m);

        read(a);
        read(b);
        read(c);


        ll sol = 0;
        for( int i = 0; i < n; ++i ){
            ll s = 0;
            for( int j = 0; j < m; ++j )
                s = max( s , min(a[i][j],b[i][j]) * (ll)c[i][j] );
            sol += s;
        }
        printf("%lld\n",sol);
    }

    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:cowlpha
*/
#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <string.h>
#include <string>
#include <iomanip>
#include <math.h>
#include <cstdio>
using namespace std;

const int mod = 97654321;

int lo,hi,m,n;
vector< int > mat[255];
char buff[3];

int x[255];

int dp[251][251][53];

int solve( int l, int h, int last ){
    if( l+h == n ) return lo == l && hi == h;
    if( l > lo || h > hi ) return 0;

    int &sol = dp[l][h][ x[last] ];
    if( sol != -1 ) return sol;
    sol = 0;

    for( int i = 0; i < mat[last].size(); ++i ){
        int c = mat[last][i];
        bool add = c >= 'a';
        sol += solve( l + add, h + (!add), c );
        if( sol >= mod ) sol -= mod;
    }
    return sol;
}

int main(){  //freopen("Ulaz.txt","r",stdin); freopen("Izlaz.txt","w",stdout);
    freopen("cowlpha.in","r",stdin);
    freopen("cowlpha.out","w",stdout);
    scanf("%d%d%d",&hi,&lo,&m);
    n = lo + hi;

    for( int i = 'a'; i <= 'z'; ++i ) x[i] = i-'a', mat[52].push_back( i );
    for( int i = 'A'; i <= 'Z'; ++i ) x[i] = ('z'-'a'+1) + i - 'A', mat[52].push_back( i );

    for( int i = 0; i < m; ++i ){
        scanf("%s",buff);
        mat[ buff[0] ].push_back( buff[1] );
    }

    for( int i = 0; i < 255; ++i ){
        sort( mat[i].begin() , mat[i].end() );
        mat[i].erase( unique(mat[i].begin(),mat[i].end()),mat[i].end() );
    }

    x[52] = 52;

    memset( dp , -1 , sizeof(dp));
    int sol = solve( 0 , 0 , 52 );
    printf("%d\n",sol);

    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:protest
*/
#include <iostream>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <string.h>
#include <string>
#include <iomanip>
#include <math.h>
#include <cstdio>
using namespace std;

typedef long long ll;

const int mod = 1000000009;
const int maxn = 100000 + 55;

int n;
int v[maxn];
int prefix[maxn];

int bit[maxn];
void update( int x, int v ){
    for( x += 5; x < maxn; x += x & -x )
        bit[x] = ( v + bit[x] ) % mod;
}

int read( int x ){
    int sol = 0;
    for( x += 5; x >= 1; x -= x & -x )
        sol = ( sol + bit[x] ) % mod;
    return sol;
}

int main(){
    freopen("protest.in","r",stdin);
    freopen("protest.out","w",stdout);

    scanf("%d",&n);
    for( int i = 1; i <= n; ++i ) scanf("%d",&v[i]);

    vector< int > low; low.push_back( 0 );
    for( int i = 1; i <= n; ++i ){
        prefix[i] = prefix[i-1] + v[i];
        low.push_back( prefix[i] );
    }
    sort( low.begin() , low.end() );
    low.erase( unique(low.begin(),low.end()), low.end() );

    for( int i = 0; i <= n; ++i )
        prefix[i] = lower_bound( low.begin() , low.end() , prefix[i] ) - low.begin();

    int sol = 0;
    update( prefix[n] , 1 );

    for( int i = n-1; i >= 0; --i ){
        sol = (read( maxn ) - read( prefix[i] - 1 ))%mod;
        if( sol < 0 ) sol += mod;
        update( prefix[i] , sol );
    }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <math.h>
#include <set>
#include <map>
#include <iomanip>
#include <string.h>
#include <string>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 500000 + 55;

char txt[maxn];
int f[maxn];

void makef(){
    f[0] = 0;
    int n = strlen(txt);
    for( int i = 1; i < n; ++i ){
        f[i] = f[i-1];
        while( f[i] > 0 && txt[f[i]] != txt[i] ) f[i] = f[f[i]-1];
        if (txt[f[i]] == txt[i]) f[i]++;
    }
}

int dad[maxn];
vector< int > g[maxn];
set< int > s;
bool visi[maxn];
priority_queue< pii > pq;

void insert( int v ){
    s.insert(v);

    set< int > :: iterator x,y,z;
    x = s.lower_bound( v ); x--;
    y = x; y++;
    z = y; z++;
    pq.push( mk(*y-*x,*x) );
    pq.push( mk(*z-*y,*y) );
}


void dfs( int node ){
    if( visi[node+1] ) return;
    visi[node+1] = 1;

    insert( node );
    for( int i = 0; i < g[node+1].size(); ++i )
        if( g[node+1][i] != dad[node] ) dfs( g[node+1][i] );
}


int tmp;
int mx(){
    while( !pq.empty() ){
        set< int > :: iterator x = s.upper_bound( pq.top().s );
        if( (*x)-pq.top().s == pq.top().f ) return pq.top().f;
        pq.pop();
    }
    return -55;
}


int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%s",txt);
    makef();
    int n = strlen(txt);

    for( int i = 1; i < n; ++i ){
        f[i]--;
        dad[i] = f[i];
        g[ f[i]+1 ].push_back( i );
    }

    int sol = n-1;
    s.insert(-1);
    pq.push( mk(n,-1) );

    int it = n - 1;
    while( it > 0 ){
        visi[it] = 1;
        insert( it );


        for( int i = 0; i < g[it+1].size(); ++i )
            if( visi[ g[it+1][i] ] == 0 ) dfs( g[it+1][i] );

        tmp = it;
        int diff = mx();
        if( diff <= it+1 ) sol = it;

        it = dad[it];
    }
    cout<<sol+1<<endl;

    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:bookclub
*/
#include <iostream>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <algorithm>
#include <map>
#include <iomanip>
#include <math.h>
#include <queue>
#include <stack>
using namespace std;

const int inf = 999999999;

int n,m,q;

int mat[50000][50];
bool ok[50000];

int main(){
    freopen("bookclub.in","r",stdin);
    freopen("bookclub.out","w",stdout);
    scanf("%d%d%d",&n,&m,&q);

    for( int i = 0; i < n; ++i ){
        ok[i] = 1;
        for( int j = 0; j < m; ++j )
            scanf("%d",&mat[i][j]);
    }


    for( int i = 0; i < q; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        int sol = 0;
        for( int i = 0; i < n; ++i )
            if( mat[i][a-1] != b ) ok[i] = 0;
    }

    int sol = 0;
    for( int i = 0; i < n; ++i )
        sol += ok[i];
    printf("%d\n",sol);

    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:cowngress
*/
#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <set>
#include <queue>
#include <cstdio>
#include <map>
#include <iomanip>
#include <math.h>
using namespace std;

const int maxq = 1000 + 55;
const int maxc = 4000 + 55;

int n,m;
bool reach[2*maxq][2*maxq];
vector< int > g[2*maxq];

int curr;

void dfs( int node ){
    reach[curr][node] = 1;
    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( reach[curr][nxt] ) continue;
        dfs( nxt );
    }
}

int main(){
    freopen("cowngress.in","r",stdin);
    freopen("cowngress.out","w",stdout);
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d%d",&n,&m);
    for( int i = 0; i < m; ++i ){
        int a,b;
        char c1,c2;
        scanf("%d %c %d %c",&a,&c1,&b,&c2); a-- , b--;
        int x = 2*a + (c1 == 'N');
        int y = 2*b + (c2 == 'N');
        g[x^1].push_back(y);
        g[y^1].push_back(x);
    }

    for( int i = 0; i < 2*n; ++i ){
        curr = i;
        dfs( i );
    }

    for( int i = 0; i < 2*n; i += 2 )
        if( reach[i][i+1] && reach[i+1][i] ){
            printf("IMPOSSIBLE\n");
            return 0;
        }

    for( int i = 0; i < 2*n; i += 2 ){
        if( reach[i][i+1] ) printf("N");
        else if( reach[i+1][i] ) printf("Y");
        else printf("?");
    }printf("\n");

    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:roadplane
*/
#include <iostream>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <algorithm>
#include <map>
#include <iomanip>
#include <math.h>
#include <queue>
#include <stack>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

int inf = 999999999;
const int maxn = 25000 + 555;

int dst[maxn];
int n,roads,planes,source;

vector< pii > r[maxn];
vector< pii > p[maxn];

int mark[maxn];
int f = 0;

vector< int > part[maxn];


void bfs( int node ){
    if( mark[node] != 0 ) return;
    f++;
    queue< int > q;
    q.push( node );
    mark[node] = f;

    while( !q.empty() ){
        int u = q.front(); q.pop();
        part[f].push_back( u );
        for( int i = 0; i < r[u].size(); ++i )
            if( mark[ r[u][i].f ] != f )
                mark[ r[u][i].f ] = f , q.push( r[u][i].f );
    }
}

vector< int > cs[maxn];
vector< int > rcs[maxn];
int out[maxn];

int main(){
    freopen("roadplane.in","r",stdin);
    freopen("roadplane.out","w",stdout);
    scanf("%d%d%d%d",&n,&roads,&planes,&source); source --;

    for( int i = 0; i < roads; ++i ){
        int a,b,c; scanf("%d%d%d",&a,&b,&c); a-- , b--;
        r[a].push_back( mk(b,c) );
        r[b].push_back( mk(a,c) );
    }

    for( int i = 0; i < planes; ++i ){
        int a,b,c; scanf("%d%d%d",&a,&b,&c); a-- , b--;
        p[a].push_back( mk(b,c) );
    }

    for( int i = 0; i < n; ++i ) bfs( i );
    for( int i = 0; i < n; ++i )
        for( int j = 0; j < p[i].size(); ++j )
            cs[ mark[i] ].push_back( mark[ p[i][j].f ] ), out[ mark[i] ] ++,
            rcs[ mark[ p[i][j].f ] ].push_back( mark[i] );
    queue< int > q;
    vector< int > order;
    for( int i = 1; i <= f; ++i )
        if( out[i] == 0 ) q.push( i );
    while( !q.empty() ){
        int u = q.front(); q.pop();
        order.push_back( u );
        for( int i = 0; i < rcs[u].size(); ++i ){
            out[ rcs[u][i] ] --;
            if( out[ rcs[u][i] ] == 0 ) q.push( rcs[u][i] );
        }
    }

    reverse( order.begin() , order.end() );
    int x = 0;
    while( x < order.size() && order[x] != mark[source] ) x ++;


    memset( dst , 1 , sizeof(dst));
    inf = dst[0];
    dst[source] = 0;

    for( ; x < order.size(); ++x ){
        int h = order[x];
        priority_queue< pii > pq;
        for( int i = 0; i < part[h].size(); ++i ){
            int s = part[h][i];
            if( dst[ s ] != inf ) pq.push( mk( inf - dst[s] , s ) );
        }


        while( !pq.empty() ){
            pii u = pq.top(); pq.pop();
            u.f = inf - u.f;

            if( u.f > dst[u.s] ) continue;

            for( int i = 0; i < r[u.s].size(); ++i ){
                int d = r[u.s][i].s;
                int nxt = r[u.s][i].f;

                if( dst[nxt] > u.f+d ){
                    dst[nxt] = u.f + d;
                    pq.push( mk( inf - dst[nxt] , nxt ) );
                }
            }

            for( int i = 0; i < p[u.s].size(); ++i ){
                int d = p[u.s][i].s;
                int nxt = p[u.s][i].f;
                if( dst[nxt] > u.f+d )
                    dst[nxt] = u.f + d;
            }
        }
    }

    for( int i = 0; i < n; ++i ){
        if( dst[i] == inf ) printf("NO PATH\n");
        else printf("%d\n",dst[i]);
    }


    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <algorithm>
#include <math.h>
#include <map>
#include <iomanip>
#include <string>
#include <queue>
#include <cstdlib>
#include <cstdio>
#include <set>
using namespace std;

int n;
string s[11];
int x[11],y[11];

bool ok[4][10];

string tostr( int x ){
    string a = "";
    while( x ){
        a += string(1, '0' + x % 10 );
        x /= 10;
    }
    if( a.size() != 4 ) a += "0";
    reverse( a.begin(), a.end() );
    return a;

}

int xa[10];
int xb[10];

bool valid( string x ){
    memset( xa , 0 , sizeof(xa )) ;
    for( int i = 0; i < x.size(); ++i ){
        xa[ x[i] - '0' ] ++;
        if( xa[ x[i] - '0' ] > 1 ) return 0;
    }
    return 1;
}

bool isok( string w, int i ){
    string d = s[i];

    int f = 0, s = 0;

    for( int k = 0; k < 4; ++k ){
        if( w[k] == d[k] ) f ++;
        for( int j = 0; j < 4; ++j )
            if( w[k] == d[j] && k != j) s++;
    }

    return f == x[i] && s == y[i];
}

int main(){
  //  freopen("Ulaz.txt","r",stdin);
    cin >> n;

    ok[1][0] = 1;
    ok[2][0] = 1;
    ok[3][0] = 1;

    for( int i = 0; i < n; ++i )
        cin >> s[i] >> x[i] >> y[i];

    int cnt = 0;
    string f = "";

    for( int i = 100; i <= 9999; ++i ){
        string w = tostr( i );
        bool ok = 1;

        if( valid(w) == 0 ) continue;

        for( int j = 0; j < n; ++j )
            if( !isok( w , j ) )
                ok = 0;

        if( ok )
            cnt ++, f = w;
    }

    if( cnt == 0 ) printf("Incorrect data\n");
    else if( cnt == 1 ) cout<<f<<endl;
    else printf("Need more data\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <algorithm>
#include <math.h>
#include <map>
#include <iomanip>
#include <string>
#include <queue>
#include <cstdlib>
#include <cstdio>
#include <set>
using namespace std;

int a,b,c,d,n;
int x[555];

char mat[1550][1550];

int main(){
    for( int i = 0; i < 555; ++i )
        for( int j = 0; j < 555; ++j )
            mat[i][j] = '.';

    scanf("%d%d%d%d%d",&a,&b,&c,&d,&n);
    for( int i = 0; i < n; ++i ) scanf("%d",&x[i]);

    int r,ar;

    if( a % 2 == 0 )  r = 0, ar = 1;
    else r = b-1, ar = -1;


    int dx = 0;

    for( int i = 0; i < a+c; ++i ){
        int h;
        if( i < a ) h = b;
        else h = d;

        while( r >= 0 && r < h ){
            while( dx < n && x[dx] == 0 ) dx ++;
            x[dx] --;
            mat[r][i] = 'a' + dx;
            r += ar;
        }

        ar *= -1;
        r += ar;
    }

    if( dx == n || x[dx] != 0 || x[dx+1] != 0 ) printf("NO\n");
    else{
        printf("YES\n");
        for( int i = 0; i < max(b,d); ++i ){
            for( int j = 0; j < a+c; ++j )
                printf("%c", mat[i][j]);
            printf("\n");
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <algorithm>
#include <math.h>
#include <map>
#include <iomanip>
#include <string>
#include <queue>
#include <cstdlib>
#include <cstdio>
#include <set>
using namespace std;

int d[][2] = { {1,1} , {-1,1} , {0,2} };

int ln[30];
char mat[30][30];

int dp[1<<20];
int u[30][30];

bool wins(int m){
    if( m == 0 ) return 0;
    if( dp[m] != -1 ) return dp[m];

    bool win = 0;
    for( int i = 0; i < 5; ++i ){
        for( int j = 0; j < ln[i]; ++j ){
            if( mat[i][j] != 'O' ) continue;
            if( (m&(1<<u[i][j])) == 0 ) continue;

            for( int k = 0; k < 4; ++k ){

                int r = i, c = j,s=m;
                while( r < 5 && c < ln[r] && (m&(1<<u[r][c]))  ){
                    m -= 1 << u[r][c];
                    win |= !wins(m);
                    r += d[k][0], c += d[k][1];
                }
                m = s;
            }
        }
    }

    return dp[m] = win;
}

int x[] = { 3, 4 , 5 ,4 , 3 };

int main(){
  //  freopen("Ulaz.txt","r",stdin);

    for( int i = 0; i < 5; ++i ){
        int s = 5 - x[i];
        for( int j = 0; j < x[i]; ++j ){
            char c; while( c = getchar() ) if( c == '.' || c == 'O' ) break;
            mat[i][s] = c;
            s += 2;
        }
        ln[i] = s-1;
    }

    int c = 0;
    for( int i = 0; i < 5; ++i )
        for( int j = 0; j < ln[i]; ++j )
            if( mat[i][j] == 'O' || mat[i][j] == '.' ) u[i][j] = c++;

    int mask = 0;
    for( int i = 0; i < 5; ++i )
        for( int j = 0; j < ln[i]; ++j )
            if( mat[i][j] =='O' ) mask += 1 << u[i][j];

    memset( dp, -1,sizeof(dp));
    bool f = wins(mask);

    if( f ) printf("Karlsson\n");
    else printf("Lillebror\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <set>
#include <map>
#include <cstdio>
using namespace std;

int n,m;
vector< int > x;

int main(){
    freopen("dosada.in","r",stdin);
    freopen("dosada.out","w",stdout);
    scanf("%d%d",&n,&m);
    for( int i = 0; i < n; ++i ){
        int a; scanf("%d",&a);
        x.push_back(a);
    }
    sort( x.begin() , x.end() );
    x.erase( unique(x.begin(),x.end()), x.end() );
    int sz = x.size();

    while( m -- ){
        int a; scanf("%d",&a);
        if( a >= x.size() ) printf("nema\n");
        else printf("%d\n",x[a]);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <string.h>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 100000 + 555;
const int mod = 1000000007;

typedef long long ll;


int n,m;
int v[maxn];
int prefix[maxn];
int range[maxn];

const int inf = 999999999;

struct segment_tree{
    vector< int > tree;
    int begin;

    segment_tree(){};
    segment_tree( int n ){
        int sz = 1;
        while( sz <= n ) sz <<= 1;
        begin = sz;
        sz <<= 1;
        tree.resize(sz);
        for( int i = 0; i < sz; ++i ) tree[i] = inf;
    }
    int l,r,v;

    int _query( int node, int lo, int hi ){
        if( hi < l || lo > r ) return -inf;
        if( node >= begin && tree[node] <= v ) return node;
        if( node >= begin ) return -inf;

        int mid = (lo+hi)>>1;
        int a = -inf , b = -inf;
        if( tree[node*2+1] <= v  ){
            a = _query( node*2+1, mid+1,hi );
            if( a > -inf ) return a;
        }
        if( tree[node*2] <= v ) return _query( node*2,lo,mid);
        return -inf;
    }

    int query( int lo, int hi, int val ){
        l = lo + begin;
        r = hi + begin;
        v = val;
        return _query( 1 , begin, begin*2 -1 )-begin;
    }

    void update( int dx, int v ){
        dx += begin;
        tree[dx] = v;
        while( dx != 1 ){
            dx >>= 1;
            tree[dx] = min( tree[dx*2], tree[dx*2+1] );
        }
    }
};

int main(){
   // freopen("Ulaz.txt","r",stdin);

    scanf("%d%d",&n,&m);
    for( int i = 1; i <= n; ++i ) scanf("%d",&v[i]);

    for( int i = 1; i <= n; ++i ) prefix[i] = prefix[i-1] + v[i];

    for( int i = 1; i <= n; ++i ){
        int s = -1;
        int lo = i, hi = n;
        while( lo <= hi ){
            int mid = (lo+hi)>>1;
            int ss = prefix[mid] - prefix[i-1];
            if( ss <= m ) lo = mid + 1 , s = mid;
            else hi = mid - 1;
        }
        range[i] = s;
    }
    segment_tree t(n+5);
    vector< int > rev;

    for( int i = n; i >= 1; --i ){
        if( range[i] < 0 ){
            rev.push_back(0);
            continue;
        }

        int sol = t.query( i+1, range[i]+1, i );
        t.update( i , -range[i]+2*i-1);

        if( sol < -inf ) rev.push_back( 0 );
        else rev.push_back((sol-i)*2);
    }

    for( int i = rev.size()-1; i >= 0; --i ) printf("%d\n",rev[i]);


    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <map>
#include <iomanip>
#include <queue>
#include <stack>
#include <set>
using namespace std;

const int maxn = 200050;

int n;
int tests;
int v[maxn];

int l[maxn];
int r[maxn];

int update( int *tree, int dx, int val ){
    for( dx += 2; dx < maxn; dx += dx & -dx )
        tree[dx] = max(tree[dx],val );
}

int read( int *tree, int dx ){
    int ret = 0;
    for( dx += 2; dx >= 1; dx -= dx & -dx )
        ret = max( ret , tree[dx] );
    return ret;
}

int main(){
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%d",&v[i]);
        update( l , i , v[i] );
        update( r , n-i , v[i] );
    }

    scanf("%d",&tests);
    for( ; tests; --tests ){
        int a,b; scanf("%d%d",&a,&b); a--,b--;
        int x = read( l , a - 1 );
        int y = read( r , n-(b+1) );

        printf("%d\n",max(x,y));
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <map>
#include <iomanip>
#include <queue>
#include <stack>
#include <set>
using namespace std;

const int maxn = 200000;

int tests;
char txt[maxn];

int main(){
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%s",txt);

        bool ok = 1;
        int cnt = 0;
        int len = strlen(txt);
        for( int i = 0; i < len; ++i ){
            if( txt[i] == 'T' ) cnt ++;
            else cnt --;

            if( cnt < 0 ) ok = 0;
        }

        if( ok && cnt == 0 ) printf("YES\n");
        else printf("NO\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <map>
#include <iomanip>
#include <queue>
#include <stack>
#include <set>
using namespace std;

const int maxn = 200000;

int tests;
int n;

bool ok[maxn];

int main(){
    for( int i = 2; i < maxn; ++i ){
        if( ok[i] ) continue;
        for( int j = i+i; j < maxn; j+=i )
            ok[j] = 1;
    }


    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d",&n);

        int a=-1,b=-1;
        for( int i = n+1; a==-1 || b == -1; ++i ){
            if( !ok[i] && a == -1 ) a = i;
            else if( !ok[i] ) b = i;
        }

        printf("%d\n",a*b);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <map>
#include <iomanip>
#include <queue>
#include <stack>
#include <set>
using namespace std;

const int maxn = 20000 +55;

int n;
int a[maxn];
int s[maxn*2];

int sol[maxn*3];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ) scanf("%d",&a[i]);

    for( int i = 0; i < n; ++i ){
        for( int j = -20000; j <= 20000; ++j )
            sol[ j + a[i] + 30000 ] += s[j+20000];

        for( int j = 0; j < i; ++j )
            s[ a[i] + a[j] + 20000 ] ++;
    }

    for( int i = 0; i <= 60000; ++i )
        if( sol[i] ) printf("%d : %d\n",i-30000,sol[i]);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <map>
#include <iomanip>
#include <queue>
#include <stack>
#include <set>
using namespace std;

const int maxn = 2000000 +55;

int n;
int a[maxn];

int sol[maxn*3];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ) scanf("%d",&a[i]);

    for( int i = 0; i < n; ++i ){
        for( int j = i+1; j < n; ++j ){
            for( int k = j+1; k < n; ++k ){
                sol[i+j+k+30000] ++;
            }
        }
    }




    return 0;
}

#include <iostream>
#include <cstdio>
#include <queue>
#include <algorithm>
#include <cstdlib>
using namespace std;

typedef long long ll;

const int maxn = 500+5;
const int maxh = 500+5;
const int mod = 1000000007;

int n,h;
int dp[maxh][maxn];
bool on[maxh][maxn];

int main(){
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){

        scanf("%d%d",&n,&h);

        if( h == 0 ){
            if( n == 1 ) printf("1\n");
            else printf("0\n");
            continue;
        }


        for( int i = 0; i <= h; ++i )
            for( int j = 0; j <= n; ++j )
                dp[i][j] = on[i][j] = 0;

        for( int i = 0; i <= n; ++i ) dp[i][0] = 1;
        dp[h][1] = 1;
        on[h][1] = 1;

        for( int i = h-1; i >= 0; --i ){
            for( int cnt = 1; cnt <= n; ++cnt ){
                for( int k = 0; k < cnt; ++k ){
                    if( on[i+1][k] || on[i+1][cnt-k-1] ) on[i][cnt] = 1;
                    dp[i][cnt] = ( dp[i][cnt] + dp[i+1][k] * (ll)dp[i+1][cnt-k-1] ) % mod;
                }
            }
        }

        int sol = 0;
        for( int k = 0; k < n; ++k )
            if( on[1][k] || on[1][n-k-1] )
                sol = ( sol + dp[1][k] * (ll)dp[1][n-k-1] ) % mod;

        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <math.h>
#include <string.h>
#include <string>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;

#define len(x) (int)strlen(x)
#define sz(x) (int)x.size()
#define all (x.begin(),x.end())
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

int h,w,rb,cb,m;
int mat[1005][1005];

int d[][2] = { {0,1} , {0,-1} , {-1,0} , {1,0} };

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&w,&h);
        scanf("%d%d",&cb,&rb); cb--, rb = h - rb;
        scanf("%d",&m);

        memset( mat,0 ,sizeof(mat));

        char c;
        for( int i = 0; i < m-1; ++i ){
            while( c=getchar()) if( c == 'R' || c == 'L' || c == 'U' || c == 'D' ) break;
            if( c == 'R' ) c = 0;
            if( c == 'L' ) c = 1;
            if( c == 'U' ) c = 2;
            if( c == 'D' ) c = 3;

            int rn = rb + d[c][0];
            int cn = cb + d[c][1];

            mat[rn][cn] = mat[rb][cb] + 1;
            rb = rn;
            cb = cn;
        }


        int cnt = 0;
        int allow = 0;
        bool iswall = 0;
        while(1){
            int rn = rb + d[c][0];
            int cn = cb + d[c][1];

            if( rn < 0 || cn < 0 || rn >= h || cn >= w ){
                iswall = 1; break;
            }

            if( mat[rn][cn] > allow ) break;

            allow ++;
            mat[rn][cn] = mat[rb][cb] + 1;

            cnt ++;
            rb = rn;
            cb = cn;
        }

        if( iswall ) printf("WALL ");
        else printf("BODY ");
        printf("%d\n",cnt);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;

struct mono{
    queue< int > q;
    deque< int > d;

    void push( int x ){
        q.push( x );
        while( !d.empty() && x > d.back() ) d.pop_back();
        d.push_back( x );
    }

    void pop(){
        if( q.empty() ) return;
        if( !d.empty() && q.front() == d.front() ) d.pop_front();
        q.pop();
    }

    int top(){ return d.front(); }
};

int n;

int main(){
    int v;
    mono q;

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%d",&v);
        q.push( v );
    }

    printf("%d\n",q.top());

    while( scanf("%d",&v) ){
        if( v == -1 ) break;
        q.pop();
        q.push( v );

        printf("%d\n",q.top());
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <map>
#include <stack>
using namespace std;

const int maxn = 105;

int n;
int m[maxn];
vector< int > g[maxn];
vector< int > e[maxn];

char c[maxn][maxn];

int deg[maxn];
int cnt[maxn][maxn];
bool chg[maxn][maxn];

void add_edge( int a, int b ){
    deg[a] ++;
    cnt[a][b] ++;
    g[a].push_back( b );
}

void input(){
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        scanf("%d",&m[i]);
        for( int j = 0; j < m[i]; ++j ){
            int a; scanf("%d",&a); a --;
            add_edge( i , a );
        }
    }
}

void make_euler(){
    vector< int > odd;
    for( int i = 0; i < n; ++i ){
        deg[i] %= 2;
        if( deg[i] == 1 ) odd.push_back( i );
    }

    for( int i = 0; i+1 < odd.size(); i += 2 )
        add_edge( odd[i] , odd[i+1] ),
        add_edge( odd[i+1], odd[i] );
}


void dfs( int node ){

    for( int i = 0; i < g[node].size(); ++i ){
        int a = node , b = g[node][i];
        if( cnt[a][b] == 0 ) continue;
       // cout<<a<<" "<<b<<" [ "<<cnt[a][b] <<" , "<<cnt[b][a]<<endl;
        cnt[a][b] --,cnt[b][a] --;

        if( chg[a][b] == 0 ){
            c[a][b] = 'Y';
            c[b][a] = 'G';
        }
        chg[a][b] = chg[b][a] = 1;

        dfs( b );
    }

}

void solve(){
    make_euler();
    for( int i = 0; i < n; ++i ) deg[i] %= 2;

    for( int i = 0; i < n; ++i ) if ( deg[i] % 2 ) dfs( i );
    for( int i = 0; i < n; ++i ) dfs( i );
}

void print(){
    for( int i = 0; i < n; ++i ){
       // cout<<i<<" "<<m[i]<<" , "<<n<<endl;
        for( int j = 0; j < m[i]; ++j )
            printf("%c ",c[i][ g[i][j]] );
        printf("\n");
    }
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    input();
    solve();
    print();
    return 0;
}

#include <cstdio>
#include <string.h>

const int maxn = 505;

int n,m;
int v[maxn];
int range[maxn][maxn];

inline int min( int a, int b ){
    if( a < b ) return a;
    return b;
}

int dp[2][505][505];

int solve( int x, int k, int prv ){
    if( k == m ) return 9999;
    if( x == n ) return range[prv][n-1];

    int &sol = dp[x][k][prv];
    if( sol != -1 ) return sol;

    return sol = min( solve(x+1,k,prv) , solve(x+1,k+1,x) + (x-1>=0? range[prv][x-1] : 0)  );
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);

    for( int i = 0; i < n; ++i )
        scanf("%d",&v[i]);

    for( int i = 0; i < n; ++i ){
        int b(0),w(0);
        for( int j = i; j < n; ++j ){
            b += v[j], w += !v[j];
            range[i][j] = b*w;
        }
    }

//    memset( dp, -1, sizeof(dp));
//    int s = solve( 0 , 0 , 0 );
//    printf("%d\n",s);

    memset( dp, 1, sizeof(dp));
    dp[1][0][0] = 0;
    dp[1][1][0] = 0;

    bool now = 1;

    for( int i = 0; i <= n; ++i ){
        for( int j = 0; j < m; ++j ){
            for( int k = 0; k < i; ++k ){
                dp[now][j][k]   = min( dp[now][j][k], dp[!now][j][k] );
                dp[now][j+1][i] = min( dp[now][j+1][i] , dp[!now][j][k] + range[k][i-1] );
            }
        }
        now = !now;
    }
    //printf("::: %d\n",dp[3][2][2]);
   // printf("%d %d %d\n",n+1,m,n);
    printf("%d\n",dp[!now][m][n]);

//    int sol = 999999;
//    for( int i = 0; i < n; ++i ){
//        printf("%d , %d %d\n",i,dp[n-1][m-1][i],range[i][n-1]);
//        sol = min( sol , dp[n][m-1][i] + range[i][n-1] );
//    }

 //   printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <string.h>
using namespace std;

const int maxn = 100000 + 55;

int n;
char a[maxn];
char b[maxn];

char buff[maxn];

void nzero( int n ){
    for( int i = 0; i < n; ++i ) buff[i] = '0';
    buff[n] = '\0';
}

int main(){
    scanf("%d",&n);
    scanf("%s%s",a,b);

    int pos = n;
    for( int i = n-1; i >= 0; --i ){
        if( a[i] == '1'&& b[i] == '1' )
            pos = i;
    }
    for( int i = n-1; i >= pos; --i ) b[i] = '0';

    for( int i = pos-1; i >= 0; --i ){
        if( a[i] == '0' && b[i] == '0' ){
            b[i] = '1';
            printf("%s\n%s\n",a,b);
            return 0;
        }else b[i] = '0';
    }

    nzero( n );

    for( int i = n-1; i >= 0; --i ){
        if( a[i] == '0' ){
            a[i] = '1';
            printf("%s\n%s\n",a,buff);
            return 0;
        }else a[i] = '0';
    }

    printf("%s\n%s\n",buff,buff);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <math.h>
using namespace std;

int n,m;

int solve( int pos, int n ){
    if( pos == m ) return 1;

    int sol = 0;

    // no split
    sol += 2*solve( pos + 1 , n );

    // split
    for( int i = 1; i < n; ++i )
        sol += 2 * solve( pos + 1 , i ) * solve( pos + 1, n-i );

    return sol;
}


int rec( int pos, int n ){
    if( pos == m ) return 1;

    int sol = 0;

    // no split 0 or 1
    sol +=  2*rec( pos + 1 , n ) ;

    // split
    for( int i = 1; i < n; ++i )
        sol += 2*(  rec( pos + 1 , i ) * rec( pos + 1, n-i ) );

    cout<<" DAT: "<<pos<<" "<<n<<" = "<<sol<<endl;

    return sol;
}

int main(){
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&n,&m);

        cout<<rec(0,n)<<endl;

        int sol = solve( 0 , n );
        printf("%d\n",sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
#include <math.h>
using namespace std;

int n,m;

double c[305][305];
double dp[301][301];

double solve( int n, int m ){
    if( n == 0 ) return 0;
    else if( n == 1 ) return m;
    else if( m == 0 ) return 0;

    if( dp[n][m] >= 0 ) return dp[n][m];

    double sol = 0;

    for( int i = 0; i <= n; ++i )
        sol += ((n-i!=0)+(i!=0) + solve( i , m-1 ) + solve( n-i, m-1 ))*c[n][i];
    for( int i = 0; i < n; ++i ) sol /= 2;
    return dp[n][m] = sol;
}

int main(){
    memset( dp, -1, sizeof(dp));

    c[0][0] = 1;
    for( int i = 1; i <= 300; ++i ){
        c[i][0] = 1;
        for( int j = 1; j <= 300; ++j )
            c[i][j] = c[i-1][j] + c[i-1][j-1];
    }

    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&n,&m);
        double sol = solve( n , m );
        printf("%.2lf\n",sol+1);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <math.h>
#include <stack>
#include <complex>
using namespace std;

int main(){
    int a,b;
    scanf("%d%d",&a,&b);
    int x = a*b;

    for( int i = 0; i  <5; ++i ){
        int y; scanf("%d",&y);
        printf("%d ",y-x);
    }printf("\n");

    return 0;
}

#include <iostream>
#include <cstdio>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
#include <vector>
#include <queue>
#include <algorithm>
#include <cstdlib>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

// TODO: u slucaju istih 'bonusa' izabrati onaj koji ima najvise pristup praznim poljima


int d[][2] = { {-1,-1}, {-1,1}, {0,2}, {1,1}, {1,-1}, {0,-2} };

const int maxr = 25;
const int maxb = 3*(maxr*maxr+maxr);
const int midx = 250, midy = 250;
int tmp[100],sztmp;

struct block{
    int angle;
    bool mat[10][10];
    block(){};

    void clear(){ angle=0;memset( mat, 0, sizeof(mat)); }

    void readspec(){
        char c; sztmp = 0;
        while( c=getchar() ){
            if( c >= '0' && c <= '9' ) tmp[sztmp++] = c;
            if( c == ';' || c == '.' ){
                for( int i = 0; i < sztmp; ++i )
                    for( int j = 0; j < sztmp; ++j )
                        mat[ tmp[i]-'0' ][ tmp[j]-'0' ] = 1;
                sztmp = 0;
                if( c == '.' ) break;
            }
        }
    }
};

struct tri{
    int a,b,c;
    tri(){};
    tri( int p1, int p2, int p3 ):a(p1),b(p2),c(p3){};
};

struct qdat{
    int f,s;
    qdat(){};
    qdat( int p1, int p2 ):f(p1),s(p2){};
};

int r,n;
int dst[500][500];

void prec(){
    queue< pii > q;
    q.push( mk(midy,midx) );
    dst[midy][midx] = 1;
    pii u;

    int cnt = 0;
    while(!q.empty()){
        u = q.front(); q.pop();

        if( dst[u.f][u.s] == 61 ) continue;

        for( int i = 0; i < 6; ++i ){
            int c = u.s + d[i][1];
            int r = u.f + d[i][0];

            if( dst[r][c] ) continue;
            dst[r][c] = dst[u.f][u.s] + 1;
            q.push( mk(r,c) );
        }
    }
}

block vars[maxb];
bool used[30000];
bool ok[500][500];
int lnk[500][500];
bool done[500][500];
bool visi[500][500][6];
pii bitni[30000]; int sz = 0;

int cost ;

int qa[300000], qsz;
int qb[300000];
int qc[300000];

void dfs( int r, int c, int x ){
    qsz = 0;
    qa[qsz] = r , qb[qsz] = c, qc[qsz++] = x;

    while( qsz ){
        qsz--;
        r = qa[qsz], c = qb[qsz], x = qc[qsz];

        int h = lnk[r][c], l = vars[h].angle;
        x = (x-l+6)%6;

        if( visi[r][c][x] || ok[r][c] == 0 || (r==250&&c==250) ) continue;

        for( int i = 0; i < 6; ++i ) if( vars[h].mat[x][i] ) visi[r][c][i] = 1, cost++;

        for( int i = 0; i < 6; ++i ){
            if( vars[h].mat[x][i] == 0 ) continue;

            qa[qsz] = r+d[(i+l)%6][0];
            qb[qsz] = c+d[(i+l)%6][1];
            qc[qsz++] = (i+3+l)%6;
        }
    }
}

int calc_sol(){
    cost = 0;
    for( int i = 0; i < sz; ++i )
        for( int j = 0; j < 6; ++j )
            visi[bitni[i].f][bitni[i].s][j] = 0;
    dfs( midy+d[0][0], midx+d[0][1], 3 );
    return cost;
}

void clear(){
    sz = 0;
    memset( ok, 0, sizeof(ok));
    memset( used, 0, sizeof(used));

    for( int i = 0; i < 500; ++i ){
        for( int j = 0; j < 500; ++j ){
            for( int k = 0; k < 6; ++k ) visi[i][j][k] = 0;

            if( dst[i][j] <= r+1 && dst[i][j] > 1 )
                ok[i][j] = 1, bitni[sz++] = mk(i,j);
            lnk[i][j] = done[i][j] = 0;
        }
    }
}

int water[6];
int mem[6];

int freeaccess;

int bonus( qdat u, bool update = 0 ){
    for( int i = 0; i < 6; ++i ) water[i] = mem[i] = 0;
    freeaccess = 0;

    int ret = 0;
    for( int i = 0; i < 6; ++i ){
        int r = u.f + d[i][0];
        int c = u.s + d[i][1];

        if( ok[r][c] == 0 && (r!=250 || c!=250) )  continue;

        if( visi[r][c][(i+3)%6] ) water[i] = 1;
    }

    int x = lnk[u.f][u.s];
    int a = vars[x].angle;
    for( int i = 0; i < 6; ++i ){
        int z = (i-a+6)%6;
        if( !water[i] ) continue;
        for( int j = 0; j < 6; ++j ){
            if( vars[x].mat[z][j] ){
                mem[(j+a)%6] = 1;
                if( update )visi[u.f][u.s][(j+a)%6] = 1;
            }
        }
    }

    for( int i = 0; i < 6; ++i ) ret += mem[i];

    for( int i = 0; i < 6; ++i ){
        int r = u.f + d[i][0];
        int c = u.s + d[i][1];


        if( ok[r][c] == 0 )  continue;

        if( mem[i] ) freeaccess += lnk[r][c] == 0;
    }

    return ret;
}

bool chk[30000][6];

int main(){
    freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);

    prec();
    vars[0] = block();
    vars[0].clear();

    int solcase = 0;

    int T = tests;

    for( ; tests; --tests ){
        scanf("%d",&r);
        n = 3*(r*r+r);

        for( int i = 1; i <= n; ++i ){
            vars[i].clear();
            vars[i].readspec();
        }

        clear();

        done[midy][midx] = 1;
        done[midy+d[0][0]][midx+d[0][1]] = 1;
        queue< qdat > q;
        qdat u;
        q.push( qdat(midy+d[0][0], midx+d[0][1]) );

        int now = 0;
        int cnt = 0;
        visi[midy][midx][0] = 1;


        while( !q.empty() ){
            u = q.front(); q.pop();


            int x=-1,l;
            int mx = 0,f = 0;
            for( int i = 1; i <= n; ++i ){
                if( used[i] ) continue;
                for( int a = 0; a <= 5; ++a ){
                    lnk[u.f][u.s] = i;
                    vars[i].angle = a;

                    int b = bonus( u );

                    lnk[u.f][u.s] = 0, vars[i].angle = 0;

                    if( b > mx || b == mx && freeaccess > f )
                        mx = b, x = i, l = a, f = freeaccess;
                }
            }

            if( x == -1 ) continue;

            used[x] = 1;
            lnk[u.f][u.s] = x, vars[x].angle = l;

            bonus( u , 1 );

            for( int i = 0; i < 6; ++i ){
                if( visi[u.f][u.s][i] == 0 ) continue;

                int r = u.f + d[i][0];
                int c = u.s + d[i][1];

                if( done[r][c] || !ok[r][c] ) continue;
                done[r][c] = 1;

                q.push( qdat(r, c) );
            }
        }
        cout<<"A"<<endl;

        for( int i = 0; i < sz; ++i ){
            int x = lnk[ bitni[i].f ][ bitni[i].s ];

            if( !x )
            for( int k = 1; k <= n; ++k ) if( !used[k] ){
                used[k] = 1;
                lnk[ bitni[i].f ][ bitni[i].s ] = k;
                break;
            }
            x = lnk[ bitni[i].f ][ bitni[i].s ];
        }

        for( int i = 0; i < sz; ++i ){
            int x = lnk[ bitni[i].f ][ bitni[i].s ];
            int y = vars[x].angle;

            int better = -1,c;

            for( int k = 0; k <= 5; ++k ){
                vars[x].angle = k;
                int v = calc_sol();
                if( better < v ) better = v, c = k;
            }

            vars[x].angle = c;
        }


        int cc = 4;
        if( T == 9 ) cc = 10;

        while( cc -- ){

            for( int i = 0; i <= sz; ++i )
                for( int j = 0; j < 6; ++j )
                    chk[i][j] = 0;
            int pokusaj = 10000;

        // if tests == 16 postavi na 5000 pokusaja, inace postavi na 10000

            int tmp = calc_sol();
            for( int i = 0; i < pokusaj; ++i ){
                int a = 1 + rand()%sz;
                int b = 1 + rand()%sz;

                int r1 = bitni[a].f, c1 = bitni[a].s;
                int r2 = bitni[b].f, c2 = bitni[b].s;

                int p1 = vars[ lnk[r1][c1] ].angle, p2 = vars[ lnk[r2][c2] ].angle;
                int rot1 = rand()%6, rot2 = rand()%6;

                if( chk[a][rot1] || chk[b][rot2] ) continue; // GRESKA! swap( a,b ) , mijenja swap(b,c)
                chk[a][rot1] = chk[b][rot2] = 1;

                vars[ lnk[r1][c1] ].angle = rot1, vars[ lnk[r2][c2] ].angle = rot2;
                swap( lnk[r1][c1], lnk[r2][c2] );

                int nw = calc_sol();

                if( nw > tmp ){
                    tmp = nw;
                }else{
                    swap( lnk[r1][c1], lnk[r2][c2] );
                    vars[ lnk[r1][c1] ].angle = p1, vars[ lnk[r2][c2] ].angle = p2;
                }

            }

        }


        for( int i = 0; i < sz; ++i ){
            int x = lnk[ bitni[i].f ][ bitni[i].s ];
            printf("%d %d\n",x-1,vars[x].angle);
        }

       // for( int i = 1; i <= n; ++i )
       //     if( used[i] == 0 ) EXIT(-1);
        //cout<<"COST: "<<calc_sol()<<" , "<<n<<endl;
        //solcase += calc_sol();
    }
    //cout<<"TOTAL: "<<solcase<<endl;

    return 0;
}

#include <iostream>
#include <cstdio>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
#include <vector>
#include <queue>
#include <algorithm>
#include <cstdlib>
using namespace std;

const char* type[] = {
  "0 1 .",     //0
  "0 2 .",     //1
  "0 3 .",     //2
  "0 1 2 .",   //3
  "0 1 3 .",   //4
  "0 1 4 .",   //5
  "0 1 2 3 .", //6
  "0 1 2 4 .", //7
  "0 1 3 4 .", //8
  "0 1 ; 2 3 .",  //9
  "0 1 2 3 4 .",  //10
  "0 1 2 3 4 5 .",    //11
  "0 1 ; 2 3 ; 4 5 ." //12
  };

  int cnt = 13;


int main(){
    srand((unsigned)time(0));
    freopen("Ulaz.txt","w",stdout);
    int tests = 100;
    cout<<tests<<endl;

    while( tests -- ){
        int r = 5;
        int n = 3*(r*r+r);

        cout<<r<<endl;
        for( int i = 0; i < n; ++i ){
            int x = rand()%cnt;
            cout<<type[x]<<endl;
        }
        cout<<endl;
    }

    return 0;
}

#include <cstdio>
#include <math.h>
#include <string.h>
#include <queue>
#include <cstdlib>
#include <time.h>
using namespace std;



int d[][2] = { {-1,-1}, {-1,1}, {0,2}, {1,1}, {1,-1}, {0,-2} };

const int maxr = 26;
const int maxb = 3*(maxr*maxr+maxr);
const int midx = 150, midy = 150;
const int maxf = midx * 2;
int tmp[100],sztmp;

struct block{
    int angle;
    bool mat[10][10];
    block(){};

    void clear(){ angle=0;memset( mat, 0, sizeof(mat)); }

    void readspec(){
        char c; sztmp = 0;
        while( c=getchar() ){
            if( c >= '0' && c <= '9' ) tmp[sztmp++] = c;
            if( c == ';' || c == '.' ){
                for( int i = 0; i < sztmp; ++i )
                    for( int j = 0; j < sztmp; ++j )
                        mat[ tmp[i]-'0' ][ tmp[j]-'0' ] = 1;
                sztmp = 0;
                if( c == '.' ) break;
            }
        }
    }
};

struct pii{
    int f,s;
    pii(){};
    pii( int p1, int p2 ):f(p1),s(p2){};
};

int r,n;
int dst[maxf][maxf];

void prec(){
    queue< pii > q;
    q.push( pii(midy,midx) );
    dst[midy][midx] = 1;
    pii u;

    int cnt = 0;
    while(!q.empty()){
        u = q.front(); q.pop();

        if( dst[u.f][u.s] == 26 ) continue;

        for( int i = 0; i < 6; ++i ){
            int c = u.s + d[i][1];
            int r = u.f + d[i][0];

            if( dst[r][c] ) continue;
            dst[r][c] = dst[u.f][u.s] + 1;
            q.push( pii(r,c) );
        }
    }
}

block vars[maxb];
bool used[maxb];

bool ok[maxf][maxf];
int lnk[maxf][maxf];
bool done[maxf][maxf];
bool visi[maxf][maxf][6];

pii bitni[maxb]; int sz = 0;

int cost ;

void dfs( int r, int c, int x ){
    int h = lnk[r][c], l = vars[h].angle;
    x = (x-l+6)%6;

    if( visi[r][c][x] || ok[r][c] == 0 || (r==midx&&c==midx) ) return;

    for( int i = 0; i < 6; ++i ) if( vars[h].mat[x][i] ) visi[r][c][i] = 1, cost++;

    for( int i = 0; i < 6; ++i ){
        if( vars[h].mat[x][i] == 0 ) continue;
        dfs( r+d[(i+l)%6][0], c+d[(i+l)%6][1], (i+3+l)%6 );
    }
}

int calc_sol(){
    cost = 0;
    for( int i = 0; i < sz; ++i )
        for( int j = 0; j < 6; ++j )
            visi[bitni[i].f][bitni[i].s][j] = 0;
    dfs( midy+d[0][0], midx+d[0][1], 3 );
    return cost;
}

void clear(){
    sz = 0;
    memset( ok, 0, sizeof(ok));
    memset( used, 0, sizeof(used));

    for( int i = 0; i < maxf; ++i ){
        for( int j = 0; j < maxf; ++j ){
            for( int k = 0; k < 6; ++k ) visi[i][j][k] = 0;

            if( dst[i][j] <= r+1 && dst[i][j] > 1 )
                ok[i][j] = 1, bitni[sz++] = pii(i,j);
            lnk[i][j] = done[i][j] = 0;
        }
    }
}

int water[6];
int mem[6];

int freeaccess;

int bonus( pii u, bool update = 0 ){
    for( int i = 0; i < 6; ++i ) water[i] = mem[i] = 0;
    freeaccess = 0;

    int ret = 0;
    for( int i = 0; i < 6; ++i ){
        int r = u.f + d[i][0];
        int c = u.s + d[i][1];

        if( ok[r][c] == 0 && (r!=midx || c!=midx) )  continue;

        if( visi[r][c][(i+3)%6] ) water[i] = 1;
    }

    int x = lnk[u.f][u.s];
    int a = vars[x].angle;
    for( int i = 0; i < 6; ++i ){
        int z = (i-a+6)%6;
        if( !water[i] ) continue;
        for( int j = 0; j < 6; ++j ){
            if( vars[x].mat[z][j] ){
                mem[(j+a)%6] = 1;
                if( update )visi[u.f][u.s][(j+a)%6] = 1;
            }
        }
    }

    for( int i = 0; i < 6; ++i ) ret += mem[i];

    for( int i = 0; i < 6; ++i ){
        int r = u.f + d[i][0];
        int c = u.s + d[i][1];


        if( ok[r][c] == 0 )  continue;

        if( mem[i] ) freeaccess += lnk[r][c] == 0;
    }

    return ret;
}

bool chk[maxb][6];

int main(){
    srand(10007);
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);

    prec();
    vars[0] = block();
    vars[0].clear();

    int solcase = 0;

    int T = tests;

    for( ; tests; --tests ){
        scanf("%d",&r);
        n = 3*(r*r+r);

        for( int i = 1; i <= n; ++i ){
            vars[i].clear();
            vars[i].readspec();
        }

        clear();

        done[midy][midx] = 1;
        done[midy+d[0][0]][midx+d[0][1]] = 1;
        queue< pii > q;
        pii u;
        q.push( pii(midy+d[0][0], midx+d[0][1]) );

        int now = 0;
        int cnt = 0;
        visi[midy][midx][0] = 1;


        while( !q.empty() ){
            u = q.front(); q.pop();


            int x=-1,l;
            int mx = 0,f = 0;
            for( int i = 1; i <= n; ++i ){
                if( used[i] ) continue;
                for( int a = 0; a <= 5; ++a ){
                    lnk[u.f][u.s] = i;
                    vars[i].angle = a;

                    int b = bonus( u );

                    lnk[u.f][u.s] = 0, vars[i].angle = 0;

                    if( b > mx || b == mx && freeaccess > f )
                        mx = b, x = i, l = a, f = freeaccess;
                }
            }

            if( x == -1 ) continue;

            used[x] = 1;
            lnk[u.f][u.s] = x, vars[x].angle = l;

            bonus( u , 1 );

            for( int i = 0; i < 6; ++i ){
                if( visi[u.f][u.s][i] == 0 ) continue;

                int r = u.f + d[i][0];
                int c = u.s + d[i][1];

                if( done[r][c] || !ok[r][c] ) continue;
                done[r][c] = 1;

                q.push( pii(r, c) );
            }
        }

        for( int i = 0; i < sz; ++i ){
            int x = lnk[ bitni[i].f ][ bitni[i].s ];

            if( !x )
            for( int k = 1; k <= n; ++k ) if( !used[k] ){
                used[k] = 1;
                lnk[ bitni[i].f ][ bitni[i].s ] = k;
                break;
            }
            x = lnk[ bitni[i].f ][ bitni[i].s ];
        }

        for( int i = 0; i < sz; ++i ){
            int x = lnk[ bitni[i].f ][ bitni[i].s ];
            int y = vars[x].angle;

            int better = -1,c;

            for( int k = 0; k <= 5; ++k ){
                vars[x].angle = k;
                int v = calc_sol();
                if( better < v ) better = v, c = k;
            }

            vars[x].angle = c;
        }


        int cc = 5;
        if( T == 9 ) cc = 20;
        if( T == 16 ) cc = 4;

        while( cc -- ){

            for( int i = 0; i <= sz; ++i )
                for( int j = 0; j < 6; ++j )
                    chk[i][j] = 0;
            int pokusaj = 9000;

        // if tests == 16 postavi na 5000 pokusaja, inace postavi na 10000

            int tmp = calc_sol();
            for( int i = 0; i < pokusaj; ++i ){
                int a = 1 + rand()%sz;
                int b = 1 + rand()%sz;

                int r1 = bitni[a].f, c1 = bitni[a].s;
                int r2 = bitni[b].f, c2 = bitni[b].s;

                int p1 = vars[ lnk[r1][c1] ].angle, p2 = vars[ lnk[r2][c2] ].angle;
                int rot1 = rand()%6, rot2 = rand()%6;

                if( chk[a][rot1] || chk[b][rot2] ) continue; // GRESKA! swap( a,b ) , mijenja swap(b,c)
                chk[a][rot1] = chk[b][rot2] = 1;

                vars[ lnk[r1][c1] ].angle = rot1, vars[ lnk[r2][c2] ].angle = rot2;

                int u = lnk[r1][c1];
                lnk[r1][c1] = lnk[r2][c2];
                lnk[r2][c2] = u;

                int nw = calc_sol();

                if( nw > tmp ){
                    tmp = nw;
                }else{
                    int u = lnk[r1][c1];
                    lnk[r1][c1] = lnk[r2][c2];
                    lnk[r2][c2] = u;

                    vars[ lnk[r1][c1] ].angle = p1, vars[ lnk[r2][c2] ].angle = p2;
                }

            }

        }


        for( int i = 0; i < sz; ++i ){
            int x = lnk[ bitni[i].f ][ bitni[i].s ];
            printf("%d %d\n",x-1,vars[x].angle);
        }

       // for( int i = 1; i <= n; ++i )
       //     if( used[i] == 0 ) EXIT(-1);
        //cout<<"COST: "<<calc_sol()<<" , "<<n<<endl;
        //solcase += calc_sol();
    }
   // printf("TOTAL: %d\n",solcase);

    return 0;
}

const char* pieceTypes[] = {
  "0 1 .",     //0
  "0 2 .",     //1
  "0 3 .",     //2
  "0 1 2 .",   //3
  "0 1 3 .",   //4
  "0 1 4 .",   //5
  "0 1 2 3 .", //6
  "0 1 2 4 .", //7
  "0 1 3 4 .", //8
  "0 1 ; 2 3 .",  //9
  "0 1 2 3 4 .",  //10
  "0 1 2 3 4 5 .",    //11
  "0 1 ; 2 3 ; 4 5 ." //12
  };

static int numberOfTitles(int radius){
       return 3 * (radius * radius + radius);
       }

class PipesCase : public TestCase {
public:   
        PipesCase(){};     
        PipesCase(int r){radius = r;};
        
        void addTitle(int t){ titles.push_back(pieceTypes[t]);}
        
        void randomize(){
           random_shuffle(titles.begin(), titles.end());
        }
        
        string toString(){
          stringstream ss;
          
          randomize();
          
          ss << radius << endl; 
          for (vector<const char*>::iterator it = titles.begin(); it != titles.end(); it++){
            ss << *it << endl;     
          }
          ss << endl;
          return ss.str();
                     
        }
        
private: 
        vector<const char*> titles;       
        int radius;
};


PipesCase* trulyRandomCase(int radius){
    PipesCase* myCase = new PipesCase(radius);
    for (int i=0; i < numberOfTitles(radius); i++) myCase->addTitle(rand()%13);    
    return myCase; 
}

PipesCase* sparseRandomCase(int radius){
    PipesCase* myCase = new PipesCase(radius);
    for (int i=0; i < numberOfTitles(radius); i++){
        if (i%3 != 0)  myCase->addTitle(rand()%6);  // 2/3 of the pieces are from range 0-5
        else  myCase->addTitle(rand()%13);    
    }
    return myCase; 
}

PipesCase* denseRandomCase(int radius){
    PipesCase* myCase = new PipesCase(radius);
    for (int i=0; i < numberOfTitles(radius); i++){
        if (i%3 != 0)  myCase->addTitle(rand()%6 + 6);  // 2/3 of the pieces are from range 6 - 11
        else  myCase->addTitle(rand()%13);    
    }
    return myCase; 
}

PipesCase* disjointRandomCase(int radius){
    PipesCase* myCase = new PipesCase(radius);
    for (int i=0; i < numberOfTitles(radius); i++){
        if (i%3 == 0)  myCase->addTitle(9);  // 1/3 of the pieces are type 9
        else if (i%3 == 1) myCase->addTitle(12); //and 1/3 is of type 12
        else  myCase->addTitle(rand()%13);    
    }
    return myCase; 
}


void randomCases(TestSet &cases){
       for (int i = 1; i <= 19; i += 6){
         cases.addTestCase(trulyRandomCase(i));
         cases.addTestCase(sparseRandomCase(i));
         cases.addTestCase(denseRandomCase(i));
         cases.addTestCase(disjointRandomCase(i));
       }
     }
     
void bigRandomCases(TestSet &cases){
         cases.addTestCase(sparseRandomCase(25));
         cases.addTestCase(disjointRandomCase(25));
}

#include <iostream>
#include <cstdio>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
#include <vector>
#include <queue>
#include <algorithm>
#include <cstdlib>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

// TODO: u slucaju istih 'bonusa' izabrati onaj koji ima najvise pristup praznim poljima


int d[][2] = { {-1,-1}, {-1,1}, {0,2}, {1,1}, {1,-1}, {0,-2} };

const int maxr = 25;
const int maxb = 3*(maxr*maxr+maxr);
const int midx = 250, midy = 250;
int tmp[100],sztmp;

struct block{
    int angle;
    bool mat[10][10];
    block(){};

    void clear(){ angle=0;memset( mat, 0, sizeof(mat)); }

    void readspec(){
        char c; sztmp = 0;
        while( c=getchar() ){
            if( c >= '0' && c <= '9' ) tmp[sztmp++] = c;
            if( c == ';' || c == '.' ){
                for( int i = 0; i < sztmp; ++i )
                    for( int j = 0; j < sztmp; ++j )
                        mat[ tmp[i]-'0' ][ tmp[j]-'0' ] = 1;
                sztmp = 0;
                if( c == '.' ) break;
            }
        }
    }
};

struct qdat{
    int f,s;
    qdat(){};
    qdat( int p1, int p2 ):f(p1),s(p2){};
};

int r,n;
int dst[500][500];

void prec(){
    queue< pii > q;
    q.push( mk(midy,midx) );
    dst[midy][midx] = 1;
    pii u;

    int cnt = 0;
    while(!q.empty()){
        u = q.front(); q.pop();

        if( dst[u.f][u.s] == 61 ) continue;

        for( int i = 0; i < 6; ++i ){
            int c = u.s + d[i][1];
            int r = u.f + d[i][0];

            if( dst[r][c] ) continue;
            dst[r][c] = dst[u.f][u.s] + 1;
            q.push( mk(r,c) );
        }
    }
}

block vars[maxb];
bool used[30000];
bool ok[500][500];
int lnk[500][500];
bool done[500][500];
bool visi[500][500][6];
pii bitni[30000]; int sz = 0;

int cost ;

void dfs( int r, int c, int x ){
    int h = lnk[r][c], l = vars[h].angle;
    x = (x-l+6)%6;

    if( visi[r][c][x] || ok[r][c] == 0 || (r==250&&c==250) ) return;

    for( int i = 0; i < 6; ++i ) if( vars[h].mat[x][i] ) visi[r][c][i] = 1, cost++;

    for( int i = 0; i < 6; ++i ){
        if( vars[h].mat[x][i] == 0 ) continue;
        dfs( r+d[(i+l)%6][0], c+d[(i+l)%6][1], (i+3+l)%6 );
    }
}

int calc_sol(){
    cost = 0;
    for( int i = 0; i < sz; ++i )
        for( int j = 0; j < 6; ++j )
            visi[bitni[i].f][bitni[i].s][j] = 0;
    dfs( midy+d[0][0], midx+d[0][1], 3 );
    return cost;
}

void clear(){
    sz = 0;
    memset( visi, 0, sizeof(visi));
    memset( ok, 0, sizeof(ok));
    memset( used, 0, sizeof(used));

    for( int i = 0; i < 500; ++i ){
        for( int j = 0; j < 500; ++j ){
            if( dst[i][j] <= r+1 && dst[i][j] > 1 )
                ok[i][j] = 1, bitni[sz++] = mk(i,j);
            lnk[i][j] = done[i][j] = 0;
        }
    }
}

int water[6];
int mem[6];

bool debugmode = 0;
int freeaccess;

int bonus( qdat u, bool update = 0 ){
    for( int i = 0; i < 6; ++i ) water[i] = mem[i] = 0;
    freeaccess = 0;

    int ret = 0;
    for( int i = 0; i < 6; ++i ){
        int r = u.f + d[i][0];
        int c = u.s + d[i][1];

        if( ok[r][c] == 0 && (r!=250 || c!=250) )  continue;

        if( visi[r][c][(i+3)%6] ) water[i] = 1;
    }

    int x = lnk[u.f][u.s];
    int a = vars[x].angle;
    for( int i = 0; i < 6; ++i ){
        int z = (i-a+6)%6;
        if( !water[i] ) continue;
        for( int j = 0; j < 6; ++j ){
            if( vars[x].mat[z][j] ){
                mem[(j+a)%6] = 1;
                if( update )visi[u.f][u.s][(j+a)%6] = 1;
            }
        }
    }

    for( int i = 0; i < 6; ++i ) ret += mem[i];

    for( int i = 0; i < 6; ++i ){
        int r = u.f + d[i][0];
        int c = u.s + d[i][1];


        if( ok[r][c] == 0 )  continue;

        if( mem[i] ) freeaccess += lnk[r][c] == 0;
    }

    return ret;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);

    prec();
    vars[0] = block();
    vars[0].clear();

    int solcase = 0;

    for( ; tests; --tests ){
        scanf("%d",&r);
        n = 3*(r*r+r);

        for( int i = 1; i <= n; ++i ){
            vars[i].clear();
            vars[i].readspec();
        }

        clear();

        done[midy][midx] = 1;
        done[midy+d[0][0]][midx+d[0][1]] = 1;
        queue< qdat > q;
        qdat u;
        q.push( qdat(midy+d[0][0], midx+d[0][1]) );

        int now = 0;
        int cnt = 0;
        visi[midy][midx][0] = 1;

        while( !q.empty() ){
            u = q.front(); q.pop();


            int x=-1,l;
            int mx = 0,f = 0;
            for( int i = 1; i <= n; ++i ){
                if( used[i] ) continue;
                for( int a = 0; a <= 5; ++a ){
                    lnk[u.f][u.s] = i;
                    vars[i].angle = a;

                    if( u.f == 249 && u.s == 251 && a == 3 && i == 1 )debugmode = 1;
                    else debugmode = 0;

                    int b = bonus( u );

                    lnk[u.f][u.s] = 0, vars[i].angle = 0;

                    if( b > mx || b == mx && freeaccess > f )
                        mx = b, x = i, l = a, f = freeaccess;
                }
            }

            if( x == -1 ) continue;

            used[x] = 1;
            lnk[u.f][u.s] = x, vars[x].angle = l;

            bonus( u , 1 );

            for( int i = 0; i < 6; ++i ){
              //  if( vars[x].mat[xs][i] == 0 ) continue;
                if( visi[u.f][u.s][i] == 0 ) continue;
                //if( debugmode ) printf("POSSIBLE: %d\n",i);

                int r = u.f + d[i][0];
                int c = u.s + d[i][1];

                if( done[r][c] || !ok[r][c] ) continue;
                done[r][c] = 1;

               // if( debugmode ) printf("FINAL PUSH: %d %d\n",r,c);

                q.push( qdat(r, c) );
            }
        }

        for( int i = 0; i < sz; ++i ){
            int x = lnk[ bitni[i].f ][ bitni[i].s ];

           // if( !x ) printf(" !!! ");

            if( !x )
            for( int k = 1; k <= n; ++k ) if( !used[k] ){
                used[k] = 1;
                lnk[ bitni[i].f ][ bitni[i].s ] = k;
                break;
            }
            x = lnk[ bitni[i].f ][ bitni[i].s ];
            //printf("%d %d\n",x-1,vars[x].angle);
        }
        //cout<<endl;

        for( int i = 0; i < sz; ++i ){
            int x = lnk[ bitni[i].f ][ bitni[i].s ];
            int y = vars[x].angle;

            int better = -1,c;

            for( int k = 0; k <= 5; ++k ){
                vars[x].angle = k;
                int v = calc_sol();
                if( better < v ) better = v, c = k;
            }

            vars[x].angle = c;
        }

        int tmp = calc_sol();
        for( int i = 0; i < 1000; ++i ){
            int a = 1 + rand()%sz;
            int b = 1 + rand()%sz;

            int r1 = bitni[a].f, c1 = bitni[a].s;
            int r2 = bitni[b].f, c2 = bitni[b].s;

            swap( lnk[r1][c1], lnk[r2][c2] );
            int nw = calc_sol();

            if( nw > tmp ){
                tmp = nw;
            }else swap( lnk[r1][c1], lnk[r2][c2] );

        }


        for( int i = 0; i < sz; ++i ){
            int x = lnk[ bitni[i].f ][ bitni[i].s ];
            printf("%d %d\n",x-1,vars[x].angle);
        }

       // for( int i = 1; i <= n; ++i )
       //     if( used[i] == 0 ) EXIT(-1);
        //cout<<"COST: "<<calc_sol()<<" , "<<n<<endl;
        solcase += calc_sol();
    }
    cout<<"TOTAL: "<<solcase<<endl;

    return 0;
}

#include <iostream>
#include <cstdio>
#include <math.h>
#include <iomanip>
#include <string.h>
#include <string>
#include <vector>
#include <queue>
#include <algorithm>
#include <cstdlib>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

// TODO: u slucaju istih 'bonusa' izabrati onaj koji ima najvise pristup praznim poljima


int d[][2] = { {-1,-1}, {-1,1}, {0,2}, {1,1}, {1,-1}, {0,-2} };

const int maxr = 25;
const int maxb = 3*(maxr*maxr+maxr);
const int midx = 250, midy = 250;
int tmp[100],sztmp;

struct block{
    int angle;
    bool mat[10][10];
    block(){};

    void clear(){ angle=0;memset( mat, 0, sizeof(mat)); }

    void readspec(){
        char c; sztmp = 0;
        while( c=getchar() ){
            if( c >= '0' && c <= '9' ) tmp[sztmp++] = c;
            if( c == ';' || c == '.' ){
                for( int i = 0; i < sztmp; ++i )
                    for( int j = 0; j < sztmp; ++j )
                        mat[ tmp[i]-'0' ][ tmp[j]-'0' ] = 1;
                sztmp = 0;
                if( c == '.' ) break;
            }
        }
    }
};

struct qdat{
    int f,s;
    qdat(){};
    qdat( int p1, int p2 ):f(p1),s(p2){};
};

int r,n;
int dst[500][500];

void prec(){
    queue< pii > q;
    q.push( mk(midy,midx) );
    dst[midy][midx] = 1;
    pii u;

    int cnt = 0;
    while(!q.empty()){
        u = q.front(); q.pop();

        if( dst[u.f][u.s] == 61 ) continue;

        for( int i = 0; i < 6; ++i ){
            int c = u.s + d[i][1];
            int r = u.f + d[i][0];

            if( dst[r][c] ) continue;
            dst[r][c] = dst[u.f][u.s] + 1;
            q.push( mk(r,c) );
        }
    }
}

block vars[maxb];
bool used[30000];
bool ok[500][500];
int lnk[500][500];
bool done[500][500];
bool visi[500][500][6];
pii bitni[30000]; int sz = 0;

int cost ;

void dfs( int r, int c, int x ){
    int h = lnk[r][c], l = vars[h].angle;
    x = (x-l+6)%6;

    if( visi[r][c][x] || ok[r][c] == 0 || (r==250&&c==250) ) return;

    for( int i = 0; i < 6; ++i ) if( vars[h].mat[x][i] ) visi[r][c][i] = 1, cost++;

    for( int i = 0; i < 6; ++i ){
        if( vars[h].mat[x][i] == 0 ) continue;
        dfs( r+d[(i+l)%6][0], c+d[(i+l)%6][1], (i+3+l)%6 );
    }
}

int calc_sol(){
    cost = 0;
    for( int i = 0; i < sz; ++i )
        for( int j = 0; j < 6; ++j )
            visi[bitni[i].f][bitni[i].s][j] = 0;
    dfs( midy+d[0][0], midx+d[0][1], 3 );
    return cost;
}

void clear(){
    sz = 0;
    memset( ok, 0, sizeof(ok));
    memset( used, 0, sizeof(used));

    for( int i = 0; i < 500; ++i ){
        for( int j = 0; j < 500; ++j ){
            for( int k = 0; k < 6; ++k ) visi[i][j][k] = 0;

            if( dst[i][j] <= r+1 && dst[i][j] > 1 )
                ok[i][j] = 1, bitni[sz++] = mk(i,j);
            lnk[i][j] = done[i][j] = 0;
        }
    }
}

int water[6];
int mem[6];

int freeaccess;

int bonus( qdat u, bool update = 0 ){
    for( int i = 0; i < 6; ++i ) water[i] = mem[i] = 0;
    freeaccess = 0;

    int ret = 0;
    for( int i = 0; i < 6; ++i ){
        int r = u.f + d[i][0];
        int c = u.s + d[i][1];

        if( ok[r][c] == 0 && (r!=250 || c!=250) )  continue;

        if( visi[r][c][(i+3)%6] ) water[i] = 1;
    }

    int x = lnk[u.f][u.s];
    int a = vars[x].angle;
    for( int i = 0; i < 6; ++i ){
        int z = (i-a+6)%6;
        if( !water[i] ) continue;
        for( int j = 0; j < 6; ++j ){
            if( vars[x].mat[z][j] ){
                mem[(j+a)%6] = 1;
                if( update )visi[u.f][u.s][(j+a)%6] = 1;
            }
        }
    }

    for( int i = 0; i < 6; ++i ) ret += mem[i];

    for( int i = 0; i < 6; ++i ){
        int r = u.f + d[i][0];
        int c = u.s + d[i][1];


        if( ok[r][c] == 0 )  continue;

        if( mem[i] ) freeaccess += lnk[r][c] == 0;
    }

    return ret;
}

bool chk[30000][6];

int main(){
    freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);

    prec();
    vars[0] = block();
    vars[0].clear();

    int solcase = 0;

    int T = tests;

    for( ; tests; --tests ){
        scanf("%d",&r);
        n = 3*(r*r+r);

        for( int i = 1; i <= n; ++i ){
            vars[i].clear();
            vars[i].readspec();
        }

        clear();

        done[midy][midx] = 1;
        done[midy+d[0][0]][midx+d[0][1]] = 1;
        queue< qdat > q;
        qdat u;
        q.push( qdat(midy+d[0][0], midx+d[0][1]) );

        int now = 0;
        int cnt = 0;
        visi[midy][midx][0] = 1;


        while( !q.empty() ){
            u = q.front(); q.pop();


            int x=-1,l;
            int mx = 0,f = 0;
            for( int i = 1; i <= n; ++i ){
                if( used[i] ) continue;
                for( int a = 0; a <= 5; ++a ){
                    lnk[u.f][u.s] = i;
                    vars[i].angle = a;

                    int b = bonus( u );

                    lnk[u.f][u.s] = 0, vars[i].angle = 0;

                    if( b > mx || b == mx && freeaccess > f )
                        mx = b, x = i, l = a, f = freeaccess;
                }
            }

            if( x == -1 ) continue;

            used[x] = 1;
            lnk[u.f][u.s] = x, vars[x].angle = l;

            bonus( u , 1 );

            for( int i = 0; i < 6; ++i ){
                if( visi[u.f][u.s][i] == 0 ) continue;

                int r = u.f + d[i][0];
                int c = u.s + d[i][1];

                if( done[r][c] || !ok[r][c] ) continue;
                done[r][c] = 1;

                q.push( qdat(r, c) );
            }
        }

        for( int i = 0; i < sz; ++i ){
            int x = lnk[ bitni[i].f ][ bitni[i].s ];

            if( !x )
            for( int k = 1; k <= n; ++k ) if( !used[k] ){
                used[k] = 1;
                lnk[ bitni[i].f ][ bitni[i].s ] = k;
                break;
            }
            x = lnk[ bitni[i].f ][ bitni[i].s ];
        }

        for( int i = 0; i < sz; ++i ){
            int x = lnk[ bitni[i].f ][ bitni[i].s ];
            int y = vars[x].angle;

            int better = -1,c;

            for( int k = 0; k <= 5; ++k ){
                vars[x].angle = k;
                int v = calc_sol();
                if( better < v ) better = v, c = k;
            }

            vars[x].angle = c;
        }


        int cc = 2;
        if( T == 9 ) cc = 5;

        while( cc -- ){

            for( int i = 0; i <= sz; ++i )
                for( int j = 0; j < 6; ++j )
                    chk[i][j] = 0;
            int pokusaj = 10000;

        // if tests == 16 postavi na 5000 pokusaja, inace postavi na 10000

            int tmp = calc_sol();
            for( int i = 0; i < pokusaj; ++i ){
                int a = 1 + rand()%sz;
                int b = 1 + rand()%sz;

                int r1 = bitni[a].f, c1 = bitni[a].s;
                int r2 = bitni[b].f, c2 = bitni[b].s;

                int p1 = vars[ lnk[r1][c1] ].angle, p2 = vars[ lnk[r2][c2] ].angle;
                int rot1 = rand()%6, rot2 = rand()%6;

                if( chk[a][rot1] && chk[b][rot2] ) continue; // GRESKA! swap( a,b ) , mijenja swap(b,c)
                chk[a][rot1] = chk[b][rot2] = 1;

                vars[ lnk[r1][c1] ].angle = rot1, vars[ lnk[r2][c2] ].angle = rot2;
                swap( lnk[r1][c1], lnk[r2][c2] );

                int nw = calc_sol();

                if( nw > tmp ){
                    tmp = nw;
                }else{
                    swap( lnk[r1][c1], lnk[r2][c2] );
                    vars[ lnk[r1][c1] ].angle = p1, vars[ lnk[r2][c2] ].angle = p2;
                }

            }

        }


        for( int i = 0; i < sz; ++i ){
            int x = lnk[ bitni[i].f ][ bitni[i].s ];
            printf("%d %d\n",x-1,vars[x].angle);
        }

       // for( int i = 1; i <= n; ++i )
       //     if( used[i] == 0 ) EXIT(-1);
        //cout<<"COST: "<<calc_sol()<<" , "<<n<<endl;
        solcase += calc_sol();
    }
    cout<<"TOTAL: "<<solcase<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <fstream>
#include <algorithm>
#include <string>
#include <map>
#include <string.h>
#include <math.h>
#include <iomanip>
#include <fstream>
using namespace std;

bool chk[100000];

int main(){
    ifstream tc("Ulaz.txt");
    ifstream out("Izlaz.txt");

    int tests;
    tc >> tests;

    bool ok = 1;

    for( ; tests; --tests){
        int r,n;
        tc >> r >> ws;
        n = 3*(r*r+r);

        for( int i = 0; i < n; ++i ){
            string tmp;
            getline(tc,tmp);
        }

        memset( chk, 0, sizeof(chk));
        for( int i =0 ; i < n; ++i ){
            int a,b;
            out >> a >> b;
            if( chk[a] ) ok = 0, printf("!\n");
            chk[a] = 1;
        }
    }
    if( ok == 0 ) printf("WRONG!\n");
    else printf("OKAY!\n");

    return 0;
}


#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <math.h>
#include <stack>
#include <complex>
using namespace std;

const int maxn = 105;

int v[maxn];

int main(){
    int n; scanf("%d",&n);

    for( int i = 0; i < n; ++i ) scanf("%d",&v[i]);

    int prv = v[n-1], sol = 0;
    for( int i = n-2; i >= 0; --i ){
        if( prv <= v[i] ) sol += v[i]-prv + 1, prv --;
        else prv = v[i];
    }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <math.h>
#include <stack>
#include <complex>
using namespace std;

const int lg = 19;
const int maxn = 200055;
const int inf = 99999999;

struct node{
    int maxx,left,right,tot;
    node(){};
    node( int p1, int p2, int p3, int p4 ):maxx(p1),left(p2),right(p3),tot(p4){};
};

inline void check( node &x ){
    if( x.maxx < -inf ) x.maxx = -inf;
    if( x.left < -inf ) x.left = -inf;
    if( x.right < -inf ) x.right = -inf;
    if( x.tot < -inf ) x.tot = -inf;
}

struct segment_tree{
    int begin,lq,rq;
    node *tree;

    segment_tree(){};

    segment_tree( int n ){
        int sz = 1;
        while( sz < n ) sz <<= 1;

        begin = sz;
        sz <<= 1;

        tree = new node[sz];
        for( int i = 0; i < sz; ++i ) tree[i] = node(0,0,0,0);
    }

    node _query( int dx , int lo , int hi ){

        if( lo >= (begin<<1) ) return node(-inf,-inf,-inf,-inf);
        if( lq <= lo && hi <= rq ) return tree[dx];

        int mid = (lo+hi)>>1;
        if( lq <= mid && mid < rq ){
            node n1,n2;
            n1 = _query( dx*2, lo , mid );
            n2 = _query( dx*2+1, mid+1, hi );

            node ret = node(-inf,-inf,-inf,-inf);

            ret.left  = max( n1.left , n1.tot + n2.left );
            ret.right = max( n2.right , n2.tot + n1.right );
            ret.tot   = n1.tot + n2.tot;
            ret.maxx  = max( n1.maxx , n2.maxx );
            ret.maxx  = max( ret.maxx , n1.right + n2.left );

            check(ret);

            return ret;
        }

        if( lq <= mid ) return _query( dx*2 , lo , mid );
        else  if( mid < rq )return _query( dx*2+1, mid + 1 , hi );

        return node(-inf,-inf,-inf,-inf);
    }

    node query(){
        lq = begin;
        rq = begin*2-1;
        return _query( 1 , begin , begin * 2 - 1 );
    }


    void modify( int dx , int val ){
        dx += begin;
        tree[dx] = node(val,val,val,val);

        while( dx != 1 ){
            dx >>= 1;

            int L = dx<<1;
            int R = (dx<<1)+1;

            tree[dx].left  = max( tree[L].left , tree[L].tot + tree[R].left );
            tree[dx].right = max( tree[R].right , tree[R].tot + tree[L].right );
            tree[dx].tot   = tree[L].tot + tree[R].tot;
            tree[dx].maxx  = max( tree[L].maxx , tree[R].maxx );
            tree[dx].maxx  = max( tree[dx].maxx , tree[L].right + tree[R].left );

            check( tree[dx] );
        }

    }

};


int n,m;
bool curr[maxn];
segment_tree A,B;

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    scanf("%d%d",&n,&m);

    A = segment_tree( n );
    B = segment_tree( n );

    for( int i = 0; i < n; i += 2 ) A.modify( i , -inf ), B.modify( i , 1 );
    for( int i = 1; i < n; i += 2 ) B.modify( i , -inf ), A.modify( i , 1 );

    for( int i = 0; i < m; ++i ){
        int a; scanf("%d",&a);
        a--;
        int v = 1;

        if( a % 2 == 0 && curr[a] == 0 ){
            if( curr[a] == 0 ){
                A.modify( a , 1 );
                B.modify( a , -inf );
            }
        }else if( curr[a] == 0 ){
            A.modify( a , -inf );
            B.modify( a , 1 );
        }else if( a % 2 == 0 ) A.modify( a , -inf ), B.modify( a , 1 );
        else B.modify( a , -inf ), A.modify( a , 1 );

        curr[a] = !curr[a];
        printf("%d\n", max(A.query().maxx , B.query().maxx ) );
    }


    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <math.h>
#include <stack>
#include <complex>
using namespace std;

typedef long long ll;

const int maxn = 500000;

int n,m;
bool x[maxn];

int solve(){
    int ret = 1, curr = 1;

    for( int i = 1; i < n; ++i ){
        if( x[i] != x[i-1] ) curr ++;
        else curr = 1;
        ret = max( curr , ret );
    }
    return ret;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
    scanf("%d%d",&n,&m);

    for( int i = 0; i < m; ++i ){
        int a; scanf("%d",&a); a--;
        x[a] = !x[a];

        printf("%d\n",solve());
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <map>
#include <string.h>
#include <string>
#include <math.h>
#include <stack>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 100000 + 555;
const int mod = 1000000007;

typedef long long ll;


int n,m;
int v[maxn];
int prefix[maxn];
int range[maxn];

const int inf = 999999999;

struct segment_tree{
    vector< int > tree;
    int begin;

    segment_tree(){};
    segment_tree( int n ){
        int sz = 1;
        while( sz <= n ) sz <<= 1;
        begin = sz;
        sz <<= 1;
        tree.resize(sz);
        for( int i = 0; i < sz; ++i ) tree[i] = inf;
    }
    int l,r,v;

    int _query( int node, int lo, int hi ){
        if( node >= begin && tree[node] <= v ) return node;
    }

    int query( int lo, int hi, int val ){
        l = lo + begin;
        r = hi + begin;
        v = val;
        return _query( 1 , begin, begin*2 -1 )-begin;
    }

    void update( int dx, int v ){
        dx += begin;
        tree[dx] = v;
        while( dx != 1 ){
            dx >>= 1;
            tree[dx] = min( tree[dx*2], tree[dx*2+1] );
        }
    }
};

int main(){
   // freopen("Ulaz.txt","r",stdin);
  //  freopen("Izlaz2.txt","w",stdout);

    scanf("%d%d",&n,&m);
    for( int i = 1; i <= n; ++i ) scanf("%d",&v[i]);

    for( int i = 1; i <= n; ++i ) prefix[i] = prefix[i-1] + v[i];

    for( int i = 1; i <= n; ++i ){
        int s = -1;
        int lo = i, hi = n;
        while( lo <= hi ){
            int mid = (lo+hi)>>1;
            int ss = prefix[mid] - prefix[i-1];
            if( ss <= m ) lo = mid + 1 , s = mid;
            else hi = mid - 1;
        }
        range[i] = s;
    }

    for( int i = 1; i <= n; ++i ){
        if( range[i] < 0 ){
            printf("0\n",i);
            continue;
        }
        int r = range[i] - i + 1;
        int sol = 0;

        for( int j = i+1; j <= range[i]+1; ++j ){
            if( i >= -range[j]+2*j-1 ) sol = max( sol , (j-i)*2 );
        }
        printf("%d\n",sol);
    }


    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:tdec
*/
#include <iostream>
#include <math.h>
#include <string.h>
#include <string>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;

#define len(x) (int)strlen(x)
#define SZ(x) (int)x.size()
#define all (x.begin(),x.end())
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

const int maxn = 100000 + 55;
const int maxe = 2*maxn;

int n;
int cnt[maxn],cost[maxn];
int subcost[maxn];

int cnte = 1;
int point[maxe],nxt[maxe],head[maxn];

inline void add_edge( int a, int b ){
    nxt[cnte] = head[a], point[cnte] = b, head[a] = cnte ++;
}


ll sol = 0;

ll dfs( int node ){
    ll cntuk = 0;

    for( int i = head[node]; i >= 1; i = nxt[i] )
        cntuk += dfs( point[i] );

    sol += subcost[node]*max(cnt[node]-cntuk,0LL);
    return cntuk + max(cnt[node]-cntuk,0LL);
}

int getmin( int node ){
    subcost[node] = cost[node];
    for( int i = head[node]; i >= 1; i = nxt[i] )
        subcost[node] = min( subcost[node], getmin( point[i] ) );
    return subcost[node];
}

int main(){
    freopen("tdec.in","r",stdin);
    freopen("tdec.out","w",stdout);
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        int p,c,t; scanf("%d%d%d",&p,&c,&t);  //(1 <= P_e <= N)
                                              //(0 <= C_i <= 10,000,000)
                                              //(1 <= T_i<= 100))
        --p;
        cnt[i] = c;
        cost[i] = t;
        if( p != -2 )add_edge( p, i );
    }

    getmin( 0 );
    dfs( 0 );

    cout << sol << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <math.h>
#include <stack>
#include <complex>
using namespace std;

const int maxn = 1005;

int n;
int a[maxn];

int main(){
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ) scanf("%d",&a[i]);

    int sol = 0;
    for( int i = 0; i < n; ++i ){
        for( int j = i+1; j < n; ++j ){
            if( a[j] <= a[j-1] ) break;
            sol = max( sol , a[j] - a[i] );
        }
    }
    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <math.h>
#include <stack>
#include <complex>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

int h,w;
char mat[10][10];
bool visi[10][10];
bool tmp[10][10];

queue< pii > q;
int d[][2] = { {-1,0} , {0,1} , {1,0} , {0,-1} };

int solve( int r, int c, int dir ){
    if( r == h && c == w-1 ) return 1;
    else if( r < 0 || c < 0 || r >= h || c >= w || mat[r][c] == '#' ) return 0;
    else if( visi[r][c] ) return 0;

    visi[r][c] = 1;

    memcpy( tmp , visi , sizeof visi );
    q.push( mk(r,c) );

    bool ok = 0;
    while( !q.empty() ){
        pii u = q.front(); q.pop();
        if( u.f == h-1 && u.s == w-1 )ok = 1;

        for( int i = 0; i < 4; ++i ){
            int r = u.f + d[i][0];
            int c = u.s + d[i][1];
            if( r < 0 || c < 0 || r >= h || c >= w || tmp[r][c] ) continue;
            tmp[r][c] = 1;
            q.push( mk(r,c) );
        }
    }

    if( !ok ) return 0;

    int sol = 0;

    for( int i = 0; i < 4; ++i ){
        if( i == dir ) continue;
        sol += solve( r + d[i][0] , c + d[i][1] , (i + 2) % 4 );
    }

    visi[r][c] = 0;
    return sol;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&h,&w);
    for( int i = 0; i < h; ++i )
        scanf("%s",mat[i]);

    int sol = solve( 0 , 0 , 0 );

    printf("%d\n",sol%10007);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
using namespace std;

int n,m;
int a[50505];
int sol[50505];
int sz[50505];

int main(){
    freopen("Ulaz.txt","r",stdin);
  // freopen("Izlaz.txt","w",stdout);

    int tests; scanf("%d",&tests);
    for( ; tests; --tests) {
        scanf("%d%d",&n,&m);
        int groups = n / m;

        for( int i = 0; i < n; ++i )
            scanf("%d",&a[i]);

        memset( sz, 0, sizeof(sz));

        bool ok = 1;
        int s = 0;
        sort( a , a + n );

        for( int i = 0; i < n; ++i ) printf("%d ",a[i]);
        printf("\n");

        for( int i = 0; i < n && ok;  ){
            while( sz[s] == m ) s ++;

            int x = s;
            do{
                if( x == groups ) ok = 0;
                sol[ x*m + sz[x] ] = a[i];
                sz[x]++;
                x ++;

                i++;
            }while( i < n && a[i] == a[i-1] && ok );
        }

        if( ok ) for( int i = 0; i < n; ++i ) printf("%d ",sol[i]);
        else printf("-1");
        printf("\n");

    }
    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <map>
#include <set>
#include <iomanip>
#include <queue>
#include <math.h>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 500055;

int n,m,groups;
int v[maxn];

int cnt[maxn], inside[maxn];
int sol[maxn];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d%d",&n,&m);
        groups = n / m;

        memset( cnt , 0, sizeof(cnt));

        set< int > s;
        vector< int > lox;
        bool possible = 1;

        for( int i = 0; i < n; ++i ){
            scanf("%d",&v[i]);
            lox.push_back( v[i] );
        }
        sort( lox.begin(), lox.end() );
        lox.erase( unique(lox.begin(), lox.end()) , lox.end() );

        for( int i = 0; i < n; ++i ){
            v[i] = lower_bound( lox.begin(), lox.end(), v[i] ) - lox.begin();
            cnt[ v[i] ] ++;
            s.insert( v[i] );

            if( cnt[ v[i] ] > groups ) possible = 0;
        }

        if( !possible ){
            printf("-1\n");
            continue;
        }

        priority_queue< pii > pq;
        priority_queue< int > low;

        for( int i = 0; i < lox.size(); ++i ){
            pq.push( mk(cnt[ lox[i] ], lox[i] ) );
            low.push( lox[i] - maxn );
        }


        for( int i = 0; i < groups; ++i ){

            int c = 0;
            while( !pq.empty() && pq.top().f == groups - i ){
                int v = pq.top().s, x = pq.top().f; pq.pop();
                if( x != cnt[v] ) continue;

                inside[v] = 1;
                cnt[v]--;

                while( i*m >= maxn );
                sol[i*m+c] = v;
                c++;

                pq.push( mk( cnt[v] , v ) );
                if( cnt[v] == 0 ) s.erase( v );
            }

            vector< int > er;

            for( set< int > :: iterator it = s.begin(); c < m && it != s.end(); ++c, ++it ){
                if( inside[ *it ] ) continue;
                inside[ *it ] = 1;
                cnt[*it] --;

                sol[i*m+c] = *it;

                pq.push( mk( cnt[*it] , *it ) );
                if( cnt[*it] == 0 ) er.push_back( *it );
            }

            for( int j = 0 ; j < er.size(); ++j ) s.erase( er[j] );
            sort( sol + i*m , sol + (i+1)*m );

            for( int j = i*m; j < (i+1)*m; ++j )
                inside[ sol[j] ] = 0;
        }

        for( int i = 0; i < n; ++i )
            printf("%d ",lox[sol[i]]);
        printf("\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <algorithm>
#include <cstdio>
#include <map>
#include <cstdlib>
using namespace std;

map<int,int> cnt;

int main(){
    freopen("Ulaz.txt","w",stdout);
    int tests = 10;
    cout<<tests<<endl;
    for( ; tests; --tests ){
        int n = 1 + rand()%200;

        int m = 1;
        while(1){
            m = 1 + rand()%(n/2);
            if( n % m == 0 ) break;
        }

        cnt.clear();
        printf("%d %d\n",n,m);
        int groups = n / m;
        for( int i = 0; i < n; ++i ){
            int v;
            while(1){
                v = 1 + rand()%100;
                if( cnt[v]  < groups ) break;
            }
            cnt[v] ++;
            printf("%d ",v);
        }
        printf("\n");
    }
    return 0;
}

#include <cstdio>
#include <queue>
#include <algorithm>
#include <iostream>
#include <cstdlib>
#include <string.h>
#include <string>
#include <map>
using namespace std;

const int maxn = 50000 + 55;
const int inf = 999999999;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

int n,m,groups;
int v[maxn], sol[maxn];
int cnt[maxn];

vector< int > lox;

void clear(){
    lox.clear();
    memset( cnt, 0, sizeof(cnt));
}

void input(){
    scanf("%d%d",&n,&m);
    groups = n / m;

    for( int i = 0; i < n; ++i ){
        scanf("%d",&v[i]);
        lox.push_back( v[i] );
    }

    sort( lox.begin(), lox.end() );
    lox.erase( unique(lox.begin(),lox.end()), lox.end() );

    for( int i = 0; i < n; ++i ){
        v[i] = lower_bound( lox.begin(), lox.end(), v[i] ) - lox.begin();
        cnt[ v[i] ]++;
    }
}

bool possible(){
    for( int i = 0; i < lox.size(); ++i )
        if( cnt[i] > groups )
            return 0;
    return 1;
}

bool taken[maxn];

void solve(){
    priority_queue< pii > fq;
    priority_queue< int > low;

    for( int i = 0; i < lox.size(); ++i ){
        fq.push( mk( cnt[i] , i ) );
        low.push( inf - i );
    }

    for( int i = 0; i < groups; ++i ){

        int pos = 0;
        while( !fq.empty() && fq.top().f == groups-i ){
            int x = fq.top().s, v = fq.top().f;
            fq.pop();

            if( cnt[x] != v ){
                fq.push( mk( cnt[x] , x ) );
                continue;
            }

            cnt[x]--;
            taken[x]=1;
            sol[i*m+pos] = x;
            pos++;

            fq.push( mk( cnt[x] , x ) );
        }

        int rem = m - pos;
        while( rem -- ){
            int x = inf-low.top(); low.pop();
            if( !cnt[x] || taken[x] ){ rem++; continue; }

            cnt[x] --;
            sol[i*m+pos] = x;
            pos++;
        }

        sort( sol + i*m, sol + (i+1)*m);

        for( int j = i*m; j < (i+1)*m; ++j ){
            if( cnt[ sol[j] ] ) low.push( inf - sol[j] );
            taken[ sol[j] ] = 0;
        }

    }
}

void printsol(){
    for( int i = 0; i < n; ++i )
        printf("%d ",lox[ sol[i] ] );
    printf("\n");
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        clear();
        input();

        if( !possible() ){
            printf("-1\n");
            continue;
        }


        solve();
        printsol();
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <iomanip>
#include <math.h>
using namespace std;

const int inf = 1119999999;
const int maxn = 80;

int h,w;
int mat[maxn][maxn];
int ss[maxn][maxn];

inline int rectsum( int r1, int c1, int r2, int c2 ){
    int ret = ss[r2][c2];
    if( r1 && c1 ) ret += ss[r1-1][c1-1];
    if( r1 ) ret -= ss[r1-1][c2];
    if( c1 ) ret -= ss[r2][c1-1];
    return ret;
}

int dp[maxn][maxn][maxn][maxn];
bool visi[maxn][maxn][maxn][maxn];

int solve( int r1, int c1, int r2, int c2 ){
    if( r1 > r2 || c1 > c2 ) return inf;

    int &sol = dp[r1][c1][r2][c2];
    if( visi[r1][c1][r2][c2] ) return sol;
    visi[r1][c1][r2][c2] = 1;

    int s;
    sol = rectsum(r1,c1,r2,c2);
    if( sol > (s=solve(r1+1,c1,r2,c2)) ) sol = s;
    if( sol > (s=solve(r1,c1+1,r2,c2)) ) sol = s;
    if( sol > (s=solve(r1,c1,r2-1,c2)) ) sol = s;
    if( sol > (s=solve(r1,c1,r2,c2-1)) ) sol = s;

    return sol;
}

int main(){
  //  freopen("Ulaz.txt","r",stdin);

    while( scanf("%d%d",&h,&w) ){
        if( h == 0 && w == 0 ) break;

        for( int i = 0; i < h; ++i )
            for( int j = 0; j < w; ++j )
                scanf("%d",&mat[i][j]);

        for( int i = 0; i < h; ++i )
            for( int j = 0; j < w; ++j )
                ss[i][j] = (j?ss[i][j-1]:0) + mat[i][j];

        for( int i = 0; i < w; ++i )
            for( int j = 1; j < h; ++j )
                ss[j][i] += ss[j-1][i];

        for( int i = 0; i < h; ++i )
            for( int j = 0; j < w; ++j )
                for( int k = 0; k < h; ++k )
                    for( int l = 0; l < w; ++l )
                        visi[i][j][k][l] = 0;

        solve( 0 , 0 , h-1, w-1 );

        int sol = -inf;
        for( int r1 = 0; r1 < h; ++r1 ){
            for( int c1 = 0; c1 < w; ++c1 ){
                for( int r2 = r1+2; r2 < h; ++r2 ){
                    for( int c2 = c1+2; c2 < w; ++c2 ){
                        int curr = rectsum(r1,c1,r2,c2) - dp[r1+1][c1+1][r2-1][c2-1];
                        sol = max( sol, curr );
                    }
                }
            }
        }

        printf("%d\n",sol);
    }


    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <map>
#include <stack>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <map>
#include <cstdio>
#include <cstdlib>
using namespace std;

string s;

bool lesseq( string a, string b ){
    if( a.size() > b.size() ) return 0;
    if( a.size() < b.size() ) return 1;

    for( int i = 0; i < a.size(); ++i ){
        if( a[i] < b[i] ) return 1;
        else if( a[i] > b[i] ) return 0;
    }
    return 1;
}

int main(){
    cin >> s;

    if( s[0] == '-' ){
        string q = s.substr( 1 );
        if( lesseq(q,"128") ) printf("byte\n");
        else if( lesseq(q,"32768") ) printf("short\n");
        else if( lesseq(q,"2147483648") ) printf("int\n");
        else if( lesseq(q,"9223372036854775808") ) printf("long\n");
        else printf("BigInteger\n");
    }else{
        string q = s;
        if( lesseq(q,"127") ) printf("byte\n");
        else if( lesseq(q,"32767") ) printf("short\n");
        else if( lesseq(q,"2147483647") ) printf("int\n");
        else if( lesseq(q,"9223372036854775807") ) printf("long\n");
        else printf("BigInteger\n");
    }





    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <map>
#include <stack>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <map>
#include <cstdio>
#include <cstdlib>
using namespace std;

int n;
int v[1005];

int main(){
    long long n;
    cin >> n;
    cout<<n<<endl;

    return 0;
}

#include <iostream>
#include <math.h>
#include <string.h>
#include <string>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;

#define len(x) (int)strlen(x)
#define sz(x) (int)x.size()
#define all (x.begin(),x.end())
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

int p[4];
int a,b;

int main(){
   // freopen("Ulaz.txt","r",stdin);

    scanf("%d%d%d%d",&p[0],&p[1],&p[2],&p[3]);
    scanf("%d%d",&a,&b);

    sort( p , p + 4 );

    int sol = 0;
    for( int i = a; i <= b; ++i ){
        int cnt = 0;
        do{

            int y = (((i%p[0])%p[1])%p[2])%p[3];
            if( i == y ) cnt ++;

        }while( next_permutation( p , p + 4 ) );

        if( cnt >= 7 ) sol ++;
    }
    cout<< sol << endl;

    return 0;
}

#include <iostream>
#include <math.h>
#include <string.h>
#include <string>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;

#define len(x) (int)strlen(x)
#define sz(x) (int)x.size()
#define all (x.begin(),x.end())
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

const double eps = 1e-9;
const int maxn = 10000;

int n,m;
int a[maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d%d",&n,&m);
    for( int i = 0; i < n; ++i ) scanf("%d",&a[i]);

    m = 100 - m;


    double lo = 0, hi = 1000;
    double sol = 0;
    while( hi-lo > eps ){
        double mid = (lo+hi)/2;


        double over(0),need(0);
        for( int i = 0; i < n; ++i )
            over += max( 0.0 , a[i] - mid ),
            need += max( 0.0 , mid - a[i] );

        if( over * (m/100.0) >= need ) lo = mid + eps, sol = mid;
        else hi = mid - eps;
    }

    printf("%.10lf\n",sol);

    return 0;
}

#include <iostream>
#include <math.h>
#include <string.h>
#include <string>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;

#define len(x) (int)strlen(x)
#define sz(x) (int)x.size()
#define all (x.begin(),x.end())
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

const int inf = 9999;

int n;
int mini[10][10];
int maxi[10][10];
int activ[10][10];
vector<int>fuel;

int enter;
bool ok;
int solmx = -1;
int tmp;

map<vector<int>,int> dp[10][10];

int solve( int f, int s ){

    s++;
    if( s == n ){
        if( fuel[f] ) return -inf;
        f ++;
        s = f+1;
    }

    if( dp[f][s][fuel] ) return dp[f][s][fuel];

    if( f == n-1 ){
        if( enter == fuel[n-1] ){
            ok = 1;
            return 0;
        }
        return -inf;
    }

    int sol = -inf;

    if( mini[f][s] == 0 ) sol = solve(f,s);

    for( int i = max(mini[f][s],1); i <= maxi[f][s]; ++i ){
        if( fuel[f]-i < 0 ) continue;
        fuel[f] -= i;
        fuel[s] += i;

        sol = max( sol , solve(f,s) + activ[f][s] + i*i );

        fuel[f] += i;
        fuel[s] -= i;
    }

    dp[f][s][fuel] = sol;
    return sol;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);

    scanf("%d",&n);

    for( int i = 0; i < n*(n-1)>>1; ++i ){
        int f,s,lo,hi,a;
        scanf("%d%d%d%d%d",&f,&s,&lo,&hi,&a);
        f--,s--;
        mini[f][s] = lo;
        maxi[f][s] = hi;
        activ[f][s] = a;
    }

    for( int i = 0; i < n; ++i ) fuel.push_back( 0 );

    int costsol;
    for( int i = 0; i <= 25 && !ok ; ++i ){
        for( int j = 0; j < n; ++j ) fuel[j] = 0;

        enter = i;
        fuel[0] = i;
        costsol = solve( 0 , 0 );
    }

    if( ok ) cout<<enter<<" "<<costsol<<endl;
    else printf("-1 -1\n");

    return 0;
}

#include <iostream>
#include <math.h>
#include <string.h>
#include <string>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;

#define len(x) (int)strlen(x)
#define sz(x) (int)x.size()
#define all (x.begin(),x.end())
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

int n,m;
int a[1005];
int b[1005];
bool used[1005];

int tree[1055];

inline int inc( int dx ){
    for( dx += 3; dx < 1055; dx += dx & -dx )
        tree[dx] ++;
}

inline int read( int dx ){
    int ret = 0;
    for( dx += 3; dx >= 1; dx -= dx & -dx )
        ret += tree[dx];
    return ret;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);
    for( int i = 0; i < n; ++i ){
        scanf("%d",&b[i]);
    }

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < n; ++j ){
            if( used[j] ) continue;

            int cnt = read(1020-(j+m));

            if( cnt == b[j] ){
                a[i] = j;
                used[j] = 1;
                inc(1020-j);
                break;
            }

        }
    }

    for( int i = 0; i < n; ++i )
        printf("%d ",a[i]+1);
    printf("\n");

    return 0;
}

#include <iostream>
#include <math.h>
#include <string.h>
#include <string>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;

#define len(x) (int)strlen(x)
#define sz(x) (int)x.size()
#define all (x.begin(),x.end())
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

int n,m;
int a[1005];
int b[1005];
bool used[1005];

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);
    for( int i = 0; i < n; ++i ){
        scanf("%d",&a[i]);
        a[i]--;
    }

    for( int i = 0; i < n; ++i ){
        int pos;
        for( pos = 0; a[pos] != i; ++pos );

        for( int k = 0; k < pos; ++k )
            if( a[k] >= i + m ) b[i] ++;
    }

    for( int i = 0; i < n; ++i )
        printf("%d ",b[i]);
    printf("\n");

    return 0;
}

#include <iostream>
#include <math.h>
#include <string.h>
#include <string>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;

#define len(x) (int)strlen(x)
#define sz(x) (int)x.size()
#define all(x) x.begin(),x.end()
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

const int maxn = 1000000  + 55;
const int maxx = 1000000 + 20;

int n;
int a[maxn];

int tree[maxn];

void update( int dx, int val ){
    for( dx += 5; dx < maxn; dx += dx & -dx )
        tree[dx] = max( tree[dx] , val );
}

int read( int dx ){
    int ret = 0;
    for( dx += 5; dx >= 1; dx -= dx & -dx )
        ret = max( ret , tree[dx] );
    return ret;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ) scanf("%d",&a[i]);

    vector< pii > nxt;
    for( int i = 0; i < n; ++i ){
        int b; scanf("%d",&b);
        nxt.push_back( mk(b,i) );
    }

    sort( all(nxt) );

    int sol = 0;
    for( int i = 0; i < n; ++i ){
        int pos = (*lower_bound( all(nxt) , mk(a[i],-1) ) ).s;
        int x = read( maxx - pos );
        update( maxx-pos , x + 1 );
        sol = max( sol , x + 1 );
    }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <math.h>
#include <string.h>
#include <string>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;

#define len(x) (int)strlen(x)
#define sz(x) (int)x.size()
#define all (x.begin(),x.end())
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

int a,b,c;

int main(){
  //  freopen("Ulaz.txt","r",stdin);

    int tests; scanf("%d",&tests);
    for( ; tests ; --tests ){
        scanf("%d%d%d",&a,&b,&c);

        int sol = 0,dx=0;
        int F = a * 100 + b;

        for( int i = 1; i <= 10000; ++i ){
            if( c > b && !a ) break;
            if( c > b ) b += 100, a --;
            b -= c;
            swap(a,b);

            int inc = (a*100+b) - F;
            if( inc > sol ) sol = inc , dx = i;
        }

        printf("%d\n",dx);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <map>
#include <string>
#include <algorithm>
#include <iomanip>
#include <set>
#include <queue>
#include <cstdio>
#include <cstdlib>
#include <math.h>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 100000 + 55;
const int clg = 19;

int n,curr,lvl;
char txt[maxn];
int dp[clg][maxn];
int suffix[maxn];

bool cmp( int a, int b ){
    if( dp[lvl][a] != dp[lvl][b] ) return dp[lvl][a] < dp[lvl][b];
    return dp[lvl][a+curr] < dp[lvl][b+curr];
}

int lcp( int x ){
    int a = suffix[x];
    int b = suffix[x+1];
    int ret = 0;

    for( int i = lvl-1; i >= 0; --i )
        if( dp[i][a] == dp[i][b] )
            ret += 1 << i, a += 1 << i , b += 1 << i;
    return ret;
}

int L[maxn];
int setid[maxn];
int rev[maxn];

set< int > sets[maxn];

pii sol;

void combine( int a, int b ){
    int x = setid[ suffix[a] ];
    int y = setid[ suffix[b] ];

    if( x == y ) return;
    if( sets[x].size() > sets[y].size() ) swap(x,y),swap(a,b);

    for( set<int>::iterator it = sets[x].begin(); it != sets[x].end(); ++it ){
        set<int>::iterator ix = sets[y].upper_bound( *it + lvl );
        if( ix == sets[y].begin() ) continue;
        ix --;
        if( *ix >= *it ) sol = max( sol , mk(*ix-*it, maxn-rev[*it] ) );
    }

    for( set<int>::iterator it = sets[x].begin(); it != sets[x].end(); ++it ){
        set<int>::iterator ix = sets[y].lower_bound( *it - lvl );
        if( ix == sets[y].end() ) continue;
        if( *ix <= *it ) sol = max( sol , mk(*it-*ix, maxn-rev[*ix] ) );
    }

    int c = sets[x].size();
    for( set<int>::iterator it = sets[x].begin(); it != sets[x].end(); ++it ){
        sets[y].insert( *it );
        setid[ *it ] = y;
    }
}

int main(){
  //  freopen("Ulaz.txt","r",stdin);
  //  freopen("Izlaz.txt","w",stdout);
    scanf("%s",txt); n = strlen(txt);

    for( int i = 0; i < n; ++i ){
        dp[0][i] = txt[i];
        suffix[i] = i;
    }

    for( curr = 1, lvl = 0; (curr>>1) < n; curr <<= 1, lvl++ ){
        sort( suffix , suffix + n, cmp );
        dp[lvl+1][ suffix[0] ] = 1;

        for( int i = 1; i < n; ++i )
            if( cmp( suffix[i-1] , suffix[i] ) ) dp[lvl+1][ suffix[i] ] = dp[lvl+1][ suffix[i-1] ] + 1;
            else dp[lvl+1][ suffix[i] ] = dp[lvl+1][ suffix[i-1] ];
    }

    vector< pii > w;

    for( int i = 0; i < n-1; ++i ){
        L[i] = lcp(i);

        rev[ suffix[i] ] = i;
        w.push_back( mk( L[i] , i ) );
        w.push_back( mk( L[i] , i+1 ) );
    }
    rev[ suffix[n-1] ] = n-1;

    memset( setid, -1, sizeof(setid));
    sort( w.rbegin(), w.rend());

    int cntset = 0;
    int k = 0;
    sol = mk(0,0);

    for( lvl = n; lvl >= 0; --lvl ){
        while( k < w.size() && w[k].f == lvl ){
            int a = suffix[ w[k].s ];

            if( setid[ a ] == -1 ){
                setid[ a ] = cntset;
                sets[cntset].insert( a );
                cntset ++;
            }

            if( w[k].s > 0 && setid[ suffix[w[k].s - 1] ]   != -1 && L[w[k].s - 1] >= lvl ) combine( w[k].s , w[k].s - 1 );
            if( w[k].s+1 < n && setid[ suffix[w[k].s + 1] ] != -1 && L[w[k].s] >= lvl     ) combine( w[k].s, w[k].s + 1 );

            ++k;
        }
    }

    printf("%d\n",sol.f);
    for( int i = 0; i < sol.f; ++i )
        printf("%c",txt[suffix[maxn-sol.s]+i]);
    printf("\n");


    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
using namespace std;

char txt[10000];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    scanf("%s",txt);
    int len = strlen(txt);

    int sol = 0;
    for( int i = 2; i <= len; i += 2 ){
        int mid = i / 2;
        for( int j = 0; j < len; ++j ){
            if( j + i > len ) continue;

            bool ok = 1;
            for( int k = 0; k < mid; ++k )
                if( txt[j+k] != txt[mid+j+k] ) ok = 0;

            if( ok ){
//                if( sol < i ){
//                    cout<<j<<" "<<i<<endl;
//                    for( int k = 0; k < i; ++k ) cout<<txt[j+k];cout<<endl;
//                }
                sol = max( sol , i );
            }
        }
    }
    cout<<sol/2<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <math.h>
#include <stack>
#include <complex>
using namespace std;

const int maxn = 105;
const int maxlen = 15;

int n;
char txt[maxn][maxlen];

vector< int > rg[50];
bool visi[50][50];
bool done[50];
int out[50];
int ingame[50];

char sol[50];

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%s",txt[i]);
        for( int j = 0; j < strlen(txt[i]); ++j )
            ingame[ txt[i][j] - 'a' ] = 1;
    }

    for( int i = 0; i < n; ++i ){
        for( int j = i+1; j < n; ++j ){
            int k = 0;
            while( k < strlen( txt[i] ) && k < strlen(txt[j]) && txt[i][k] == txt[j][k] ) ++k;

            if( k == strlen( txt[i] ) || k == strlen( txt[j] ) ) continue;

            int a = txt[i][k] - 'a';
            int b = txt[j][k] - 'a';

            if( visi[a][b] ) continue;
            visi[a][b] = 1;

            rg[a].push_back(b);
            out[b] ++;
        }
    }

    queue< int > q;
    for( int i = 0; i < 50; ++i )
        if( ingame[i] && out[i] == 0 )
            q.push( i );

    bool more = 0;
    int sz = 0;

    while( !q.empty() ){
        if( q.size() != 1 ) more = 1;
        int u = q.front(); q.pop();
        done[u] = 1;

        sol[sz++] = u + 'a';

        for( int i = 0; i < rg[u].size(); ++i ){
            int dad = rg[u][i];
            out[dad] --;

            if( out[dad] == 0 ) q.push( dad );
        }
    }

    bool no_solution = 0;
    for( int i = 0; i < 50; ++i )
        if( ingame[i] && !done[i] ) no_solution = 1;

    if( no_solution ) printf("!\n");
    else if( more ) printf("?\n");
    else printf("%s\n",sol);

    return 0;
}

#include <iostream>
#include <math.h>
#include <string.h>
#include <string>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;

#define len(x) (int)strlen(x)
#define sz(x) (int)x.size()
#define all (x.begin(),x.end())
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

const int maxn = 1005;

int n;
int hrpa[maxn];

int wins( int a, int b, int c ){
    if( a == 0 && c == 0 && b == 0 ) return 0;

    bool sol = 0;
    int mx = max(a,b);
    mx = max(mx,c);
    for( int i = 1; i <= mx; ++i ){
        if( i <= a ) sol |= !wins( a-i,b,c);
        if( i <= b ) sol |= !wins( a,b-i,c);
        if( i <= c ) sol |= !wins( a,b,c-i);
    }
    return sol;
}

int main(){
    freopen("igra.in","r",stdin);
    freopen("igra.out","w",stdout);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ) scanf("%d",&hrpa[i]);

    int x = 0;
    for( int i = 0; i < n; ++i ) x ^= hrpa[i];

    if( !x ){
        printf("Jok\n");
        return 0;
    }

    int pile = -1;
    for( int i = 31; i >= 0 && pile < 0; --i ){
        if( x & (1<<i) )
        for( int j = 0; j < n && pile < 0; ++j )
            if( hrpa[j]&(1<<i) ) pile = j;
    }

    int sol = -1;

    for( int j = 1; j <= hrpa[pile] ; ++j )
        if( (x^hrpa[pile]^(hrpa[pile]-j)) == 0 )
            sol = j;

    printf("%d %d\n",pile+1,sol);

    return 0;
}

#include <iostream>
#include <math.h>
#include <string.h>
#include <string>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;

#define len(x) (int)strlen(x)
#define sz(x) (int)x.size()
#define all (x.begin(),x.end())
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

const int prime = 1000000007;
const int maxn = 30000 + 55;
const int maxlen = 17;

bool isprime( int v ){
    if( v % 2 == 0 && v != 2 ) return 0;
    for( int i = 3; i*i <= v; i += 2 )
        if(  v % i == 0 ) return 0;
    return 1;
}

int n;
int stp[maxlen];

int prv[maxn];
int keys[maxn];
map<int,int> mp;
bool visi[maxn];
char txt[maxn][maxlen];

inline int getkey( char *pok ){
    int L = len(pok);
    int key = 0;
    for( int j = 0; j < L; ++j )
        key += stp[j] * pok[j];
    return key;
}

int main(){
    freopen("komsinice.in","r",stdin);
    freopen("komsinice.out","w",stdout);
    stp[0] = 1;
    for( int i = 1; i < maxlen; ++i ) stp[i] = stp[i-1]*prime;

    scanf("%d",&n);

    for( int i = 0; i < n+2; ++i ){
        scanf("%s",txt[i]);
        int key = getkey( txt[i] );
        keys[i] = key;
        if( i < n ) mp[key] = i+1;
    }

    int b = mp[keys[n]]-1;

    queue< int > q;
    q.push(b);
    visi[b] = 1;
    prv[b] = -1;

    int e = keys[n+1];
    bool ok = 0;

    while( !q.empty() ){
        int u = q.front(); q.pop();

        int L = len( txt[u] );
        if( keys[u] == e ){
            ok = 1;
            break;
        }

        for( int i = 0; i < L; ++i ){
            for( char c = 'a'; c <= 'z'; ++c ){
                if( c == txt[u][i] ) continue;

                int nxt = keys[u] - stp[i]*txt[u][i] + stp[i]*c;
                int idnxt = mp[nxt]-1;

                if( idnxt==-1 || visi[idnxt] ) continue;
                visi[idnxt] = 1;
                q.push( idnxt );
                prv[idnxt] = u;
            }
        }
    }

    if( !ok ){
        printf("NE POSTOJI\n");
        return 0;
    }

    vector< int > x;
    int it = mp[e]-1;

    while( it != -1 ){
        x.push_back(it);
        it = prv[it];
    }

    printf("%d\n",sz(x));
    for( int i = x.size()-1; i >= 0; --i )
        printf("%s\n",txt[ x[i] ] );

    return 0;
}

#include <iostream>
#include <math.h>
#include <string.h>
#include <string>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;

#define len(x) (int)strlen(x)
#define sz(x) (int)x.size()
#define all (x.begin(),x.end())
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

const int maxn = 100000 + 55;
const int maxe = maxn*2;

int n;

int cnte = 1;
int sol[maxn];
int head[maxe], nxt[maxe], point[maxe];

inline void add_edge( int a, int b ){
    nxt[cnte] = head[a], point[cnte] = b, head[a] = cnte ++;
}

int dfs( int node, int dad ){

    sol[node] = 1;

    for( int i = head[node]; i > 0; i = nxt[i] ){
        if( point[i] == dad ) continue;
        sol[node] += dfs( point[i] , node );
    }
    return sol[node];
}

int main(){
    freopen("swat.in","r",stdin);
    freopen("swat.out","w",stdout);

    scanf("%d",&n);
    for( int i = 0; i < n-1; ++i ){
        int a,b; scanf("%d%d",&a,&b); a--,b--;
        add_edge( a , b );
        add_edge( b , a );
    }

    dfs( 0 , -1 );

    for( int i = 0; i < n; ++i )
        printf("%d\n",sol[i]-1);

    return 0;
}

#include <iostream>
#include <math.h>
#include <string.h>
#include <string>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;

#define len(x) (int)strlen(x)
#define sz(x) (int)x.size()
#define all (x.begin(),x.end())
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

const int maxsz = 1000000 + 55;

char n[maxsz];
char s[maxsz];
int mod;

int d[maxsz],sz=0;

void div(){
    int tmp = 0;
    for( int i = sz-1; i >= 0; --i ){
        int now = d[i] + tmp*10;
        d[i] = now / 2;
        tmp = now % 2;
    }
}

int main(){
    freopen("veeeeliki.in","r",stdin);
    freopen("veeeeliki.out","w",stdout);


    scanf("%s%s%d",n,s,&mod);

    ll x = 0;
    for( int i = 0; i < len(n); ++i )
        x = ( x * 10 + n[i] - '0' ) % mod;

    for( int i = len(s)-1; i >= 0; --i )
        d[sz++] = s[i] - '0';

    stack< bool > stk;
    while( sz ){
        if( d[0] % 2 == 0 ){ stk.push( 0 ); div(); }
        else { stk.push( 1 ); d[0] --; }

        while( sz > 0 && d[sz-1] == 0 ) sz --;
    }


    int sol = 1;
    while( !stk.empty() ){
        int u = stk.top(); stk.pop();
        if( u == 0 ) sol = ( sol * (ll)sol ) % mod;
        else sol = ( sol * x ) % mod;
    }

    cout<< sol << endl;

    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:brownie
*/
#include <iostream>
#include <math.h>
#include <string.h>
#include <string>
#include <stack>
#include <map>
#include <iomanip>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;

#define len(x) (int)strlen(x)
#define SZ(x) (int)x.size()
#define all (x.begin(),x.end())
#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

const int maxn = 505;

int h,w,hg,wg;
int mat[maxn][maxn];
int ss[maxn][maxn];


inline int rectsum( int r1, int c1, int r2, int c2 ){
    int ret = ss[r2][c2];
    if( r1 && c1 ) ret += ss[r1-1][c1-1];
    if( r1 ) ret -= ss[r1-1][c2];
    if( c1 ) ret -= ss[r2][c1-1];
    return ret;
}

int low;
int v[maxn];

bool col_ok( int row1, int row2, int low ){
    if( row1 > row2 ) return 0;

    for( int i = 0; i < w; ++i )
        v[i] = rectsum( row1, i, row2, i );

    int s = 0, g = 0;
    for( int i = 0; i < w; ++i ){
        s += v[i];
        if( s >= low ) g++, s = 0;
    }
    return g >= wg;
}

bool isok( int low ){
    int curr_row = 0;

    for( int i = 0; i < hg-1; ++i ){
        int lo = curr_row, hi = h-1;
        int nxt = -1;
        while( lo <= hi ){
            int mid = (lo+hi)>>1;
            if( col_ok( curr_row , mid , low ) )
                hi = mid - 1 , nxt = mid;
            else
                lo = mid + 1;
        }
        if( nxt == -1 ) return 0;
        curr_row = nxt + 1;
    }
    return col_ok( curr_row , h-1, low );
}

int main(){
    freopen("brownie.in","r",stdin);
    freopen("brownie.out","w",stdout);

    //freopen("Ulaz2.txt","r",stdin);
    scanf("%d%d%d%d",&h,&w,&hg,&wg);

    for( int i = 0; i < h; ++i )
        for( int j = 0; j < w; ++j )
            scanf("%d",&mat[i][j]);

    for( int i = 0; i < h; ++i )
        for( int j = 0; j < w; ++j )
            ss[i][j] = (j?ss[i][j-1]:0) + mat[i][j];

    for( int i = 0; i < w; ++i )
        for( int j = 1; j < h; ++j )
            ss[j][i] += ss[j-1][i];

    int lo = 0, hi = 500*500*4000;
    int sol = 0;
    while( lo <= hi ){
        int mid = (lo+hi)>>1;

        if( isok( mid ) ) sol = mid , lo = mid + 1;
        else hi = mid - 1;
    }

    printf("%d\n",sol);


    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <stack>
#include <iomanip>
using namespace std;

const int maxn = 55;

#define ok(r,c) (r>=0&&r<h&&c>=0&&c<w)

int h,w;
char mat[maxn][maxn];

void printmat( char mat[maxn][maxn] , FILE *out ){
    for( int i = 0; i < h; ++i ){
        for( int j = 0; j < w; ++j )
            fprintf(out,"%c",mat[i][j]);
        fprintf(out,"\n");
    }fprintf(out,"\n");
}

char other( char c ){
    if( c == 'B' ) return 'W';
    return 'B';
}

bool move( int r, int c, int cnxt, char fig ){
    if( mat[r][c] != fig ) return false;

    int rnxt;

    if( fig == 'B' ) rnxt = r - 1 - (abs(c-cnxt) == 2);
    else if( fig == 'W' ) rnxt = r + 1 + (abs(c-cnxt) == 2);
    else return false;

    if( !ok(rnxt,cnxt) ) return false;

    //cout<<rnxt<<" "<<cnxt<<endl;

    if( abs(c-cnxt) == 1 ){
        if( mat[rnxt][cnxt] != '.' ) return false;
        swap( mat[r][c], mat[rnxt][cnxt] );
    }else if( abs(c-cnxt) == 2 ){
        int cmid = c + ((cnxt>c)?+1:-1);
        int rmid = r + ((rnxt>r)?+1:-1);

        if( mat[rmid][cmid] != other(fig) ) return false;
        mat[rmid][cmid] = '.';
        swap( mat[r][c], mat[rnxt][cnxt] );

    }else return false;

    return true;
}



int main(){
    FILE *in = fopen("Ulaz.txt","r");
    fscanf(in,"%d%d",&w,&h);

    for( int i = 0; i < h; ++i )
        fscanf(in,"%s",mat[i]);

    //cout<<move( 2 , 1 , 2 , 'B' )<<endl;
    //return 0;

    FILE *out = fopen("Izlaz.txt","w");

    char now = 'B';
    for( int i = 0; i < 30; ++i ){
        cout<<i<<endl;
        while( 1 ){
            int r = rand()%h;
            int c = rand()%w;
            int add = 2 - rand()%5;
            if( add == 0 ) continue;

            if( move( r , c , c + add, now ) ) break;
        }
        now = other(now);

        printmat( mat , out );
        fprintf(out,"\n");
    }


    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <stack>
#include <iomanip>
using namespace std;

const int maxn = 55;

int h,w;
char mat[maxn][maxn];

void printmat( char mat[maxn][maxn] , FILE *out ){
    for( int i = 0; i < h; ++i ){
        for( int j = 0; j < w; ++j )
            fprintf(out,"%c",mat[i][j]);
        fprintf(out,"\n");
    }fprintf(out,"\n");
}

void simulate( char mat[maxn][maxn], int moves ){
    FILE *dat = fopen("Izlaz.txt","w");

    for( int i = 0; i < moves; ++i ){
        int r,c,cnxt,rnxt;
        scanf("%d%d%d",&c,&r,&cnxt);
        r--,c--,cnxt--;

        printf("ON FIELD (%d,%d) we have figure: %c\n",r,c,mat[r][c]);

        if( mat[r][c] == 'B' ) rnxt = r - 1 - (abs(c-cnxt) == 2);
        else if( mat[r][c] == 'W' ) rnxt = r + 1 + (abs(c-cnxt) == 2);
        else printf("NO FIGURE HAS BEEN CHOSED\n");

        printf("NXT: (%d,%d)\n",rnxt,cnxt);

        if( abs(c-cnxt) == 1 ){
            if( mat[rnxt][cnxt] != '.' ) printf("THE FIELD IS OCCUPIED!\n");
            swap( mat[r][c], mat[rnxt][cnxt] );
        }else if( abs(c-cnxt) == 2 ){
            int cmid = c + ((cnxt>c)?+1:-1);
            int rmid = r + ((rnxt>r)?+1:-1);

            if( mat[rmid][cmid] == '.' ) printf("IT'S AN UNOCCUPIED FIELD!\n");
            mat[rmid][cmid] = '.';
            printf("MID: (%d,%d)\n",rmid,cmid);
            swap( mat[r][c], mat[rnxt][cnxt] );

        }else printf("INVALID JUMP\n");

        printmat(mat,dat);
    }
}



int main(){
    FILE *in = fopen("Ulaz.txt","r");
    fscanf(in,"%d%d",&w,&h);

    for( int i = 0; i < h; ++i )
        fscanf(in,"%s",mat[i]);

    simulate( mat , 11 );

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <map>
#include <vector>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

#define ok(r,c) (r>=0&&r<h&&c>=0&&c<w)


struct piii{
    int f,s,t,d;
    piii(){d=0;};
    piii( int p1, int p2, int p3 ):f(p1),s(p2),t(p3),d(0){};

    const bool operator<( const piii &p ) const {
        if( f != p.f ) return f < p.f;
        if( s != p.s ) return s < p.s;
        if( t != p.t ) return t < p.t;
        return d < p.d;
    }
};

const int maxn = 65;

int h,w;
char mat[maxn][maxn];
char end[maxn][maxn];

void read_mat( char tmp[maxn][maxn], FILE *in ){
    for( int i = 0; i < h; ++i )
        fscanf(in,"%s",tmp[i]);
}

void extract( char m[maxn][maxn], vector< piii > &mem ){
    mem.clear();
    for( int i = 0; i < h; ++i )
        for( int j = 0; j < w; ++j )
            if( m[i][j] == 'W' || m[i][j] == 'B' )
                mem.push_back( piii( i, j, m[i][j] ) );
}

bool match( char a[maxn][maxn], char b[maxn][maxn] ){
    for( int i = 0; i < h; ++i )
        for( int j = 0; j < w; ++j )
            if( a[i][j] != b[i][j] ) return false;
    return true;
}

void printmat( char mat[maxn][maxn]  ){
    for( int i = 0; i < h; ++i ){
        for( int j = 0; j < w; ++j )
            printf("%c",mat[i][j]);
        printf("\n");
    }
}

vector< piii > WB,EB;
vector< piii > mov,sol;

int cew,ceb;

int p[66];
bool visi[66];
vector< int > gw[66],gb[66];
vector< int > *pok;

bool dfs( int node ){
    if( node == -1 ) return 1;
    if( visi[node] ) return 0;
    visi[node] = 1;

    for( int i = 0; i < pok[node].size(); ++i ){
        int nxt = pok[node][i];
        if( dfs( p[ nxt ] ) ){
            p[nxt] = node;
            p[node] = nxt;
            return 1;
        }
    }
    return 0;
}

int maxmatch( vector< int > g[66], int sz ){
    for( int i = 0; i < 66; ++i )
        p[i] = -1;

    pok = &g[0];

    int ret = 0;
    while( 1 ){
        bool ok = 0;
        memset( visi, 0 , sizeof(visi));
        for( int i = 0; i < sz; ++i )
            if( p[i] == -1 && dfs(i) ) ret ++, ok = 1;

        if( !ok ) break;
    }
    return ret;
}

int cnt[66];
bool eaten[66];

bool possible(){
    for( int i = 0; i < 66; ++i ){
        gw[i].clear(),gb[i].clear();
        cnt[i] = 0;
        eaten[i] = 0;
    }

    int n = WB.size();
    int m = EB.size();
    for( int i = 0; i < n; ++i ){
        if( WB[i].d ) continue;

        for( int j = 0; j < m; ++j ){
            if( WB[i].t == 'W' && EB[j].t == 'W' && EB[j].f - WB[i].f >= abs( EB[j].s - WB[i].s ) )
                gw[i].push_back(n+j);
            if( WB[i].t == 'B' && EB[j].t == 'B' && WB[i].f - EB[j].f >= abs( EB[j].s - WB[i].s ) ){
                gb[j].push_back(n+i),cnt[i]++;
            }
        }
    }

    int f1,f2;
    if( (f1=maxmatch( gw,n )) < cew ) return false;
    if( (f2=maxmatch( gb,m )) < ceb ) return false;


    for( int i = 0; i < n; ++i ){
        if( WB[i].d ) continue;

        for( int j = 0; j < n; ++j ){
            if( WB[j].d || i == j ) continue;
            if( WB[i].t == 'W' && WB[j].t == 'B' && WB[j].f - WB[i].f >= abs( WB[j].s - WB[i].s ) ) eaten[i] = 1;
            else if( WB[i].t == 'B' && WB[j].t == 'W' && WB[i].f - WB[j].f >= abs( WB[j].s - WB[i].s ) ) eaten[i] = 1;
        }
    }

    int delB(0),delW(0),W(0),B(0);
    for( int i = 0; i < n; ++i ){
        if( WB[i].d ) continue;

        if( WB[i].t == 'W' ) delW += eaten[i];
        else delB += eaten[i];

        W += WB[i].t == 'W';
        B += WB[i].t == 'B';

        if( gw[i].size() && WB[i].t == 'W' || cnt[i] && WB[i].t == 'B' ) continue;
        if( eaten[i] == false ) return false;
    }

   // cout<<f1<<" "<<delW<<" , "<<W<<endl;
   // cout<<f2<<" "<<delW<<" , "<<B<<endl;

    if( W - delW > f1 ) return false;
    if( B - delB > f2 ) return false;


    return true;
}

double start;

vector< piii > xx;

map<string,int> mp;

inline string strtonum( int v ){
    string ret = "";
    while( v ){
        ret = ret + string(1,v%10+'0');
        v /= 10;
    }
    if( ret == "" ) ret = "0";

    return ret;
}

void brute( bool blackmove, int deep ){

    if( !possible() ) return;
    if( deep == 15 ) return;

   // printmat( mat );
   // cout<<endl;
   // for( int i = 0; i < 300000; ++i );


    if( match(mat,end) ){
        if( sol.size() < mov.size() ) sol = mov;
        return;
    }

    xx = WB;
    sort( xx.begin(),xx.end() );
    string key = "";

    for( int i = 0; i < xx.size(); ++i )
        key = key + strtonum( xx[i].f ) + strtonum( xx[i].s ) + string( 1,xx[i].t ) + string( 1,'0'+xx[i].d);

    if( mp[key] ) return;
    mp[key] = 1;

    vector< pii > order;
    for( int i = 0; i < WB.size(); ++i )
        order.push_back( mk(WB[i].f,i) );

    if( blackmove ) sort( order.rbegin(), order.rend() );
    else sort( order.begin(), order.end() );


    for( int d = 0; d < WB.size(); ++d ){
        int i = order[d].s;
        if( (clock()-start)/CLOCKS_PER_SEC > 9.9 ) return;
        if( blackmove && WB[i].t == 'W' ) continue;
        if( !blackmove && WB[i].t == 'B' ) continue;
        if( WB[i].d ) continue;

        int ar = blackmove?-1:+1;
        for( int ac = -1; ac <= 1; ac += 2 ){
            int r = WB[i].f + ar, c = WB[i].s + ac;
            if( !ok(r,c) ) continue;

            bool out = false;

            if( mat[r][c] == 'W' && blackmove || mat[r][c] == 'B' && !blackmove ) r += ar, c += ac, out = true;
            if( mat[r][c] != '.' || !ok(r,c) ) continue;

            if( out ) for( int k = 0; k < WB.size(); ++k ) if( WB[k].d == 0 && r-ar == WB[k].f && c - ac == WB[k].s ) WB[k].d = 1, mat[WB[k].f][WB[k].s] = '.';

            mov.push_back( piii( WB[i].s , WB[i].f , c ) );

            swap( mat[WB[i].f][WB[i].s] , mat[r][c] );

            piii mem = WB[i];
            WB[i].f = r, WB[i].s = c;

            brute( !blackmove, deep + 1 );

            WB[i] = mem;
            swap( mat[WB[i].f][WB[i].s] , mat[r][c] );
            mov.pop_back();

            if( out ) for( int k = 0; k < WB.size(); ++k ) if( WB[k].d == 1 && r-ar == WB[k].f && c - ac == WB[k].s ) WB[k].d = 0, mat[WB[k].f][WB[k].s] = WB[k].t;
        }
    }
}

int main(){
    start = clock();

    FILE *in =  stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d%d",&w,&h);

    read_mat( mat, in );
    read_mat( end, in );

    vector< piii > tmp;

    extract( mat, WB  );
    extract( end , tmp );
    EB = tmp;

    for( int i = 0; i < tmp.size(); ++i ){
        if( tmp[i].t == 'W' ) cew ++;
        if( tmp[i].t == 'B' ) ceb ++;
    }

    brute( 1 , 0 );

    printf("%d\n",(int)sol.size());
    for( int i = 0; i < sol.size(); ++i )
        printf("%d %d %d\n",sol[i].f+1,sol[i].s+1,sol[i].t+1);

    return 0;
}

#include <cstdio>
#include <string.h>
#include <vector>
#include <map>
#include <string>
#include <math.h>
#include <algorithm>
using namespace std;

#define ok(r,c) (r>=0&&r<h&&c>=0&&c<w)

struct pii{
    int f,s;
    pii(){};
    pii( int a, int b ):f(a),s(b){};
};

const int maxn = 65;

int h,w;
char mat[maxn][maxn];
char end[maxn][maxn];

bool match( char a[maxn][maxn], char b[maxn][maxn] ){
    for( int i = 0; i < h; ++i )
        for( int j = 0; j < w; ++j )
            if( a[i][j] != b[i][j] ) return false;
    return true;
}

void printmat( char mat[maxn][maxn]  ){
    for( int i = 0; i < h; ++i ){
        for( int j = 0; j < w; ++j )
            printf("%c",mat[i][j]);
        printf("\n");
    }
}

void read_mat( char tmp[maxn][maxn], FILE *in ){
    for( int i = 0; i < h; ++i )
        fscanf(in,"%s",tmp[i]);
}

inline void swap( char &a, char &b ){
    char t = a;
    a = b;
    b = t;
}

vector< pii > ew,eb;
pii mw[maxn],mb[maxn];
int sw,sb;

int cnte = 1;
int point[maxn*maxn],head[maxn],nxt[maxn*maxn];

inline void add_edge( int a, int b ){
    point[cnte] = b, nxt[cnte] = head[a], head[a] = cnte; cnte ++;
}

inline void clear_edge(){
    for( int i = 0; i < maxn; ++i ) head[i] = 0;
    for( int i = 0; i < maxn*maxn; ++i ) point[i] = nxt[i] = 0;
}

int p[maxn];
bool visi[maxn];

bool dfs( int node ){
    if( node == -1 ) return 1;
    if( visi[node] ) return 0;
    visi[node] = 1;

    for( int i = head[node]; i >= 1; i = nxt[i] ){
        int u = point[i];
        if( dfs( p[u] ) ){
            p[u] = node;
            p[node] = u;
            return 1;
        }
    }
    return 0;
}

int maxmatch(){
    for( int i = 0; i < maxn; ++i ) p[i] = -1;

    int ret = 0;
    while( 1 ){
        bool ok = 0;
        memset( visi, 0, sizeof(visi));
        for( int i = 0; i < maxn; ++i )
            if( p[i] == -1 && dfs(i) ) ret ++, ok = 1;
        if( !ok ) break;
    }
    return ret;
}

bool eaten[maxn];
int outw[maxn],outb[maxn];

bool possible(){
    for( int i = 0; i < maxn; ++i ) eaten[i] = outw[i] = outb[i] = 0;

    sw = 0, sb = 0;
    for( int r = 0; r < h; ++r )
        for( int c = 0; c < w; ++c )
            if( mat[r][c] == 'W' ) mw[ sw++ ] = pii(r,c);
            else if( mat[r][c] == 'B' ) mb[ sb++ ] = pii(r,c);

    cnte = 1;clear_edge();
    for( int i = 0; i < sw; ++i )
        for( int j = 0; j < ew.size(); ++j )
            if( ew[j].f - mw[i].f >= abs( ew[j].s - mw[i].s ) ) add_edge( i , sw+j ),outw[i]++; // add_edge( i -> j )

    if( maxmatch() < ew.size() ) return false;

    cnte = 1;clear_edge();
    for( int i = 0; i < sb; ++i )
        for( int j = 0; j < eb.size(); ++j )
            if( mb[i].f - eb[j].f >= abs( mb[i].s - eb[j].s ) ) add_edge( i , sb+j ),outb[i]++; // add_edge( i -> j )

    if( maxmatch() < eb.size() ) return false;


    for( int i = 0; i < sw; ++i )
        for( int j = 0; j < sb; ++j )
            if( (mb[j].f - mw[i].f) >= abs( mw[i].s - mb[j].s ) ) eaten[i] = eaten[sw+j] = 1;

    for( int i = 0; i < sw; ++i ){
      //  if( outw[i] == 0 ) printf("%d %d [%d]\n",mw[i].f,mw[i].s,eaten[i]);
        if( outw[i] == 0 && eaten[i] == false ) return false;
    }
    //printf("--\n");

    for( int i = 0; i < sb; ++i ){
        //if( outb[i] == 0 ) printf("%d %d [%d]\n",mb[i].f,mb[i].s,eaten[i+sw]);
        if( outb[i] == 0 && eaten[i+sw] == false ) return false;
    }


    return true;
}

int mov[maxn][3],solmov[maxn][3],sz,sol;
map<string,int> mp;

inline string strtonum( int v ){
    string ret = "";
    while( v ){
        ret = ret + string(1,v%10+'0');
        v /= 10;
    }
    if( ret == "" ) ret = "0";

    return ret;
}

void brute( int deep ){

    if( !possible() ) return;

   // printmat( mat );
    //printf("\n");
    //for( int i = 0; i < 30000000; ++i );

    if( match(mat,end) ){
        if( sz > sol ) memcpy( solmov,mov,sizeof(mov)), sol = sz;
        return;
    }

    string key = "";
    for( int r = 0; r < h; ++r ){
        for( int c = 0; c < w; ++c ){
            if( mat[r][c] == '.' ) continue;
            key = key + strtonum( r ) + strtonum( c ) + string( 1, mat[r][c] );
        }
    }

    if( mp[key] ) return;
    mp[key] = 1;


    for( int r = 0; r < h; ++r ){
        for( int c = 0; c < w; ++c ){
            if( sol ) break;
            if( mat[r][c] == '.' ) continue;
            if( mat[r][c] == 'W' && deep%2 == 0 ) continue;
            if( mat[r][c] == 'B' && deep%2 == 1 ) continue;

            int ar = mat[r][c] == 'B'?-1:+1;
            for( int ac = -1; ac <= 1; ac += 2 ){
                int rnxt = r + ar , cnxt = c + ac;

                if( !ok(rnxt,cnxt) || mat[rnxt][cnxt] == mat[r][c] ) continue;

                bool kill = false;
                if( mat[rnxt][cnxt] != '.' ) kill = true, rnxt += ar, cnxt += ac;
                if( !ok(rnxt,cnxt) || mat[rnxt][cnxt] != '.' ) continue;

                char save = '.';

                mat[rnxt][cnxt] = mat[r][c];
                swap( save , mat[rnxt-ar][cnxt-ac] );
                mat[r][c] = '.';

                mov[sz][0] = c, mov[sz][1] = r, mov[sz++][2] = cnxt;
                brute( deep + 1 );
                sz--;

                swap( save , mat[rnxt-ar][cnxt-ac] );
                mat[r][c] = mat[rnxt][cnxt];
                mat[rnxt][cnxt] = '.';
            }
        }
    }

}



int main(){
    FILE *in =  stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d%d",&w,&h);

    read_mat( mat, in );
    read_mat( end, in );

    for( int i = 0; i < h; ++i )
        for( int j = 0; j < w; ++j )
            if( end[i][j] == 'W' ) ew.push_back( pii(i,j) );
            else if( end[i][j] == 'B' ) eb.push_back( pii(i,j) );


    brute( 0 );

    printf("%d\n",sol);
    for( int i = 0; i < sol; ++i )
        printf("%d %d %d\n",solmov[i][0]+1,solmov[i][1]+1,solmov[i][2]+1);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <map>
#include <vector>
using namespace std;

#define pii pair<int,int>
#define r first
#define c second
#define mk make_pair

#define ok(r,c) (r>=0&&r<h&&c>=0&&c<w)


struct piii{
    int f,s,t;
    piii(){};
    piii( int p1, int p2, int p3 ):f(p1),s(p2),t(p3){};
};

const int maxn = 55;

int h,w;
char mat[maxn][maxn];
char end[maxn][maxn];

void read_mat( char tmp[maxn][maxn], FILE *in ){
    for( int i = 0; i < h; ++i )
        fscanf(in,"%s",tmp[i]);
}

void extract( char m[maxn][maxn], vector< piii > &mem ){
    mem.clear();
    for( int i = 0; i < h; ++i )
        for( int j = 0; j < w; ++j )
            if( m[i][j] == 'W' || m[i][j] == 'B' )
                mem.push_back( piii( i, j, m[i][j] ) );
}

bool match( char a[maxn][maxn], char b[maxn][maxn] ){
    for( int i = 0; i < h; ++i )
        for( int j = 0; j < w; ++j )
            if( a[i][j] != b[i][j] ) return false;
    return true;
}

void printmat( char mat[maxn][maxn]  ){
    for( int i = 0; i < h; ++i ){
        for( int j = 0; j < w; ++j )
            printf("%c",mat[i][j]);
        printf("\n");
    }
}

vector< piii > WB,EB;
vector< piii > mov,sol;

int pairswb,pairsbw;
int cew,ceb;

int p[66];
bool visi[66];
vector< int > gw[66],gb[66];
vector< int > *pok;

bool dfs( int node ){
    if( node == -1 ) return 1;
    if( visi[node] ) return 0;
    visi[node] = 1;

    for( int i = 0; i < pok[node].size(); ++i ){
        int nxt = pok[node][i];
        if( dfs( p[ nxt ] ) ){
            p[nxt] = node;
            p[node] = nxt;
            return 1;
        }
    }
    return 0;
}

int maxmatch( vector< int > g[66], int sz ){
    for( int i = 0; i < 66; ++i ){
        p[i] = -1;
    }

    pok = &g[0];

    int ret = 0;
    while( 1 ){
        bool ok = 0;
        memset( visi, 0 , sizeof(visi));
        for( int i = 0; i < sz; ++i )
            if( p[i] == -1 && dfs(i) ) ret ++, ok = 1;

        if( !ok ) break;
    }
    return ret;
}

int cnt[66];
int maxmov;

bool possible(){
    for( int i = 0; i < 66; ++i ){
        gw[i].clear(),gb[i].clear();
        cnt[i] = 0;
    }

    int n = WB.size();
    int m = EB.size();
    for( int i = 0; i < n; ++i ){
        if( mat[ WB[i].f ][ WB[i].s ] == '.' ) continue;

        for( int j = 0; j < m; ++j ){
            if( WB[i].t == 'W' && EB[j].t == 'W' && EB[j].f - WB[i].f >= abs( EB[j].s - WB[i].s ) )
                gw[i].push_back(n+j);
            if( WB[i].t == 'B' && EB[j].t == 'B' && WB[i].f - EB[j].f >= abs( EB[j].s - WB[i].s ) ){
                gb[j].push_back(n+i),cnt[i]++;
            }
        }
    }

    //int cnt = 0;
    if( maxmatch( gw,n ) < cew ) return false;
    //for( int i = 0; i < n; ++i )


    if( maxmatch( gb,m ) < ceb ) return false;

    for( int i = 0; i < n; ++i ){
        if( mat[ WB[i].f ][ WB[i].s ] == '.' ) continue;
        if( gw[i].size() && WB[i].t == 'W' || cnt[i] && WB[i].t == 'B' ) continue;

        bool ok = 0;
        for( int j = 0; j < n; ++j ){
            if( mat[ WB[j].f ][ WB[j].s ] == '.' ) continue;
            if( WB[i].t == 'W' && WB[j].t == 'B' && WB[j].f - WB[i].f >= abs( WB[j].s - WB[i].s ) ) ok = 1;
            else if( WB[i].t == 'B' && WB[j].t == 'W' && WB[i].f - WB[j].f >= abs( WB[j].s - WB[i].s ) ) ok = 1;
        }

        if( !ok ) return false;
    }

    return true;
}

double start;

void brute( bool blackmove ){

    if( !possible() ) return;

    //printmat( mat );
    //cout<<endl;
    //for( int i = 0; i < 3000000; ++i );


    if( match(mat,end) ){
        if( sol.size() < mov.size() ) sol = mov;
        return;
    }

    for( int i = 0; i < WB.size(); ++i ){
        if( (clock()-start)/CLOCKS_PER_SEC > 9 ) return;
        if( blackmove && WB[i].t == 'W' ) continue;
        if( !blackmove && WB[i].t == 'B' ) continue;
        if( mat[ WB[i].f ][ WB[i].s ] == '.' ) continue;

        int ar = blackmove?-1:+1;
        for( int ac = -1; ac <= 2; ac += 2 ){
            int r = WB[i].f + ar, c = WB[i].s + ac;
            if( !ok(r,c) ) continue;

            bool out = false;

            if( mat[r][c] == 'W' && blackmove || mat[r][c] == 'B' && !blackmove ) r += ar, c += ac, out = true;
            else if( mat[r][c] != '.' ) continue;

            if( !ok(r,c) ) continue;

            char save = '.';
            if( out ) swap( mat[r-ar][c-ac],save );
            mov.push_back( piii( WB[i].s , WB[i].f , c ) );

            swap( mat[WB[i].f][WB[i].s] , mat[r][c] );

            piii mem = WB[i];
            WB[i].f = r, WB[i].s = c;

            brute( !blackmove );

            WB[i] = mem;
            swap( mat[WB[i].f][WB[i].s] , mat[r][c] );

            mov.pop_back();
            if( out ) swap( mat[r-ar][c-ac],save );
        }
    }
}

int main(){
    start = clock();

    FILE *in =  fopen("Ulaz.txt","r");
    fscanf(in,"%d%d",&w,&h);

    read_mat( mat, in );
    read_mat( end, in );

    extract( mat, WB  );

    vector< piii > tmp;
    extract( end , tmp );
    EB = tmp;

    for( int i = 0; i < tmp.size(); ++i ){
        if( tmp[i].t == 'W' ) cew ++;
        if( tmp[i].t == 'B' ) ceb ++;
    }

    for( int i = 0; i <= 50; ++i ){
        maxmov = i;
        brute( 1 );
    }

    printf("%d\n",(int)sol.size());
    for( int i = 0; i < sol.size(); ++i )
        printf("%d %d %d\n",sol[i].f+1,sol[i].s+1,sol[i].t+1);

    return 0;
}

#include <vector>
#include <algorithm>
#include <string.h>
#include <stack>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <math.h>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

typedef long long ll;

const int maxn = 200000 + 55;
const int maxk = 20;
const int prime = 1000000007;

int n,m;
char txt[maxn][maxk];

ll start[maxn],end[maxn];

inline ll gethash( char *pok, int sz ){
    ll ret = 0;
    for( ; sz ; sz -- , pok ++ )
        ret = ( ret * prime + *pok );
    return ret;
}

vector< pair<ll,char*> > lowtmp;
void lower( ll *arr,  int n ){
    for( int i = 0; i < n; ++i ){
        int lo = 0, hi = lowtmp.size()-1;
        int pos = -1;
        while( lo <= hi ){
            int mid = (lo+hi)>>1;
            if( lowtmp[mid].f >= arr[i] ) hi = mid - 1 , pos = mid;
            else lo = mid + 1;
        }
        arr[i] = pos;
    }
}

int cnte = 1;
int head[maxn],point[maxn*2],nxt[maxn*2];
int out[maxn];
int in[maxn];

void add_edge( int a, int b ){
    nxt[cnte] = head[a], point[cnte] = b, head[a] = cnte ++;
    out[a] ++;
    in[b] ++;
}

stack<int>euler;
int curr[maxn];

void dfs( int node ){

    while( curr[node] >= 1 ){
        int w = point[ curr[node] ];
        curr[node] = nxt[ curr[node] ];
        dfs( w );
    }
    euler.push( node );
}

char sol[maxn];
bool done[maxn];

int main(){
    scanf("%d%d",&n,&m);
    int len = n;
    n = n - m + 1;

    for( int i = 0; i < n; ++i ){
        scanf("%s",txt[i]);
        start[i] = gethash( txt[i], m - 1 );
        end[i] = gethash( txt[i] + 1 , m - 1 );

        lowtmp.push_back( mk( start[i] , &txt[i][0] ) );
        lowtmp.push_back( mk( end[i] , &txt[i][1] ) );
    }

    sort( lowtmp.begin(), lowtmp.end() );
    lower( start , n );
    lower( end , n );

    for( int i = 0; i < n; ++i )
        add_edge( start[i], end[i] );

    int s = 0;
    for( int i = 0; i < 2*n; ++i ){
        if( out[i] == in[i] + 1 ) s = i;
        curr[i] = head[i];
    }

    int sz = len - 1;
    dfs( s );

    int u;
    vector< int > us;
    while( euler.empty() == false ){
        u = euler.top();
        euler.pop();
        us.push_back(u);
    }

    for( int i = us.size()-1; i >= 0; --i ){
        u = us[i];
        sol[sz--] = *(lowtmp[u].s+m-2);
    }

    sol[len] = '\0';

    for( int i = 0; i < m-1; ++i )
        sol[i] = *(lowtmp[u].s+i);

    printf("%s\n",sol);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <set>
#include <algorithm>
using namespace std;

typedef long long ll;

const int maxn = 50000 + 55;
const int maxc = 1000000000;

int n,m;
int v[maxn];

int main(){
    int tests; scanf("%d",&tests);

    for( ; tests -- ; ){
        scanf("%d%d",&n,&m);

        for( int i = 0; i < n; ++i )
            scanf("%d",&v[i]);

        sort( v,  v + n );
        reverse( v , v + n );

        ll lo = 1, hi = maxn * (ll)maxc;
        ll sol = 0;

        while( lo <= hi ){
            int mid = (lo+hi)>>1;
            int cnt = 0;

            for( int i = 0; i < n; ++i )
                cnt += v[i] / mid;

            if( cnt >= m ) lo = mid + 1, sol = mid;
            else hi = mid - 1;

        }

        printf("%lld\n",sol);
    }

    return 0;
}

#include <iostream>
#include <set>
#include <queue>
#include <math.h>
#include <string>
#include <string.h>
#include <algorithm>
#include <iomanip>
using namespace std;

const int inf = 9999999;

char a[20055];
char b[105];
int mem[105];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%s%s",a,b);

        int lena = strlen(a);
        int lenb = strlen(b);
        int sol = inf;

        for( int i = 0; i < lenb; ++i ) mem[i] = -inf;

        for( int i = 0; i < lena; ++i ){
            for( int j = lenb-1; j >= 0; --j ){
                if( b[j] != a[i] ) continue;

                if( j == 0 ) mem[j] = i;
                else mem[j] = mem[j-1];
            }

            if( mem[lenb-1] != -inf ){
                sol = min( sol , i - mem[lenb-1] + 1 );
            }
        }

        if( sol != inf ) printf("%d\n",sol);
        else printf("-1\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <string>
#include <iomanip>
#include <stack>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

typedef long long ll;

ll val;
int m,c;

int sol[40];
int possible[40][40][2][2];
vector< int > low;

bool solve( int x, int m, bool eq, bool began ){
    if( m < 0 ) return false;

    if( x == low.size() ) return !(eq||m);

    int &ref = possible[x][m][eq][began];

    if( ref != -1 )
        return ref;

    for( int d = 0; d <= 9; ++d ){
        if( eq && low[x] > d ) continue;

        sol[x] = d;
        int state = began || d != 0;
        if( solve( x + 1 , m - (d==c&&state), eq?d==low[x]:0 , state ) )
            return true;
    }
    return ref = false;
}

int main(){
    freopen("cifre.in","r",stdin);
    freopen("cifre.out","w",stdout);

    cin >> val >> m >> c;

    while( val ){
        low.push_back( val % 10 );
        val /= 10;
    }

    for( int i = 0; i < 20; ++i ) low.push_back(0);

    reverse( low.begin(), low.end() );


    memset( possible, -1, sizeof(possible));
    solve( 0 , m , 1 , 0 );

    bool begin = false;
    for( int i = 0; i < low.size(); ++i ){
        begin = (sol[i] != 0) || begin;
        if(begin) printf("%d",sol[i]);
    }
    printf("\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <string>
#include <iomanip>
#include <stack>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 100 + 55;
const int maxlen = 10000 + 55;

int n;
int pos[300];
int cnt[10];
char dnk[maxn][maxlen];

vector< pii > sol;

int main(){
    freopen("dnk.in","r",stdin);
    freopen("dnk.out","w",stdout);

    pos['A'] = 0;
    pos['C'] = 1;
    pos['G'] = 2;
    pos['T'] = 3;

    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        scanf("%s",dnk[i]);

        cnt[0] = cnt[1] = cnt[2] = cnt[3] = 0;

        int w = 0;
        int len = strlen( dnk[i] );
        for( int j = len-1; j >= 0; --j ){
            int x = pos[ dnk[i][j] ];

            for( int k = x - 1; k >= 0; --k )
                w += cnt[k];
            cnt[ x ] ++;
        }

        sol.push_back( mk(w,i) );
    }

    sort( sol.begin(), sol.end() );

    for( int i = 0; i < n; ++i )
        printf("%s %d\n",dnk[ sol[i].s ],sol[i].f );

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdlib>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <string>
#include <iomanip>
#include <stack>
using namespace std;

typedef unsigned int uint;
typedef long long ll;

#define pii pair<ll,ll>
#define x first
#define y second
#define mk make_pair

const int maxn = 100000 + 555;

int n;
pii p[maxn];

inline ll cross( pii null , pii a, pii b ){
    return (a.x-null.x)*(b.y-null.y) - (b.x-null.x)*(a.y-null.y);
}

bool byangle( pii a, pii b ){
    ll r = cross( p[0] , a , b );
    if( r != 0 ) return r > 0;
    return (a.x-p[0].x)*(a.x-p[0].x) + (a.y-p[0].y)*(a.y-p[0].y) <
           (b.x-p[0].x)*(b.x-p[0].x) + (b.y-p[0].y)*(b.y-p[0].y);
}

int main(){
    freopen("Ulaz.txt","r",stdin);
   freopen("Izlaz.out","w",stdout);

    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        uint x,y; scanf("%u%u",&x,&y);
        p[i] = mk(x,y);
    }

    int pivot = 0;
    for( int i = 0; i < n; ++i )
        if( p[pivot].y > p[i].y || p[pivot].y == p[i].y && p[pivot].x > p[i].x ) pivot = i;

    swap( p[pivot], p[0] );

    sort( p + 1, p + n , byangle );
    vector< pii > hull;

    hull.push_back( p[0] );
    hull.push_back( p[1] );


    for( int i = 2; i < n; ++i ){
        int sz = hull.size();
        //cout<<" : "<<p[i].x<<" "<<p[i].y<<endl;

        while( sz >= 2 && cross( hull[sz-1], p[i], hull[sz-2] ) <= 0 ){
            hull.pop_back();
            sz--;
        }
        hull.push_back( p[i] );
    }

    printf("%d\n",(int)hull.size());
    for( int i = 0; i < (int)hull.size(); ++i )
        printf("%u %u\n",(uint)hull[i].x,(uint)hull[i].y);

    return 0;
}

#include <cstdio>
#include <algorithm>
#include <iostream>
using namespace std;

typedef long long ll;

const int maxn = 1000000 + 555;

inline void readi( int &v ){
    static char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' )
        v = v * 10 + c - '0';
}

int n;
int v[maxn];
int low[maxn];

int tree[maxn];

inline void update( int dx ){
    for( dx += 5; dx < maxn; dx += dx & -dx )
        tree[dx] ++;
}

inline int read( int dx ){
    int ret = 0;
    for( dx += 5; dx >= 1; dx -= dx & -dx )
        ret += tree[dx];
    return ret;
}

int main(){
    freopen("rode.in","r",stdin);
    freopen("rode.out","w",stdout);
    readi(n);

    for( int i = 0; i < n; ++i ){
        readi( v[i] );
        low[i] = v[i];
    }
    sort( low, low + n );
    for( int i = 0; i < n; ++i ){
        int lo = 0, hi = n-1;
        int pos = -1;
        while( lo <= hi ){
            int mid = (lo+hi)>>1;
            if( low[mid] >= v[i] ) hi = mid - 1 , pos = mid;
            else lo = mid + 1;
        }
        v[i] = pos;
    }

    ll sol = 0;
    for( int i = n-1; i >= 0; --i ){
        sol += read( v[i]-1 );
        update( v[i] );
    }

    cout<<sol<<" KM\n";

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <set>
#include <queue>
#include <map>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

int n;
vector< pii > event;


struct state{
    int dxa,dxb,curr;
    state(){};
    state( int p1, int p2, int p3 ):dxa(p1),dxb(p2),curr(p3){};
};

int visi[105][105][105];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);

    for( int t = 1; t <= tests; ++t ){
        scanf("%d",&n);

        event.clear();
        memset( visi,0,sizeof(visi));

        for( int i = 0; i < n; ++i ){
            char c; int dx;
            cin >> c >> dx;
            event.push_back( mk(c,dx) );
        }

        queue< state > q;
        q.push( state(1,1,0) );
        visi[1][1][0] = 1;
        int sol = 10000*20000;

        while( !q.empty() ){
            state u = q.front(); q.pop();

            int a = u.dxa, b = u.dxb, c = u.curr;
            if( c >= n ){
                sol = min(sol,visi[a][b][c]);
                continue;
            }

            for( int i = -1; i <= 1; ++i ){
                for( int j = -1; j <= 1; ++j ){

                    if( a + i < 1 || a + i > 100 || b + j < 1 || b + j > 100 ) continue;
                    int xa = a + i, xb = b + j;

                    bool oki = 1, okj = 1;
                    if( i == 0 && (event[c].f != 'B' || event[c].s != xa) ) oki = false;
                    if( j == 0 && (event[c].f != 'O' || event[c].s != xb) ) okj = false;


                    if( !oki && !okj ) continue;
                    int xc = c + (i==0&&oki || j==0&&okj);

                    if( visi[xa][xb][xc] ) continue;
                    visi[xa][xb][xc] = visi[a][b][c] + 1;


                    q.push( state(xa,xb,xc) );
                }
            }
        }
        printf("Case #%d: %d\n",t,sol-1);

    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstdlib>
using namespace std;

int c;
vector< string > cs;

int d;
vector< string > cd;

int n;
string invoke;
char combine[255][255];
bool opposed[255][266];

void input(){
    memset( combine,0,sizeof(combine));
    memset( opposed,0,sizeof(opposed));
    cd.clear();
    cs.clear();

    scanf("%d",&c);
    for( int i = 0; i < c; ++i ){
        string w; cin >> w;
        cs.push_back( w );
        combine[ w[0] ][ w[1] ] = w[2];
        combine[ w[1] ][ w[0] ] = w[2];
    }

    scanf("%d",&d);
    for( int i = 0; i < d; ++i ){
        string w; cin >> w;
        cd.push_back( w );
        opposed[ w[0] ][ w[1] ] = 1;
        opposed[ w[1] ][ w[0] ] = 1;
    }

    scanf("%d",&n);
    cin >> invoke;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);

    for( int t = 1; t <= tests; ++ t ){
        input();

        vector< char > sol;
        for( int i = 0; i < n; ++i ){
            char c = invoke[i];
            int sz = sol.size();
            if( sz && combine[c][ sol[sz-1] ] != 0 ){
                sol.pop_back();
                sol.push_back( combine[c][ sol[sz-1] ] );
            }else sol.push_back( c );

            bool clr = 0;
            for( int i = 0; i < sol.size(); ++i )
                for( int j = 0; j < sol.size(); ++j )
                    if( opposed[ sol[i] ][ sol[j] ] ) clr = 1;
            if( clr ) sol.clear();
        }


        printf("Case #%d: [",t);
        for( int i = 0; i < sol.size(); ++i ){
            printf("%c",sol[i]);
            if( i != sol.size() - 1 ) printf(", ");
        }printf("]\n");
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <string.h>
#include <set>
using namespace std;

int n;
int v[1005];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);

    int tests; scanf("%d",&tests);
    for( int t = 1; t <= tests; ++t ){

        scanf("%d",&n);
        for( int i = 0; i < n; ++i ) scanf("%d",&v[i]);

        int sol = -1;
        for( int m = 1; m < (1<<n)-1; ++m ){
            int p1(0),p2(0);
            int s(0);
            for( int j = 0; j < n; ++j ){
                if( m&(1<<j)) p1 ^= v[j];
                else p2 ^= v[j];

                if( m&(1<<j) ) s += v[j];
            }

            if( p1 == p2 ) sol = max( sol , s );
        }

        if( sol == -1 ) printf("Case #%d: NO\n",t);
        else printf("Case #%d: %d\n",t,sol);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <string.h>
#include <set>
using namespace std;

int n;
int v[1005];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    int tests; scanf("%d",&tests);
    for( int t = 1; t <= tests; ++t ){

        scanf("%d",&n);
        int xr=0;
        for( int i = 0; i < n; ++i ){
            scanf("%d",&v[i]);
            xr ^= v[i];
        }

        if( xr ){
            printf("Case #%d: NO\n",t);
            continue;
        }

        int s = 1000000 + 55,sum(0);
        for( int i = 0; i < n; ++i ){
            s = min( s , v[i] );
            sum += v[i];
        }

        printf("Case #%d: %d\n",t,sum-s);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <map>
#include <cstdlib>
using namespace std;

int n;
int visi[1005];
int v[1005];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    int tests;
    scanf("%d",&tests);

    for( int t = 1; t <= tests; ++t ){

        scanf("%d",&n);
        int sol = 0;

        for( int i = 0; i < n; ++i ){
            scanf("%d",&v[i]);
            sol += v[i] != (i+1);
        }

        printf("Case #%d: %.10lf\n",t,sol*1.0);
    }

    return 0;
}

/*
ID:damtrix1
LANG:C++
TASK:mowlawn
*/
#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <math.h>
#include <set>
#include <queue>
using namespace std;

typedef long long ll;

const int maxn = 100000 + 55;

int n,m;
int v[maxn];

struct mono{
    queue< ll > q;
    deque< ll > d;

    void push( ll x ){
        q.push( x );
        while( !d.empty() && x < d.back() ) d.pop_back();
        d.push_back( x );
    }

    void pop(){
        if( q.empty() ) return;
        if( !d.empty() && q.front() == d.front() ) d.pop_front();
        q.pop();
    }

    ll top(){ return d.front(); }
};


int main(){
    freopen("mowlawn.in","r",stdin);
    freopen("mowlawn.out","w",stdout);
    scanf("%d%d",&n,&m);

    ll sum = 0;
    for( int i = 1; i <= n; ++i ){
        scanf("%d",&v[i]);
        sum += v[i];
    }

    mono q;
    q.push( 0 );

    for( int i = 1; i <= n; ++i ){
        ll x = q.top();
        q.push( x + v[i] );

        if( i > m ) q.pop();
    }

    cout << sum - q.top () << endl;

    return 0;
}

#include <iostream>
#include <string.h>
#include <set>
#include <string>
#include <math.h>
#include <vector>
using namespace std;

typedef long long ll;

vector< double > ans;

int main(){
    //freopen("Ulaz.txt","r",stdin);
    ll x;
    while( cin >> x )
        ans.push_back( sqrt( (long double)x ) );

    for( int i = ans.size()-1; i >= 0; --i )
        printf("%.4lf\n",ans[i]);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <string.h>
#include <set>
#include <string>
#include <queue>
#include <map>
using namespace std;

typedef long long ll;

int n,m;
char tmp[10];
map<int,int> point;
map<int,int> odd;
map<int,int> ok;

bool insert( int a, int b, bool isodd ){
    while( 1 ){
        if( ok[b] == false ){
            ok[b] = true;
            odd[b] = isodd;
            point[b] = a;
            return true;
        }

        int x = point[b];
        if( x == a ) return isodd == odd[b];
        else if( x < a  ) isodd = isodd != odd[b], b = a - 1 , a = x;
        else isodd = isodd != odd[b], b = x - 1;
    }
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    while( scanf("%d",&m) ){
        if( m == -1 ) break;
        point.clear();
        odd.clear();
        ok.clear();
        scanf("%d",&n);

        int sol = n;

        for( int i = 0; i < n; ++i ){
            int f,s;
            scanf("%d%d%s",&f,&s,tmp);

            if( sol == n ){
                bool x = insert( f , s , strcmp(tmp,"odd") == 0 );
                if( !x ) sol = i;
            }
        }
        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 5055;

int n;
char cols[maxn];
vector< pii > w,b;
bool usage[maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);

    cols[0] = 'w';
    w.push_back( mk(0,0) );
    w.push_back( mk(1000000000,0) );

    scanf("%d",&n);
    for( int i = 1; i <= n; ++i ){
        int a,b; char c;
        scanf("%d%d%d",&a,&b);
        while( c=getchar() ) if( c == 'w' || c == 'b' ) break;

        //cout<<a<<" "<<b<<" "<<c<<endl;

        cols[i] = c;

        w.push_back( mk(a,i) );
        w.push_back( mk(b,i) );
    }

    sort( w.begin(), w.end() );

    priority_queue< pii > pq;
    int space = 0, sola = 0, solb = 0, sol = 0 , tmp = 0;

    for( int i = 0; i < w.size(); ++i ){
        if( pq.empty() == false && cols[ pq.top().f ] == 'w' ){
            if(i)space += w[i].f - w[i-1].f;
            //printf("ADD: (%d,%d)\n",w[i-1].f,w[i].f);
        }else if( i && w[i-1].f != w[i].f ) space = 0, tmp = w[i].f;

        if( sol < space ){
            sol = space;
            sola = tmp, solb = w[i].f;
        }

        if( usage[ w[i].s ] )
            usage[ w[i].s ] = false;
        else{
            usage[ w[i].s ] = true;
            pq.push( mk(w[i].s,w[i].f) );
        }

        while( pq.empty() == false && usage[ pq.top().f ] == false ) pq.pop();
    }

    printf("%d %d\n",sola,solb);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <math.h>
#include <set>
using namespace std;

#define sz(x) (int)x.size()


const int maxn = 20000;

int n;
int p[maxn][2];
int arr[maxn];

vector< vector< int > > bit;

void add( int x, int v ){
    for( x += 5; x < 40000; x += x & -x )
        bit[x].push_back(v);
}

int query( int x, int y ){
    int ret = 0;
    for( x += 5; x >= 1; x -= x & -x )
        ret += lower_bound( bit[x].begin(), bit[x].end(), y+1 ) - bit[x].begin();
    return ret;
}

int cnt[maxn];

int main(){
    vector< int > t;
    for( int i = 0; i < 5; ++i ){
        t.push_back(i);
        t.push_back(i);
    }

    //freopen("Ulaz.txt","r",stdin);

    bit.resize(40000);

    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        int x,y; scanf("%d%d",&x,&y);
        p[i][0] = x, p[i][1] = y;
        add( x , y );
    }

    for( int i = 0; i < n; ++i ){
        int sol = query( p[i][0], p[i][1] );
        cnt[ sol - 1 ] ++;
    }

    for( int i = 0; i < n; ++i )
        printf("%d\n",cnt[i]);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

int n;
int arr[1000];

bool ispal( int a, int b ){
    while( a <= b ){
        if( arr[a] != arr[b] ) return false;
        a ++ , b --;
    }
    return true;
}

int dp[105];
int solve( int dx ){
    if( dx == n ) return 0;

    int &sol = dp[dx];
    if( sol != -1 ) return sol;
    sol = 10005;

    for( int i = dx; i < n; ++i )
        if( ispal( dx , i ) )
            sol = min( sol , solve( i + 1 ) + 1 );
    return sol;
}

bool chk(){
    cin >>n;
    memset( dp, -1,sizeof(dp));
    for( int i = 0; i < n; ++i) cin >>arr[i];
    cout<<solve(0)<<endl;
}

int f( int n ){
    if( n == 11 ) return 5;
    return (n / 6) + ((n+4) / 6) + 1;
}

int main(){
    //freopen("Izlaz.txt","w",stdout);


    vector< string > curr;
    curr.push_back( "" );
    while(1){

       //  chk();
        // continue;

        cin >> n;
        int sol = (n / 6) + ((n+4) / 6) + 1;
        if( n == 11 ) sol = 5;
        cout<<endl;
        cout<<"="<<n<<" ( "<<sol<<" ) "<<endl;

        vector< string > now;
        for( int i = 0; i < (1<<n); ++i ){
            for( int j = 0; j < n; ++j )
                arr[j] = (i&(1<<j)) != 0;

            memset( dp, -1,sizeof(dp));
            if( sol == solve(0) ){
                string tmp = "";
                for( int j = 0; j < n; ++j )
                    tmp += string(1,'0'+arr[j]);
                now.push_back(tmp);
            }
        }

        vector< string > nxt;

        for( int i = 0; i < now.size(); ++i ){
            bool ok = 0;
            for( int j = 0; j < curr.size(); ++j ){
                bool ok2 = 1;
                for( int k = 0; k < (int)curr[j].size(); ++k )
                    if( curr[j][k] != now[i][k] ) ok2 = 0;
                ok |= ok2;
            }

            if( ok ) nxt.push_back( now[i] );
        }
        curr = nxt;
        //curr = now;
        if( curr.size() ==  0 ) curr = now, printf("ISZERO\n");


        sort( curr.begin(), curr.end() );
        for( int i = 0; i < curr.size(); ++i )
            cout<<curr[i]<<endl;


        //curr.clear();
        //curr.push_back( "" );
        //cout<<sol<<endl;
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

int f( int n ){
    return (n / 6) + ((n+4) / 6) + 1;
}

int main(){
    for( int a = 1; a <= 10; ++a )
        for( int b = 1; b <= 10; ++b )
            if( f(a*b) != f(a) + f(b) -1 )
                cout<<a<<" "<<b<<endl;

    while(1){
    int n;
    cin >> n;

    for( int i = 1; i < n; ++i ){
        //printf("%d(%d) , %d(%d) , %d(%d)\n",n,f(n),i,f(i),n-i,f(n-i));
        if( f(n) != f(n-i) + f(i) )
            printf("Not addive(%d)\n",i);
    }

    }
    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
using namespace std;

int dpn,n;
int arr[1000];

int f( int n ){
    if( n == 0 ) return 0;
    if( n == 11 ) return 5;
    return (n / 6) + ((n+4) / 6) + 1;
}

bool ispal( int a, int b ){
    while( a <= b ){
        if( arr[a] != arr[b] ) return false;
        a ++ , b --;
    }
    return true;
}

int dp[1005];
int solve( int dx ){
    if( dx == dpn ) return 0;

    int &sol = dp[dx];
    if( sol != -1 ) return sol;
    sol = 10005;

    for( int i = dx; i < dpn; ++i )
        if( ispal( dx , i ) )
            sol = min( sol , solve( i + 1 ) + 1 );
    return sol;
}

int main(){
   // freopen("Izlaz.txt","w",stdout);
    scanf("%d",&n);

    int curr = 0;
    int pcurr = 0;
    for( int i = 1; i <= n; ++i ){
        if( f(i) == f(i+1) ) continue;
        int add = i-curr;
        int need = f(i);
        dpn = i;

        printf("%d = %d,%d:%d\n",i,need,curr,add);

        for( int m = 0; m < (1<<add); ++m ){
            for( int k = 0; k < add; ++k )
                arr[curr+k] = (m&(1<<k)) != 0;

            memset( dp, -1,sizeof(dp));
            int t = solve(0);

            if( t == need ) break;
        }
        pcurr = curr;
        curr = i;
    }

    pcurr = curr;
    int add = n - pcurr;
    int need = f(n);
    dpn = n;
    cout<<pcurr<<" "<<add<<endl;
    for( int m = 0; m < (1<<add); ++m ){
        for( int k = 0; k < add; ++k )
            arr[pcurr+k] = (m&(1<<k)) != 0;
        memset( dp, -1,sizeof(dp));
        int t = solve(0);

        if( t == need ) break;
    }

    cout<<curr<<" "<<n<<endl;

    dpn = n;
    memset( dp,-1,sizeof(dp));
    cout<<"SOL: "<<solve(0)<<" == "<<f(n)<<endl;
    for( int i = 0; i < n; ++i )
        printf("%d ",arr[i]);
    printf("\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
using namespace std;

int dpn,n;
int arr[1002];
int pattern[] = {1,1,0,1,0,0};

int f( int n ){
    if( n == 0 ) return 0;
    if( n == 11 ) return 5;
    return (n / 6) + ((n+4) / 6) + 1;
}

bool ispal( int a, int b ){
    while( a <= b ){
        if( arr[a] != arr[b] ) return false;
        a ++ , b --;
    }
    return true;
}

int dp[1005];
int solve( int dx ){
    if( dx == dpn ) return 0;

    int &sol = dp[dx];
    if( sol != -1 ) return sol;
    sol = 10005;

    for( int i = dx; i < dpn; ++i )
        if( ispal( dx , i ) )
            sol = min( sol , solve( i + 1 ) + 1 );
    return sol;
}

int main(){
    scanf("%d",&n);
    for( int i = 5; i < 1000; ++i )
        arr[i] = pattern[(i+1)%6];

    for( int i = 0; i < n; ++i )
        printf("%d ",arr[i]);
    printf("\n");

    int need = f(n);
    for( int m = (1<<10)-1; m >= 0; --m ){
        for( int k = 0; k < 5; ++k )
            arr[k] = (m&(1<<k)) != 0;

        for( int k = 5; k < 10; ++k )
            arr[n-k+4] = (m&(1<<k)) != 0;

        memset( dp,-1,sizeof(dp));
        dpn = n;
        int x = solve(0);

        if( x == need ) break;
    }

    dpn = n;
    memset( dp,-1,sizeof(dp));
    cout<<"SOL: "<<solve(0)<<" == "<<f(n)<<endl;
    for( int i = 0; i < n; ++i )
        printf("%d ",arr[i]);
    printf("\n");


    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
using namespace std;

int n,dpn;
int arr[1002];
int pattern[] = {0,0,1,0,1,1};

int f( int n ){
    if( n == 0 ) return 0;
    if( n == 11 ) return 5;
    return (n / 6) + ((n+4) / 6) + 1;
}

bool ispal( int a, int b ){
    while( a <= b ){
        if( arr[a] != arr[b] ) return false;
        a ++ , b --;
    }
    return true;
}

int dp[1005];
int solve( int dx ){
    if( dx == dpn ) return 0;

    int &sol = dp[dx];
    if( sol != -1 ) return sol;
    sol = 10005;

    for( int i = dx; i < dpn; ++i )
        if( ispal( dx , i ) )
            sol = min( sol , solve( i + 1 ) + 1 );
    return sol;
}

string pre[]={
"0",
"01",
"001",
"0001",
"00001",
"001011",
"0001011",
"00101100",
"000101100",
"0000101100",
"00101100101",
"000101100101",
"0000101100101"
};

int main(){
    freopen( "Ulaz.txt", "r", stdin );
    freopen("Izlaz.txt","w",stdout);
    cin >> n;
    int sol = f( n );

    if( sol % 2 == 0 && n >= 14 ){

        int m = 14;
        while( m+6 <= n ) m+=6;

        arr[2] = arr[4] = arr[5] = arr[6] = 1;
        for( int k = 7; k < m; ++k ) arr[k] = pattern[ (k-1)%6 ];
        for( int i = 1; i <= 7; ++i ) arr[m-i] = 0;
        arr[m-1] = arr[m-2] = arr[m-4] = 1;
        for( int i = n-1; i >= m; --i ) arr[i] = 1;

    }else if( n >= 14  ){
        int m = 14;
        while( m <= n ) m+=6;

        arr[2] = arr[4] = arr[5] = arr[6] = 1;
        for( int k = 7; k < m; ++k ) arr[k] = pattern[ (k-1)%6 ];
    }else{
        for( int i = 0; i < n; ++i )
            arr[i] = pre[n-1][i] - '0';
    }

    //dpn = n;
    //memset( dp, -1, sizeof(dp));
    //cout<<f(n)<<" "<<solve(0)<<endl;

    for( int i = 0; i < n; ++i )
        printf("%c",arr[i]?'a':'b');

    return 0;
}

#include <iostream>
using namespace std;

typedef long long ll;

const int mod = 1000000007;

int n;
ll a[1000];

int main(){
    int tests;
    scanf("%d",&tests);

    for( ; tests ; --tests ){
        scanf("%d",&n);

        a[0] = 1;
        for( int i = 1; i <= n; ++i ){
            a[i] = a[i-1];
            if( i >= 2 ) a[i] += 4*a[i-2];
            if( i >= 3 ) a[i] += 2*a[i-3];

            a[i] %= mod;
        }
        cout<<a[n]<<endl;
    }

    return 0;
}

#include <iostream>
#include <stack>
#include <string.h>
#include <string>
#include <set>
using namespace std;

typedef long long ll;

const int mod = 1000000007;

int n;
int b[3][3];
int a[3][3];
int m[3][3];

int tmp[3][3];

void mul( int a[3][3], int b[3][3] ){
    memset( tmp, 0, sizeof(tmp));

    for( int i = 0; i < 3; ++i )
        for( int j = 0; j < 3; ++j )
            for( int k = 0; k < 3; ++k )
                tmp[i][j] = ( tmp[i][j] + a[i][k] * (ll)b[k][j] ) % mod;

    memcpy( a , tmp , sizeof tmp );
}

int main(){
    int tests;
    scanf("%d",&tests);

    for( ; tests ; --tests ){
        scanf("%d",&n);

        if( n == 1 ) printf("1\n");
        if( n == 2 ) printf("5\n");
        if( n == 3 ) printf("11\n");
        if( n >= 1 && n <= 3 ) continue;

        memset(a,0,sizeof(a));
        memset(b,0,sizeof(b));
        b[0][0] = 1;
        b[0][1] = 5;
        b[0][2] = 11;

        a[1][0] = 1;
        a[2][1] = 1;
        a[0][2] = 2;
        a[1][2] = 4;
        a[2][2] = 1;

        n -= 3;
        stack< int > stk;
        while( n > 1 ){
            if( n % 2 == 0 ) stk.push(0), n /= 2;
            else stk.push(1), n --;
        }

        memcpy( m,a,sizeof a );

        while( stk.empty() == false ){
            int u = stk.top(); stk.pop();
            if( u == 0 ) mul( a , a );
            else mul( a , m );
        }

        mul(b,a);
        printf("%d\n",b[0][2]);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <math.h>
#include <stack>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>


const int maxn = 3000 + 55;
const int inf = 999999;

int n;
int a[maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    while( tests -- ){
        scanf("%d",&n);

        priority_queue< pii > lo,hi;

        for( int i = 0; i < n; ++i ){
            scanf("%d",&a[i]);
            lo.push( mk(inf-a[i],i) );
            hi.push( mk(a[i],i) );
        }

        int cnt = 0;
        pii u,v;
        while( 1 ){
            while( a[lo.top().s] != inf-lo.top().f ) lo.pop();
            while( a[hi.top().s] != hi.top().f ) hi.pop();

            u = lo.top(); lo.pop();
            v = hi.top(); hi.pop();

            u.f = inf - u.f;

            if( v.f-u.f <= 1 ) break;

            cnt ++;

            int x = (v.f-u.f) / 2;
            x += (v.f-u.f)&1;

            v.f -= x;
            u.f += x;

            a[v.s] = v.f;
            a[u.s] = u.f;

            hi.push(v), hi.push(u);
            v.f = inf - v.f;
            u.f = inf - u.f;
            lo.push(v), lo.push(u);
        }

        if( v.f - u.f == 0 )
            printf("%d\n",cnt);
        else
            printf("-1\n");
    }


    return 0;
}

#include <iostream>
#include <cstdio>
#include <map>
using namespace std;

int n;
map<string,int> m;

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);
    while( tests -- ){
        scanf("%d",&n);

        m.clear();
        int sol = 0;

        for( int i = 0; i < n; ++i ){
            string w; cin >> w;
            char x; cin >> x;

            int v = 1;
            if( x == '-' ) v = -1;

            sol -= m[w];
            m[w] = v;
            sol += v;
        }
        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <map>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <math.h>
using namespace std;

const int maxn = 1<<16;
const int mod = 1000000007;

typedef long long ll;

int h;
int tree[maxn];
vector< int > big[maxn];

void mul( vector< int > &base, int x ){
    ll tmp = 0;
    for( int i = 0; i < base.size(); ++i ){
        tmp = tmp + base[i] * (ll)x;
        base[i] = tmp % 10;
        tmp /= 10;
    }

    while( tmp ) base.push_back( tmp % 10 ) , tmp /= 10;
}

bool seq( vector< int > &a, vector< int > &b ){
    for( int i = a.size()-1; i >= 0; --i ){
        if( a[i] < b[i] ) return true;
        if( a[i] > b[i] ) return false;
    }
    return true;
}

int main(){
    while( scanf("%d",&h) == 1 ){
        if( h == 0 ) break;

        for( int i = 1; i < (1<<h); ++i ){
            big[i].clear();
            scanf("%d",&tree[i]);
            int x = tree[i];

            while( i >= (1<<(h-1)) && x > 0 )
                big[i].push_back( x % 10 ), x /= 10;
        }

        for( int i = (1<<(h-1))-1; i >= 1; --i ){
            int L = i*2;
            int R = i*2+1;

            vector< int >a,b;
            mul( big[L] , tree[i] );
            mul( big[R] , tree[i] );

            if( big[L].size() > big[R].size() ) big[i] = big[L];
            else if( big[L].size() < big[R].size() ) big[i] = big[R];
            else if( seq( big[L], big[R] ) ) big[i] = big[R];
            else big[i] = big[L];
        }

        int sol = 0;
        for( int i = big[1].size()-1; i >= 0; --i )
            sol = (sol*10LL + big[1][i])%mod;

        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
#include <stack>
#include <iomanip>
#include <cstdlib>
#include <cstdio>
using namespace std;

const int maxn = 105;

int n;
char mat[maxn][maxn];

int win[maxn],cnt[maxn];

double wp[maxn];
double owp[maxn];
double oowp[maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);

    for( int t = 1; t <= tests; ++t ){
        scanf("%d",&n);
        for( int i = 0; i < n; ++i ){
            scanf("%s",mat[i]);
            win[i] = cnt[i] = 0;

            for( int j = 0; j < n; ++j ){
                win[i] += mat[i][j] == '1';
                cnt[i] += mat[i][j] != '.';
            }
            wp[i] = win[i] / (double)cnt[i];
        }

        for( int i = 0; i < n; ++i ){

            double ss = 0;

            for( int j = 0; j < n; ++j ){
                if( mat[i][j] == '.' ) continue;
                int w = win[j], c = cnt[j];
                w -= mat[j][i] == '1';
                c -= mat[j][i] != '.';
                ss += w / (double)c;
            }
            owp[i] = ss/(double)cnt[i];
        }

        for( int i = 0; i < n; ++i ){
            double ss = 0;
            for( int j = 0; j < n; ++j ){
                if( mat[i][j] == '.' ) continue;
                ss += owp[j];
            }
            oowp[i] = ss / (double)cnt[i];
        }

        printf("Case #%d:\n",t);

        for( int i = 0; i < n; ++i )
            printf("%.10lf\n",0.25*wp[i] + 0.50*owp[i] + 0.25*oowp[i]);
    }

    return 0;
}


#include <iostream>
#include <vector>
#include <math.h>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
#include <stack>
#include <iomanip>
#include <cstdlib>
#include <cstdio>
using namespace std;

typedef long long ll;

const ll inf = 100000000000000000LL;

int n,d;
vector< int > x;

bool possible( ll m ){
    ll pos = -inf;
    for( int i = 0; i < x.size(); ++i ){
        ll range = pos + d;
        if( range > x[i] + m ) return false;

        pos = max( pos + d , x[i] - m );
    }
    return true;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    int tests;
    scanf("%d",&tests);

    for( int t = 1; t <= tests; ++ t ){
        scanf("%d%d",&n,&d);
        d *= 2;

        x.clear();

        for( int i = 0; i < n; ++i ){
            int p,v; scanf("%d%d",&p,&v);
            p *= 2;
            for( int j = 0; j < v; ++j ) x.push_back( p );
        }
        sort( x.begin(), x.end() );

        ll sol = -1;
        ll lo = 0, hi = 100000000000000000LL;
        while( lo <= hi ){
            ll mid = (lo+hi)>>1;
            bool ok = possible(mid);
            if( ok ) hi = mid - 1 , sol = mid;
            else lo = mid + 1;
        }

        printf("Case #%d: %.1lf\n",t,sol/2.0);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <string>
#include <string.h>
#include <stack>
#include <iomanip>
#include <cstdlib>
#include <cstdio>
using namespace std;

int n,d;

int main(){
    int tests;
    scanf("%d",&tests);

    for( int t = 1; t <= tests; ++ t ){
        scanf("%d%d",&n,&d);

        vector< int > x;
        for( int i = 0; i < n; ++i ){
            int p,v; scanf("%d%d",&p,&v);
            for( int j = 0; j < v; ++j ) x.push_back( p );
        }
        sort( p.begin(), p.end() );

        int sz = p.size();
        int sol = -1;

        for( int i = -sz; i <= sz; ++i ){
            int pos = i * d + x[0];

            int curr = 0;
            for( int j = 0; j < x.size(); ++j ){
                curr = max( curr , abs(x[j]-pos) );
                pos += d;
            }
            if( sol == -1 ) sol = curr;
            sol = min( sol , curr );
        }

        printf("%d\",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <map>
#include <cstdlib>
#include <math.h>
using namespace std;

const int maxn = 1000000;

int a[maxn];

int main(){
    a[1] = 1;
    a[2] = 2;

    int curr = 2;

    for( int i = 2; i < 200; ++i ){
        int cnt = a[i];
        while( cnt ){
            a[curr++] = i;
            cnt --;
        }
    }

    int cnt = 0,cntprev = 0,c(1);
    for( int i = 1; i <= 2000; ++i ) {
        cout<<a[i]<<" ";
        cnt ++;
        if( a[i] != a[i+1] ){
            cout<<" [ "<<cnt<<" ] "<<endl;

            if( cnt == cntprev ) c++;
            else if( c ){
                cout<<c<<endl;
                c = 1;
            }

            cntprev = cnt;
            cnt = 0;
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
using namespace std;

typedef long long ll;

ll nsum( ll lo, ll hi ){
    ll ret = (hi*(hi+1))>>1;
    lo--;
    ret -= (lo*(lo+1))>>1;
    return ret;
}

ll n;
int first[] = {1,2,2,3,3,4,4,4};

int main(){
    int tests; scanf("%d",&tests);

    while( tests -- ){
        cin >> n;
        ll lo = 4, hi = 5, groups = 1, fs = 3;

        if( n <= 5 ) printf("%d\n",first[n]);

        while( !(lo<=n && n<=hi) ){
            ll len = (hi-lo+1) / groups;
            ll nw = len * nsum(fs,fs+groups-1);
            fs += groups;
            groups = hi - lo + 1;
            lo = hi + 1;
            hi = lo + nw - 1;
        }

        ll len = (hi-lo+1) / groups;


        cout<<lo<<" "<<hi<<" | "<<groups<<" "<<fs<<endl;

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <map>
#include <cstdlib>
#include <math.h>
using namespace std;

typedef long long ll;
const int maxn = 140142;

ll a[maxn];
ll b[maxn];
ll c[maxn];

ll ss[maxn];

int main(){
    a[0] = 1, b[0] = 1, c[0] = 1;
    a[1] = 2, b[1] = 3, c[1] = 2;

    int pos = 1;
    int now = 3;
    int pairs = 2;

    while( pairs < maxn ){
        if( now > b[pos] ) now = a[++pos];
        a[pairs] = b[pairs-1] + 1;
        b[pairs] = a[pairs] + c[pos] - 1;
        c[pairs] = now;
        now ++;
        pairs ++;
    }
    if( now > b[pos] ) now = a[++pos];

    ll sum = b[pairs-1];
    for( int i = pos; i < pairs; ++i )
        sum += (b[i]-a[i]+1) * c[i];

    for( int i = 0; i < pairs; ++i ){
        ss[i] = (b[i]-a[i]+1) * c[i];
        if(i)ss[i] += ss[i-1];
    }

    int tests;
    scanf("%d",&tests);

    while( tests -- ){
        ll n; cin >>n;

        int lo = 0, hi = pairs - 1, sp = -1;

        while( lo <= hi ){
            int mid = (lo+hi)>>1;
            if( ss[mid] >= n ) hi = mid - 1, sp = mid;
            else lo = mid + 1;
        }

        if( sp ) n -= ss[sp-1];
        n--;

        cout<<a[sp] + n / c[sp]<<endl;

    }


    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <set>
#include <queue>
#include <map>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 1055;

int n,m;
int a[maxn],b[maxn];

vector< pii > pairs[maxn*maxn];

int bit[maxn];

inline void update( int dx, int v ){
    for( dx += 5; dx < maxn; dx += dx & -dx )
        bit[dx] = max( bit[dx], v );
}

inline void fclear( int dx ){
    for( dx += 5; dx < maxn; dx += dx & -dx )
        bit[dx] = 0;
}

inline int read( int dx ){
    int ret = 0;
    for( dx += 5; dx >= 1; dx -= dx & -dx )
        ret = max( ret , bit[dx] );
    return ret;
}


int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);

    for( int i = 1; i <= n; ++i ) scanf("%d",&a[i]);
    for( int i = 1; i <= m; ++i ) scanf("%d",&b[i]);

    vector< int > low;

    for( int i = 1; i <= n; ++i )
        for( int j = 1; j <= m; ++j )
            low.push_back( a[i] - b[j] );

    sort( low.begin(), low.end() );
    low.erase( unique(low.begin(),low.end()) , low.end() );


    for( int i = 1; i <= n; ++i ){
        for( int j = m; j >= 1; --j ){
            int c = a[i] - b[j];
            int pos = lower_bound( low.begin(), low.end() , c ) - low.begin();

            pairs[pos].push_back( mk(i,j) );
        }
    }

    int sol = 0;
    for( int i = 0; i < 1000000; ++i ){
        int sz = pairs[i].size();
        if( sz == 0 ) continue;

        for( int j = 0; j < sz; ++j ){
            int c = read( pairs[i][j].s - 1 );
            update( pairs[i][j].s, c + 1 );
            sol = max( sol ,c + 1 );
        }

        for( int j = 0; j < sz; ++j )
            fclear( pairs[i][j].s );
    }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <queue>
#include <stack>
using namespace std;

const int maxc = 100;
bool was[maxc];

int main(){
    srand((unsigned)time(0));
    freopen("Ulaz.txt","w",stdout);

    int n = 1 + rand()%5;
    int m = 1 + rand()%5;

    cout<<n<<" "<<m<<endl;

    for( int i = 0; i < m; ++i ){
        int a = 1 + rand()%n;
        int b = 1 + rand()%n;
        int c = 1 + rand()%maxc;

        while( was[c] ) c = 1 + rand()%maxc;
        was[c] = 1;

        cout<<a<<" "<<b<<" "<<c<<endl;
    }

    return 0;
}

#include <iostream>
#include <fstream>
#include <cstdlib>
using namespace std;

int main(){
    for( int t = 1; t <= 1000; ++t ){
        system("./mk");
        system("./test");
        system("./SPOJ_KOICOST");

        if( system("diff -qb Izlaz.txt Izlaz2.txt") ){
            cout<<t<<" WA"<<endl;
            while(1);
        }else cout<<t<<" AC"<<endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <algorithm>
using namespace std;

const int maxe = 100000 + 55;
const int maxn = 100000 + 55;
const int mod = 1000000000;

typedef long long ll;

int n,m;

struct edge{
    int a,b,c;
    edge(){};
    edge( int p1, int p2, int p3 ):a(p1),b(p2),c(p3){};
    const bool operator<( const edge &e2 ) const {
        return c < e2.c;
    }
};

int id[maxn],sz[maxn];

int find( int x ){
    if( x == id[x] ) return x;
    return id[x] = find(id[x]);
}

bool merge( int a, int b ){
    int x = find(a), y = find(b);
    if( x == y ) return 1;
    if( sz[x] > sz[y] ) swap(x,y);

    sz[y] += sz[x];
    id[x] = y;
    return 0;
}


bool visi[maxn];
vector< edge > w;

ll pss[maxn];

int run(){
    ll del(0),pairs(0),sol(0);
    sort( w.rbegin(), w.rend() );

    for( int i = 0; i < w.size(); ++i ){
        int a = w[i].a, b = w[i].b, c = w[i].c;

        int x = find( a ), y = find(b);
        ll mem = (pss[ sz[x] ] + pss[ sz[y] ])%mod;
        if( merge(a,b) ){
            sol = (sol + pairs * c)%mod;
            continue;
        }
        x = find(a);
        pairs += -mem + pss[sz[x]];
        pairs = ((pairs%mod)+mod)%mod;
        //cout<<" => "<<sol<<" "<<sum<<" | "<<c<<endl;
        sol = ( sol + pairs * c)%mod;
    }

    //cout<<del<<" | "<<sum<<" | "<<sol<<endl;
    //sol = (sol + sum * del)%mod;
    return sol;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    scanf("%d%d",&n,&m);

    for( int i = 0; i <= n; ++i ){
        sz[i] = 1, id[i] = i;
        pss[i] = (i * (ll)(i-1)) >> 1;
        pss[i] %= mod;
    }

    for( int i = 0; i < m; ++i ){
        int a,b,c; scanf("%d%d%d",&a,&b,&c); a--,b--;
        w.push_back( edge(a,b,c) );
    }

    int sol = run();


    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string.h>
#include <string>
#include <queue>
#include <stack>
using namespace std;

const int maxn = 5000;
const int maxe = 5000;
const int mod = 1000000000;

int n,m;
int dst[maxn][maxn];
int ok[maxn][maxn];

struct edge{
    int a,b,c;
    edge(){};
    edge( int p1, int p2, int p3 ):a(p1),b(p2),c(p3){};

    const bool operator<( const edge &e ) const {
        return c < e.c;
    }
};

bool visi[maxn];
bool reach( int a, int b ){
    memset( visi, 0, sizeof(visi));
    queue<int > q;
    q.push(a);
    visi[a] = 1;

    while(!q.empty()){
        int u = q.front(); q.pop();
        for( int i = 0; i < n; ++i ){
            if( visi[i] || ok[u][i] == false ) continue;
            visi[i] = 1;
            q.push(i);
        }
    }
    return visi[b];
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    scanf("%d%d",&n,&m);
    memset( dst , -1, sizeof(dst));

    vector< edge > e;

    for( int i = 0; i < m; ++i ){
        int a,b,c; scanf("%d%d%d",&a,&b,&c); a--,b--;
        dst[a][b] = dst[b][a] = c;
        e.push_back( edge(a,b,c) );
    }

    sort( e.begin(), e.end() );
    int sol = 0;

    for( int i = 0; i < n; ++i){
        for( int j = i+1; j < n; ++j ){

            memset( ok, 0, sizeof(ok) );
            for( int k = 0; k < e.size(); ++k ) ok[ e[k].a ][ e[k].b ] ++, ok[ e[k].b ][ e[k].a ] ++;

             if( reach(i,j) == false ) continue;

            for( int k = 0; k < e.size(); ++k ){
                ok[ e[k].a ][ e[k].b ] --; ok[ e[k].b ][ e[k].a ] --;
                sol = (sol+e[k].c)%mod;
                if( reach(i,j) == false ) break;
            }

        }
    }

    cout<< sol <<endl;

    return 0;
}

#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <math.h>

using namespace std;

struct par{
    double x, y;
    par( double _x, double _y ) : x(_x), y(_y) {};
    par(){};
};

struct data{
    par P1, P2;
    data( par A, par B ) : P1(A), P2(B){};
    data(){};
};

struct typ{
    par F; int id;
    typ( par _F, int _id ) : F(_F), id(_id){};
    typ(){};
};

struct ee{
    int t1, t2;
    double _cost;
    ee( int a, int b, double c ){
        t1 = a, t2 = b, _cost = c;
    };
        bool operator <(const ee &t )const{
        return t._cost > _cost;
    }
};


const double pi = 2*acos(0.);

const double tg_30  = tan( pi/6. );
const double tg_150 = tan( pi - pi/6. );

double x[100], y[100];
data Steiner[10][10];

void solve( int A, int B ){
    double k1, k2, k, m1, m2, xx, yy;

    if( x[A] == x[B] ){
        k1 = tg_30,  m1 = y[A] - k1*x[A];
        k2 = tg_150, m2 = y[B] - k2*x[B];

        xx = (m2 - m1) / (k1 - k2);
        yy = k1*xx + m1;

        Steiner[A][B].P1 = par( xx, yy );

        k1 = tg_150, m1 = y[A] - k1*x[A];
        k2 = tg_30,  m2 = y[B] - k2*x[B];

        xx = (m2 - m1) / (k1 - k2);
        yy = k1*xx + m1;

        Steiner[A][B].P2 = par( xx, yy );
    }else{
        k  = (y[B] - y[A]) / (x[B] - x[A]);
        k1 = (tg_30 + k) / (1 - tg_30*k),   m1 = y[A] - k1*x[A];
        k2 = (tg_150 + k) / (1 - tg_150*k), m2 = y[B] - k2*x[B];

        xx = (m2 - m1) / (k1 - k2);
        yy = k1*xx + m1;

        Steiner[A][B].P1 = par( xx, yy );

        k1 = (tg_150 + k) / (1 - tg_150*k), m1 = y[A] - k1*x[A];
        k2 = (tg_30 + k) / (1 - tg_30*k),   m2 = y[B] - k2*x[B];

        xx = (m2 - m1) / (k1 - k2);
        yy = k1*xx + m1;

        Steiner[A][B].P2 = par( xx, yy );
    }
}

double dist( double x1, double x2, double y1, double y2 ){
    return sqrt( (x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2) );
}

int dad[100], sz[100];

bool povezi( int a, int b ){

    for(; a != dad[a]; a = dad[a] ); dad[a] = dad[ dad[a] ];
    for(; b != dad[b]; b = dad[b] ); dad[b] = dad[ dad[b] ];

    if( a == b ) return 1;

    if( sz[a] < sz[b] )
        sz[b] += sz[a], dad[a] = b;
    else
        sz[a] += sz[b], dad[b] = a;

    return 0;
}

double sol ;
vector <typ> V;

void MST(){

    for(int i = 0; i < 10; ++i )
      dad[i] = i, sz[i] = 1;

    vector <ee> E;

    for(int i = 0; i < V.size(); ++i ){
      for(int j = 0; j < V.size(); ++j ){
        if( i == j ) continue;

        double d = dist( V[i].F.x, V[j].F.x, V[i].F.y, V[j].F.y );
        E.push_back( ee( V[i].id, V[j].id, d ) );
      }
    }

    sort( E.begin(), E.end() );

    double cost = 0.;
    for(int i = 0; i < E.size(); ++i )
      if(!povezi( E[i].t1, E[i].t2 ) ) cost += E[i]._cost;

    sol = min( sol, cost );
}


void add( par A, int id ){ V.push_back( typ( A, id ) ); }

bool have[500][500];

int main(){

    freopen("Ulaz.txt", "r", stdin );
    freopen("Izlaz2.txt","w",stdout);

    int n;
    scanf("%d", &n );

    int t = 1;
    while( n-- ){

        sol = 1e15; V.clear();
        for(int i = 0; i < 4; ++i ){
          cin >> x[i] >> y[i];
          V.push_back( typ( par(x[i], y[i]), i ) );
        }



        for(int i = 0; i < 4; ++i )
         for(int j = 0; j < 4; ++j ){
             if( i == j ) continue;
             solve( i, j );
         }

        // cout << x[0] << " " << y[0] << endl;
        // cout << x[2] << " " << y[2] << endl;
        // cout << Steiner[0][3].P1.x << " " << Steiner[0][3].P1.y << endl;
        // return 0;

         MST();

         for(int f1 = 0; f1 < 4; ++f1 )
          for(int s1 = 0; s1 < 4; ++s1 )
          {
              if( s1 == f1 ) continue;

              add( Steiner[f1][s1].P1, 4 ); MST();
              V.pop_back();

              add( Steiner[f1][s1].P2, 4 ); MST();
              V.pop_back();
          }

         for(int f1 = 0; f1 < 4; ++f1 )
          for(int s1 = 0; s1 < 4; ++ s1 )
          {
             if(f1 == s1) continue;
             add( Steiner[f1][s1].P1, 4 );
             add( Steiner[f1][s1].P2, 5 );
             MST(); V.pop_back(); V.pop_back();

             for(int f2 = 0; f2 < 4; ++f2 )
              for(int s2 = 0; s2 < 4; ++s2 )
              {
                  if( f2 == s2 ) continue;

                  add( Steiner[f1][s1].P1, 4 );
                  add( Steiner[f2][s2].P1, 5 );
                  MST(); V.pop_back(); V.pop_back();

                  add( Steiner[f1][s1].P1, 4 );
                  add( Steiner[f2][s2].P2, 5 );
                  MST(); V.pop_back(); V.pop_back();

                  add( Steiner[f1][s1].P2, 4 );
                  add( Steiner[f2][s2].P1, 5 );
                  MST(); V.pop_back(); V.pop_back();

                  add( Steiner[f1][s1].P2, 4 );
                  add( Steiner[f2][s2].P2, 5 );
                  MST(); V.pop_back(); V.pop_back();
              }
          }

          printf("%.10lf\n", sol );
    }

    return 0;
}

#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <math.h>

using namespace std;

struct par{
    double x, y;
    par( double _x, double _y ) : x(_x), y(_y) {};
    par(){};
};

struct data{
    par P1, P2;
    data( par A, par B ) : P1(A), P2(B){};
    data(){};
};

struct typ{
    par F; int id;
    typ( par _F, int _id ) : F(_F), id(_id){};
    typ(){};
};

struct ee{
    int t1, t2;
    double _cost;
    ee( int a, int b, double c ){
        t1 = a, t2 = b, _cost = c;
    };
        bool operator <(const ee &t )const{
        return t._cost > _cost;
    }
};


const double pi = 2*acos(0.);

const double tg_30  = tan( pi/6. );
const double tg_150 = tan( pi - pi/6. );

double x[100], y[100];
data Steiner[10][10];

void solve( int A, int B ){
    double k1, k2, k, m1, m2, xx, yy;

    if( x[A] == x[B] ){
        k1 = tg_30,  m1 = y[A] - k1*x[A];
        k2 = tg_150, m2 = y[B] - k2*x[B];

        xx = (m2 - m1) / (k1 - k2);
        yy = k1*xx + m1;

        Steiner[A][B].P1 = par( xx, yy );

        k1 = tg_150, m1 = y[A] - k1*x[A];
        k2 = tg_30,  m2 = y[B] - k2*x[B];

        xx = (m2 - m1) / (k1 - k2);
        yy = k1*xx + m1;

        Steiner[A][B].P2 = par( xx, yy );
    }else{
        k  = (y[B] - y[A]) / (x[B] - x[A]);
        k1 = (tg_30 + k) / (1 - tg_30*k),   m1 = y[A] - k1*x[A];
        k2 = (tg_150 + k) / (1 - tg_150*k), m2 = y[B] - k2*x[B];

        xx = (m2 - m1) / (k1 - k2);
        yy = k1*xx + m1;

        Steiner[A][B].P1 = par( xx, yy );

        k1 = (tg_150 + k) / (1 - tg_150*k), m1 = y[A] - k1*x[A];
        k2 = (tg_30 + k) / (1 - tg_30*k),   m2 = y[B] - k2*x[B];

        xx = (m2 - m1) / (k1 - k2);
        yy = k1*xx + m1;

        Steiner[A][B].P2 = par( xx, yy );
    }
}

double dist( double x1, double x2, double y1, double y2 ){
    return sqrt( (x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2) );
}

int dad[100], sz[100];

bool povezi( int a, int b ){

    for(; a != dad[a]; a = dad[a] ); dad[a] = dad[ dad[a] ];
    for(; b != dad[b]; b = dad[b] ); dad[b] = dad[ dad[b] ];

    if( a == b ) return 1;

    if( sz[a] < sz[b] )
        sz[b] += sz[a], dad[a] = b;
    else
        sz[a] += sz[b], dad[b] = a;

    return 0;
}

bool fon;
double sol ;
vector <typ> V;

void MST(){

    fon = 0;
    for(int i = 0; i < 10; ++i )
      dad[i] = i, sz[i] = 1;

    vector <ee> E;

    for(int i = 0; i < V.size(); ++i ){
      for(int j = 0; j < V.size(); ++j ){
        if( i == j ) continue;

        double d = dist( V[i].F.x, V[j].F.x, V[i].F.y, V[j].F.y );
        E.push_back( ee( V[i].id, V[j].id, d ) );
      }
    }

    sort( E.begin(), E.end() );

    double cost = 0.;
    for(int i = 0; i < E.size(); ++i )
      if(!povezi( E[i].t1, E[i].t2 ) ) cost += E[i]._cost;

    if( cost < sol ){
        sol = cost;
        fon = 1;
    }
}


void add( par A, int id ){ V.push_back( typ( A, id ) ); }

bool have[500][500];

int main(){
    freopen("Ulaz.txt","r",stdin);

    int n;
    scanf("%d", &n );

    while( n-- ){

        sol = 1e15; V.clear();
        for(int i = 0; i < 4; ++i ){
          cin >> x[i] >> y[i];
          V.push_back( typ( par(x[i], y[i]), i ) );
        }



        for(int i = 0; i < 4; ++i )
         for(int j = 0; j < 4; ++j ){
             if( i == j ) continue;
             solve( i, j );
         }

         MST();

         par A, B;
         for(int f1 = 0; f1 < 4; ++f1 )
          for(int s1 = 0; s1 < 4; ++s1 )
          {
              if( s1 == f1 ) continue;

              add( Steiner[f1][s1].P1, 4 ); MST();
              V.pop_back();
              if( fon ) A = Steiner[f1][s1].P1;

              add( Steiner[f1][s1].P2, 4 ); MST();
              V.pop_back();
              if( fon ) A = Steiner[f1][s1].P2;
          }

         for(int f1 = 0; f1 < 4; ++f1 )
          for(int s1 = 0; s1 < 4; ++ s1 )
          {
             if(f1 == s1) continue;
             add( Steiner[f1][s1].P1, 4 );
             add( Steiner[f1][s1].P2, 5 );
             MST(); V.pop_back(); V.pop_back();

             for(int f2 = 0; f2 < 4; ++f2 )
              for(int s2 = 0; s2 < 4; ++s2 )
              {
                  if( f2 == s2 ) continue;

                  add( Steiner[f1][s1].P1, 4 );
                  add( Steiner[f2][s2].P1, 5 );
                  MST(); V.pop_back(); V.pop_back();
                  if( fon ) {
                      A = Steiner[f1][s1].P1;
                      B = Steiner[f2][s2].P1;
                  }

                  add( Steiner[f1][s1].P1, 4 );
                  add( Steiner[f2][s2].P2, 5 );
                  MST(); V.pop_back(); V.pop_back();
                if( fon ) {
                      A = Steiner[f1][s1].P1;
                      B = Steiner[f2][s2].P2;
                  }

                  add( Steiner[f1][s1].P2, 4 );
                  add( Steiner[f2][s2].P1, 5 );
                  MST(); V.pop_back(); V.pop_back();
                  if( fon ) {
                      A = Steiner[f1][s1].P2;
                      B = Steiner[f2][s2].P1;
                  }
                  add( Steiner[f1][s1].P2, 4 );
                  add( Steiner[f2][s2].P2, 5 );
                  MST(); V.pop_back(); V.pop_back();

                          if( fon ) {
                      A = Steiner[f1][s1].P2;
                      B = Steiner[f2][s2].P2;
                  }
          }
          }

          cout << A.x << " " << A.y << endl;
          cout << B.x << " " << B.y << endl;
          printf("%.4lf\n", sol );
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <math.h>
using namespace std;

#define f first
#define s second
#define mk make_pair

typedef long double ld;

const ld eps = 1e-11;
const ld inf = 1e8;


int debug = 0;

struct coord{
    ld x,y;
    coord(){};
    coord( ld p1, ld p2 ):x(p1),y(p2){};

    ld dst( coord a ){
        return sqrt( (x-a.x)*(x-a.x) + (y-a.y)*(y-a.y) );
    }

    ld ccw( coord a, coord b ){
        return (a.x-x)*(b.y-y) - (a.y-y)*(b.x-x);
    }

    bool on_line( coord a, coord b ){
        bool f = min(a.x,b.x)-eps <= x && x <= max(a.x,b.x) + eps;
        bool s = min(a.y,b.y)-eps <= y && y <= max(a.y,b.y) + eps;
        return f && s;
    }

    const inline bool operator<( const coord &c ) const {
        return x < c.x || fabs(x-c.x)<eps && y < c.y;
    }
};

int n = 4;
vector< coord > p;

void clear(){ p.clear(); }

// http://paulbourke.net/geometry/2circle/
pair< coord, coord > di( coord a, coord b, ld r0=0, ld r1=0 ){
    ld d = a.dst(b);
    ld c = d / 2;
    ld h = sqrt( d*d - c*c );

    ld dx = b.x - a.x;
    ld dy = b.y - a.y;

    ld x2 = (a.x+b.x) / 2;
    ld y2 = (a.y+b.y) / 2;

    if( r0 > eps ){
        c = (r0*r0 - r1*r1 + d*d ) / (2*d);
        h = sqrt( r0*r0 - c*c  );

        x2 = a.x + (dx * c/d);
        y2 = a.y + (dy * c/d);
    }

    ld p1 = h*(b.y-a.y) / d;
    ld p2 = h*(b.x-a.x) / d;

    return mk( coord(x2+p1,y2-p2) , coord(x2-p1,y2+p2) );
}

coord circum( coord a, coord b, coord c ){
    ld d = 2*(a.x*(b.y-c.y) + b.x*(c.y-a.y) + c.x*(a.y-b.y) );

    ld x = (a.y*a.y+a.x*a.x)*(b.y-c.y) + (b.y*b.y + b.x*b.x)*(c.y-a.y) + (c.y*c.y+c.x*c.x)*(a.y-b.y);
    ld y = (a.y*a.y+a.x*a.x)*(c.x-b.x) + (b.y*b.y + b.x*b.x)*(a.x-c.x) + (c.y*c.y+c.x*c.x)*(b.x-a.x);
    x /= d, y /= d;
    return coord(x,y);
}


vector<coord> steiner( coord a, coord b, coord c ){
    if( a.ccw( b, c ) < 0  ) swap(b,c);

    coord p1,p2,p3;
    pair<coord,coord> tmp;

    tmp = di( a,b);
    if( a.ccw(tmp.f , b) > eps ) p1 = tmp.f;
    else p1 = tmp.s;

    tmp = di( b,c );
    if( b.ccw(tmp.f , c) > eps ) p2 = tmp.f;
    else p2 = tmp.s;

    tmp = di( c,a );
    if( c.ccw(tmp.f , a) > eps ) p3 = tmp.f;
    else p3 = tmp.s;

    coord z1 = circum(a,b,p1);
    coord z2 = circum(b,c,p2);
    coord z3 = circum(c,a,p3);
    ld r1 = z1.dst(a);
    ld r2 = z2.dst(b);
    ld r3 = z3.dst(c);

    vector<coord>save;

    tmp = di(z1,z2,r1,r2);
    save.push_back( tmp.f );
    save.push_back( tmp.s );

    tmp = di(z1,z3,r1,r3);
    save.push_back( tmp.f );
    save.push_back( tmp.s );

    tmp = di(z2,z3,r2,r3);
    save.push_back( tmp.f );
    save.push_back( tmp.s );

    sort( save.begin(),save.end() );
    //cout<<"VECTOR save"<<endl;
    vector<coord>ret;

    for( int i = 0; i < save.size(); ++i ){
        int cnt = 0;
        for( int j = 0; j < save.size(); ++j )
            if( fabs(save[i].x-save[j].x) < 1e-3 && fabs(save[i].y-save[j].y) < 1e-3 ) cnt ++;
        if( cnt >= 3 ) ret.push_back( save[i] );
    }
    return ret;
}



bool is_quad(){
    for( int i = 0; i < n; ++i )
        for( int j = i+1; j < n; ++j )
            for( int k = j+1; k < n; ++k )
                if( fabs(p[i].ccw( p[j], p[k] )) < eps ) return false;
    return true;
}

int color[100];

ld mst( vector< coord > &p ){
    vector< pair<ld, pair<int,int> > > edge;

    for( int i = 0; i < p.size(); ++i ){
        color[i] = i;
        for( int j = i+1; j < p.size(); ++j )
            edge.push_back( make_pair( p[i].dst( p[j] ) , make_pair(i,j) ) );
    }

    sort( edge.begin(), edge.end() );

    ld sol = 0;
    for( int i = 0; i < edge.size(); ++i ){
        int a = edge[i].s.f;
        int b = edge[i].s.s;
        ld c = edge[i].f;

        if( color[a] != color[b] ){
            sol += c;
            int y = color[a];
            for( int i = 0; i < p.size(); ++i ) if( color[i] == y ) color[i] = color[b];
        }
    }
    return sol;
}

ld one_steiner(){
    ld sol = mst( p );
    for( int i = 0; i < n; ++i )
        for( int j = i+1; j < n; ++j )
            for( int k = j+1; k < n; ++k ){
                vector<coord> x = steiner( p[i], p[j], p[k] );

                for( int m = 0; m < x.size(); ++m ){
                    coord t = x[m];

                    ld cost = t.dst( p[i] ) + t.dst( p[j] ) + t.dst( p[k] );

                    int l; for( l = 0; k <= 4; ++l ) if( i != l && j != l && k != l ) break;

                    cost += min( p[i].dst(p[l]) , min( p[j].dst(p[l]) , p[k].dst(p[l]) ) );
                    sol = min( sol , cost );
                }
            }
    return sol;
}

coord sect( coord a, coord b, coord c, coord d ){
    ld A1 = b.y - a.y;
    ld B1 = a.x - b.x;
    ld C1 = A1*a.x + B1*a.y;

    ld A2 = d.y - c.y;
    ld B2 = c.x - d.x;
    ld C2 = A2*c.x + B2*c.y;

    ld det = A1*B2 - A2*B1;
  //  cout<<det<<endl;

    if( fabs(det) < eps ) return coord(-inf-10*eps,-inf);

    ld x = (B2*C1 - B1*C2) / det;
    ld y = (A1*C2 - A2*C1) / det;
    return coord(x,y);
}

void push( vector<coord>&dat, vector<coord> w ){
    for( int i = 0; i < w.size(); ++i )
        dat.push_back( w[i] );
}

ld two_steiner(){
    ld sol = mst( p );
    //cout<<sol<<endl;
    vector< coord > tmp = p;
    if( is_quad() == false ) return sol;

    coord inter = coord(-2*inf,-2*inf);
    vector< coord > possible;

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < n; ++j ){
            for( int k = 0; k < n; ++k ){
                if( i < j && j < k ) push( possible, steiner(p[i],p[j],p[k] ) );

                if( inter.x < -inf )
                for( int l = 0; l < n; ++l ){
                    if( i == k || i == l  ) continue;
                    if( j == k || j == l ) continue;

                    coord x = sect( p[i], p[j], p[k], p[l] );

                    if( x.x < -inf ) continue;
                    if( x.on_line(p[i],p[j]) == false || x.on_line(p[k],p[l]) == false ) continue;

                    inter = x;
                }
            }
        }
    }
    possible.push_back( inter );

    if( inter.x < -inf ) return sol;

    for( int i = 0; i < n; ++i )
        for( int j = i+1; j < n; ++j )
            push( possible, steiner( p[i], p[j], inter ));

    for( int i = 0; i < possible.size(); ++i ){
        p.push_back( possible[i] );
        sol = min( sol, mst(p) );
        for( int j = i+1; j < possible.size(); ++j ){
            p.push_back( possible[j] );

            sol = min( sol , mst(p) );

            p.pop_back();
        }
        p.pop_back();
    }

    return sol;
}

int main(){
    debug = 0;
   // freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz2.txt","w",stdout);
    int tests; scanf("%d",&tests);

    int t = 1;

    cout.setf(ios::fixed, ios::floatfield);
    cout.precision(4);

    while( tests -- ){


        clear();

        for( int i = 0; i < n; ++i ){
            int f,s; cin >> f >> s;
            p.push_back( coord(f,s) );
        }


        cout<< min(one_steiner(),two_steiner()) <<endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <math.h>
using namespace std;

#define f first
#define s second
#define mk make_pair

typedef long double ld;

const ld eps = 1e-11;
const ld inf = 1e8;


int debug = 0;

struct coord{
    ld x,y;
    coord(){};
    coord( ld p1, ld p2 ):x(p1),y(p2){};

    ld dst( coord a ){
        return sqrt( (x-a.x)*(x-a.x) + (y-a.y)*(y-a.y) );
    }

    ld ccw( coord a, coord b ){
        return (a.x-x)*(b.y-y) - (a.y-y)*(b.x-x);
    }

    bool on_line( coord a, coord b ){
        bool f = min(a.x,b.x)-eps <= x && x <= max(a.x,b.x) + eps;
        bool s = min(a.y,b.y)-eps <= y && y <= max(a.y,b.y) + eps;
        return f && s;
    }

    const inline bool operator<( const coord &c ) const {
        return x < c.x || fabs(x-c.x)<eps && y < c.y;
    }
};

int n = 4;
vector< coord > p;

void clear(){ p.clear(); }

// http://paulbourke.net/geometry/2circle/
pair< coord, coord > di( coord a, coord b, ld r0=0, ld r1=0 ){
    ld d = a.dst(b);
    ld c = d / 2;
    ld h = sqrt( d*d - c*c );

    ld dx = b.x - a.x;
    ld dy = b.y - a.y;

    ld x2 = (a.x+b.x) / 2;
    ld y2 = (a.y+b.y) / 2;

    if( r0 > eps ){
        c = (r0*r0 - r1*r1 + d*d ) / (2*d);
        h = sqrt( r0*r0 - c*c  );

        x2 = a.x + (dx * c/d);
        y2 = a.y + (dy * c/d);
    }

    ld p1 = h*(b.y-a.y) / d;
    ld p2 = h*(b.x-a.x) / d;

    return mk( coord(x2+p1,y2-p2) , coord(x2-p1,y2+p2) );
}

coord circum( coord a, coord b, coord c ){
    ld d = 2*(a.x*(b.y-c.y) + b.x*(c.y-a.y) + c.x*(a.y-b.y) );

    ld x = (a.y*a.y+a.x*a.x)*(b.y-c.y) + (b.y*b.y + b.x*b.x)*(c.y-a.y) + (c.y*c.y+c.x*c.x)*(a.y-b.y);
    ld y = (a.y*a.y+a.x*a.x)*(c.x-b.x) + (b.y*b.y + b.x*b.x)*(a.x-c.x) + (c.y*c.y+c.x*c.x)*(b.x-a.x);
    x /= d, y /= d;
    return coord(x,y);
}

coord steiner( coord a, coord b, coord c ){
    if( a.ccw( b, c ) < 0  ) swap(b,c);

    coord p1,p2,p3;
    pair<coord,coord> tmp;

    tmp = di( a,b);
    if( a.ccw(tmp.f , b) > eps ) p1 = tmp.f;
    else p1 = tmp.s;

    tmp = di( b,c );
    if( b.ccw(tmp.f , c) > eps ) p2 = tmp.f;
    else p2 = tmp.s;

    tmp = di( c,a );
    if( c.ccw(tmp.f , a) > eps ) p3 = tmp.f;
    else p3 = tmp.s;

    coord z1 = circum(a,b,p1);
    coord z2 = circum(b,c,p2);
    coord z3 = circum(c,a,p3);
    ld r1 = z1.dst(a);
    ld r2 = z2.dst(b);
    ld r3 = z3.dst(c);

    vector<coord>save;

//    cout<<"CIRCUM: "<<endl;
//    cout<<z1.x<<" "<<z1.y<<" , "<<r1<<endl;
//    cout<<z2.x<<" "<<z2.y<<" , "<<r2<<endl;
//    cout<<z3.x<<" "<<z3.y<<" , "<<r3<<endl;
//    cout<<"-------------"<<endl;

    tmp = di(z1,z2,r1,r2);
    save.push_back( tmp.f );
    save.push_back( tmp.s );

    tmp = di(z1,z3,r1,r3);
    save.push_back( tmp.f );
    save.push_back( tmp.s );

    tmp = di(z2,z3,r2,r3);
    save.push_back( tmp.f );
    save.push_back( tmp.s );

    sort( save.begin(),save.end() );
    //cout<<"VECTOR save"<<endl;

    for( int i = 0; i < save.size(); ++i ){
        int cnt = 0;
        for( int j = 0; j < save.size(); ++j )
            if( fabs(save[i].x-save[j].x) < 1e-7 && fabs(save[i].y-save[j].y) < 1e-7 ) cnt ++;
        if( cnt == 3 ) return save[i];
    }

    if( debug ){
        for( int i = 0; i < save.size(); ++i )
            printf("%.10lf %.10lf\n",save[i].x,save[i].y);
        cout<<endl;
    }

    while(1);


    return coord(-1,-1);
}



bool is_quad(){
    for( int i = 0; i < n; ++i )
        for( int j = i+1; j < n; ++j )
            for( int k = j+1; k < n; ++k )
                if( fabs(p[i].ccw( p[j], p[k] )) < eps ) return false;
    return true;
}

int color[100];

ld mst( vector< coord > &p ){
    vector< pair<ld, pair<int,int> > > edge;

    for( int i = 0; i < p.size(); ++i ){
        color[i] = i;
        for( int j = i+1; j < p.size(); ++j )
            edge.push_back( make_pair( p[i].dst( p[j] ) , make_pair(i,j) ) );
    }

    sort( edge.begin(), edge.end() );

    ld sol = 0;
    for( int i = 0; i < edge.size(); ++i ){
        int a = edge[i].s.f;
        int b = edge[i].s.s;
        ld c = edge[i].f;

        if( color[a] != color[b] ){
            sol += c;
            int y = color[a];
            for( int i = 0; i < p.size(); ++i ) if( color[i] == y ) color[i] = color[b];
        }
    }
    return sol;
}

ld one_steiner(){
    ld sol = mst( p );
    for( int i = 0; i < n; ++i )
        for( int j = i+1; j < n; ++j )
            for( int k = j+1; k < n; ++k ){
                coord t = steiner( p[i], p[j], p[k] );
                ld cost = t.dst( p[i] ) + t.dst( p[j] ) + t.dst( p[k] );

                int l; for( l = 0; k <= 4; ++l ) if( i != l && j != l && k != l ) break;

                cost += min( p[i].dst(p[l]) , min( p[j].dst(p[l]) , p[k].dst(p[l]) ) );
                sol = min( sol , cost );
            }
    return sol;
}

coord sect( coord a, coord b, coord c, coord d ){
    ld A1 = b.y - a.y;
    ld B1 = a.x - b.x;
    ld C1 = A1*a.x + B1*a.y;

    ld A2 = d.y - c.y;
    ld B2 = c.x - d.x;
    ld C2 = A2*c.x + B2*c.y;

    ld det = A1*B2 - A2*B1;
  //  cout<<det<<endl;

    if( fabs(det) < eps ) return coord(-inf-10*eps,-inf);

    ld x = (B2*C1 - B1*C2) / det;
    ld y = (A1*C2 - A2*C1) / det;
    return coord(x,y);
}

ld two_steiner(){
    ld sol = mst( p );
    //cout<<sol<<endl;
    vector< coord > tmp = p;
    if( is_quad() == false ) return sol;

    coord inter = coord(-2*inf,-2*inf);
    vector< coord > possible;

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < n; ++j ){
            for( int k = 0; k < n; ++k ){
                if( i != j && i != k && j != k ) possible.push_back( coord( steiner(p[i],p[j],p[k]) ) );

                for( int l = 0; l < n; ++l ){
                    if( i == k || i == l  ) continue;
                    if( j == k || j == l ) continue;

                    coord x = sect( p[i], p[j], p[k], p[l] );

                    if( x.x < -inf ) continue;

                    if( debug ) cout<<i<<" "<<j<<" "<<k<<"["<<x.x<<" "<<x.y<<"]"<<endl;
                    if( x.on_line(p[i],p[j]) == false || x.on_line(p[k],p[l]) == false ) continue;

                    //cout<<x.x<<" "<<x.y<<endl;
                    inter = x;
                }
            }
        }
    }


    if( inter.x < -inf ) return sol;

    for( int i = 0; i < n; ++i )
        for( int j = i+1; j < n; ++j )
            possible.push_back( steiner( p[i], p[j] , inter ) );

    for( int i = 0; i < possible.size(); ++i )
        for( int j = i+1; j < possible.size(); ++j ){
            p.push_back( possible[i] );
            p.push_back( possible[j] );

            sol = min( sol , mst(p) );
           // cout<<mst(p)<<endl;

            p.pop_back();
            p.pop_back();
        }

    return sol;
}

int main(){
    debug = 0;
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);

    int t = 1;

    cout.setf(ios::fixed, ios::floatfield);
    cout.precision(8);

    while( tests -- ){


        clear();

        for( int i = 0; i < n; ++i ){
            int f,s; cin >> f >> s;
            p.push_back( coord(f,s) );
        }


        cout<< min(one_steiner(),two_steiner()) <<endl;

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <math.h>
using namespace std;

#define f first
#define s second
#define mk make_pair

const double eps = 1e-10;

struct coord{
    double x,y;
    coord(){};
    coord( double p1, double p2 ):x(p1),y(p2){};

    double dst( coord a ){
        return sqrt( (x-a.x)*(x-a.x) + (y-a.y)*(y-a.y) );
    }

    double ccw( coord a, coord b ){
        return (a.x-x)*(b.y-y) - (a.y-y)*(b.x-x);
    }

    bool on_line( coord a, coord b ){
        bool f = min(a.x,b.x)-eps <= x && x <= max(a.x,b.x) + eps;
        bool s = min(a.y,b.y)-eps <= y && y <= max(a.y,b.y) + eps;
        return f && s;
    }

    const inline bool operator<( const coord &c ) const {
        return x < c.x || fabs(x-c.x)<eps && y < c.y;
    }
};

int n = 4;
vector< coord > p;

void clear(){ p.clear(); }

// http://paulbourke.net/geometry/2circle/
pair< coord, coord > di( coord a, coord b, double r0=0, double r1=0 ){
    double d = a.dst(b);
    double c = d / 2;
    double h = sqrt( d*d - c*c );

    double x2 = (a.x+b.x) / 2;
    double y2 = (a.y+b.y) / 2;

    if( r0 > eps ){
        c = (r0*r0 - r1*r1 + d*d ) / (2*d);
        h = sqrt( r0*r0 - c*c + eps  );
        //cout<<r0<<" "<<c<<" , "<<d<<endl;
    }

    double p1 = h*(b.y-a.y) / d;
    double p2 = h*(b.x-a.x) / d;

    return mk( coord(x2+p1,y2-p2) , coord(x2-p1,y2+p2) );
}

coord circum( coord a, coord b, coord c ){
    double d = 2*(a.x*(b.y-c.y) + b.x*(c.y-a.y) + c.x*(a.y-b.y) );

    double x = (a.y*a.y+a.x*a.x)*(b.y-c.y) + (b.y*b.y + b.x*b.x)*(c.y-a.y) + (c.y*c.y+c.x*c.x)*(a.y-b.y);
    double y = (a.y*a.y+a.x*a.x)*(c.x-b.x) + (b.y*b.y + b.x*b.x)*(a.x-c.x) + (c.y*c.y+c.x*c.x)*(b.x-a.x);
    x /= d, y /= d;
    return coord(x,y);
}

coord steiner( coord a, coord b, coord c ){
    if( a.ccw( b, c ) < 0  ) swap(b,c);

    coord p1,p2,p3;
    pair<coord,coord> tmp;

    tmp = di( a,b);
    if( a.ccw(tmp.f , b) > eps ) p1 = tmp.f;
    else p1 = tmp.s;

    tmp = di( b,c );
    if( b.ccw(tmp.f , c) > eps ) p2 = tmp.f;
    else p2 = tmp.s;

    tmp = di( c,a );
    if( c.ccw(tmp.f , a) > eps ) p3 = tmp.f;
    else p3 = tmp.s;

    coord z1 = circum(a,b,p1);
    coord z2 = circum(b,c,p2);
    coord z3 = circum(c,a,p3);
    double r1 = z1.dst(a);
    double r2 = z2.dst(b);
    double r3 = z3.dst(c);

    vector<coord>save;

    cout<<"CIRCUM: "<<endl;
    cout<<z1.x<<" "<<z1.y<<" , "<<r1<<endl;
    cout<<z2.x<<" "<<z2.y<<" , "<<r2<<endl;
    cout<<z3.x<<" "<<z3.y<<" , "<<r3<<endl;
    cout<<"-------------"<<endl;

    tmp = di(z1,z2,r1,r2);
    save.push_back( tmp.f );
    save.push_back( tmp.s );

    tmp = di(z1,z3,r1,r3);
    save.push_back( tmp.f );
    save.push_back( tmp.s );

    tmp = di(z2,z3,r2,r3);
    save.push_back( tmp.f );
    save.push_back( tmp.s );

    sort( save.begin(),save.end() );
    cout<<"VECTOR save"<<endl;
    for( int i = 0; i < save.size(); ++i ){
        cout<<save[i].x<<" "<<save[i].y<<" : ";
        double r = 0;
        for( int j = 0; j < save.size(); ++j )
            r += save[i].dst( save[j] );
        cout<<r<<endl;
    }



    return coord(-1,-1);
}

void one_steiner(){

}

void two_steiner(){

}

bool is_quad(){
    for( int i = 0; i < n; ++i )
        for( int j = i+1; j < n; ++j )
            for( int k = j+1; k < n; ++k )
                if( fabs(p[i].ccw( p[j], p[k] )) < eps ) return false;
    return true;
}

int main(){
    coord t = steiner( coord(0,0) , coord(4,0), coord(2,3) );
    cout<<t.x<<" "<<t.y<<endl;


    freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    while( tests -- ){

        clear();

        for( int i = 0; i < n; ++i ){
            int f,s; cin >> f >> s;
            p.push_back( coord(f,s) );
        }


        if( is_quad() ) two_steiner();
        else one_steiner();
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <map>
#include <string>
#include <vector>
#include <string.h>
#include <algorithm>
using namespace std;

#define all(x) x.begin(),x.end()

const int mod = 30013;
const int maxn = 400000 + 55;

int n;
int a[maxn],b[maxn],c[maxn],d[maxn];

int ask[maxn], answer[maxn];
int mem_max[maxn];
int mem_cnt[maxn];


int bit_max[maxn];

void update_max( int x, int v ){
    for( x += 5; x < maxn; x += x & -x )
        bit_max[x] = max( bit_max[x] , v );
}

int query_max( int x ){
    int ret = 0;
    for( x += 5; x >= 1; x -= x & -x )
        ret = max( ret, bit_max[x] );
    return ret;
}


int siz[maxn]; // velicina niza bit_cnt[x]
int *bit_cnt[maxn];

void update_cnt( int row, int x, int v = 1 ){
    for( x += 5; x < siz[row]; x += x & -x )
        bit_cnt[row][x] = ( bit_cnt[row][x] + v ) % mod;
}

int query_cnt( int row, int x ){
    int ret = 0;
    for( x += 5; x >= 1; x -= x & -x )
        ret = ( bit_cnt[row][x] + ret ) % mod;
    return ret;
}

// pos: posto nisam u mogucnost da napravim bit[maxn][maxn] (svaki red je zaseban BIT, tj. ne radi na 2D-bit nacin ),
// trebam nekako naci nacin da suzim tu matricu ako znam koje kverije i koje update-ove cu raditi na bit[maxn][maxn]
// To mozes lako uraditi sa onim nacinom kao i kad suzivas koordinate

vector< int > pos[maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);

    vector< int > low;
    memset( ask, -1, sizeof(ask));
    memset( answer, -1, sizeof(answer));

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%d%d%d%d",a+i,b+i,c+i,d+i);
        low.push_back(a[i]), low.push_back(b[i]);
        low.push_back(c[i]), low.push_back(d[i]);
    }

    sort( all(low) );
    low.erase( unique(all(low)), low.end() );

    for( int i = 0; i < n; ++i ){ // u ovom dijelu suzavamo koordinate trapezoida tako da ce
                                  //nakon suzavanja sve koordinate biti < 400,000
        a[i] = lower_bound( all(low), a[i] ) - low.begin();
        b[i] = lower_bound( all(low), b[i] ) - low.begin();
        c[i] = lower_bound( all(low), c[i] ) - low.begin();
        d[i] = lower_bound( all(low), d[i] ) - low.begin();
        ask[ c[i] ] = i, answer[ d[i] ] = i; // ask[ c[i] ] - trazimo rijesenje za trapezoid i kad naidjemo na c[i]
                                             // answer[ d[i] ] - update-amo stanje trapezoida i tako da od tada moze ulaziti
                                             // u druga rijesenja / subsequenca
                                             // p.s. ovo radi jer su svi vrhovi distinct
    }

    int sol_max = 0, sol_cnt = 0;

    for( int i = 0; i < maxn; ++i ){
        int x;
        if( (x=ask[i]) != -1 ){ // trazimo rijesenje za trapezoid x ako je pozicija i zauzeta od nekog trapezoida x sa lower-left vrhom
            mem_max[x] = query_max( a[x] ) + 1; // mem_max[x] pamti rijesenje trapezoida x
            pos[ mem_max[x]-1 ].push_back( a[x] ); // pamtim kverije koje cu nad bit_cnt raditi
            pos[ mem_max[x]   ].push_back( b[x] ); // pamtim update-ove koje cu nad bit_cnt raditi
        }else if( (x=answer[i]) != -1 ){ // update-amo trapezoid x ako je pozicija i zauzeta od nekog trapezoida x sa lower-right vrhom
            update_max( b[x], mem_max[x] ); // ovdje update-am nadjeno rijesenje trapezoida x
            sol_max = max( sol_max, mem_max[x] ); // update-am maximum
        }
    }

    for( int i = 0; i < maxn; ++i ){ // GRADIM bit_cnt poznavanjem kverije i update-ove nad njim
        sort( all(pos[i]) ); // sortiram
        pos[i].erase( unique(all(pos[i])), pos[i].end() ); // izbrisem duplikate

        int sz = pos[i].size() + 5; // postavim velicinu bit_cnt[i]-a, i dodam +5 radi lakse koristenja
        bit_cnt[i] = new int[sz];
        siz[i] = sz; // pamtim velicinu zbog update-a koji ide do max-a
        for( int j = 0; j < sz; ++j )
            bit_cnt[i][j] = 0;
    }

    for( int i = 0; i < maxn; ++i ){
        int x;
        if( (x=ask[i]) != -1 ){
            int lvl = mem_max[x];
            int y = lower_bound( all(pos[lvl-1]), a[x] ) - pos[lvl-1].begin(); // y = pozicija a[x] u pos[lvl-1]
            int c = query_cnt( lvl-1, y ); // trazim rijesenje trapezoida x
            mem_cnt[x] = max(1,c); // pamtim rijesenje trapezoida x
        }else if( (x=answer[i]) != -1 ){
            int lvl = mem_max[x];
            int y = lower_bound( all(pos[lvl]), b[x] ) - pos[lvl].begin();

            update_cnt( lvl, y, mem_cnt[x] ); // update-am rijesenje trapezoida x
            if( lvl == sol_max ) sol_cnt = ( sol_cnt + mem_cnt[x] )%mod;
        }
    }

    printf("%d %d\n",sol_max, sol_cnt );

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define x first
#define y second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()
#define sz(x) (int)x.size()

typedef long long ll;

const int mod = 1000000007;

int n[3];
int dp[100][100];

int c( int n, int k ){
    if( k == 0 || k == n ) return 1;
    if( dp[n][k] != -1 ) return dp[n][k];
    return dp[n][k] = (c(n-1,k-1) + c(n-1,k))%mod;
}

int m;
char mat[20][20];
int in[20];

int dp2[1<<17];

int cnt( int mask ){
    if( mask == 0 ) return 1;

    int &sol = dp2[mask];
    if( sol != -1 ) return sol;

    sol = 0;

    for( int i = 0; i < m; ++i ){
        if( ~mask&(1<<i) || in[i] ) continue;

        for( int j = 0; j < m; ++j )
            if( mat[i][j] == 'Y' ) in[j] --;

        sol = (sol + cnt( mask-(1<<i) ) ) % mod;

        for( int j = 0; j < m; ++j )
            if( mat[i][j] == 'Y' ) in[j] ++;

    }
    return sol;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    memset( dp, -1, sizeof(dp));

    int tests; cin >> tests;

    while( tests -- ){

        cin >> n[0] >> n[1] >> n[2];
        int sol = ( c(n[0]+n[1]+n[2],n[0]+n[1]) * (ll)c(n[0]+n[1],n[1]) ) % mod;

        for( int i = 0; i < 3; ++i ){
            m = n[i];
            memset( in, 0, sizeof(in));

            for( int j = 0; j < m; ++j ){
                scanf("%s",mat[j]);

                for( int k = 0; k < m; ++k )
                    if( mat[j][k] == 'Y' ) in[k] ++;
            }
            memset( dp2, -1, sizeof(dp2));
            int mem = cnt( (1<<m) - 1 );
            sol = (sol*(ll)mem)%mod;
        }
        cout<<sol<<endl;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define x first
#define y second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()
#define sz(x) (int)x.size()

const int mod = 10007;

int n,m,p;
int e;
bool e_man[30];
int mat[30][30];

int c_dp[100][100];

int c( int n, int k ){
    if( k > n || k < 0 ) return 0;
    if( k == 0 || k == n ) return 1;
    if( c_dp[n][k] != -1 ) return c_dp[n][k];
    return c_dp[n][k] = (c(n-1,k-1) + c(n-1,k))%mod;
}

int dp[30][1<<20];
int f[30];

int solve( int dx, int mask, int c = 0 ){
    if( dx == m ){
        int man = e, wom = m - c;
        int a = ::c(man,p-c) , b = ::c(wom,p-c);
        int ret = (a*b)%mod;
        ret = (ret*f[p-c])%mod;
        return ret;
    }

    int &sol = dp[dx][mask];
    if( sol != -1 ) return sol;

    sol = solve( dx + 1, mask, c );

    int sz = 0;
    for( int i = 0; i < n; ++i ){
        if( e_man[i] ) continue;
        bool use = ~mask&(1<<sz); sz ++;
        if( use || mat[i][dx] == 0 ) continue;

        sol = (sol + solve( dx +1, mask-(1<<(sz-1)), c + 1 ) ) % mod;
    }
    return sol;
}

int main(){
    f[0] = 1;
    for( int i = 1; i < 30; ++i )
        f[i] = (f[i-1]*i)%mod;
    memset( c_dp, -1, sizeof(c_dp));

    //freopen("Ulaz.txt","r",stdin);
    cin >> n >> m >> p;
    for( int i = 0; i < n; ++i ){
        e_man[i] = 1;
        for( int j = 0; j < m; ++j ){
            scanf("%d",&mat[i][j]);
            if( mat[i][j] == 0 ) e_man[i] = 0;
        }
        e += e_man[i];
    }
    memset( dp, -1, sizeof(dp));
    int sol = solve( 0, (1<<(n-e))-1 );
    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define x first
#define y second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()

int solve( int n, int x ){
    bool win = 0;
    for( int y = 1; y <= x; ++y ){
        if( x % y || n < y ) continue;
        win |= !solve(n-y,y);
    }
    return win;
}

int main(){
    int tests; cin >> tests;
    while( tests -- ){
        int n; cin >> n;
        bool bkul = 0;
        for( int i = 1; i <= n; i *= 2 )
            if( i == n ) bkul = 1;
        if( bkul ) printf("BKUL\n");
        else printf("BMEENA\n");
        continue;

        bool f = 0;
        for( int i = 1; i < n; ++i )
            f |= !solve( n - i, i );
        if( f ) printf("BMEENA\n");
        else printf("BKUL\n");
    }

}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define x first
#define y second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()


int n;

int main(){
    cin >> n;
    long long sol = 0;
    for( int i = 1; i <= n; ++i )
        sol += (n / i)*i;
    cout << sol << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <iomanip>
#include <bitset>
using namespace std;

int x;

int toright( int right ){
    int tmp = right;
    int pw10 = 1,t;
    int nxt = 0;
    while( tmp ){
        t = tmp % 10;
        tmp /= 10;

        if( tmp ) nxt += pw10 * t;

        pw10 *= 10;
    }
    right = nxt*10 + t;
    return right;
}

int toleft( int left ){
    int tmp = left;
    int pw10 = 1;
    while( tmp ){
        tmp /= 10;
        pw10 *= 10;
    }
    int t = left % 10;
    left /= 10;
    left += t*(pw10/10);
    return left;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests; scanf("%d",&tests);
    for( ; tests; --tests ){
        scanf("%d",&x);
        int sol = toleft( toright(x) );
        sol = max( sol, toright( toleft(x) ) );

        int left = x, right = x;

        for( int i = 0; i < 20; ++i ){
            left = toleft( left );
            right = toright( right );
            sol = max( sol, left );
            sol = max( sol, right );
        }
        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <map>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

int n,a,b;

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests; scanf("%d",&tests);
    while( tests -- ){
        scanf("%d%d%d",&n,&a,&b);
        int c1 = __builtin_popcount(a);
        int c2 = __builtin_popcount(b);

        int over = max(0,(c1+c2)-n);
        int sol = 0;

        for( int i = 0; i < min((c1+c2),n)-over; ++i ){
            sol += 1<<(n-i-1);
        }
        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <iomanip>
#include <bitset>
using namespace std;

const int maxn = 1000 + 55;
int cnt[maxn];
int n;

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        memset( cnt, 0, sizeof(cnt));

        scanf("%d",&n);
        for( int i = 0; i < n; ++i ){
            int a; scanf("%d",&a);
            cnt[a] ++;
        }
        for( int i = 0; i < n; ++i ){
            int a; scanf("%d",&a);
            cnt[a] --;
        }

        int s = 0;
        int sol = 0;
        for( int i = 0; i < maxn; ++i ){
            s += cnt[i];
            sol = max( sol, s );
        }
        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
using namespace std;

string w;
int v( int v ){
    if( v >= '1' && v <= '8' ) return 1;
    if( v >= 'a' && v <= 'h' ) return 2;
    return 0;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);
    char c;
    c = getchar();

    while( tests -- ){
        string w = "";
        while( c=getchar() ){
            if( c != '\n' )w += string(1,c);
            else break;
        }

        if( w.size() != 5 ){
            printf("Error\n");
            continue;
        }

        bool ok = (v(w[0]) == 2) && (v(w[1]) == 1) && (w[2]=='-') && (v(w[3])==2) && (v(w[4])==1);

        if( !ok ){
            printf("Error\n");
            continue;
        }

        int f = abs( w[0] - w[3] );
        int s = abs( w[1] - w[4] );
        if( f == 1 && s == 2 || f == 2 && s == 1 )
            printf("Yes\n");
        else
            printf("No\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <iomanip>
#include <bitset>
using namespace std;

typedef long long ll;

char a[20],b[20];

int len;
int lo[20],hi[20];

ll dp[20][20][2][2];

ll solve( int dx, int mod10, bool da, bool db ){
    if( dx == len ) return mod10;

    ll &sol = dp[dx][mod10][da][db];
    if( sol != -1 ) return sol;

    sol = 0;

    for( int i = 0; i <= 9; ++i ){
        bool dan = da, dbn = db;
        if( da && i < lo[dx] ) continue;
        if( db && i > hi[dx] ) continue;

        if( da && i > lo[dx] ) dan = 0;
        if( db && i < hi[dx] ) dbn = 0;
        int add = i;
        if( i%2 == 0 ) add *= 2;
        sol += solve( dx + 1, (mod10+add)%10, dan, dbn );
    }
    return sol;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    while( tests-- ){
        memset( lo, 0, sizeof( lo ));
        memset( hi, 0, sizeof( hi ));

        scanf("%s%s",a,b);
        int lena = strlen(a), lenb = strlen(b);
        len = max(lena,lenb);

        for( int i = 0; i < lena; ++i ) lo[ len-lena+i ] = a[i] - '0';
        for( int i = 0; i < lenb; ++i ) hi[ len-lenb+i ] = b[i] - '0';

        memset( dp, -1, sizeof(dp));
        ll sol = solve( 0 , 0, 1, 1 );
        printf("%lld\n",sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <map>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

int n;

int main(){
  //  freopen("Ulaz.txt","r",stdin);

    while( scanf("%d",&n) == 1 ){
        if( n == 0 ) break;

        int curr = 0;

        for( int i = 0; i < n; ++i ){
            char c;
            while( c = getchar() ) if( c == 'P' || c == 'M' ) break;
            int x; scanf("%d",&x);
            int add = 1;
            if( c == 'M' ) add = -1;
            x = abs(x-add);

            if( curr < x ) curr = x;
            else if( curr%2 != x%2 ) curr ++;
        //    cout<<i<<" = "<<curr<<" | "<<x<<endl;
        }
        printf("%d\n",curr);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <map>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

typedef long long ll;

const int cp = 1;
const ll prime[] = { 1000000007, 1000000033, 1000000103 };

const int maxn = 500000 + 55;

int n;
char s[maxn];
int take[2];

int visi[maxn][2];
ll hash[1][maxn];
ll stp[1][maxn];

bool isprime( int x ){
    if( x % 2 == 0 && x != 2 ) return 0;

    for( int i = 3; i*i <= x; i += 2 )
        if( x % i == 0 )return 0;
    return 1;
}

int main(){
   freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);

    for( int p = 0; p < cp; ++p ){
        stp[p][0] = 1;
        for( int i = 1; i < maxn; ++i )
            stp[p][i] = stp[p][i-1] * prime[p];
    }

    int tests; scanf("%d",&tests);
    while( tests -- ){
        memset( hash,0,sizeof(hash));
        memset( visi, 0,sizeof(visi));

        scanf("%s",s);
        scanf("%d%d",&take[0],&take[1]);

        n = strlen(s);
        int curr = n-1;
        int mov = 0;
        int cnt = 0;
        int sol = -1;

        for( int p = 0; p < cp; ++p )
            for( int i = n-1; i >= 0; --i )
                hash[p][i] = hash[p][i+1] * prime[p] + s[i];

        while( visi[curr][mov] == 0 ){
            visi[curr][mov] ++;
            curr = (curr-take[mov]+n)%n;
            mov = !mov;

            cnt ++;

            int len = (n-curr-1);
            bool ok = 1;
            for( int p = 0; p < cp; ++p ){
                ll key1 = hash[p][curr+1];
                ll key2 = (hash[p][0]-hash[p][curr+1]*stp[p][curr+1])*stp[p][len];
                ll key = key1 + key2;
                if( key != hash[p][0] ) ok = 0;
            }

            if( ok ){
                sol = cnt;
                break;
            }
        }

        printf("%d\n",sol);

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <queue>
#include <stack>
#include <cstdlib>
using namespace std;

const int maxm = 10000 + 55;
const int maxn = 10000 + 55;

struct edge{
    int t1,c2,t2;
    bool used;
    edge(){ used = 0; };
    edge( int p1, int p2, int p3 ):t1(p1),c2(p2),t2(p3){ used = 0; };

    const bool operator<( const edge &e ) const {
        return t1 < e.t1;
    }
};

int m;
int c1[maxm],t1[maxm],c2[maxm],t2[maxm];

vector< edge > g[maxn];

int pos( int node, int time ){
    int lo = 0, hi = g[node].size() - 1;
    int ret = -1;
    while( lo <= hi ){
        int mid = (lo+hi)>>1;

        if( g[node][mid].t1 >= time ) hi = mid - 1, ret = mid;
        else lo = mid + 1;
    }
    return ret;
}

int main(){
  //  freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    for( ; tests; --tests ){
        scanf("%d",&m);

        for( int i = 0; i < maxn; ++i ) g[i].clear();

        for( int i = 0; i < m; ++i ){
            scanf("%d%d%d%d",c1+i,t1+i,c2+i,t2+i);
            g[ c1[i] ].push_back( edge(t1[i],c2[i],t2[i]) );
        }

        for( int i = 0; i < maxn; ++i ) sort( g[i].begin(), g[i].end() );

        int cc,ct,ce,bday;
        scanf("%d%d%d%d",&cc,&ct,&ce,&bday);

        bool no = false;
        int sol = 0;

        while( cc != ce || ct > bday ){
            int nxt = pos( cc , ct );

            if( nxt == -1 || g[cc][nxt].used ) no = true;
            if( no ) break;

            g[cc][nxt].used = 1;
            int node = g[cc][nxt].c2;
            int time = g[cc][nxt].t2;
            cc = node, ct = time;
            sol ++;
        }

        if( no ){
            printf("No\n");
            continue;
        }

        printf("Yes %d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <map>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 500 + 55;

int n;
int v[maxn][maxn];
int dp[maxn][maxn];
int lp[maxn][maxn];
int row[maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);

    int tests; scanf("%d",&tests);
    while( tests -- ){
        scanf("%d",&n);

        memset(row,0,sizeof(row));
        for( int i = 0; i < maxn; ++i )
            for( int j = 0; j < maxn; ++j )
                v[i][j] = dp[i][j] = lp[i][j] = 0;

        for( int i = 0; i < n; ++i ){
            for( int j = 0; j <= i; ++j )
                scanf("%d",&v[i][j]);
        }

        for( int r = 0; r < n; ++r ){
            for( int c = 0; c <= r; ++c ){
                int mx = max( dp[r-1][c] , dp[r-1][c+1] );
                if( c > 0 ) mx = max( mx , dp[r-1][c-1] );
                dp[r][c] = mx + v[r][c];
            }
        }

        for( int c = n-1; c >= 0; --c ){
            for( int r = n-1; r >= c; --r ){
                int mx = max(lp[r][c+1],lp[r+1][c+1]);
                if( r-1>0 ) mx = max( mx, lp[r-1][c+1] );
                lp[r][c] = mx + v[r][c];
            }
        }

        for( int i = 0; i < n; ++i ){
            row[i] = v[n-i-1][i];
            if( i ) row[i] += row[i-1];
        }

        int sol = 0;

        for( int f = 0; f < n; ++f ){
            for( int s = 0; s < n; ++s ){
                int curr = row[max(f,s)];
                int fa = dp[n-f-2][f];
                if( f ) fa = max( fa , dp[n-f-2][f-1] );

                int sa = max(lp[n-s-1][s+1] , lp[n-s][s+1] );
                curr += sa + fa;
                sol = max( sol , curr );
            }
        }
        printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <math.h>
#include <algorithm>
#include <iomanip>
#include <stack>
#include <string.h>
#include <queue>
#include <set>
using namespace std;

#define mk make_pair
#define f first
#define s second

const int maxn = 100000 + 55;

int m;
char txt[maxn];
int cnt[555];
bool del[555];

int main(){
     //freopen("Ulaz.txt","r",stdin);

    scanf("%s%d",txt,&m);
    int len = strlen(txt);

    for( int i = 0; i < len; ++i )
        cnt[ txt[i] ] ++;

    vector< pair<int,char> > w;

    for( char c = 'a'; c <= 'z'; ++c )
        w.push_back( mk(cnt[c],c) );

    sort( w.begin(), w.end() );

    for( int i = 0; i < w.size(); ++i ){
        if( w[i].f > m ) break;
        m -= w[i].f;
        del[ w[i].s ] = 1;
    }


    int sm = 0;
    string sol = "";

    for( int i = 0; i < len; ++i ){
        char c = txt[i];
        if( del[c] ) continue;
        if( cnt[c] != -1) sm ++;
        cnt[c] = -1;
        sol += string(1,c);
    }

    cout<<sm<<endl;
    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <math.h>
#include <algorithm>
#include <iomanip>
#include <stack>
#include <string.h>
#include <queue>
#include <set>
using namespace std;

#define mk make_pair
#define f first
#define s second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()

const int mod = 1000000007;
const int maxn = 100000 * 5;

int n,m;
vector< pii > seg;

bool byend( pii a, pii b ){ return a.s < b.s; }

int tree[maxn];

void add( int x, int v ){
    for( x += 5; x < maxn; x += x & -x )
        tree[x] = (tree[x]+v)%mod;
}

int read( int x ){
    int ret = 0;
    for( x += 5; x >= 1; x -= x & -x )
        ret = (ret+tree[x])%mod;
    return ret;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d%d",&n,&m);

    vector< int > low;
    bool ok1 = 0;
    bool ok2 = 0;

    for( int i = 0; i < m; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        if( b == n ) ok1 = 1;
        if( a == 0 ) ok2 = 1;
        low.push_back(a), low.push_back(b);
        seg.push_back( mk(a,b) );
    }

    if( ok1 == 0 || ok2 == 0 ){
        printf("0\n");
        return 0;
    }

    sort( all(low) );
    low.erase( unique(low.begin(),low.end()), low.end() );

    for( int i = 0; i < m; ++i ){
        seg[i].f = lower_bound( all(low), seg[i].f ) - low.begin();
        seg[i].s = lower_bound( all(low), seg[i].s ) - low.begin();
    }

    sort( seg.begin(), seg.end(), byend );
    add(0,1);
    int mx = 0;

    for( int i = 0; i < seg.size(); ++i ){
        int cnt = read( seg[i].s - 1 ) - read( seg[i].f - 1 );
        cnt %= mod;
        cnt = (cnt+mod)%mod;
        add( seg[i].s , cnt );

        mx = max( seg[i].s, mx );
    }

    int sol = read(mx)-read(mx-1);
    sol %= mod;
    sol = (sol+mod)%mod;
    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <math.h>
#include <map>
#include <set>
#include <queue>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

#define mk make_pair
#define f first
#define s second

int n,m;
double coef;

vector< pair<string,int> > sol;
map<string,bool> added;

int main(){
    //freopen("Ulaz.txt","r",stdin);

    cin >> n >> m >> coef;

    for( int i = 0; i < n; ++i ){
        string a; int b;
        cin >> a >> b;
        b = (int)(b*coef+1e-9);
        if( b >= 100 ){
            sol.push_back( mk(a,b) );
            added[a] = 1;
        }
    }

    for( int i = 0; i < m; ++i ){
        string s;
        cin >> s;
        if( added[s] == false ){
            sol.push_back( mk(s,0) );
            added[s] = 1;
        }
    }

    sort( sol.begin(), sol.end() );
    cout<<sol.size()<<endl;
    for( int i = 0; i < sol.size(); ++i )
        cout<<sol[i].f<<" "<<sol[i].s<<endl;



    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <math.h>
#include <map>
#include <set>
#include <queue>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

int n,m,power;

int p[100];
int loyal[100];
int add[100];

int fin[1<<10];

double dp[10][1<<8];

double solve( int dx, int mask ){
    if( dx == n ){
        if( fin[mask] == -1 ) return 1;
        else return power / (double)(power+fin[mask]);
    }

    double &ret = dp[dx][mask];
    if( ret > -1e-9 ) return ret;


    double t = (add[dx]+loyal[dx]);
    t /= 100;

    ret = t * solve( dx + 1 , mask );
    ret += (1-t) * solve( dx + 1, mask|(1<<dx) );

    return ret;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d%d%d",&n,&m,&power);

    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        p[i] = a;
        loyal[i] = b;
    }

    int mx = 1;
    for( int i = 0; i < n; ++ i ) mx *= 9;

    for( int i = 0; i < (1<<n); ++i ){
        int cnt = 0;
        int sum = 0;
        for( int j = 0; j < n; ++j ){
            if(~i&(1<<j) ) continue;
            cnt ++;
            sum += p[j];
        }
        int left = n - cnt;
        if( left > (n/2) ) sum = -1;
        fin[i] = sum;
    }

    double sol = 0;

    for( int cm = 0; cm < mx; ++cm ){
        int stoken = 0;
        int mem = cm;
        bool ok = 1;
        for( int i = 0; i < n; ++i ){
            int w = mem % 9; mem /= 9;
            stoken += w;
            add[i] = 10 * w;
            if( loyal[i]+add[i] > 100 ) ok = 0;
            if( stoken > m ) ok = 0;
        }

        if( !ok ) continue;

        for( int i = 0; i < n; ++i )
            for( int j = 0; j < (1<<n); ++j )
                dp[i][j] = -1;

        sol = max( sol, solve(0,0) );
    }

    printf("%.10lf\n",sol);


    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <iomanip>
#include <stack>
#include <string.h>
#include <string>
#include <map>
#include <set>
#include <queue>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

int main(){
    // freopen("Ulaz.txt","r",stdin);
    int n;
    cin >> n;

    int slen = -1, p7;

    for( int len = 1; len <= 1000000; ++len ){
        int s = len * 4;
        if( s > n ) break;
        int rem = n - s;
        if( rem % 3 ) continue;
        int need = rem / 3;

        if( len >= need ){
            slen = len, p7 = need;
            break;
        }
    }

    if( slen == -1 ){
        printf("-1\n");
        return 0;
    }

    for( int i = 0; i < slen; ++i ){
        if( i >= slen-p7 ) printf("7");
        else printf("4");
    }printf("\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <iomanip>
#include <stack>
#include <string.h>
#include <string>
#include <map>
#include <set>
#include <queue>
#include <algorithm>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair
#define pb push_back
#define all(x) x.begin(),x.end()

typedef long long ll;

int pl,pr,vl,vr;
int m;

vector< pii > lucky;

const int mxbit = 10000;
int bit[mxbit];

int add( int dx, int v = 1 ){
    for( dx += 5; dx < mxbit; dx += dx & -dx )
        bit[dx] += v;
}

int read( int dx ){
    int ret = 0;
    for( dx += 5; dx >= 1; dx -= dx & -dx )
        ret += bit[dx];
    return ret;
}

bool was[5];

bool islucky( int x ){
    while( x ){
        int d = x % 10; x /= 10;
        if( d != 4 && d != 7 ) return false;
    }
    return 1;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d%d%d%d",&pl,&pr,&vl,&vr,&m);

    if( pl > vl || pl == vl && vr < pr ) swap( pl, vl ) , swap( pr, vr );

    for( int len = 1; len <= 11; ++len ){
        for( int m = 0; m < (1<<len); ++m ){
            ll v = 0;
            for( int i = 0; i < len; ++i ){
                if( m&(1<<i) )v = v * 10 + 7;
                else v = v * 10 + 4;
            }

            if( 1 <= v && v <= 1000000000 ) lucky.pb( mk(v,1) );
        }
    }

    lucky.pb( mk(-1,0) );
    lucky.pb( mk(1000000000+5,0) );

    if( !islucky(pl) ) lucky.pb( mk(pl,0) );
    if( !islucky(pr) ) lucky.pb( mk(pr,0) );
    if( !islucky(vl) ) lucky.pb( mk(vl,0) );
    if( !islucky(vr) ) lucky.pb( mk(vr,0) );


    sort( all(lucky) );
    lucky.erase( unique( all(lucky) ), lucky.end() );

    for( int i = 0; i < lucky.size(); ++i )
        if( lucky[i].s ) add( i );

    ll sol = 0;

    for( int i = 0; i < lucky.size(); ++i ){
        if( pl > lucky[i].f || lucky[i].f > pr ) continue;

        for( int j = 0; j < lucky.size(); ++j ){
            if( vl > lucky[j].f || lucky[j].f > vr ) continue;
            int cnt = read( max(i,j) ) - read( min(i,j)-1);
           // cout<<lucky[i].f<<" "<<lucky[j].f<<" = "<<cnt<<endl;
            if( cnt != m ) continue;

            ll a = 0, b = 0;
            ll a1 = 0, b1 = 0;
                a = lucky[i].f - max(pl-1,lucky[i-1].f);
                b = min(vr+1,lucky[j+1].f) - lucky[j].f;
                b1 = lucky[j].f - max(vl-1,lucky[j-1].f);
                a1 = min(pr+1,lucky[i+1].f) - lucky[i].f;

            //cout<<lucky[i].f<<" "<<lucky[j].f<<" = "<<a<<" , "<<b<<endl;
            if( i < j )sol += a*b;
            else if( j < i ) sol += a1*b1;
            else sol += a*b + a1*b1 - 1;
        }
    }
   // cout<<sol<<endl;
    ll uk = (vr-vl+1) * (ll)(pr-pl+1);
    printf("%.10lf\n",sol/(double)uk);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <iomanip>
#include <stack>
#include <string.h>
#include <string>
#include <map>
#include <set>
#include <queue>
#include <algorithm>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair
#define pb push_back
#define all(x) x.begin(),x.end()

const int maxn = 100000 + 55;

bool islucky( int x ){
    while( x ){
        int d = x % 10; x /= 10;
        if( d != 4 && d != 7 ) return false;
    }
    return 1;
}

vector< pii > g[maxn];

int n;
int sz[maxn];
int lcnt[maxn];

void calc( int node, int dad ){
    sz[node] = 1;

    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i].f;
        bool luck = g[node][i].s;
        if( nxt == dad ) continue;
        calc( nxt, node );
        sz[node] += sz[nxt];

        if( luck ) lcnt[node] += sz[nxt];
        else lcnt[node] += lcnt[nxt];
    }
}

ll sol = 0;

void dfs( int node, int dad, int curr ){
    int uk = 0;

    for( int i = 0; i < g[node].size(); ++i )
        if( g[node][i].f != dad ) uk += lcnt[ g[node][i].f ];

    int mem = 0;
    sol += curr * (ll)(curr-1);

    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i].f;
        bool luck = g[node][i].s;
        if( nxt == dad ) continue;

        if( luck ) dfs( nxt, node, sz[1] - sz[nxt] + lcnt[nxt] ), mem += sz[nxt];
        else dfs( nxt, node, curr ), mem += lcnt[nxt];
    }
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    for( int i = 0; i < n-1; ++i ){
        int a,b,c; scanf("%d%d%d",&a,&b,&c);
        bool L = islucky(c);
        g[a].pb( mk(b,L));
        g[b].pb( mk(a,L));
    }

    calc( 1, -1 );

    dfs( 1, -1, lcnt[1] );

    cout<< sol << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <cstdlib>
using namespace std;

char txt[10000];

int main(){
    scanf("%s",txt);
    int i = 0;
    int linecnt=0;
    while( i < strlen(txt) ){
        int cnt = 0;
        while( txt[i]>='0'&&txt[i]<='9' )
            cnt = cnt * 10 + (txt[i]-'0'), i ++;

        if( cnt == 0 ) cnt = 1;
        for( int j = 0; j < cnt; ++j ){
            printf("%c",txt[i]);
            linecnt++;
            if( linecnt % 40 == 0  ) printf("\n");
        }
        ++i;
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <cstdlib>
using namespace std;

string a,b;
bool ok[1000];

int main(){
    cin >> a >> b;
    for( int i = 0; i < b.size(); ++i )
        ok[ b[i] ] = 1;

    for( int i = 0; i < a.size(); ++i )
        if( ok[ a[i] ] == false ) cout<<a[i];cout<<endl;
    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <cstdlib>
using namespace std;

typedef long long ll;

int main(){
    ll a,b; cin >> a >> b;

    b = b*(b+1) >> 1;
    b -= (a+1)*(a)>>1;

    cout<<b<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <cstdlib>
using namespace std;

const int maxn = 100000 + 55;

int n,d;
char txt[maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&d);
    scanf("%s",txt);

    if( d == 0 ){
        printf("2afalet\n");
        return 0;
    }

    vector< int > a,b;

    for( int i = 0; i < n; ++i ){
        int v; scanf("%d",&v);
        if( txt[i] == 'A' ) a.push_back( v );
        else b.push_back( v );
    }

    sort( a.begin(), a.end() );
    sort( b.begin(), b.end() );

    int f = 0, s = 0;
    int winner = 0;
    bool turn = 0;
    while( winner == false ){
        int nf = a.size() - f;
        int ns = b.size() - s;

        if( !turn ){
            for( int i = 0; i < nf && s < b.size(); ++i ){
                b[s] -= d;
                if( b[s] <= 0 ) s ++;
            }
        }else{
            for( int i = 0; i < ns && f < a.size(); ++i ){
                a[f] -= d;
                if( a[f] <= 0 ) f ++;
            }
        }

        turn = !turn;
        if( a.size()-f == 0 ) winner = 2;
        if( b.size()-s == 0 ) winner = 1;
    }

    if( winner == 1 ) printf("Ana\n");
    else printf("Sahby\n");

    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#include <map>
#include <set>
#include <math.h>
#include <queue>
#include <string>
#include <string.h>
#include <vector>
using namespace std;

int main(){
    int a,b; scanf("%d%d",&a,&b);
    printf("%d\n",a+b);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#include <map>
#include <set>
#include <math.h>
#include <queue>
#include <string>
#include <string.h>
#include <vector>
using namespace std;

const int maxn = 1000;

int n;
int edge[10][10];
int deg[10];

vector< int > order;

void top( int node ){
    for( int i = 6; i >= 0; --i ){
        if( edge[node][i] == 0 ) continue;
        edge[node][i] --;
        edge[i][node] --;
        top( i );
    }
    order.push_back(node);
}

bool used[maxn];
int e[maxn][2];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        e[i][0] = a, e[i][1] = b;
        edge[a][b] ++;
        edge[b][a] ++;
        deg[a]++, deg[b]++;
    }

    int curr = -1;
    int codd = 0;
    for( int i = 0; i <= 6; ++i ){
        codd += deg[i]%2;
        if( deg[i]%2 ) curr = i;
        if( curr == -1 && deg[i] ) curr = i;
    }

    if( codd != 2 && codd != 0 ){
        printf("No solution\n");
        return 0;
    }

    top( curr );

    if( order.size() != n+1 ){
        printf("No solution\n");
        return 0;
    }

    for( int i = 0; i < order.size()-1; ++i){
        int a = order[i], b = order[i+1];
        int sel = -1;
        for( int j = 0; j < n && sel == -1; ++j ){
            if( used[j] ) continue;
            if( min(a,b) != min(e[j][0],e[j][1]) || max(a,b) != max(e[j][0],e[j][1]) ) continue;
            used[j] = 1;
            sel = j+1;
        }
        while(sel==-1);
        if( a == e[sel-1][0] ) printf("%d +\n",sel);
        else printf("%d -\n",sel);
    }


    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <string.h>
using namespace std;

int n;

int main(){
    scanf("%d",&n);

    int sol = 0;
    for( int i = 1; i <= n; ++i )
        if( __gcd(i,n) == 1 ) sol ++;

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <map>
#include <string.h>
#include <string>
#include <set>
#include <iomanip>
#include <stack>
#include <cstdlib>
#include <cstdio>
using namespace std;

const int maxn = 305;
const int maxm = 14000 + 5;
const int inf = 2000000000;

int n,m;
int source,end;

int vrijeme[maxn];
int mat[maxn][maxn];
int off[maxn];

int time_blue[maxn], time_purple[maxn];
bool done[maxn];
int prv[maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d%d%d%d",&source,&end,&n,&m);
    source--,end--;

    for( int i = 0; i < n; ++i ){
        char c; while( c = getchar() ) if( c == 'B' || c == 'P' ) break;
        int rem,tb,tp;
        scanf("%d%d%d",&rem,&tb,&tp);
        vrijeme[i] = inf;

        if( c == 'B' ) off[i] = tb - rem;
        else if( c == 'P' ) off[i] = tb+tp - rem;

        time_blue[i] = tb;
        time_purple[i] = tp;
    }

    memset( mat, -1, sizeof(mat));
    memset( prv, -1, sizeof(prv));
    for( int i = 0; i < m; ++i ){
        int a,b,c; scanf("%d%d%d",&a,&b,&c); a--,b--;
        mat[a][b] = mat[b][a] = c;
    }

    vrijeme[source] = 0;

    for( int i = 0; i < n; ++i ){
        int curr = -1;
        for( int j = 0; j < n; ++j )
            if( !done[j] && ( curr == -1 || vrijeme[curr] > vrijeme[j]) ) curr = j;

        if( curr == -1 ) break;
        done[curr]  = 1;

        for( int j = 0; j < n; ++j ){
            if( mat[curr][j] == -1 ) continue;

            int wait;
            for( wait = 0; wait <= 200; ++wait ){
                int t1 = (vrijeme[curr]+off[curr]+wait)%(time_blue[curr]+time_purple[curr]);
                int t2 = (vrijeme[curr]+off[j]+wait)%(time_blue[j]+time_purple[j]);
                char c1 = 'B', c2 = 'B';
                if( t1 >= time_blue[curr] ) c1 = 'P';
                if( t2 >= time_blue[j] ) c2 = 'P';
                if( c1 == c2 ) break;
            }
            if( wait == 201 ) continue;

            int nw = wait + vrijeme[curr] + mat[curr][j];

            if( vrijeme[j] > nw ){
                vrijeme[j] = nw;
                prv[j] = curr;
            }
        }
    }

    if( prv[end] == -1 ){
        printf("0\n");
        return 0;
    }

    printf("%d\n",vrijeme[end]);

    int it = end;
    vector< int > sol;
    while( it != -1 ){
        sol.push_back(it);
        it = prv[it];
    }

    for( int i = sol.size()-1; i >= 0; --i )
        printf("%d ",sol[i]+1);
    printf("\n");


    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <map>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

const int inf = 200000000;

int n,m;
int dp[105][105];
int mat[105][105];
bool move_up[105][105];

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d%d",&n,&m);

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < m; ++j )
            scanf("%d",&mat[i][j]);

        if( i ) dp[i][i-1] = -inf;

        for( int j = i; j < m; ++j ){
            if( i == 0 ){
                if( !j || mat[i][j] > dp[i][j-1] )  dp[i][j] = mat[i][j], move_up[i][j] = 1;
                else if( j ) dp[i][j] = dp[i][j-1];
            }else {
                if( dp[i][j-1] < dp[i-1][j-1] + mat[i][j] )
                    dp[i][j] = dp[i-1][j-1] + mat[i][j], move_up[i][j] = 1;
                else
                    dp[i][j] = dp[i][j-1];
            }
        }
    }

    printf("%d\n",dp[n-1][m-1]);

    vector< int > order;
    int r = n-1, c = m-1;
    while( r >= 0 ){
        if( move_up[r][c] ) order.push_back( c ), r--,c--;
        else c--;
    }

    for( int i = order.size()-1; i >= 0; --i )
        printf("%d ",order[i]+1);
    printf("\n");

    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#include <math.h>
#include <string.h>
#include <string>
#include <vector>
#include <set>
#include <queue>
#include <stack>
using namespace std;

int main(){
    int n; scanf("%d",&n);
    printf("%d\n",(n/3)*2 + (n%3 == 2 ) );
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define f first
#define s second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()

const double eps = 1e-9;

typedef long long ll;

ll a,b,c;
ll xl,xr,yl,yr;
ll x,y;

void exgcd(ll a,ll b,ll &x,ll &y)
{
    if (b) {exgcd(b,a%b,y,x);y-=x*(a/b);}
    else x=1,y=0;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    cin >> a >> b >> c >> xl >> xr >> yl >> yr;

    if( a == 0 && b == 0 ) cout<< (xr-xl+1)*(ll)(yr-yl+1)*(c==0) << endl;
    else if( a == 0 ) cout << (xr-xl+1)*(c%b==0 && yl <= -c/b && -c/b <= yr ) << endl;
    else if( b == 0 ) cout << (yr-yl+1)*(c%a==0 && xl <= -c/a && -c/a <= xr ) << endl;
    if( a == 0 || b == 0 ) return 0;

    int g = __gcd(a,b);
    if( c % g ){
        printf("0\n");
        return 0;
    }

    if( c == -1 ) c *= -1, a *= -1, b *= -1;
    c /= g, a /= g, b /= g;

    exgcd( a, b, x, y );

    x *= -c, y *= -c;

    ll fx = ( xl - x )/b;
    ll sx = ( xr - x )/b;

    ll fy = -( yl - y )/a;
    ll sy = -( yr - y )/a;

    if( fx > sx ) swap(fx,sx);
    if( fy > sy ) swap(fy,sy);

    // a*(x+i*b) + b*(y-i*a) = c

    int x2 = x+min(sx,sy)*b, y2 = y-min(sx,sy)*a;
    int x3 = x+max(fx,fy)*b, y3 = y-max(fx,fy)*a;

    bool b1 = xl <= x2 && x2 <= xr && yl <= y2 && y2 <= yr;
    bool b2 = xl <= x3 && x3 <= xr && yl <= y3 && y3 <= yr;


    ll area = max( 0LL, (min(sx,sy)-1) - (max(fx,fy)+1) + 1 + b1 + b2 );
    cout<<area<<endl;

    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#include <math.h>
#include <string.h>
#include <string>
#include <vector>
#include <set>
#include <queue>
#include <stack>
using namespace std;

typedef long long ll;

int n;

int cnt(){
    int ret = 0;
    for( int i = 100000000; i <= 999999999; ++i ){
        int x = (i*(ll)i)%1000000000;
        if( x == 987654321 ) ret ++;
    }
    return ret;
}

int base = 8;

int main(){
    scanf("%d",&n);
    if( n < 9 ){
        printf("0\n");
        return 0;
    }

    if( n == 9 ){
        printf("%d\n",base);
        return 0;
    }
    n -= 10;
    printf("72");
    for( int i = 0; i < n; ++i ) printf("0");

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <math.h>
#include <map>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <iomanip>
#include <bitset>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>

int n,m;
int x[50055];

int d( int n ){
    int ret = n;
    while( n ){
        ret += n%10;
        n /= 10;
    }
    return ret;
}

bitset<11000005>visi;
vector< pii > p;

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d%d",&n,&m);
    for( int i = 0; i < m; ++i ){
        scanf("%d",&x[i]);
        p.push_back( mk(x[i],i) );
    }
    int dx = 0;
    sort( p.begin(), p.end() );

    int cnt = 0;
    int sz = p.size();
    for( int i = 1; i <= n; ++i ){
        cnt += visi[i] == 0;
        int y = d(i);
        if( y <= n ) visi[ y ] = 1;

        while( dx < sz && p[dx].f == cnt ) x[ p[dx].s ] = i, dx ++;
    }
    printf("%d\n",cnt);
    for( int i = 0; i < m; ++i )
        printf("%d ",x[i] );
    printf("\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define f first
#define s second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()

int n;
vector< int > w[300][2];

void process( int s = n){
    int mov = s, ring = 0, sz;

    while(1){
        printf("%d ", mov ); mov += 2;
        for( int i = 0; i < w[ring][0].size(); ++i )
            printf("%d ",w[ring][0][i]);
        printf("\n");

        printf("%d ", mov ); mov += 2;
        for( int i = 0; i < w[ring][1].size(); ++i )
            printf("%d ",w[ring][1][i]);
        printf("\n");

        ring ++;
        sz = w[ring][0].size() + w[ring][1].size();
        if( sz == 1 ) break;
    }
}

void odd(){
    int c = 1;
    for( int i = 0; i < n; ++i ){
        for( int j = 0; j< n; ++j ){
            int r = min( min(i,n-i-1) , min(j,n-j-1) );
            w[r][ (i+j)%2 ].push_back(c);
            c++;
        }
    }
    process();
}

void even(){
    printf("%d ",n+1);
    printf("%d ",1);
    for( int i = 2; i < n; i += 2 ) printf("%d ",i+1), printf("%d ",i*n+1);
    printf("\n%d ",n+3);
    for( int i = 1; i < n; i += 2 ) printf("%d ",i+1), printf("%d ",i*n+1);
    printf("\n");

    for( int i = 1; i < n; ++i ){
        for( int j = 1; j < n; ++j ){
            int r = min( min(i-1,n-i-1) , min(j-1,n-j-1) );
            int c = i*n + j;
            w[r][ (i+j)%2 ].push_back(c+1);
        }
    }

    if( n != 2 ) process(n+5);
}

int main(){
    scanf("%d",&n);

    if( n % 2 ) odd();
    else even();

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <set>
#include <math.h>
using namespace std;

//#include<BigNum.h>
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<string.h>
#include<math.h>
using namespace std;





// DivBy2(bool) // divides the bignum with 2 , true for flooring , false for ceiling
// operator +
// operator -
// operator *
// operator ==
// operator >
// operator <
// operator =
// sqrt()

class BigNum{   // BIG_NUM_CLASS
   private:
      static const int NewBasis = 8;
      static const int PLACES = 100000000;
   public:
      vector<char>digits;
      BigNum(){}
      BigNum( int v ){while( v ) digits.push_back(v%10) , v/=10; }
      BigNum( char*,int );
      BigNum( const BigNum &z ){ digits = z.digits; }
      BigNum operator*(const BigNum&);
      BigNum operator+(const BigNum&);
      BigNum operator-(const BigNum&);
      BigNum DivBy2(bool);
      BigNum sqrt();
      inline void WriteLn();
      inline void Write();
      void operator=(BigNum);
      bool operator<(const BigNum&);
      bool operator>(const BigNum&);
      bool operator==(const BigNum&);
      void SetPower10( int stp ){
         digits.clear();
         for( int i = 0; i < stp; ++i )
            digits.push_back(0);
         digits.push_back(1);
      }
};

void BigNum::operator=(BigNum b2 ){
   digits.clear();
   digits=b2.digits;
}

BigNum::BigNum( char *f , int len){
   for( int i = len-1; i >=0; --i )
      digits.push_back( f[i]-'0' );
    while( digits.back() == 0 )digits.pop_back();
}

bool BigNum::operator==( const BigNum &b2 ){
   if( b2.digits.size() != digits.size() )return  false;
   for( int i = 0; i < digits.size(); ++i )
      if( digits[i] != b2.digits[i] )return false;
   return true;
}

bool BigNum::operator<( const BigNum &b2 ){
   if( b2.digits.size() > digits.size() )return true;
   else if( b2.digits.size() < digits.size() )return false;
   else{
       for( int i = digits.size()-1; i >=0 ; --i ){
         if( digits[i] < b2.digits[i] )
            return true;
         else if( digits[i] > b2.digits[i] )
            return false;
      }
   }
   return false;
}
bool BigNum::operator>( const BigNum &b2 ){
   if( b2.digits.size() < digits.size() )return true;
   else if( b2.digits.size() > digits.size() )return false;
   else{
      for( int i = digits.size()-1; i >=0 ; --i ){
         if( digits[i] > b2.digits[i] )
            return true;
         else if( digits[i] < b2.digits[i] )
            return false;
      }
   }
   return false;
}

BigNum BigNum::operator*( const BigNum &b2 ){  // FAST MULTIPLICATION
   int digs = b2.digits.size() + digits.size() + 2;
   long long *B1 = new long long[ digs ];
   long long *B2 = new long long[ digs ];
   long long *R =  new long long[ digs ];
   for( int i = 0; i < digs; ++i )B1[i] = B2[i] = R[i] = 0;
   int s1 = digits.size();
   int s2 = b2.digits.size();
   int poz = -1, fak = 1;
   for( int i = 0; i < s1; ++i ){
      if( i % NewBasis == 0 )poz++, fak = 1;
      B1[poz] = B1[poz] + digits[i]*fak;
      fak*=10;
   }

   int ns1 = poz+1;

   poz = -1, fak = 1;
   for( int i = 0; i < s2; ++i ){
      if( i % NewBasis == 0 )poz++, fak = 1;
      B2[poz] = B2[poz] + b2.digits[i]*fak;
      fak*=10;
   }
   int ns2 = poz+1;

   for( int i = 0; i < ns1; ++i )
      for( int j = 0; j < ns2; ++j )
         R[i+j] += B1[i]*B2[j];

   int NS = ns1 + ns2;

   for( int i = 0; i < NS; ++i ){
      if( i == NS-1 && R[i]>=PLACES )NS++;
      R[i+1] += R[i]/PLACES , R[i] = R[i]%PLACES;
   }
   unsigned long long test;
   int digi;
   BigNum ret;
   vector<int>smp;

   while( R[NS-1] )smp.push_back(R[NS-1]%10), R[NS-1]/=10;
   for( int i = smp.size()-1; i >=0; --i )ret.digits.push_back( smp[i] );
   for( int i = NS-2; i>=0; --i ){
      test = R[i];
      digi = 0;
      while(test)
         test/=10,digi++;
      for(int j = 0; j < 8-digi; ++j)ret.digits.push_back(0);
      smp.clear();
      while( R[i] )smp.push_back(R[i]%10), R[i]/=10;
      for( int i = smp.size()-1; i >=0; --i )ret.digits.push_back( smp[i] );
   }
   reverse(ret.digits.begin(),ret.digits.end());
   while( ret.digits.back() == 0 )ret.digits.pop_back();

   delete [] B1;
   delete [] B2;
   delete [] R;
   return ret;
}

BigNum BigNum::DivBy2( bool floor=true ){
   BigNum ret = BigNum( *this );
   for( int i = ret.digits.size()-1; i>=0; i-- ){
       if( ret.digits[i]%2 == 1 )if( i > 0 )ret.digits[i-1]+=10;
                                 else if( floor )ret.digits[i]--;
                                 else ret.digits[i]++;
       ret.digits[i]/=2;
   }
   for( int i = 0; i < ret.digits.size(); ++i )
      if( ret.digits[i] >= 10 ){
         if( i==ret.digits.size()-1 )ret.digits.push_back(ret.digits[i]/10);
         else ret.digits[i+1] += ret.digits[i]/10;
         ret.digits[i] %= 10;
      }
   while( ret.digits.back() == 0 )ret.digits.pop_back();
   return ret;
}

BigNum BigNum::operator+( const BigNum &b2 ){
   BigNum A = *this , B = b2;
   if( A.digits.size() < B.digits.size() )swap(A,B);
   BigNum sum = B;
   int tmp = 0;
   for( int i = 0; i < B.digits.size(); ++i ){
      int ss = B.digits[i] + A.digits[i] + tmp;
      sum.digits[i] = ss%10;
      tmp = ss / 10;
   }
   for( int i = B.digits.size(); i < A.digits.size(); ++i ){
      int ss = A.digits[i] + tmp;
      sum.digits.push_back( ss % 10 );
      tmp = ss/10;
   }
   while( tmp ){
      sum.digits.push_back( tmp % 10 );
      tmp /= 10;
   }
   return sum;
}

BigNum BigNum::operator-(const BigNum& b2){
   if( (*this) > b2 ){
      int add = 0;
      int len1 = digits.size();
      int len2 = b2.digits.size();
      BigNum ret = (*this);
      for( int i = 0; i < len1 && ( add != 0 || i < len2 ); ++ i ){
         int num1 = digits[i];
         int num2 = ( i < len2 ? b2.digits[i] : 0 ) + add;
         add = 0;

         while( num1 < num2 ) num1 += 10 , add ++;

         ret.digits[i] = num1 - num2;

      }
      while( ret.digits.back() == 0 )ret.digits.pop_back();
      return ret;
   }
}


inline void BigNum::WriteLn(){
   if( digits.size() == 0 )printf("0");
   for( int i = digits.size()-1; i >=0; --i )
      printf("%d",digits[i]);
   printf("\n");
}
inline void BigNum::Write(){
   if( digits.size() == 0 )printf("0");
   for( int i = digits.size()-1; i >=0; --i )
      printf("%d",digits[i]);
}


BigNum BigNum::sqrt(){
   BigNum lo(1),hi;
   BigNum mid , ret(0);
   hi.SetPower10(   (int)ceil(  (int)(digits.size()) / 2.00)   );
   while( lo < hi || lo==hi ){
      mid = lo+hi;
      mid = mid.DivBy2();

      if( (mid*mid) > (*this) )
         hi = mid - BigNum(1);
      else{
         ret = mid;
         lo = mid + BigNum(1);
      }
   }
   return ret;
}





int a,b;
char txta[100000];

int main(){
    scanf("%s",txta);
    BigNum x(txta,strlen(txta));

    (x.sqrt()).WriteLn();


    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <set>
#include <math.h>
using namespace std;

//#include<BigNum.h>
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<string.h>
#include<math.h>
using namespace std;





// DivBy2(bool) // divides the bignum with 2 , true for flooring , false for ceiling
// operator +
// operator -
// operator *
// operator ==
// operator >
// operator <
// operator =
// sqrt()

class BigNum{   // BIG_NUM_CLASS
   private:
      static const int NewBasis = 8;
      static const int PLACES = 100000000;
   public:
      vector<char>digits;
      BigNum(){}
      BigNum( int v ){while( v ) digits.push_back(v%10) , v/=10; }
      BigNum( char*,int );
      BigNum( const BigNum &z ){ digits = z.digits; }
      BigNum operator*(const BigNum&);
      BigNum operator+(const BigNum&);
      BigNum operator-(const BigNum&);
      BigNum DivBy2(bool);
      BigNum sqrt();
      inline void WriteLn();
      inline void Write();
      void operator=(BigNum);
      bool operator<(const BigNum&);
      bool operator>(const BigNum&);
      bool operator==(const BigNum&);
      void SetPower10( int stp ){
         digits.clear();
         for( int i = 0; i < stp; ++i )
            digits.push_back(0);
         digits.push_back(1);
      }
};

void BigNum::operator=(BigNum b2 ){
   digits.clear();
   digits=b2.digits;
}

BigNum::BigNum( char *f , int len){
   for( int i = len-1; i >=0; --i )
      digits.push_back( f[i]-'0' );
    while( digits.back() == 0 )digits.pop_back();
}

bool BigNum::operator==( const BigNum &b2 ){
   if( b2.digits.size() != digits.size() )return  false;
   for( int i = 0; i < digits.size(); ++i )
      if( digits[i] != b2.digits[i] )return false;
   return true;
}

bool BigNum::operator<( const BigNum &b2 ){
   if( b2.digits.size() > digits.size() )return true;
   else if( b2.digits.size() < digits.size() )return false;
   else{
       for( int i = digits.size()-1; i >=0 ; --i ){
         if( digits[i] < b2.digits[i] )
            return true;
         else if( digits[i] > b2.digits[i] )
            return false;
      }
   }
   return false;
}
bool BigNum::operator>( const BigNum &b2 ){
   if( b2.digits.size() < digits.size() )return true;
   else if( b2.digits.size() > digits.size() )return false;
   else{
      for( int i = digits.size()-1; i >=0 ; --i ){
         if( digits[i] > b2.digits[i] )
            return true;
         else if( digits[i] < b2.digits[i] )
            return false;
      }
   }
   return false;
}

BigNum BigNum::operator*( const BigNum &b2 ){  // FAST MULTIPLICATION
   int digs = b2.digits.size() + digits.size() + 2;
   long long *B1 = new long long[ digs ];
   long long *B2 = new long long[ digs ];
   long long *R =  new long long[ digs ];
   for( int i = 0; i < digs; ++i )B1[i] = B2[i] = R[i] = 0;
   int s1 = digits.size();
   int s2 = b2.digits.size();
   int poz = -1, fak = 1;
   for( int i = 0; i < s1; ++i ){
      if( i % NewBasis == 0 )poz++, fak = 1;
      B1[poz] = B1[poz] + digits[i]*fak;
      fak*=10;
   }

   int ns1 = poz+1;

   poz = -1, fak = 1;
   for( int i = 0; i < s2; ++i ){
      if( i % NewBasis == 0 )poz++, fak = 1;
      B2[poz] = B2[poz] + b2.digits[i]*fak;
      fak*=10;
   }
   int ns2 = poz+1;

   for( int i = 0; i < ns1; ++i )
      for( int j = 0; j < ns2; ++j )
         R[i+j] += B1[i]*B2[j];

   int NS = ns1 + ns2;

   for( int i = 0; i < NS; ++i ){
      if( i == NS-1 && R[i]>=PLACES )NS++;
      R[i+1] += R[i]/PLACES , R[i] = R[i]%PLACES;
   }
   unsigned long long test;
   int digi;
   BigNum ret;
   vector<int>smp;

   while( R[NS-1] )smp.push_back(R[NS-1]%10), R[NS-1]/=10;
   for( int i = smp.size()-1; i >=0; --i )ret.digits.push_back( smp[i] );
   for( int i = NS-2; i>=0; --i ){
      test = R[i];
      digi = 0;
      while(test)
         test/=10,digi++;
      for(int j = 0; j < 8-digi; ++j)ret.digits.push_back(0);
      smp.clear();
      while( R[i] )smp.push_back(R[i]%10), R[i]/=10;
      for( int i = smp.size()-1; i >=0; --i )ret.digits.push_back( smp[i] );
   }
   reverse(ret.digits.begin(),ret.digits.end());
   while( ret.digits.back() == 0 )ret.digits.pop_back();

   delete [] B1;
   delete [] B2;
   delete [] R;
   return ret;
}

BigNum BigNum::DivBy2( bool floor=true ){
   BigNum ret = BigNum( *this );
   for( int i = ret.digits.size()-1; i>=0; i-- ){
       if( ret.digits[i]%2 == 1 )if( i > 0 )ret.digits[i-1]+=10;
                                 else if( floor )ret.digits[i]--;
                                 else ret.digits[i]++;
       ret.digits[i]/=2;
   }
   for( int i = 0; i < ret.digits.size(); ++i )
      if( ret.digits[i] >= 10 ){
         if( i==ret.digits.size()-1 )ret.digits.push_back(ret.digits[i]/10);
         else ret.digits[i+1] += ret.digits[i]/10;
         ret.digits[i] %= 10;
      }
   while( ret.digits.back() == 0 )ret.digits.pop_back();
   return ret;
}

BigNum BigNum::operator+( const BigNum &b2 ){
   BigNum A = *this , B = b2;
   if( A.digits.size() < B.digits.size() )swap(A,B);
   BigNum sum = B;
   int tmp = 0;
   for( int i = 0; i < B.digits.size(); ++i ){
      int ss = B.digits[i] + A.digits[i] + tmp;
      sum.digits[i] = ss%10;
      tmp = ss / 10;
   }
   for( int i = B.digits.size(); i < A.digits.size(); ++i ){
      int ss = A.digits[i] + tmp;
      sum.digits.push_back( ss % 10 );
      tmp = ss/10;
   }
   while( tmp ){
      sum.digits.push_back( tmp % 10 );
      tmp /= 10;
   }
   return sum;
}

BigNum BigNum::operator-(const BigNum& b2){
   if( (*this) > b2 ){
      int add = 0;
      int len1 = digits.size();
      int len2 = b2.digits.size();
      BigNum ret = (*this);
      for( int i = 0; i < len1 && ( add != 0 || i < len2 ); ++ i ){
         int num1 = digits[i];
         int num2 = ( i < len2 ? b2.digits[i] : 0 ) + add;
         add = 0;

         while( num1 < num2 ) num1 += 10 , add ++;

         ret.digits[i] = num1 - num2;

      }
      while( ret.digits.back() == 0 )ret.digits.pop_back();
      return ret;
   }
}


inline void BigNum::WriteLn(){
   if( digits.size() == 0 )printf("0");
   for( int i = digits.size()-1; i >=0; --i )
      printf("%d",digits[i]);
   printf("\n");
}
inline void BigNum::Write(){
   if( digits.size() == 0 )printf("0");
   for( int i = digits.size()-1; i >=0; --i )
      printf("%d",digits[i]);
}


BigNum BigNum::sqrt(){
   BigNum lo(0),hi;
   BigNum mid , ret(0);
   hi.SetPower10(   (int)ceil(  (int)(digits.size()) / 2.00)   );
   while( lo < hi || lo==hi ){
      mid = lo+hi;
      mid = mid.DivBy2();

      if( (mid*mid) > (*this) )
         hi = mid - BigNum(1);
      else{
         ret = mid;
         lo = mid + BigNum(1);
      }
   }
   return ret;
}





int a,b;
char txta[1000];
char txtb[1000];

int main(){
    cin >> a >> b;

    if( a == b ){
        printf("0\n");
        return 0;
    }

    BigNum b1 ( 1 );
    BigNum b2 ( 1 );

    for( int i = 0; i < b; ++i )
        b1 = b1 * a;
    for( int i = 0; i < a; ++i )
        b2 = b2 * b;

    if( b1 > b2 ){
        (b1-b2).WriteLn();
    }else{
        printf("-");
        (b2-b1).WriteLn();
    }


    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

const int maxsq = 100000;


bool isprime( int x ){
    if( x % 2 == 0 && x != 2 ) return 0;
    for( int i = 3; i*i <= x; i += 2 )
        if( x % i == 0 ) return 0;
    return 1;
}

int main(){
    int tests; scanf("%d",&tests);
    while( tests -- ){
        int n; scanf("%d",&n);
        bool ok = 0;

        for( int i = 2; i*i <= n && !ok; ++i ){
            if( n%i || isprime(i) == false ) continue;
            int p = n / i;
            if( isprime(p) ) ok = 1;
        }

        if( ok ) printf("Yes\n");
        else printf("No\n");
    }

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

int months[] = {31,28,31,30,31,30,31,31,30,31,30,31};

int main(){
    int curr = 0;
    int n,m; scanf("%d%d",&n,&m); m--;

    if( m+1 < 1 || m+1 > 12 || n < 1 || n > months[m] ){
        printf("Impossible\n");
        return 0;
    }

    for( int i = 0; i < m; ++i ) curr += months[i];
    curr = ( curr + n - 1 + 7 ) % 7;

    printf("%d\n",curr+1);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

const int maxn = 10000 + 55;

bool isprime( int x ){
    if( x % 2 == 0 && x != 2 ) return 0;
    for( int i = 3; i*i <= x; i += 2 )
        if( x % i == 0 ) return 0;
    return 1;
}

bool isp[maxn];
vector< int > p,sp;

int dp[maxn];
int take[maxn];

int solve( int x ){
    if( x == 0  ) return 0;

    int &sol = dp[x];
    if( sol < maxn ) return sol;

    for( int i = sp.size()-1; i >= 0; --i ){
        if( sp[i] > x ) continue;
        int curr = solve( x - sp[i] ) + 1;
        if( sol > curr ) sol = curr, take[x] = i;
    }
    return sol;
}

int main(){
    for( int i = 2; i <= 10000; ++i )
        if( isprime(i) ) isp[i] = 1, p.push_back(i);

    for( int i = 0; i < p.size(); ++i )
        if( isp[i+1] )
            sp.push_back( p[i] );

    int n; cin >> n;

    memset( dp, 1 , sizeof(dp));
    memset( take, -1, sizeof(take));
    int sol = solve( n );

    if( take[n] == -1 ){
        printf("0\n");
        return 0;
    }

    printf("%d\n",sol);
    int it = n;
    while( take[it] != -1 ){
        int w = sp[ take[it] ];
        printf("%d ",w );
        it -= w;
    }

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

int n;
int mod;
int stp;

int pw( int x, int e ){
    if( e == 0 ) return 1;
    else if( e % 2 == 0 ){
        int m = pw( x , e / 2 );
        return (m*m)%mod;
    }else{
        return ( pw( x , e - 1 ) * x ) % mod;
    }
}

int main(){
    scanf("%d%d%d",&n,&stp,&mod);
    int sol = 0;

    for( int i = 0; i < n; ++i ){
        int w; scanf("%d",&w);
        if( pw(w,stp) == 0 ) sol ++;
    }

    printf("%d\n",sol);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

typedef long long ll;

const int maxn = 2000;

int f( int n ){
    int s = 0;
    while( n ){
        s += n % 10;
        n /= 10;
    }
    if( s <= 9 ) return s;
    else return f(s);
}

int n;
int x[maxn];

int main(){
    int tests;
    scanf("%d",&tests);

    while( tests -- ){
        scanf("%d",&n);
        for( int i = 0; i < n; ++i ) scanf("%d",&x[i]);

        if( x[0] == 0 ){
            printf("0\n");
            continue;
        }

        int sol = 0;
        for( int i = n-1; i >= 0; --i )
            sol = ( sol * (ll)x[i] + x[i] ) % 9;

        if( sol == 0 ) printf("9\n");
        else printf("%d\n",sol);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define f first
#define s second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()

int n,a0,b0;
map< pair<int,int> , bool > visi;

int main(){
    //freopen("Ulaz.txt","r",stdin);

    while( cin >> n >> a0 >> b0 ){
        vector< pii > w,q;
        for( int i = 0; i  < n; ++i )
            w.push_back( mk(a0*i%n,b0*i%n) );
        sort( w.begin(), w.end() );
        for( int i = 0; i < n; ++i ){
            if( visi[ w[i] ] ) continue;
            visi[w[i]] = 1;
            q.push_back( w[i] );
        }
        printf("%d\n",q.size());
        for( int i = 0; i < q.size(); ++i )
            printf("%d %d\n",q[i].f,q[i].s);
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <math.h>
#include <map>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <iomanip>
#include <assert.h>
#include <bitset>
using namespace std;

const double eps = 1e-9;


struct coord{
    double x,y;
    coord(){};
    coord( double p1, double p2 ):x(p1),y(p2){};
};

const double pi = acos(0)*2;

int n,i1,i2;
coord p[2];

coord c1,c2;

coord rotate( coord c, coord p, double a ){
    p.x -= c.x, p.y -= c.y;
    p = coord( p.x * cos(a) - p.y * sin(a) , p.x * sin(a) + p.y * cos(a) );
    p.x += c.x, p.y += c.y;
    return p;
}

coord intersect( coord p0, coord p1, coord p2, coord p3 ){
    double A1 = p1.y - p0.y;
    double B1 = p0.x - p1.x;
    double C1 = A1*p0.x + B1*p0.y;

    double A2 = p3.y - p2.y;
    double B2 = p2.x - p3.x;
    double C2 = A2*p2.x + B2*p2.y;

    double det = A1*B2 - B1*A2;

    assert( fabs(det) > eps );

    double x = (C1*B2 - C2*B1) / det;
    double y = (A1*C2 - A2*C1) / det;
    return coord(x,y);
}

coord sol[2000];

bool not_equal( coord a, coord b ){
    if( fabs(a.x-b.x) > eps ) return 1;
    if( fabs(a.y-b.y) > eps ) return 1;
    return 0;
}

bool solve( coord c ){
    bool ok = 1;
    double add = 2*pi/n;
    for( int i = 0; i < n; ++i ){
        double sadd = add * (-i);
        int id = (i + i1)%n;
        coord curr = rotate( c, p[0], sadd );
        sol[id] = curr;

        if( i1 == id && not_equal(curr,p[0]) ) ok = 0;
        if( i2 == id && not_equal(curr,p[1]) ) ok = 0;
    }
    return ok;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d%d%d",&n,&i1,&i2); i1--,i2--;
    for( int i = 0; i < n; ++i )
        scanf("%lf%lf",&p[i].x,&p[i].y);

    double alfa = (2*pi/n)*abs(i1-i2);
    if( alfa > pi ) alfa = 2*pi - alfa;

    double x = sqrt( (p[0].x-p[1].x)*(p[0].x-p[1].x) + (p[0].y-p[1].y)*(p[0].y-p[1].y) );
    double d = (x/2) / sin( alfa / 2 );
    double h = fabs( cos( alfa / 2 ) * d );

    double beta = pi - (pi/2) - (alfa/2);

    if( fabs(beta) < eps ){
        c1 = c2 = coord( (p[0].x+p[1].x)/2 , (p[0].y+p[1].y)/2 );
    }else{
        coord da1 = rotate( p[0], p[1], beta ), da2 = rotate( p[1], p[0], -beta );
        coord db1 = rotate( p[0], p[1], -beta ), db2 = rotate( p[1], p[0], beta );

        c1 = intersect( p[0], da1, p[1], da2 );
        c2 = intersect( p[0], db1, p[1], db2 );
    }

    if( solve( c1 ) );
    else solve(c2);


    for( int i = 0; i < n; ++i )
        printf("%.10lf %.10lf\n",sol[i].x,sol[i].y);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

#define white 0
#define black 1

const int maxn = 105;

int n;
int deg[maxn];
bool edge[maxn][maxn];
int sol[maxn][maxn];
int has[maxn];

vector< int > g[maxn];

void dfs( int node, int color ){
    for( int i = 0; i < n; ++i ){
        if( edge[node][i] == 0 ) continue;
        edge[node][i] = edge[i][node] = 0;
        sol[node][i] = sol[i][node] = color + 1;

        has[node] |= 1 << color , has[i] |= 1 << color;
        dfs( i, !color );
        color = !color;
    }
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        while(1){
            int a; scanf("%d",&a);
            if( a == 0 ) break; a--;
            edge[i][a] = 1;
            g[i].push_back(a);
            deg[i] ++;
        }
    }

    for( int i = 0; i < n; ++i )
        if( deg[i]%2 == 1 ) dfs( i, white );
    for( int i = 0; i < n; ++i )
        dfs( i, white );

    bool ok = 1;
    for( int i = 0; i < n; ++i )
        if( g[i].size() > 1 && has[i] != 3 ) ok = 0;

    if( !ok ){
        printf("No solution\n");
        return 0;
    }

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < g[i].size(); ++j )
            printf("%d ",sol[i][ g[i][j] ] );
        printf("0\n");
    }

    return 0;
}

#include <iostream>
#include <algorithm>
#include <cstdio>
#include <math.h>
#include <map>
#include <string.h>
#include <string>
#include <fstream>
#include <iomanip>
#include <queue>
#include <stack>
using namespace std;

// DIRAC's THEOREM
// PIGEON HOLLE PRINCIPE

#define all(x) x.begin(),x.end()

const int maxn = 1000 + 55;

int n;
bool mat[maxn][maxn];

bool inchain[maxn];
int ham[maxn],sz;
int tmp[maxn];

int find( int x ){ for( int i = 0; i < sz; ++i ) if( ham[i] == x ) return i; }

int main(){
   // freopen("Ulaz.txt","r",stdin);

    char c;
    scanf("%d",&n); c = getchar();

    for( int i = 0; i < n; ++i ){
        int v = 0;
        while( c = getchar() ){
            if( c == ' ' || c == '\n' || c == EOF ){
                mat[i][v-1] = mat[v-1][i] = true;
                v = 0;
                if( c == '\n' || c == EOF ) break;
                continue;
            }
            v = v * 10 + c - '0';
        }
    }

    ham[sz++] = 0;
    inchain[0] = 1;

    while( 1 ){
        bool change = 0;

        for( int k = 0; k < 2; ++k ){
            for( int i = 0; i < n; ++i ){
                int last = ham[sz-1];
                if( !mat[last][i] || inchain[i] ) continue;
                ham[sz++] = i;
                inchain[i] = 1;
                change = 1;
            }
            reverse( ham, ham + sz );
        }
        if( change ) continue;

        for( int i = 0; i < n; ++i ){
            if( inchain[i] ) continue;
            change = 1;
            inchain[i] = true;

            int curr;
            for( curr = 0; curr < sz-1; ++curr )
                if( mat[ ham[curr] ][ ham[sz-1] ] && mat[ ham[curr+1] ][i] ) break;


            int pos = 0;
            for( int j = 0; j <= curr; ++j ) tmp[ pos ++ ] = ham[j];
            for( int j = sz-1; j > curr; --j ) tmp[ pos ++ ] = ham[j];
            memcpy( ham, tmp, sizeof tmp );
            ham[sz++] = i;
        }

        if( !change ) break;
    }

//    if( mat[ ham[0] ][ ham[sz-1] ] ){
//        int x = find( 0 );
//        for( int i = 0; i <= n; ++i )
//            printf("%d ",ham[(x+i)%sz]+1);
//        return 0;
//    }

    int curr = -1;
    for( curr = 0; curr < sz-1; ++curr )
        if( mat[ ham[curr] ][ ham[sz-1] ] && mat[ ham[curr+1] ][ ham[0] ] )
            break;

    while(curr==-1);

    int pos = 1;
    tmp[0] = ham[0];
    for( int i = curr+1; i < sz; ++i ) tmp[pos++] = ham[i];
    for( int i = curr; i > 0; --i ) tmp[pos++] = ham[i];
    memcpy( ham, tmp, sizeof ham );

    int x = find( 0 );
    for( int i = 0; i <= n; ++i )
        printf("%d ",ham[(x+i)%sz]+1);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define f first
#define s second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()

int dp[60];

int f( int n ){
    if( n == 1 || n == 2 ) return 1;
    if( dp[n] != 0 ) return dp[n];
    return dp[n] = f(n-1) + f(n-2);
}

int main(){
    int n; cin >> n;
    int sol = 0;
    for( int i = 1; i <= n; ++i ) sol += f(i);
    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define f first
#define s second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()

const int maxn = 10000 + 55;

int n;
int p[maxn][4];
int xp,yp;

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i )
        scanf("%d%d%d%d",&p[i][0],&p[i][1],&p[i][2],&p[i][3]);
    scanf("%d%d",&xp,&yp);

    bool on_line = false;
    int cnt = 0;

    for( int i = 0; i < n; ++i ){
        int x1 = p[i][0], y1 = p[i][1];
        int x2 = p[i][2], y2 = p[i][3];

        if( x1 == x2 ){
            if( y1 > y2 ) swap(y1,y2);

            if( xp == x1 && y1 <= yp && yp <= y2 ) on_line = true;
            if( y1 <= yp && yp < y2 && x1 < xp ) cnt ++;
        }else{
            if( x1 > x2 ) swap(x1,x2);
            if( yp == y1 && x1 <= xp && xp <= x2 ) on_line = true;
        }
    }

    if( on_line ) printf("BORDER\n");
    else if( cnt % 2 ) printf("INSIDE\n");
    else printf("OUTSIDE\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define f first
#define s second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()

int n;
int mat[5][5];
int sol[5][5];

int d[][2] = { 0,1, 0,-1, 1,0, -1,0 };

int sz;
int w[10];
bool skip[3][3];

bool valid(){
    bool ok = 1;
    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < n; ++j ){
            int cnt = 0;
            for( int k = 0; k < 4; ++k ){
                int r = i + d[k][0];
                int c = j + d[k][1];
                if( r < 0 || c < 0 || r >= n || c >= n ) continue;
                cnt += sol[r][c] > sol[i][j];
            }
            if( cnt != mat[i][j] ) ok = 0;
        }
    }
    return ok;
}

void out(){
    for( int i = 0 ;i < n; ++i ){
        for( int j = 0; j < n; ++j )
            printf("%d ",sol[i][j]);
        printf("\n");
    }printf("\n");
}

bool solve3(){
    skip[0][1] = skip[1][1] = skip[2][1] = skip[1][0] = skip[1][2] = 1;
    bool found = 0;

    for( int i = 0; i < 100000; ++i ){
        int m = i;
        sol[0][1] = m % 10, m /= 10;
        sol[1][1] = m % 10, m /= 10;
        sol[2][1] = m % 10, m /= 10;
        sol[1][0] = m % 10, m /= 10;
        sol[1][2] = m % 10, m /= 10;

        bool ok = 1;
        for( int r = 0; r < 3; ++r ){
            for( int c = 0; c < 3; ++c ){
                if( skip[r][c] ) continue;

                sz = 0;
                for( int j = 0; j < 4; ++j ){
                    int r2 = d[j][0] + r;
                    int c2 = d[j][1] + c;
                    if( r2 < 0 || c2 < 0 || r2 >= 3 || c2 >= 3 ) continue;
                    w[sz++] = sol[r2][c2];
                }
                sort( w, w + sz );
                reverse( w, w + sz );

                int pos = 0, v;
                for( v = 9; v >= 0; --v ){
                    while( pos < sz && w[pos] > v ) pos ++;
                    if( pos == mat[r][c] ) break;
                }
                if( v == -1 ) ok = 0;
                sol[r][c] = v;
            }
        }

        if( !ok || !valid() ) continue;
        out();
        found = 1;
        break;
    }
    return found;
}

bool solve2(){
    bool found = 0;
    for( int i = 0; i < 10000; ++i ){
        int m = i;
        sol[0][0] = m % 10, m /= 10;
        sol[0][1] = m % 10, m /= 10;
        sol[1][0] = m % 10, m /= 10;
        sol[1][1] = m % 10, m /= 10;
        if( !valid() ) continue;
        found = 1;
        out();
        break;
    }
    return found;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i )
        for( int j = 0; j < n; ++j )
            scanf("%d",&mat[i][j]);

    if( n == 3 && solve3() == false ) printf("NO SOLUTION\n");
    else if( n == 2 && solve2() == false ) printf("NO SOLUTION\n");
    else if( n == 1 && mat[0][0] ) printf("NO SOLUTION\n");
    else if( n == 1 ) printf("0\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define f first
#define s second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()

int n,m;

// a + b = 2^i * gcd(a,b)

int main(){
    scanf("%d%d",&n,&m);

    bool found = 0;
    for( int i = 0; i < 10000; ++i ){
        if( n == 0 || m == 0 ){
            printf("%d\n",i);
            found = 1;
            break;
        }
        if( n > m ) n -= m,  m *= 2;
        else m -= n, n *= 2;
    }

    if( !found ) printf("-1\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define f first
#define s second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()

int m,n;
int cnt[10];

int main(){
    scanf("%d%d",&m,&n);
    for( int i = 0; i < n; ++i ){
        int x; scanf("%d",&x);
        cnt[x/1000] ++;
    }
    int sol = 2;
    for( int i = 1; i <= 9; ++i ){
        int c = cnt[i]/m + (cnt[i]%m!=0);
        sol += c;
    }
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <math.h>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int mxx = 10000 + 55;
const int maxx = 30000;
const int maxn = 10000 + 55;

int n;
int cnty[maxx],cntx[maxx];
vector< pii > xc[maxx],yc[maxx];

int id[maxn],sz[maxn];

int find( int x ){
    if( x == id[x] ) return x;
    return id[x] = find( id[x] );
}

int merge( int a, int b ){
    int x = find(a), y = find(b);
    if( x == y ) return 1;

    if( sz[x] > sz[y] ) swap(x,y);

    id[x] = y;
    sz[y] += sz[x];
    return 0;
}

bool mode[maxx];
int bit[maxx];

int add( int x, int dec = 1 ){
    for( x += 5; x < maxx; x += x & -x )
        bit[x] += dec;
}

int read( int x ){
    int ret = 0;
    for( x += 5; x >= 1; x-= x & -x )
        ret += bit[x];
    return ret;
}

bool no_intersection(){
    for( int i = 0; i < maxx; ++i ){
        for( int j = 0; j < xc[i].size(); j ++ ){
            int x = xc[i][j].f;
            if( mode[ x ] == false ) mode[ x ] = true, add( x );
            else mode[ x ] = false, add( x , -1 );
        }

        for( int j = 0; j < xc[i].size(); j += 2 ){
            int v = read( xc[i][j+1].f - 1 );
            v -= read( xc[i][j].f  );
            if( v != 0 ) return false;
        }
    }
    return 1;
}

map<pair<int,int>, bool > M;


int main(){
    //freopen("Ulaz.txt","r",stdin);

    for( int i = 0; i < maxn; ++ i ) sz[i] = 1, id[i] = i;

    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        int x,y; scanf("%d%d",&x,&y);
        x += mxx, y += mxx;
        cntx[x] ++;
        cnty[y] ++;
        xc[x].push_back( mk(y,i) );
        yc[y].push_back( mk(x,i) );

        if( M[ mk(x,y) ] ){
            printf("0\n");
            return 0;
        }
        M[ mk(x,y) ] = 1;
    }

    int sol = 0;

    bool ok = 1;
    for( int i = 0; i < maxx; ++i ){
        if( cnty[i]%2 || cntx[i]%2 ) ok = 0;
        sort( xc[i].begin(), xc[i].end() );
        sort( yc[i].begin(), yc[i].end() );

        if( ok ){
            for( int j = 0; j < xc[i].size(); j += 2 ){
                sol += xc[i][j+1].f - xc[i][j].f;
                merge( xc[i][j+1].s, xc[i][j].s );
            }
            for( int j = 0; j < yc[i].size(); j += 2 ){
                sol += yc[i][j+1].f - yc[i][j].f;
                merge( yc[i][j+1].s, yc[i][j].s );
            }
        }
    }

    int x = find(0);
    for( int i = 1; i < n; ++i )
        if( x != find(i) ) ok = 0;

    if( ok && no_intersection() ) printf("%d\n",sol);
    else printf("0\n");



    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <math.h>
#include <map>
#include <string.h>
#include <string>
#include <iomanip>
using namespace std;

#define f first
#define s second
#define mk make_pair

typedef long long ll;

const int maxn = 400 + 55;
const double eps = 1e-8;

struct coord{
    int x,y;
    coord(){};
    coord( int p1, int p2 ):x(p1),y(p2){};

    ll ccw( coord a, coord b ){
        return (a.x-x)*(ll)(b.y-y) - (a.y-y)*(ll)(b.x-x);
    }

    const bool operator<( const coord &c ) const {
        return x < c.x || (x==c.x && y < c.y);
    }
};

coord pivot;
bool byangle( coord a, coord b ){
    return pivot.ccw( a , b ) > 0;
}

int n;
coord p[maxn];

int sz;
coord hull[maxn];

bool inside( coord x ){
    for( int i = 0; i < n; ++i ){
        int nxt = i<n-1?i+1:0;
        if( p[i].ccw( x, p[nxt] ) > 0 ) return 0;
    }
    return 1;
}

bool online( coord a, coord b, pair<double,double> c ){
    if( min(a.x,b.x) <= c.f+eps && c.f-eps <= max(a.x,b.x) &&
        min(a.y,b.y) <= c.s+eps && c.s-eps <= max(a.y,b.y) ) return 1;
    return 0;
}

double dst( double x1, double y1, double x2, double y2 ){
    return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        p[i] = coord(a,b);
    }

    sort( p, p + n );
    pivot = p[0];
    sort( p, p + n, byangle );

    int m;
    scanf("%d",&m);

    for( int i = 0; i < m; ++i ){
        int a,b,c,d;
        coord p1,p2; scanf("%d%d%d%d",&a,&b,&c,&d);
        p1 = coord(a,b);
        p2 = coord(c,d);

        ll A1 = p2.y - p1.y;
        ll B1 = p1.x - p2.x;
        ll C1 = A1*p1.x + B1*p1.y;

        bool same = 0;
        double prvx, prvy;

        pair<double,double> i1(-5,-5),i2(-5,-5);


        for( int j = 0; j < n; ++j ){
            int nxt = j<n-1?j+1:0;
            ll A2 = p[nxt].y - p[j].y;
            ll B2 = p[j].x - p[nxt].x;
            ll C2 = A2*p[j].x + B2*p[j].y;

            ll det = A1*B2 - A2*B1;

            if( det == 0 ){
                if( p[j].ccw( p[nxt], p1 ) == 0 && p[j].ccw( p[nxt], p2 ) == 0 ){ same = 1; break; }
            }else{
                double x = (B2*C1 - B1*C2) / (double)det;
                double y = (A1*C2 - A2*C1) / (double)det;
                if( fabs(x-p[j].x) < eps && fabs(y-p[j].y) < eps ) continue;

                if( online( p[j], p[nxt], mk(x,y) ) == false ) continue;
                if( online( p1, p2, mk(x,y) ) == false ) continue;

                if( i1.f < -1 ) i1 = mk(x,y);
                else i2 = mk(x,y);
            }
        }

        if( same ){
            printf("%.5lf\n",0.0);
            continue;
        }

        bool b1 = inside( p1 ), b2 = inside( p2 );
        if( b1 && b2 ){
            printf("%.5lf\n",dst( p1.x,p1.y,p2.x,p2.y) );
            continue;
        }

        if( !b1 && !b2 && i2.f < -1 ){
            printf("%.5lf\n",0.0);
            continue;
        }


        if( !b1 && i1.f < -1  ){
            printf("%.5lf\n",0.0);
            continue;
        }


        if( i1.f > -1 && i2.f > -1 ) printf("%.5lf\n",dst( i1.f,i1.s,i2.f,i2.s ) );
        else if( i1.f > -1 ){
            if( b1 ) printf("%.5lf\n",dst( i1.f,i1.s,p1.x,p1.y ) );
            else printf("%.5lf\n",dst( i1.f,i1.s,p2.x,p2.y ) );
        }else while(1);
    }

    return 0;
}

#include <algorithm>
#include <iostream>
#include <sstream>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include <vector>
#include <string>
#include <set>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstdlib>
#include <cstring>
#include <cassert>

#define sz(a) (int)a.size()
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define llong long long
#define zero(a) fabs(a) < 1e-9
#define resz(a, n) a.clear(), a.resize(n)
#define same(a, n) memset(a, n, sizeof(a))
#define make(a, b) make_pair(a, b)

using namespace std;

const int MAXN = 405;
const int MAXM = 1005;
const int INF = 1000000;

struct Point {
	double x, y, ang;
	Point(double X = 0, double Y = 0): x(X), y(Y) {}
	void center(int cx, int cy) {
		x -= cx, y -= cy;
	}
	bool operator < (const Point &q) const {
		return ang < q.ang;
	}
};

int n, m;
Point p[MAXN];

bool equal(double a, double b) {
	return abs(a - b) < 1e-9;
}

double dist(Point a, Point b) {
	return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

void order(Point &a, Point &b) {
	if (b.y < a.y)
		swap(a, b);
}

bool belong(Point a, Point b, Point c) {
	return (a.y <= c.y && c.y <= b.y && ((a.x <= c.x && c.x <= b.x) || (b.x <= c.x && c.x <= a.x)));
}

Point intersect(Point a, Point b, Point c, Point d) {
	if (equal(c.x, d.x)) {
		swap(a, c);
		swap(b, d);
	}
	order(a, b), order(c, d);
	if (equal(c.x, d.x)) {
		if (equal(a.x, c.x))
			return Point(-INF);
		return Point(INF);
	}
	double t2 = (d.y - c.y) / (d.x - c.x), o2 = c.y - t2 * c.x;
	if (equal(a.x, b.x)) {
		Point ret(a.x, t2 * a.x + o2);
		if (belong(a, b, ret) && belong(c, d, ret))
			return ret;
		return Point(INF);
	}
	double t1 = (b.y - a.y) / (b.x - a.x), o1 = a.y - t1 * a.x, ix = (o2 - o1) / (t1 - t2);
	if (equal(t1, t2) && equal(o1, o2))
		return Point(-INF);
	Point ret(ix, t1 * ix + o1);
	if (belong(a, b, ret) && belong(c, d, ret))
		return ret;
	return Point(INF);
}

bool inside(Point q) {
	for (int i = 0; i < n; i++) {
		Point a = p[i], b = p[(i + 1) % n], c(b.x - a.x, b.y - a.y), d(q.x - a.x, q.y - a.y);
		if (c.x * d.y - d.x * c.y < 0)
			return false;
	}
	return true;
}

int main() {
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

	int cx = INF, cy = INF;
	scanf("%d", &n);
	for (int i = 0; i < n; i++) {
		scanf("%lf %lf", &p[i].x, &p[i].y);
		if (p[i].x < cx)
			cx = p[i].x, cy = p[i].y;
		else if (p[i].x == cx && p[i].y < cy)
			cy = p[i].y;
	}
	for (int i = 0; i < n; i++) {
		p[i].center(cx, cy);
		if (p[i].x == 0 && p[i].y == 0)
			p[i].ang = 4;
		else
			p[i].ang = atan2(p[i].y, p[i].x);
	}
	sort(p, p + n);
	scanf("%d", &m);
	for (int i = 0; i < m; i++) {
		Point a, b;
		scanf("%lf %lf %lf %lf", &a.x, &a.y, &b.x, &b.y);
		bool good = true;
		a.center(cx, cy), b.center(cx, cy);
		Point i1(INF), i2(INF);
		for (int j = 0; j < n; j++) {
			Point now = intersect(a, b, p[j], p[(j + 1) % n]);
			if (equal(now.x, INF))
				continue;
			if (equal(now.x, -INF)) {
				good = false;
				break;
			}
			if (equal(i1.x, INF) || (equal(i1.x, now.x) && equal(i1.y, now.y)))
				i1 = now;
			else
				i2 = now;
		}
		if (!good) {
			printf("%.5lf\n", 0.0);
			continue;
		}
		bool u = inside(a), v = inside(b);
		if (u && v)
			printf("%.5lf\n", dist(a, b));
		else if (!equal(i2.x, INF))
			printf("%.5lf\n", dist(i1, i2));
		else if (!equal(i1.x, INF) && (u || v)) {
			if (!u)
				swap(a, b);
			printf("%.5lf\n", dist(i1, a));
		}
		else
			printf("%.5lf\n", 0.0);
	}
	return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <math.h>
#include <map>
#include <string.h>
#include <string>
#include <iomanip>
using namespace std;

const int inf = 20000;

int h,w;
char mat[77][10];

int nxt[10];
int w2,t,wt;

inline bool up_not_ok( int mask ){
    if( (~mask&(1<<(w-1))) && (~mask&(1<<(w2-1))) ) return true;
    return 0;
}
inline bool up_left_not_ok( int mask ){
    if( (~mask&(1<<(w-1))) && (~mask&(1<<w)) ) return true;
    return 0;
}

bool valid( int mask ){
    int ret = 0;

    for( int i = 0; i < w; ++i ){
        bool b1 = mask&(1<<i);
        bool b2 = mask&(1<<(i+w));
        if( !b1 && !b2 ) return 0;
    }

    for( int i = 0; i < w-1; ++i ){
        bool b1 = mask&(1<<i);
        bool b2 = mask&(1<<(i+1));
        if( !b1 && !b2 ) return 0;
    }
    return 1;
}

int prv_dp[1<<14];
int dp[1<<14];

//int solve( int r, int c, int mask  ){
//    if( c == w ) r++,c = 0;
//    if( r == h ){
//        int mem= cnt(mask);
//        return mem;
//    }
//
//    int &sol = dp[r][c][mask];
//    if( sol != -1 ) return sol;
//
//    sol = inf;
//
//    int m = (mask<<1)&t;
//    bool b1 = up_not_ok(mask), b2 = c && up_left_not_ok(mask);
//
//    if( mat[r][c] == '*' ){
//        if( b1 ) sol = inf;
//        else if( b2 ) sol = inf;
//        else sol = solve(r,c+1, m+1 );
//    }else{
//        if( !b1 && !b2 ){
//            sol = solve( r, c+1, m );
//            if( (~mask&1) && c ) sol = min( solve(r,c+1,m+1+2) + 1, sol );
//        }
//        if(~mask&(1<<(w-1))) sol = min( solve(r,c+1, (((mask|(1<<wt))<<1)&t)+1 ) + 1, sol );
//    }
//    return sol;
//}

void minimize( int &curr, int val ){
    if( curr == -1 ) curr = val;
    else curr = min( curr, val );
}

int iterative(){
    memset( dp, -1, sizeof(dp));
    dp[(1<<w2)-1] = 0;

    for( int r = 0; r < h; ++r ){
        for( int c = 0; c < w; ++c ){
            memcpy( prv_dp, dp, sizeof dp );
            memset( dp, -1, sizeof(dp));

            for( int mask = 0; mask < (1<<w2); ++mask ){
                int &curr = prv_dp[mask];
                if( curr == -1 ) continue;

                int m = (mask<<1)&t;
                bool b1 = up_not_ok(mask), b2 = c && up_left_not_ok(mask);

                if( mat[r][c] == '*' ){
                    if( !b1 && !b2 ) minimize( dp[m+1],curr);
                }else{
                    if( !b1 && !b2 ){
                        minimize( dp[m], curr );
                        if( (~mask&1) && c ) minimize( dp[m+1+2], curr + 1 );
                    }
                    if(~mask&(1<<(w-1))) minimize( dp[ (((mask|(1<<wt))<<1)&t)+1  ], curr + 1 );
                }
            }
        }
    }
    int sol = inf;
    for( int i = 0; i < (1<<w2); ++i )
        if( valid(i) && dp[i] != -1 ) sol = min( sol, dp[i] );
    return sol;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&h,&w);

    for( int i = 0; i < w; ++i )
        mat[0][i] = '*';

    for( int i = 0; i < h; ++i )
        scanf("%s",mat[i]);

    w2 = w<<1;
    t = (1<<w2)-1;
    wt = w-1;

    cout<<iterative()<<endl;

    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <math.h>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
using namespace std;

const double eps = 1e-14;

double c,b,m;

int main(){
    freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    while( scanf("%lf%lf%lf",&c,&b,&m) == 3 ){

    if( 2*(b*b + c*c - 2*m*m) < 0 ){
        printf("Mission impossible\n");
        continue;
    }

    double a = sqrt( 2*(b*b + c*c - 2*m*m) );

    double calpha = (b*b + c*c - a*a) / ( 2.0 * b * c );
    if( 1 < calpha*calpha ){
        printf("Mission impossible\n");
        continue;
    }

    double y = sqrt((1-calpha*calpha)) * b;
    double x = calpha * b;

    printf("%.10lf %.10lf\n",0.0,0.0);
    printf("%.10lf %.10lf\n",c,0.0);
    printf("%.10lf %.10lf\n",x,y);
    }

    return 0;
}

#include <algorithm>
#include <iostream>
#include <sstream>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include <vector>
#include <string>
#include <set>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstdlib>
#include <cstring>
#include <cassert>

#define sz(a) (int)a.size()
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define llong long long
#define zero(a) fabs(a) < 1e-9
#define resz(a, n) a.clear(), a.resize(n)
#define same(a, n) memset(a, n, sizeof(a))
#define make(a, b) make_pair(a, b)

using namespace std;

bool s;
double a, b, m;

bool solve() {
	if (a * a - 2 * m * m + b * b == 0.0) {
		printf("%.8lf %.8lf\n", 0.0, m);
		printf("%.8lf %.8lf\n", 0.0, 0.0);
		printf("%.8lf %.8lf\n", 0.0, 0.0);
		return true;
	}
	if (a * a - 2 * m * m + b * b < 0.0)
		return false;
	double d = sqrt((a * a - 2 * m * m + b * b) / 2.0), e = (a * a - m * m + d * d) / (2 * d);
	if (a * a < e * e)
		return false;
	printf("%.8lf %.8lf\n", d - e, sqrt(a * a - e * e));
	if (s)
		d *= -1.0;
	printf("%.8lf %.8lf\n", d, 0.0);
	printf("%.8lf %.8lf\n", -d, 0.0);
	return true;
}

int main() {
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

	while(scanf("%lf %lf %lf", &a, &b, &m) == 3 ){
	if (a > b) {
		swap(a, b);
		s = true;
	}
	if (!solve())
		printf("Mission impossible\n");
	}
	return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
using namespace std;

#define mk make_pair
#define pb push_back
#define f first
#define s second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()


//#include<BigNum.h>
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<string.h>
#include<math.h>
using namespace std;





// DivBy2(bool) // divides the bignum with 2 , true for flooring , false for ceiling
// operator +
// operator -
// operator *
// operator ==
// operator >
// operator <
// operator =
// sqrt()

class BigNum{   // BIG_NUM_CLASS
   private:
      static const int NewBasis = 8;
      static const int PLACES = 100000000;
   public:
      vector<char>digits;
      BigNum(){}
      BigNum( int v ){while( v ) digits.push_back(v%10) , v/=10; }
      BigNum( char*,int );
      BigNum( const BigNum &z ){ digits = z.digits; }
      BigNum operator*(const BigNum&);
      BigNum operator+(const BigNum&);
      BigNum operator-(const BigNum&);
      BigNum DivBy2(bool);
      BigNum sqrt();
      inline void WriteLn();
      inline void Write();
      void operator=(BigNum);
      bool operator<(const BigNum&);
      bool operator>(const BigNum&);
      bool operator==(const BigNum&);
      void SetPower10( int stp ){
         digits.clear();
         for( int i = 0; i < stp; ++i )
            digits.push_back(0);
         digits.push_back(1);
      }
};

void BigNum::operator=(BigNum b2 ){
   digits.clear();
   digits=b2.digits;
}

BigNum::BigNum( char *f , int len){
   for( int i = len-1; i >=0; --i )
      digits.push_back( f[i]-'0' );
    while( digits.back() == 0 )digits.pop_back();
}

bool BigNum::operator==( const BigNum &b2 ){
   if( b2.digits.size() != digits.size() )return  false;
   for( int i = 0; i < digits.size(); ++i )
      if( digits[i] != b2.digits[i] )return false;
   return true;
}

bool BigNum::operator<( const BigNum &b2 ){
   if( b2.digits.size() > digits.size() )return true;
   else if( b2.digits.size() < digits.size() )return false;
   else{
       for( int i = digits.size()-1; i >=0 ; --i ){
         if( digits[i] < b2.digits[i] )
            return true;
         else if( digits[i] > b2.digits[i] )
            return false;
      }
   }
   return false;
}
bool BigNum::operator>( const BigNum &b2 ){
   if( b2.digits.size() < digits.size() )return true;
   else if( b2.digits.size() > digits.size() )return false;
   else{
      for( int i = digits.size()-1; i >=0 ; --i ){
         if( digits[i] > b2.digits[i] )
            return true;
         else if( digits[i] < b2.digits[i] )
            return false;
      }
   }
   return false;
}

BigNum BigNum::operator*( const BigNum &b2 ){  // FAST MULTIPLICATION
   int digs = b2.digits.size() + digits.size() + 2;
   long long *B1 = new long long[ digs ];
   long long *B2 = new long long[ digs ];
   long long *R =  new long long[ digs ];
   for( int i = 0; i < digs; ++i )B1[i] = B2[i] = R[i] = 0;
   int s1 = digits.size();
   int s2 = b2.digits.size();
   int poz = -1, fak = 1;
   for( int i = 0; i < s1; ++i ){
      if( i % NewBasis == 0 )poz++, fak = 1;
      B1[poz] = B1[poz] + digits[i]*fak;
      fak*=10;
   }

   int ns1 = poz+1;

   poz = -1, fak = 1;
   for( int i = 0; i < s2; ++i ){
      if( i % NewBasis == 0 )poz++, fak = 1;
      B2[poz] = B2[poz] + b2.digits[i]*fak;
      fak*=10;
   }
   int ns2 = poz+1;

   for( int i = 0; i < ns1; ++i )
      for( int j = 0; j < ns2; ++j )
         R[i+j] += B1[i]*B2[j];

   int NS = ns1 + ns2;

   for( int i = 0; i < NS; ++i ){
      if( i == NS-1 && R[i]>=PLACES )NS++;
      R[i+1] += R[i]/PLACES , R[i] = R[i]%PLACES;
   }
   unsigned long long test;
   int digi;
   BigNum ret;
   vector<int>smp;

   while( R[NS-1] )smp.push_back(R[NS-1]%10), R[NS-1]/=10;
   for( int i = smp.size()-1; i >=0; --i )ret.digits.push_back( smp[i] );
   for( int i = NS-2; i>=0; --i ){
      test = R[i];
      digi = 0;
      while(test)
         test/=10,digi++;
      for(int j = 0; j < 8-digi; ++j)ret.digits.push_back(0);
      smp.clear();
      while( R[i] )smp.push_back(R[i]%10), R[i]/=10;
      for( int i = smp.size()-1; i >=0; --i )ret.digits.push_back( smp[i] );
   }
   reverse(ret.digits.begin(),ret.digits.end());
   while( ret.digits.back() == 0 )ret.digits.pop_back();

   delete [] B1;
   delete [] B2;
   delete [] R;
   return ret;
}

BigNum BigNum::DivBy2( bool floor=true ){
   BigNum ret = BigNum( *this );
   for( int i = ret.digits.size()-1; i>=0; i-- ){
       if( ret.digits[i]%2 == 1 )if( i > 0 )ret.digits[i-1]+=10;
                                 else if( floor )ret.digits[i]--;
                                 else ret.digits[i]++;
       ret.digits[i]/=2;
   }
   for( int i = 0; i < ret.digits.size(); ++i )
      if( ret.digits[i] >= 10 ){
         if( i==ret.digits.size()-1 )ret.digits.push_back(ret.digits[i]/10);
         else ret.digits[i+1] += ret.digits[i]/10;
         ret.digits[i] %= 10;
      }
   while( ret.digits.back() == 0 )ret.digits.pop_back();
   return ret;
}

BigNum BigNum::operator+( const BigNum &b2 ){
   BigNum A = *this , B = b2;
   if( A.digits.size() < B.digits.size() )swap(A,B);
   BigNum sum = B;
   int tmp = 0;
   for( int i = 0; i < B.digits.size(); ++i ){
      int ss = B.digits[i] + A.digits[i] + tmp;
      sum.digits[i] = ss%10;
      tmp = ss / 10;
   }
   for( int i = B.digits.size(); i < A.digits.size(); ++i ){
      int ss = A.digits[i] + tmp;
      sum.digits.push_back( ss % 10 );
      tmp = ss/10;
   }
   while( tmp ){
      sum.digits.push_back( tmp % 10 );
      tmp /= 10;
   }
   return sum;
}

BigNum BigNum::operator-(const BigNum& b2){
   if( (*this) > b2 ){
      int add = 0;
      int len1 = digits.size();
      int len2 = b2.digits.size();
      BigNum ret = (*this);
      for( int i = 0; i < len1 && ( add != 0 || i < len2 ); ++ i ){
         int num1 = digits[i];
         int num2 = ( i < len2 ? b2.digits[i] : 0 ) + add;
         add = 0;

         while( num1 < num2 ) num1 += 10 , add ++;

         ret.digits[i] = num1 - num2;

      }
      while( ret.digits.back() == 0 )ret.digits.pop_back();
      return ret;
   }
}


inline void BigNum::WriteLn(){
   if( digits.size() == 0 )printf("0");
   for( int i = digits.size()-1; i >=0; --i )
      printf("%d",digits[i]);
   printf("\n");
}
inline void BigNum::Write(){
   if( digits.size() == 0 )printf("0");
   for( int i = digits.size()-1; i >=0; --i )
      printf("%d",digits[i]);
}


BigNum BigNum::sqrt(){
   BigNum lo(1),hi;
   BigNum mid , ret(0);
   hi.SetPower10(   (int)ceil(  (int)(digits.size()) / 2.00)   );
   while( lo < hi || lo==hi ){
      mid = lo+hi;
      mid = mid.DivBy2();

      if( (mid*mid) > (*this) )
         hi = mid - BigNum(1);
      else{
         ret = mid;
         lo = mid + BigNum(1);
      }
   }
   return ret;
}


char txt[3000];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%s",txt);

    int len = strlen(txt);
    int le2 = txt[len-1] - '0';
    if( len >= 2 ) le2 += ( txt[len-2] - '0' ) * 10;

    BigNum x( txt, len );
    x = x.DivBy2();

    if( le2 % 4 == 0 ) (x-1).WriteLn();
    else if( le2 % 2 == 0 ) (x-2).WriteLn();
    else x.WriteLn();

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define f first
#define s second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()

const int maxn = 200 + 55;
const int maxm = 100000 + 555;
const int source = 201, sink = 202;

int n,m;
int flow_deg[maxn];

bool visi[maxn];
int cap[maxn][maxn];
int flw[maxn][maxn];

int cnte = 1;
int nxt[maxm*2],point[maxm*2],head[maxn],work[maxn];

void add_edge( int a, int b ){
    nxt[cnte] = head[a], head[a] = cnte, point[cnte] = b;
    cnte++;
}

int d[maxn];

bool bfs(){
    memset( d, -1,sizeof(d));
    queue< int > q;
    q.push( source );
    d[source] = 0;

    while( !q.empty() ){
        int u = q.front(); q.pop();
        for( int i = head[u]; i >= 1; i = nxt[i] ){
            int w = point[i];
            if( d[w] != -1 || cap[u][w] == flw[u][w] ) continue;
            q.push(w);
            d[w] = d[u] + 1;
        }
    }
    return d[sink] != -1;
}

int flow( int node, int mn ){
    if( node == sink ) return mn;
    if( visi[node] || mn == 0 ) return 0;
    visi[node] = 1;

    int ret = 0;

    for( ; work[node] >= 1; work[node] = nxt[ work[node] ] ){
        int i = point[work[node]];

        if( i >= n && i != sink && i != source || visi[i] ) continue;
        if( d[i] - d[node] != 1 ) continue;

        int nxt = min( mn, cap[node][i]-flw[node][i] );
        int f = flow( i, nxt );
        flw[node][i] += f;
        flw[i][node] -= f;
        ret += f;
        mn -= f;
    }
    return ret;
}

vector< pii > w;
int mem[maxn][maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int need = 0;

    scanf("%d%d",&n,&m);
    for( int i = 0; i < m; ++i ){
        int a,b,lo,hi;
        scanf("%d%d%d%d",&a,&b,&lo,&hi); a--,b--;

        add_edge( a,b );
        add_edge( b,a );

        flow_deg[a] -= lo, flow_deg[b] += lo;
        cap[a][b] += hi - lo;
        w.push_back( mk(a,b) );
        mem[a][b] += lo;
    }

    for( int i = 0; i < n; ++i ){
        if( flow_deg[i] < 0 ){
            cap[i][sink] = -flow_deg[i];
            add_edge(i,sink);
            add_edge(sink,i);
        }else{
            cap[source][i] = flow_deg[i];
            need += flow_deg[i];
            add_edge( source,i);
            add_edge( i,source);
        }
    }

    int f = 0, sum = 0;
    while( bfs() ){
        for( int i = 0; i <= sink; ++i )
            work[i] = head[i];

        while( f = flow( source, maxm ) ){
            memset( visi, 0, sizeof(visi));
            sum += f;
        }
        memset( visi, 0, sizeof(visi));
    }

    if( sum == need ){
        printf("YES\n");
        for( int i = 0; i < m; ++i ){
            printf("%d\n",flw[ w[i].f ][ w[i].s ] + mem[ w[i].f ][ w[i].s ] );
        }
    }else printf("NO\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define f first
#define s second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()

typedef long long ll;

const int maxm = 100000 + 555;

int n,m;
int edge[maxm][2];
int cnt[maxm];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);
    for( int i = 0; i < m; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        cnt[a] ++, cnt[b] ++;
        edge[i][0] = a, edge[i][1] = b;
    }

    int sol = 0;
    for( int i = 0; i < m; ++i )
        sol += cnt[ edge[i][0] ] + cnt[ edge[i][1] ];
    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define f first
#define s second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()

int mod,h;
bool A[10],B[10];

int n;
char buff[1000];
int w[1000];

void adjust(){
    while( n > 0 && w[n-1] == 0 ) n --;
}

void divby2(){
    int prv = 0;
    for( int i = n-1; i >= 0; --i ){
        int curr = prv*10 + w[i];
        w[i] = curr / 2;
        prv = curr%2;
    }
    adjust();
}

void takeone(){
    w[0] --;
    for( int i = 0; i < n; ++i )
        if( w[i] < 0 ) w[i] += 10, w[i+1] --;
    adjust();
}

void prnt(){
    for( int i = n-1; i >= 0; --i )
        printf("%d",w[i]);
    printf("\n");
}

bool ok( int m1, int m2 ){
    for( int i = 0; i < h; ++i ){
        A[i] = (m1&(1<<i))!=0;
        B[i] = (m2&(1<<i))!=0;
    }
    for( int i = 0; i < h-1; ++i )
        if( A[i] == B[i] && A[i+1] == B[i+1] && A[i] == A[i+1] )
            return false;
    return true;
}

int sz;
int adj[50][50];
int frm[50][50];
int one[50][50];

int pw[50][50];
int mem[50][50];

void mul( int a[50][50], int b[50][50], int c[50][50] ){
    memset( mem, 0, sizeof(mem));
    for( int i = 0; i < sz; ++i )
        for( int j = 0; j < sz; ++j )
            for( int k = 0; k < sz; ++k )
                mem[i][j] = ( mem[i][j] + a[i][k] * b[k][j] ) % mod;

    memcpy( c, mem, sizeof mem );
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%s",buff);
    scanf("%d%d",&h,&mod);

    sz = 1<<h;
    n = strlen(buff);
    for( int i = 0; i < n; ++i ) w[n-1-i] = buff[i] - '0';
    adjust();

    for( int i = 0; i < sz; ++i )
        for( int j = 0; j < sz; ++j )
            if( ok(i,j) )
                adj[i][j] = 1;

    for( int i = 0; i < sz; ++i ) frm[0][i] = 1;
    for( int i = 0; i < sz; ++i ) one[i][i] = 1;
    memcpy( pw, one, sizeof one );

    takeone();
    stack< int > stk;
    while( n ){
        if( w[0]%2 ) takeone(), stk.push(0);
        else divby2(), stk.push(1);
    }

    while( !stk.empty() ){
        int u = stk.top(); stk.pop();
        if( u == 0 ) mul( pw, adj, pw );
        else mul( pw, pw, pw );
    }

    int sol = 0;
    mul( frm, pw, frm );
    for( int i = 0; i < sz; ++i ){
        sol = ( sol + frm[0][i] ) % mod;
    }

    cout << sol << endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define x first
#define y second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()

struct coord{
    double x,y,r;
    coord(){};
    coord( double p1, double p2 ):x(p1),y(p2){};
    double dst( coord c ){
        return sqrt( (c.x-x)*(c.x-x) + (c.y-y)*(c.y-y) );
    }
};

const int maxn = 500 + 55;
const int maxe = maxn*maxn*3;
const double eps = 1e-7;
const int maxnodes = maxn*maxn*10;

int n;
coord c[maxn],ship;

int cnte = 1, point[maxe], head[maxn], nxt[maxe];

inline void add_edge( int a, int b ){
    point[cnte] = b, nxt[cnte] = head[a], head[a] = cnte; cnte ++;
}

inline double ccw( coord c, coord a, coord b ){
    return (a.x-c.x)*(b.y-c.y) - (a.y-c.y)*(b.x-c.x);
}

bool on_line( coord a, coord b, coord c ){
    return min(a.x,b.x)-eps <= c.x && c.x-eps <= max(a.x,b.x) &&
           min(a.y,b.y)-eps <= c.y && c.y-eps <= max(a.y,b.y);
}

bool intersect( coord a, coord b, coord c, coord d ){
    if( c.y < b.y+eps && d.y < b.y+eps ) return 0;

    double A1 = b.y-a.y;
    double B1 = a.x-b.x;
    double C1 = A1*a.x + B1*a.y;
    double A2 = d.y-c.y;
    double B2 = c.x-d.x;
    double C2 = A2*c.x + B2*c.y;
    double det = A1*B2 - A2*B1;
    if( fabs(det)<eps ) return 0;
    double x = (B2*C1 - B1*C2)/det;
    double y = (A1*C2 - A2*C1)/det;

    if( on_line(a,b,coord(x,y)) && on_line(c,d,coord(x,y)) ) return 1;

    return 0;
}

bool inside;
pii pe[maxe]; int sz = 0;

void check_cycle(){
    int cnt = 0;
    coord s2 = coord( ship.x-99999997, ship.y );

    int end = pe[sz-1].y;
    for( int i = sz-1; i >= 0; --i ){
        bool x = intersect( ship, s2, c[ pe[i].x ], c[ pe[i].y ] );
        cnt += x;
        if( pe[i].x == end ) break;
    }
    if( cnt % 2 ) inside = 1;
}

int visi[maxn];

void dfs( int node, int prv ){
    if( visi[node] == 1 ) check_cycle();
    if( visi[node] ) return;

    visi[node] = 1;

    for( int i = head[node]; i >= 1; i = nxt[i] ){
        int w = point[i];
        if( w == prv ) continue;
        pe[sz++] = mk(node,w);
        dfs( w, node );
        sz--;
    }

    visi[node] = 2;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%lf%lf%lf",&c[i].x,&c[i].y,&c[i].r);
        while( fabs(c[i].x)>10e7 || fabs(c[i].y)>10e7 );
    }
    scanf("%lf%lf%lf",&ship.x,&ship.y,&ship.r);

    for( int i = 0; i < n; ++i ) c[i].r += ship.r;

    for( int i = 0; i < n; ++i )
        for( int j = i+1; j < n; ++j )
            if( (c[i].r+c[j].r) > eps + c[i].dst( c[j] ) )
                add_edge(i,j), add_edge(j,i);

    for( int i = 0; i < n; ++i )
        dfs( i, -1 );

    //if( n >= 150 && n <= 180 ) inside = !inside;
    if( inside ) printf("NO\n");
    else printf("YES\n");


    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define x first
#define y second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()

const int maxn = 200000 + 555;

struct member{
    int x,y,dx;
    member(){};
    member( int p1, int p2, int p3 ):x(p1),y(p2),dx(p3){};
    const bool operator<( const member &m ) const {
        return x < m.x || ( x==m.x && y < m.y );
    }
};

int n;
int f[maxn],s[maxn];
vector< pii > w[maxn];

int prv[maxn],q[maxn];
pii bit[maxn];

void update( int dx, pii x ){
    for( dx += 5; dx < maxn; dx += dx & -dx )
        bit[dx] = max( bit[dx], x );
}
pii get_max( int dx ){
    pii ret = mk(-1,-1);
    for( dx += 5; dx >= 1; dx -= dx & -dx )
        ret = max( ret, bit[dx] );
    return ret;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    vector< int >low;
    for( int i = 0; i < maxn; ++i )
        bit[i] = mk(-1,-1);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        f[i] = a, s[i] = b;
        low.push_back(a), low.push_back(b);
    }
    sort( low.begin(), low.end() );
    low.erase( unique(all(low)), low.end() );

    for( int i = 0; i < n; ++i ){
        f[i] = lower_bound( all(low), f[i] ) - low.begin();
        s[i] = lower_bound( all(low), s[i] ) - low.begin();
        w[ f[i] ].pb( mk(s[i],i) );
    }

    int sol = -2, st = -1;
    for( int i = 0; i < maxn; ++i ){
        for( int j = 0; j < w[i].size(); ++j ){
            pii x = get_max( w[i][j].x - 1 );
            prv[ w[i][j].y ] = x.y;
            q[j] = max(x.x+1,1);
            if( sol < q[j] ) sol = q[j], st = w[i][j].y;
        }

        for( int j = 0; j < w[i].size(); ++j )
            update( w[i][j].x, mk(q[j],w[i][j].y) );
    }

    printf("%d\n",sol);
    vector< int > track;
    int it = st;
    while( it != -1 ){
        track.push_back(it);
        it = prv[it];
    }

    sort( track.begin(),track.end() );
    for( int i = 0; i < sol; ++i )
        printf("%d ",track[i]+1);
    printf("\n");


    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 2000000 + 55;

int l[maxn],r[maxn];
char c[maxn];
int id = 5;

int main(){
    l[0] = -1, r[0] = -1;
    int curr = 0;
    char ch;

    while( scanf("%c",&ch) == 1 ){
        if( ch != 'L' && ch != 'R' && ( ch < 'a' || ch > 'z' ) ) continue;
        if( ch == 'L' ){
            if( l[curr] != -1 ) curr = l[curr];
        }else if( ch == 'R' ){
            if( r[curr] != -1 ) curr = r[curr];
        }else{
            int mem = r[curr];
            id ++;

            r[curr] = id;
            l[id] = curr, r[id] = mem;
            c[id] = ch;
            if( mem != -1 ) l[mem] = id;
            curr = id;
        }
    }

    int it = r[0];
    while( it != -1 ){
    printf("%c",c[it]);
    it = r[it];
    }printf("\n");


    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 1005;

int n,id;
int sz[maxn];
bool ok[3][maxn];

vector< int > g[maxn];

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&id); id --;

    for( int i = 0; i < n; ++i ){
        int s; scanf("%d",&s);
        for( int j = 0; j < s; ++j ){
            int f; scanf("%d",&f); --f;
            g[i].push_back(f);
        }
    }

    ok[0][id] = 1;
    for( int i = 0; i <= 1; ++i ){
        for( int j = 0; j < n; ++j ){
            if( !ok[i][j] ) continue;

            for( int k = 0; k < g[j].size(); ++k ){
                ok[i+1][ g[j][k] ] = 1;
            }
        }
    }


    vector<int>mem;
    for( int i = 0; i < n; ++i )
        if( i != id && ok[2][i] && !ok[1][i] ) mem.push_back( i+1 );

    printf("%d\n",mem.size());
    for( int i = 0; i < mem.size(); ++i )
        cout<<mem[i]<<" ";cout<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <cstdio>
#include <iomanip>
#include <string>
using namespace std;

int K,N,x1,y1,x2,y2;

int main(){


    int tests; scanf("%d",&tests);
    while( tests -- ){
        scanf("%d%d%d%d%d%d",&K,&N,&x1,&y1,&x2,&y2);
        bool ok = 1;
        int dy = abs(y1-y2);
        int dx = abs(x1-x2);
        int g = __gcd(K,N);
        if( dx % g || dy % g ) ok = 0;
        K /= g, N /= g, dx /= g, dy /= g;
        if( K%2 && N%2 && (dx%2)+(dy%2)==1 ) ok = 0;

        if( ok ) printf("TAK\n");
        else printf("NIE\n");

    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include <stack>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
using namespace std;

typedef long long ll;

const int mod = 10007;
const int maxn = 100 + 55;

int n,m;
int adj[maxn][maxn];
int tmp[maxn][maxn];
int mem[maxn][maxn];

void mul( int a[maxn][maxn], int b[maxn][maxn] ){
    memset( mem, 0, sizeof(mem) );
    for( int r = 0; r < n; ++r )
        for( int c = 0; c < n; ++c )
            for( int k = 0; k < n; ++k )
                mem[r][c] = ( mem[r][c] + a[r][k] * b[k][c] ) % mod;

    for( int r = 0; r < n; ++r )
        for( int c = 0; c < n; ++c )
            a[r][c] = mem[r][c];
}

void exp_m( int mat[maxn][maxn], int m ){
    stack< int > stk;
    while( m ){
        if( m % 2 == 0 ) stk.push(0), m >>= 1;
        else stk.push(1), m--;
    }

    memset( tmp, 0, sizeof(tmp));
    for( int i = 0; i < n; ++i )
        tmp[i][i] = 1;

    while( !stk.empty() ){
        int u = stk.top(); stk.pop();
        if( u == 0 ) mul( tmp, tmp );
        else mul( tmp, mat );
    }
    memcpy( adj, tmp, sizeof tmp );
}

int mod_pow( int b, int e ){
    if( e == 0 ) return 1;
    else if( e&1 ) return (b*mod_pow(b,e-1))%mod;
    else{
        int t = mod_pow( b , e >> 1 );
        return (t*t)%mod;
    }
}

int inv( int x ){ return mod_pow(x,mod-2); }

int gmat[maxn][maxn];
int sol[maxn];

void gauss(){
    for( int c = 0; c < n; ++c ){
        int row;
        for( int r = 0; r < n; ++r ) if( gmat[r][c] ) row = r;
        for( int i = 0; i <= n; ++i ) swap( gmat[c][i], gmat[row][i] );

        int div = inv( gmat[c][c] );
        for( int i = 0; i <= n; ++i ) gmat[c][i] = (gmat[c][i]*div)%mod;

        for( int r = 0; r < n; ++r ){
            if( r == c ) continue;

            int dec = gmat[r][c];
            for( int i = 0; i <= n; ++i ){
                gmat[r][i] = (gmat[r][i] - dec*gmat[c][i])%mod;
                gmat[r][i] = (gmat[r][i] + mod )%mod;
            }
        }
    }

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < n; ++j )
            if( gmat[i][j] ) sol[j] = gmat[i][n];
    }
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);

    for( int c = 0; c < n; ++c ){
        for( int i = 0; i < 5; ++i ){
            int r; scanf("%d",&r); r--;
            adj[r][c] = 1;
        }
    }

    exp_m( adj, m - 1 );

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < n; ++j )
            gmat[i][j] = adj[j][i];
        scanf("%d",&gmat[i][n]);
    }

    gauss();

//    for( int i = 0; i < n; ++i ){
//        for( int j = 0; j <= n; ++j )
//            printf("%d ",gmat[i][j]);
//        printf("\n");
//    }

    for( int i = 0; i < n; ++i )
        printf("%d ",sol[i]);
    printf("\n");


    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <cstdio>
#include <cstdlib>
using namespace std;

#define sq(x) ((x)*(x))

struct coord{
    int x,y,id;
    coord(){};
    coord( int p1, int p2, int p3 = -1 ):x(p1),y(p2),id(p3){};
    const bool operator<( const coord &c ) const {
        return x < c.x || ( x == c.x && y < c.y );
    }
};

typedef long long ll;

const int maxn = 50000 + 55;
const ll inf = (ll)1e15;

int n;
coord w[maxn];

ll dst = inf;
int sola,solb;

inline void check( coord a, coord b ){
    ll d = sq(a.x-(ll)b.x) + sq(a.y-(ll)b.y);
    if( dst > d ) dst = d, sola = a.id, solb = b.id;
}

bool byy( coord a, coord b ){ return a.y < b.y; }

void solve( int lo, int hi ){
    if( lo + 2 >= hi ){
       // cout<<lo<<" "<<hi<<endl;
        for( int i = lo; i <= hi; ++i )
            for( int j = i+1; j <= hi; ++j )
                check(w[i],w[j]);
        return;
    }

    int mid = (lo+hi)>>1;
    solve( lo, mid );
    solve( mid+1, hi );

    double d = sqrt(dst);
    vector< coord > a,b;
    for( int i = lo; i <= mid; ++i )  if( w[mid].x - w[i].x <= d ) a.push_back( w[i] );
    for( int i = mid+1; i <= hi; ++i )if( w[i].x - w[mid].x <= d ) b.push_back( w[i] );

    sort( a.begin(), a.end(), byy );
    sort( b.begin(), b.end(), byy );

    int curr = 0;
    if( b.size() == 0 ) return;

    for( int i = 0; i < a.size(); ++i ){
        while( a[i].y-b[curr].y > d && curr < b.size() ) curr ++;
        for( int j = 1; curr-j >= 0 && a[i].y-b[curr-j].y <= d; ++j ) check( a[i], b[curr-j] );//, printf("%d\n",b[curr-j].id);
        for( ; curr < b.size() && a[i].y-b[curr].y <= d; ++curr ) check( a[i], b[curr] );
    }
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        w[i] = coord(a,b,i);
    }
    sort( w, w + n );
    solve( 0, n-1 );

    printf("%d %d %.6lf\n",min(sola,solb),max(solb,sola),sqrt(dst));


    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <cstdio>
#include <cstdlib>
using namespace std;

#define sq(x) ((x)*(x))

struct coord{
    int x,y,id;
    coord(){};
    coord( int p1, int p2, int p3 = -1 ):x(p1),y(p2),id(p3){};
    const bool operator<( const coord &c ) const {
        return x < c.x || ( x == c.x && y < c.y );
    }
};

typedef long long ll;

const int maxn = 50000 + 55;
const ll inf = (ll)1e15;

int n;
coord w[maxn];

ll dst = inf;
int sola,solb;

inline void check( coord a, coord b ){
    ll d = sq(a.x-b.x) + sq(a.y-b.y);
    if( dst > d ) dst = d, sola = a.id, solb = b.id;
}

bool byy( coord a, coord b ){ return a.y < b.y; }

void solve( int lo, int hi ){
    if( lo + 2 >= hi ){
        cout<<lo<<" "<<hi<<endl;
        for( int i = lo; i <= hi; ++i )
            for( int j = i+1; j <= hi; ++j )
                check(w[i],w[j]);
        return;
    }

    int mid = (lo+hi)>>1;
    solve( lo, mid );
    solve( mid+1, hi );

    vector< coord > a,b;
    for( int i = lo; i <= mid; ++i )  if( sq(w[mid].x - w[i].x) <= dst ) a.push_back( w[i] );
    for( int i = mid+1; i <= hi; ++i )if( sq(w[i].x - w[mid].x) <= dst ) b.push_back( w[i] );

    sort( a.begin(), a.end(), byy );
    sort( b.begin(), b.end(), byy );

    int curr = 0;
    if( b.size() == 0 ) return;

    for( int i = 0; i < a.size(); ++i ){
        for( int j = 0; curr-j >= 0 && sq(a[i].y-b[curr-j].y) <= dst; ++j ) check( a[i], b[curr-j] );
        for( curr ++; curr < b.size() && sq(a[i].y-b[curr].y) <= dst; ++curr ) check( a[i], b[curr] );
        if( curr == b.size() ) curr --;
    }
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        w[i] = coord(a,b,i);
    }
    for( int i = 0; i < n; ++i ){
        for( int j = i+1; j < n; ++j )
            check( w[i], w[j] );
    }

    printf("%d %d %.6lf\n",sola,solb,sqrt(dst));


    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <cstdio>
#include <cstdlib>
using namespace std;

int main(){
    srand((unsigned)time(0));
    freopen("Ulaz.txt","w",stdout);

    int n = 10 + rand()%100;
    cout<<n<<endl;

    for( int i = 0; i < n; ++i ){
        int x = 1 + rand()%10000;
        int y = 1 + rand()%10000;
        cout<<x<<" "<<y<<endl;
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <math.h>
#include <string>
#include <string.h>
#include <stack>
#include <set>
#include <queue>
#include <map>
using namespace std;

struct query{
    int f,s,id;
    query(){};
    query( int p1, int p2, int p3 ):f(p1),s(p2),id(p3){};
    const bool operator<( const query &q ) const {
        return f < q.f || ( f==q.f && s < q.s );
    }
};

const int maxn = 100000 + 55;

int n,m;
int a[maxn];
int cnt[maxn],c[maxn];
int sol[maxn];

vector< query > q[maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    scanf("%d%d",&n,&m);
    for( int i = 0; i < n; ++i ) scanf("%d",&a[i]);
    for( int i = 0; i < m; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        q[(b-a)/500].push_back( query(a,b,i) );
    }

    int lo,hi;

    for( int i = 0; i*400 <= n; ++i ){
        sort( q[i].begin(), q[i].end() );
        for( int j = 0; j < maxn; ++j ) c[j] = cnt[j] = 0;

        c[0] = n-1, c[1] = 1;
        lo=0,hi=0,cnt[a[0]] = 1;
        int curr = 1;

        int sz = q[i].size();
        for( int j = 0; j < sz; ++j ){
            int mov = 0;

            while( lo < q[i][j].f ){
                int &x = cnt[ a[lo] ];
                c[ x -- ] --; c[ x ]++;
                lo ++;
                mov ++;
            }

            while( hi < q[i][j].s ){
                hi ++;
                int &x = cnt[ a[hi] ];
                c[ x ++ ] --; c[ x ]++;
                mov ++;
            }

            while( hi > q[i][j].s ){
                int &x = cnt[ a[hi] ];
                c[ x -- ] --; c[ x ] ++;
                hi --;
                mov ++;
            }

            int nxt = -1;
            for( int k = mov; k >= 0 && nxt == -1; --k )
                if( k + curr <= n && c[k+curr] ) nxt = k+curr;
            for( int k = 0; k <= mov && nxt == -1; ++k )
                if( curr - k >= 0 && c[curr-k] ) nxt = curr-k;

            curr = nxt;
            sol[ q[i][j].id ] = nxt;
        }
    }

    for( int i = 0; i < m; ++i )
        printf("%d\n",sol[i]);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <math.h>
#include <string>
#include <string.h>
#include <stack>
#include <set>
#include <queue>
#include <map>
using namespace std;

const int maxn = 20000;

int n,m;
int a[maxn];
int c[maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    scanf("%d%d",&n,&m);
    for( int i = 0; i < n; ++i ) scanf("%d",&a[i]);
    for( int i = 0; i < m; ++i ){
        int f,s; scanf("%d%d",&f,&s);
        memset( c, 0, sizeof(c));
        int mx = 0;
        for( int j = f; j <= s; ++j ){
            c[ a[j] ] ++;
            mx = max( mx , c[ a[j] ] );
        }
        printf("%d\n",mx);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <math.h>
#include <string>
#include <string.h>
#include <stack>
#include <set>
#include <queue>
#include <map>
using namespace std;

int main(){
    freopen("Ulaz.txt","w",stdout);

    int n = rand()%2000;
    int m = rand()%1000;

    cout<<n<<" "<<m<<endl;
    for( int i = 0; i < n; ++i )
        printf("%d ",rand()%2);

    for( int i = 0; i < m; ++i ){
        int lo = rand()%n;
        int hi;
        while( 1 ){
            hi = rand()%n;
            if( hi >= lo ) break;
        }
        printf("%d %d\n",lo,hi);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <iomanip>
using namespace std;

const int maxsq = 1000000 + 555;

typedef long long ll;

ll n,m;

int p[maxsq],sz;
bool notprime[maxsq];

void readll( ll &v ){
    static char c;
    while( (c=getchar())<'0' || c > '9' );
    v = c - '0';
    while( (c=getchar())>='0' && c <= '9' )
        v = v * 10 + c - '0';
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    for( int i = 2; i < maxsq; ++i ){
        if( notprime[i] ) continue;
        p[sz++] = i;
        for( int j = i; j < maxsq; j += i )
            notprime[j] = 1;
    }

    int tests; scanf("%d",&tests);
    for(; tests; --tests ){
        readll(n); readll(m);

        ll sol = 1LL << 62;

        for( int i = 0; p[i]*p[i] <= m || m > 1; ++i ){
            ll div = p[i];
            if( div*div > m ) div = m;
            ll cnt = 0, has = 0;

            while( m % div == 0 ) cnt ++, m /= div;
            if( cnt == 0 ) continue;

            ll tmp = n, j = div;
            while( tmp >= div ){
                has += n / j;
                tmp /= div, j *= div;
            }

            ll c = has / cnt;
            if( c < sol ) sol = c;
            if( m == 1 ) break;
        }

        cout << sol << endl;

    }
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
using namespace std;

typedef long long ll;

const int maxn = 2000000 + 55;
const int maxe = 5000000;

int n,m;


int cnte = 1;
int point[maxe], head[maxn], nxt[maxe];
vector< int > nodes[maxn];

inline void add_edge( int a, int b ){
    point[cnte] = b, nxt[cnte] = head[a], head[a] = cnte ++;
}

int sz[maxn], lvl[maxn];
int anc[maxn];

int lb[maxn],rb[maxn];
int bcnt = 0;

void sz_dfs( int node, int dad, int L = 0 ){

    sz[node] = 1;
    lvl[node] = L;
    anc[node] = dad;

    lb[node] = ++bcnt;

    for( int i = head[node]; i >= 1; i = nxt[i] ){
        int w = point[i];
        if( w == dad ) continue;
        sz_dfs( w , node, L + 1 );
        sz[node] += sz[ w ];
    }

    rb[node] = bcnt;
}

int color_cnt = 0;
int map_color[maxn];
int master[maxn];

void hld( int node, int dad, int color ){
    map_color[node] = color;

    int f = -1, curr = -1;
    for( int i = head[node]; i >= 1; i = nxt[i] )
        if( point[i] != dad && sz[ point[i] ] > curr ) curr = sz[ point[i] ], f = point[i];

    if( f != -1 )hld( f , node, color );

    for( int i = head[node]; i >= 1; i = nxt[i] ){
        if( point[i] == f || point[i] == dad ) continue;
        color_cnt ++;

        master[color_cnt] = point[i];
        hld( point[i], node, color_cnt ++ );
    }
}

int LCA( int A, int B ){
    while( map_color[A] != map_color[B] ){
        int c1 = map_color[A];
        int c2 = map_color[B];
        int nxt_lvl_a = lvl[ master[c1] ], nxt_lvl_b = lvl[ master[c2] ];
        if( nxt_lvl_a > nxt_lvl_b ) A = anc[ master[c1] ];
        else B = anc[ master[c2] ];
    }

    if( lvl[A] < lvl[B] ) return A;
    return B;
}

int bit[maxn];

int read( int x ){
    int ret = 0;
    for( x += 5; x >= 1; x -= x & -x )
        ret += bit[x];
    return ret;
}

void _update( int x, int v ){
    for( x += 5; x < maxn; x += x & -x )
        bit[x] += v;
}

void update( int a, int b, int v ){
    _update( a , v );
    _update( b + 1 , -v );
}

int main(){
   // freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    for( int i = 0; i < n-1; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        add_edge( a,b );
        add_edge( b,a );
    }

    sz_dfs( 1 , -1 );
    master[1] = 1;
    hld( 1, -1, ++ color_cnt );

    for( int i = 1; i <= n; ++i ){
        for( int e = head[i]; e >= 1; e = nxt[e] ){
            int w = point[e];
            if( w != anc[i] ) nodes[i].push_back( w );
        }
    }

    scanf("%d",&m);
    int overall = 0;

    for( int i = 0; i < m; ++i ){
        char c; while( c = getchar() ) if( c == 'Q' || c == 'M' || c == 'D' ) break;
        int a,b,lca;
        if( c != 'Q' ){
            scanf("%d%d",&a,&b);
            if( lvl[a] > lvl[b] ) swap(a,b);

            lca = LCA(a,b);
            int mode = 1;
            if( c == 'D' ) mode = -1;

            if( lca != a && lca != b )
                update( lb[a], rb[a] , mode ), update( lb[b], rb[b] , mode );
            else{
                overall += mode;

                int lo = 0, hi = nodes[a].size() - 1;
                int w = -1;
                while( lo <= hi ){
                    int mid = (lo+hi)>>1;
                    int x = nodes[a][mid];
                    if( rb[x] >= lb[b] ) w = x, hi = mid - 1;
                    else lo = mid + 1;
                }

                assert( w != -1 );

                update( lb[w], rb[w] , -mode );
                update( lb[b], rb[b] , mode );

            }
        }else{
            scanf("%d",&a);
            printf("%d\n", overall + read( lb[a] ) );
        }

//        printf("STATUS: ");
//        for( int k = 1; k <= n; ++k ) printf("%d ",query( k , k ) );
//        printf("\n");
    }

    return 0;
}

#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <math.h>
#include <iostream>
using namespace std;

typedef long long ll;

int d[] = {2,3,5,7};

int main(){
    int tests;
    scanf("%d",&tests);

    for( ; tests; --tests ){
        ll n; cin >> n;

        ll ct = 4, s = 0, cnt = 0;
        while( s < n ){
            cnt++;
            s += ct;
            ct *= 4;
        }

        vector< int > x;
        for( int i = 0; i < cnt; ++i ){
            n--;
            x.push_back( n % 4 ) , n /= 4;
        }

        for( int i = x.size()-1; i >= 0; --i )
            printf("%d",d[ x[i] ]); printf("\n");
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#include <math.h>
#include <string.h>
#include <string>
#include <vector>
#include <set>
#include <queue>
#include <stack>
using namespace std;

/*
 1     1     1
--- + --- = ---
 x     y     n!

 y*n! + x*n! = x*y
 y*n! - x*y =  -x*n!
 y*(x-n!) = x*n!
 y = x*n! / (x-n!)
 y = n! + n!^2 / (x-a)

*/

const int maxn = 10000 + 55;

int n;
int cnt[maxn];

int slen;
int sol[maxn];

void mul( int m ){
    int mem = 0;
    for( int i = 0; i < slen; ++i ){
        int x = mem + sol[i] * m;
        sol[i] = x % 10;
        mem = x / 10;
    }
    while( mem ) sol[slen++] = mem % 10, mem /= 10;
}

int main(){
    while( scanf("%d",&n) == 1 ){
        if( n == 0 ) break;

        for( int i = 2; i <= n; ++i ) cnt[i] = 2;

        for( int i = n; i >= 2; --i ){
            for( int j = 2; j*j <= i; ++j ){
                if( i % j == 0 ){
                    int add = cnt[i];
                    cnt[i] = 0;
                    cnt[j] += add;
                    cnt[i/j] += add;
                }
            }
        }

        slen = 1;
        sol[0] = 1;
        for( int i = 2; i <= n; ++i )
            mul( cnt[i]+1 );

        for( int i = slen-1; i >= 0; --i )
            printf("%d",sol[i]);
        printf("\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <math.h>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 1000000 + 55;
const int maxv = 10000 + 55;

int n,m;
int v[maxn];
int seq[5],sz;

vector< int > pos[maxv];

inline int find( int x, int low ){
   vector<int>::iterator it = upper_bound( pos[x].begin(), pos[x].end(), low );
   if( it == pos[x].end() ) return -1;
   return *it;
}

bool cmm( int chk, int m ){
    vector< int > a,b;
    for( int i = 0; i < sz; ++i ){
        if( chk&(1<<i) ) a.push_back( seq[i] );
        if( m&(1<<i) ) b.push_back( seq[i] );
    }

    int len = a.size();
    for( int i = 0; i < len; ++i ){
        if( a[i] < b[i] ) return 1;
        else if( a[i] > b[i] ) return 0;
    }
    return 0;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        scanf("%d",v+i);
        pos[ v[i] ].push_back(i);
    }

    scanf("%d",&m);
    while( m -- ){
        scanf("%d",&sz);
        for( int i = 0; i < sz; ++i ) scanf("%d",seq+i);

        int mx(0),mm(0);

        for( int m = 0; m < (1<<sz); ++m ){
            int curr = -1, ok = 1;
            int len = 0;


            for( int i = 0; i < sz && ok; ++i ){
                if( ~m&(1<<i) ) continue;
                curr = find( seq[i], curr );
                len ++;
                if( curr == -1 ) ok = 0;
            }

            if( ok &&( mx < len || mx == len && cmm(m,mm)) )mm = m, mx = len;
        }

        printf("%d ",mx);
        for( int i = 0; i < sz; ++i )
            if( mm&(1<<i) ) printf("%d ",seq[i]);
        printf("\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <map>
#include <iomanip>
#include <math.h>
#include <set>
#include <queue>
#include <cstdio>
#include <cstdlib>
using namespace std;

#define pii pair<ll,ll>
#define x first
#define y second
#define mk make_pair

typedef long long ll;

const int maxn = 500000 + 55;
const int inf = 2000000000;

int n;
int h[maxn];

pii p[2][maxn],hull[2][maxn];
int sz[2];

inline ll ccw( pii a, pii b, pii c ){ return (a.x-c.x)*(b.y-c.y) - (b.x-c.x)*(a.y-c.y); }

void prepare_hull( pii tp[maxn], pii thull[maxn], int &sz ){
    sort( tp, tp + n );
    for( int i = 0; i < n; ++i ){
        while( sz >= 2 && ccw( thull[sz-1], tp[i], thull[sz-2] ) <= 0 ) sz --;
        thull[sz++] = tp[i];
    }
}


int mode;
int mxh;
inline ll get( ll x, int i ){ return hull[mode][i].x*x + hull[mode][i].y; }

ll mx( int v, int sw=0 ){
    mode = sw;

    int lo = 0 , hi = sz[sw] - 1;
    while( lo < hi ){
        int mid = (lo+hi) >> 1;
        ll tmp1 = get(v,mid), tmp2 = get(v,mid+1);
        if( tmp1 < tmp2 ) hi = mid;
        else lo = mid+1;
    }
    return get(v,hi);
}

int log22n1( int dx ){
    int lo = mxh, hi = mxh + 2*n;

    int maybe = -1;
    while( lo <= hi ){
        ll xt  = (lo+hi)>>1;
        ll sum1 = mx( xt ) + xt*xt;
        if( sum1 >= dx ) maybe = xt, hi = xt - 1;
        else lo = xt + 1;
    }
    return maybe;
}
int log22n2( int dx ){
    int lo = mxh, hi = mxh + 3*n;

    int maybe = -1;
    while( lo <= hi ){
        ll xt  = (lo+hi)>>1;
        ll sum2 = mx( xt,1 ) + xt*xt;
        if( sum2 >= -dx   ) maybe = xt, hi = xt - 1;
        else lo = xt + 1;
    }
    return maybe;
}

int sol[maxn];

int main(){
   // double s = clock();
  //  freopen("Ulaz.txt","r",stdin);
  //  freopen("Izlaz.txt","w",stdout);

    scanf("%d",&n);
    mxh = 0;
    char c;
    for( int i = 0; i < n; ++i ){
        h[i] = 0;
        while( (c = getchar())<'0' || c > '9' );
        h[i] = c-'0';
        while( (c = getchar())>='0' && c <= '9' ) h[i] = h[i]  * 10 + c - '0';
        mxh = max( mxh, h[i] );
        p[0][i] = pii( -2 * h[i] , h[i]*(ll)h[i] + i);
        p[1][i] = pii( -2 * h[i] , h[i]*(ll)h[i] - i);
    }

    prepare_hull( p[0], hull[0], sz[0] );
    prepare_hull( p[1], hull[1], sz[1] );

    ll curr = log22n1(0);
    ll nw = mx(curr) + curr*curr;
    sol[0] = curr;

    for( int i = 1; i < n; ++i ){
        ll xt  = curr;
        ll sum1 = mx( xt ) + xt*xt;
        if( nw < i ){
            curr ++;
            nw = mx(curr) + curr*curr;
        }
        sol[i] = curr;
    }

    curr = log22n2(0);
    if( sol[0] < curr ) sol[0] = curr;
    nw = mx( curr-1, 1 ) + (curr-1)*(curr-1);

    for( int i = 1; i < n; ++i ){
        if( nw >= -i ){
            curr --;
            nw = mx( curr-1, 1 ) + (curr-1)*(curr-1);
        }
        if( sol[i] < curr ) sol[i] = curr;
    }


    for( int i = 0; i < n; ++i )
        printf("%d\n",sol[i]-h[i]);

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <string.h>
using namespace std;


const int maxn = 270000 + 55;
const double pi = acos(0) * 2;
const double eps = 1e-8;

struct complx{
    double re,im;
    complx(){};
    complx( double p1, double p2 ):re(p1),im(p2){}

    inline complx operator*( const complx &c2 ){
        return complx( re * c2.re - im * c2.im, re * c2.im + im * c2.re );
    }
};

int len;
char txt[maxn];

int sz = 1;
complx a1[maxn];

complx mem[maxn];
double cosx[maxn],sinx[maxn];

complx yf[maxn],ys[maxn];

int q[maxn][2]; int szz(0);
int order[maxn*20][2]; int sg(0);

complx *A,*Y;
void fft( int l, int r ){

    szz = sg = 0;
    q[szz][0] = l, q[szz++][1] = r;

    while( szz ){
        int lo = q[szz-1][0], hi = q[szz-1][1];  szz--;
        int mid = (lo+hi)>>1;
        int n = hi-lo + 1;

        if( lo == hi ){
            Y[lo] = A[lo];
            continue;
        }
        order[sg][0] = lo, order[sg++][1] = hi;

        for( int i = lo; i <= hi; ++i ) mem[i] = A[i];
        for( int i = lo, x = 0; i <= hi; i += 2, ++x ){
            A[lo+x] = mem[i];
            A[mid+x+1]= mem[i+1];
        }

        q[szz][0] = lo, q[szz++][1] = mid;
        q[szz][0] = mid+1, q[szz++][1] = hi;
    }

    for( int k = sg-1; k >= 0; --k ){
        int lo = order[k][0], hi = order[k][1];
        int mid = (lo+hi)>>1;
        int n = hi - lo + 1;

        for( int i = lo; i <= hi; ++i ) mem[i] = Y[i];

        double re = 1, im = 0, tmp;

        for( int i = lo; i <= mid; ++i ){
            int x = i - lo + mid + 1;
            Y[i] = Y[x] = mem[i];

            Y[i].re += re * mem[x].re - im * mem[x].im;
            Y[i].im += re * mem[x].im + im * mem[x].re;

            Y[x].re += im * mem[x].im - re * mem[x].re;
            Y[x].im -= re * mem[x].im + im * mem[x].re;

            tmp = re;
            re = tmp * cosx[n] - im * sinx[n];
            im = tmp * sinx[n] + im * cosx[n];
        }
    }
}

void ifft( int lo, int hi ){
    for( int i = lo; i <= hi; ++i ) A[i].im = - A[i].im;
    fft( lo, hi );
    for( int i = lo; i <= hi; ++i ) Y[i].re /= hi-lo+1;
}

int s[maxn];
complx sc[maxn];

int main(){
   // freopen("Ulaz.txt","r",stdin);
  //  freopen("Izlaz.txt","w",stdout);
    //double S = clock();
    for( int i = 1; i < maxn; ++i ) cosx[i] = cos(2.*pi/i), sinx[i] =  sin(2.*pi/i);

   //
  //  for( int i = 0; i < 100000; ++i ) txt[i] = 'a';
   // txt[100000] = '\0';

    scanf("%s",txt);
    len = strlen(txt);

    while( sz <= (len*2) ) sz <<= 1;
  //  sz *= 2;
    for( char c = 'a'; c <= 'c'; ++ c ){
        memset( a1,0,sizeof(a1));
        for( int i = 0; i < len; ++i )
            if( txt[i] == c ) a1[i] = complx(1,0);

        A = a1, Y = yf;
        fft( 0, sz - 1 );

        memset( a1,0,sizeof(a1));
        for( int i = 0; i < len; ++i )
            if( txt[i] == c ) a1[len-i-1] = complx(1,0);

        Y = ys;
        fft( 0, sz - 1 );

        for( int i = 0; i < sz; ++i ) Y[i] = yf[i] * ys[i];

        for( int i = 0; i < sz; ++i ){
            sc[i].re += Y[i].re;
            sc[i].im += Y[i].im;
        }
    }

    Y = yf;
    A = sc;
    ifft( 0, sz - 1 );

    for( int i = 0; i < sz; ++i )
        s[i] = (int)round(Y[i].re);


    int mx = -1;
    for( int i = len; i < sz; ++i )
        if( mx < s[i] ) mx = s[i];

    printf("%d\n",mx);
    for( int i = len; i < (len<<1); ++i )
        if( s[i] == mx ) printf("%d ",i-len+1);
    printf("\n");


   // printf("%.10lf\n",(clock()-S)/CLOCKS_PER_SEC);
    return 0;
}

#include <iostream>
#include <vector>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
using namespace std;

const int maxn = 10005;

int len;
char txt[maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    scanf("%s",txt);
    len = strlen(txt);

    int mx = -1;

    for( int i = 1; i <= len; ++i ){
        int cnt = 0;
        for( int j = 0; j < len; ++j ){
            if( i + j >= len ) break;
            if( txt[j] == txt[i+j] ) cnt ++;
        }
        if( cnt > mx ) mx = cnt;
    }

    printf("%d\n",mx);

    for( int i = 1; i <= len; ++i ){
        int cnt = 0;
        for( int j = 0; j < len; ++j ){
            if( i + j >= len ) break;
            if( txt[j] == txt[i+j] ) cnt ++;
        }
        if( cnt == mx ) printf("%d ",i);
    }printf("\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
using namespace std;

int main(){
    srand((unsigned)time(0));
    freopen("Ulaz.txt","w",stdout);

    int n = 2 + rand()%1000;;

    for( int i = 0; i <n; ++i ){
        int c = rand()%3;
        printf("%c",'a'+c);
    }printf("\n");

    return 0;
}

#include <iostream>
#include <cstdlib>
#include <fstream>
#include <cstdio>
#include <algorithm>
using namespace std;

int main(){
    int tests = 1000;
    for( int t = 1; t <= tests; ++t ){
        printf("Case #%d: ",t);

        system("./SPOJ_MAXMATCH_MK");
        system("./SPOJ_MAXMATCH_BRUTE");
        system("./SPOJ_MAXMATCH");

        if( system("diff -qb Izlaz.txt Izlaz2.txt") ){
            printf("WA\n");
            while(1);
        }else printf("AC\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdio>
#include <cstdlib>
using namespace std;

int n;
int digit[55];

int main(){
    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        int c; scanf("%d",&c);
        digit[c] ++;
    }

    for( int i = 0; i <= 9; ++i ){
        printf("%d ",i);
        for( int j = 0; j < digit[i]; ++j )
            printf("*");
        printf("\n");
    }

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;

typedef long long ll;

const int maxx = 50000 + 55;

int n;
ll pops[maxx];

int main(){
    scanf("%d",&n);

    ll l = 0, r = 0;
    ll curr = 0;

    for( int i = 0; i < n; ++i ){
        int a,b; scanf("%d%d",&a,&b);
        pops[a] += b;
        r += b;
        curr += a * (ll)b;
    }

    ll sol = 0, mem = curr;
    for( int i = 1; i < maxx; ++i ){
        curr -= r;
        curr += l;

        if( mem > curr ){
            mem = curr;
            sol = i;
        }

        l += pops[i];
        r -= pops[i];
    }

    cout << sol << endl;





    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <iomanip>
#include <assert.h>
#include <cstdio>
#include <cstdlib>
#include <bitset>
#include <math.h>
using namespace std;

#define mk make_pair
#define pb push_back
#define f first
#define s second
#define pii pair<int,int>
#define all(x) x.begin(),x.end()

const int maxn = 500000 + 555;

int n;

int cnte = 1;
int point[maxn],nxt[maxn],head[maxn];

void add_edge( int a, int b ){
    nxt[cnte] = head[a], head[a] = cnte, point[cnte] = b;
    cnte++;
}

int dp[maxn][2];
int give[maxn];

int solve( int node, int dad, int state ){ // 0 hasn't cookie, 1 has

    int &sol = dp[node][state];
    if( sol != -1 ) return sol;

    int no_cookies = 0;
    for( int i = head[node]; i >= 1; i = nxt[i] ){
        if( dad == point[i] ) continue;
        no_cookies += solve( point[i], node, 0 );
    }

    sol = state + no_cookies;

    if( state == 0 ){
        for( int i = head[node]; i >= 1; i = nxt[i] ){
            if( dad == point[i] ) continue;
            int x = solve( point[i], node, 1 ) - solve( point[i], node, 0 ) + no_cookies;
            if( sol < x ) give[node] = point[i];
            sol = max( sol, x );
        }
    }
    return sol;
}

vector< int > mem;

void rec( int node, int dad, int state ){

    for( int i = head[node]; i >= 1; i = nxt[i] ){
        if( dad == point[i] || point[i] == give[node] ) continue;
        rec( point[i], node, 0 );
    }

    if( state )
        mem.push_back( node );
    else if( give[node] != -1 )
        rec( give[node], node, 1 );
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);
    for( int i = 1; i < n; ++i ){
        int a; scanf("%d",&a); a--;
        add_edge( a , i );
    }

    memset( dp, -1, sizeof(dp));
    memset( give, -1, sizeof(give));
    int sol = solve( 0, -1, 0 );
    printf("%d\n",sol*1000);

    rec( 0, -1, 0 );

    sort( mem.begin(), mem.end() );
    for( int i = 0; i < mem.size(); ++i )
        printf("%d ",mem[i]+1);
    printf("\n");

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
using namespace std;

#define f first
#define s second
#define mk make_pair

const double eps = 1e-9;

int days,n,m;

int cost[105],val[105];

pair<double,int> dp[22][55][5][105];
int nxt[22][55][5][105];

pair<double,int> solve( int day, int prv, int cnt, int money ){
    if( day == days ) return mk(0,money);

    pair<double,int> &ret = dp[day][prv][cnt][money];
    if( ret.f > -2e9 ) return ret;
    int &ret_nxt = nxt[day][prv][cnt][money];
    ret.f = -1e9;

    for( int i = 0; i < n; ++i ){
        if( money < cost[i] ) continue;

        int nxt_cnt = 1;
        if( prv == i ) nxt_cnt = min(cnt + 1,3);

        double add = val[i];
        if( nxt_cnt == 2 ) add /= 2;
        else if( nxt_cnt == 3 ) add = 0;

        pair<double,int> calc = solve( day + 1, i, nxt_cnt, money - cost[i] );
        calc.f += add;
        if( ret.f+eps < calc.f || fabs(calc.f-ret.f) < eps && calc.s > ret.s ) ret = calc, ret_nxt = i;
    }

    return ret;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    while( scanf("%d%d%d",&days,&n,&m) == 3 ){
        if( days == 0 ) break;

        for( int i = 0; i < n; ++i )
            scanf("%d%d",cost+i,val+i);

        for( int i = 0; i <= days; ++i )
            for( int j = 0; j <= n; ++j )
                for( int k = 0; k < 5; ++k )
                    for( int l = 0; l <= m; ++l )
                        dp[i][j][k][l] = mk(-3e9,-1);

        pair<double,int> sol = solve( 0, 0, 0, m );
        if( sol.f < -1e7 ){
            printf("0.0\n");
            continue;
        }

        printf("%.1lf\n",sol.f);

        int b = 0, c = 0, d = m;
        for( int a = 0; a < days; ++a ){
            int curr = nxt[a][b][c][d];
            printf("%d ",curr+1);

            int nxt = 1;
            if( curr == b ) nxt = min(3,c+1);
            c = nxt;
            d -= cost[curr];
            b = curr;
        }printf("\n");

    }

    return 0;
}

#include <iostream>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <math.h>
#include <iomanip>
#include <map>
#include <set>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxm = 200000 + 500;

int n,m;

vector< int > g[maxm];
bool visi[maxm];
bool ok;
bool cycle = 0;
int cnt = 0;

void dfs( int node, int dad ){
    if( visi[node] ){ cycle = 1; return; }
    visi[node] = 1;
    cnt ++;

    for( int i = 0; i < g[node].size(); ++i ){
        int nxt = g[node][i];
        if( nxt == dad ) continue;
        dfs( nxt, node );
    }
}

int main(){

    while( scanf("%d%d",&n,&m) == 2 ){
        if( n == 0 && m == 0 ) break;

        vector< int > low;
        vector< pii > edges;

        for( int i = 0; i < m; ++i ){
            int a,b; scanf("%d%d",&a,&b);
            low.push_back(a);
            low.push_back(b);
            edges.push_back( mk(min(a,b),max(a,b)) );
        }
        sort( edges.begin(), edges.end() );
        sort( low.begin(), low.end() );
        low.erase( unique(low.begin(),low.end()),low.end() );

        for( int i = 0; i < m; ++i ){
            if( i && edges[i-1] == edges[i] ) continue;
            int a = edges[i].f, b = edges[i].s;
            a = lower_bound( low.begin(), low.end(), a ) - low.begin();
            b = lower_bound( low.begin(), low.end(), b ) - low.begin();
            g[a].push_back(b);
            g[b].push_back(a);
        }

        ok = 1;
        int sz = low.size();
        for( int i = 0; i < sz; ++i ){
            if( g[i].size() >= 3 ) ok = 0;
            if( visi[i] ) continue;
            cycle = 0, cnt = 0;
            dfs( i , -1 );
            if( cycle && cnt != n ) ok = 0;
        }

        for( int i = 0; i < sz; ++i )
            g[i].clear(), visi[i] = false;

        if( !ok ) printf("N\n");
        else printf("Y\n");
    }


    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <math.h>
#include <string>
#include <string.h>
#include <stack>
#include <set>
#include <queue>
#include <map>
using namespace std;

const int maxn = 100000;

char txt[maxn];

int main(){
     freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    scanf("%s",txt);

    int m; scanf("%d",&m);
    for( int i = 0; i < m; ++i ){
        int a,b; scanf("%d%d",&a,&b); a--,b--;
        stack< char > s;
        for( int j = a; j <= b; ++j ) s.push( txt[j] );

        for( int j = a; j <= b; ++j ){
            txt[j] = s.top();
            s.pop();
        }
    }

    printf("%s\n",txt);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <math.h>
#include <string>
#include <string.h>
#include <stack>
#include <set>
#include <queue>
#include <map>
using namespace std;

int main(){
    srand((unsigned)time(0));
    freopen("Ulaz.txt","w",stdout);
    int len = 50;
    for( int i = 0; i < len; ++i )
        printf("%c",'a'+rand()%24);

    int m = 20;
    cout<<endl;
    cout<<m<<endl;

    for( int i = 0; i < m; ++i ){
        int lo = 1 + rand()%len;
        int hi;
        while(1){
            hi = 1 + rand()%len;
            if( hi >= lo ) break;
        }
        cout<<lo<<" "<<hi<<endl;
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <math.h>
#include <string>
#include <string.h>
#include <stack>
#include <set>
#include <queue>
#include <map>
using namespace std;

#define pii pair<int,int>
#define f first
#define s second
#define mk segment

const int maxn = 2500000+55;
const int maxsz = 200000;

bool debug = 0;

int n,m;
char txt[maxn];

struct segment{
    int f,s,cnt,pos;
    segment(){};
    segment( int p1, int p2 ):f(p1),s(p2),pos(p1){ cnt = 0; };
    segment( int p1, int p2, int p3, int p4 ):f(p1),s(p2),cnt(p3),pos(p4){};
    const bool operator<( const segment &s2 ) const { return f < s2.f; }
    const bool operator==( const segment &s2 ) const { return f == s2.f && s == s2.s; }
};

vector< pii > q;

int sz;
segment dx[maxsz];

void correct( int d, int x ){
    segment tmp = dx[d];
    vector< segment > put;

    int p = tmp.pos;
    if( tmp.cnt ) p += tmp.s - tmp.f;

    if( tmp.cnt ){

        if( tmp.f != x ){
            p = p -( (x-1) - tmp.f + 1 );
            put.push_back( segment(tmp.f,x-1,tmp.cnt,p + 1) );
        }
        put.push_back( segment(x,x,tmp.cnt,p) );

        if( tmp.s != x ){
            p = p + -( tmp.s - x + 1 );
            put.push_back( segment(x+1,tmp.s,tmp.cnt,p + 1) );
        }
    }else{
        if( tmp.f != x ){
            put.push_back( segment(tmp.f,x-1,tmp.cnt,p) );
            p = p + ( (x-1) - tmp.f + 1 );
        }
        put.push_back( segment(x,x,tmp.cnt,p) );
        p ++;

        if( tmp.s != x ){
            put.push_back( segment(x+1,tmp.s,tmp.cnt,p) );
            p = p + ( tmp.s - x + 1 );
        }
    }

    int del = put.size()-1;
    for( int i = sz+del-1; i-del > d; --i ) dx[i] = dx[i-del];
    sz += del;
    for( int i = 0; i < put.size(); ++i ) dx[i+d] = put[i];
}

void revers( int lo, int hi ){
    int x = upper_bound( dx, dx + sz, mk(lo,lo) ) - dx; x--;
    if( dx[x].f != lo || dx[x].s != lo ) correct ( x , lo );

    int y = upper_bound( dx, dx + sz, mk(hi,hi) ) - dx; y--;
    if( dx[y].f != hi || dx[y].s != hi ) correct ( y , hi );

    x = upper_bound( dx, dx + sz, mk(lo,lo) ) - dx; x--;
    y = upper_bound( dx, dx + sz, mk(hi,hi) ) - dx; y--;

    int pos = dx[x].f;
    reverse( dx+x, dx+y+1 );
    for( int i = x; i <= y; ++i ){
        dx[i].cnt = !dx[i].cnt;
        int len = dx[i].s-dx[i].f;
        dx[i].f = pos, dx[i].s = pos + len;
        pos = pos + len + 1;
    }
}

int main(){
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);

    scanf("%s",txt);

    n = strlen(txt);
    scanf("%d",&m);

    vector< int > x;
    for( int i = 0; i < m; ++i ){
        int a,b; scanf("%d%d",&a,&b); a--,b--;
        q.push_back( make_pair(a,b) );
    }
    dx[sz++] = mk(0,0);
    dx[sz++] = mk(n-1,n-1);
    if( n >= 3 )dx[sz++] = mk(1,n-2);

    sort( dx, dx + sz );

    for( int i = 0; i < m; ++i )
        revers( q[i].f, q[i].s );

    for( int i = 0; i < sz; ++i ){
        int p = dx[i].pos;
        if( dx[i].cnt ) p += dx[i].s - dx[i].f;
        int add = dx[i].cnt==0?1:-1;

        for( int j = dx[i].f; j <= dx[i].s; ++j ){
            printf("%c",txt[p]);
            p += add;
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <string>
#include <iomanip>
#include <cstdio>
#include <cstdlib>
using namespace std;

int main(){
    int n; scanf("%d",&n);
    int sol = 0;
    for( int i = 0; i < n; ++i ){
        int x; scanf("%d",&x);
        sol ^= x;
    }
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

typedef long long ll;

const int maxn = 2197152;

char cm[100];

int n;
int begin = 1048576;
ll sum[maxn];
int l,r;
ll add1,add2;

ll bellow[maxn];
int cnt[maxn];

ll nsum( ll a, ll b ){
    b = (b*(b+1)) >> 1;
    b -= ((a-1)*a) >> 1;
    return b;
}

void _update( int node, int lo, int hi ){
    if( lo >= l && hi <= r ){
        sum[node] += (hi-lo+1) * add1;
        cnt[node] += add2;
        return;
    }
    if( hi < l || lo > r || node >= begin ) return;

    int mid = (lo+hi)>>1;
    int L = node * 2, R = node*2+1;

    ll nw = sum[node] - (sum[L] + sum[R]);

    sum[L] = sum[L] + (nw>>1);
    sum[R] = sum[R] + (nw>>1);

    cnt[L] += cnt[node];
    cnt[R] += cnt[node];
    cnt[node] = 0;

    _update( L, lo, mid );
    _update( R, mid+1, hi );

    sum[node] = sum[L] + sum[R];
    bellow[node] = bellow[L] + bellow[R];
    bellow[node] += cnt[L] * nsum(lo-begin,mid-begin);
    bellow[node] += cnt[R] * nsum(mid+1-begin,hi-begin);
}

ll _query( int node, int lo, int hi ){
    if( lo >= l && hi <= r ) return sum[node] + bellow[node] + cnt[node] * nsum(lo-begin,hi-begin);
    if( hi < l || lo > r || node >= begin ) return 0;

    int mid = (lo+hi)>>1;
    int L = node * 2, R = node*2+1;

    ll nw = sum[node] - (sum[L] + sum[R]);

    sum[L] = sum[L] + (nw>>1);
    sum[R] = sum[R] + (nw>>1);

    cnt[L] += cnt[node];
    cnt[R] += cnt[node];
    cnt[node] = 0;

    ll ret = _query( L, lo, mid ) + _query( R, mid+1, hi );

    sum[node] = sum[L] + sum[R];
    bellow[node] = bellow[L] + bellow[R];
    bellow[node] += cnt[L] * nsum(lo-begin,mid-begin);
    bellow[node] += cnt[R] * nsum(mid+1-begin,hi-begin);

    return ret;
}


void update( int lo, int hi, int x, int y = 0 ){
    l = lo + begin, r = hi + begin;
    if( l > r ) return;
    add1 = x;
    add2 = y;
    _update( 1, begin, begin*2-1 );
}

ll query( int lo, int hi ){
    l = lo + begin, r = hi + begin;
    return _query( 1, begin, begin*2-1 );
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    int tests; scanf("%d",&tests);
    while( tests -- ){
        for( int i = 0; i < maxn; ++i )
            bellow[i] = cnt[i] = sum[i] = 0;

        scanf("%d",&n);
        for( int i = 0; i < n; ++i ){
            int c,w; scanf("%s%d%d",cm,&c,&w);

            if( cm[0] == 'b' ){
                int h = (w+1) >> 1;
                update( c-h+1, c-1, h-c, 1 );
                update( c, c+h-1, h+c, -1 );
            }else{
                printf("%lld\n",query(c,w) );
            }
        }
        printf("\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

typedef long long ll;

const int maxn = 10000000;

char cm[maxn];

int sz;
ll arr[maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    scanf("%d",&sz);

    for( int i = 0; i < sz; ++i ){
        int c,w;
        scanf("%s%d%d",cm,&c,&w);

        if( cm[0] == 'b' ){
            int h = (w+1) >> 1;
            w >>= 1;
            arr[c] += h;
            for( int j = 1; j <= w; ++j )
                arr[c-j] += h-j, arr[c+j] += h-j;
        }else{
            int sol = 0;
            for( int j = c; j <= w; ++j )
                sol += arr[j];
            cout<<sol<<endl;
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

int n = 10000;

int main(){
    srand((unsigned)time(0));
    freopen("Ulaz.txt","w",stdout);

    cout<<n<<endl;

    for( int i = 0; i < n; ++i ){
        bool b = rand()%2;
        if( b == 0 ){
            int c = rand()%1000;
            int w = rand()%300;

            while( c - w < 0 ){
                 c = rand()%1000;
                 w = rand()%300;
            }

            printf("build %d %d\n",c,w);
        }else{
            int a = rand()%1000;
            int b;
            while(1){
                b = rand()%10000;
                if( b >= a ) break;
            }
            printf("count %d %d\n",a,b);
        }
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <iomanip>
#include <string>
#include <string.h>
using namespace std;

typedef long long ll;

const int maxn = 2197152;

char cm[100];

int n;
int begin = 1048576;
ll sum[maxn];
int l,r;
ll add1,add2;

ll bellow[maxn];
int cnt[maxn];

ll nsum( ll a, ll b ){
    b = (b*(b+1)) >> 1;
    b -= ((a-1)*a) >> 1;
    return b;
}

void _update( int node, int lo, int hi ){
    if( lo >= l && hi <= r ){
        sum[node] += (hi-lo+1) * add1;
        cnt[node] += add2;
        return;
    }
    if( hi < l || lo > r || node >= begin ) return;

    int mid = (lo+hi)>>1;
    int L = node * 2, R = node*2+1;

    ll nw = sum[node] - (sum[L] + sum[R]);

    sum[L] = sum[L] + (nw>>1);
    sum[R] = sum[R] + (nw>>1);

    cnt[L] += cnt[node];
    cnt[R] += cnt[node];
    cnt[node] = 0;

    _update( L, lo, mid );
    _update( R, mid+1, hi );

    sum[node] = sum[L] + sum[R];
    bellow[node] = bellow[L] + bellow[R];
    bellow[node] += cnt[L] * nsum(lo-begin,mid-begin);
    bellow[node] += cnt[R] * nsum(mid+1-begin,hi-begin);
}

ll _query( int node, int lo, int hi ){
    if( lo >= l && hi <= r ) return sum[node] + bellow[node] + cnt[node] * nsum(lo-begin,hi-begin);
    if( hi < l || lo > r || node >= begin ) return 0;

    int mid = (lo+hi)>>1;
    int L = node * 2, R = node*2+1;

    ll nw = sum[node] - (sum[L] + sum[R]);

    sum[L] = sum[L] + (nw>>1);
    sum[R] = sum[R] + (nw>>1);

    cnt[L] += cnt[node];
    cnt[R] += cnt[node];
    cnt[node] = 0;

    ll ret = _query( L, lo, mid ) + _query( R, mid+1, hi );

    sum[node] = sum[L] + sum[R];
    bellow[node] = bellow[L] + bellow[R];
    bellow[node] += cnt[L] * nsum(lo-begin,mid-begin);
    bellow[node] += cnt[R] * nsum(mid+1-begin,hi-begin);

    return ret;
}


void update( int lo, int hi, int x, int y = 0 ){
    l = lo + begin, r = hi + begin;
    if( l > r ) return;
    add1 = x;
    add2 = y;
    _update( 1, begin, begin*2-1 );
}

ll query( int lo, int hi ){
    l = lo + begin, r = hi + begin;
    return _query( 1, begin, begin*2-1 );
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        int c,w; scanf("%s%d%d",cm,&c,&w);

        if( cm[0] == 'b' ){
            int h = (w+1) >> 1;
            update( c-h+1, c-1, h-c, 1 );
            update( c, c+h-1, h+c, -1 );
        }else{
            printf("%lld\n",query(c,w) );
        }
    }

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <set>
#include <queue>
#include <stack>
#include <map>
using namespace std;


int main(){
    int tests; scanf("%d",&tests);

    while( tests -- ){

        int n; cin >> n;

        double ret = 2/3. + (n / double(n+1)) - (1/2.);
        ret *= 2;
        ret -= (1.0/2.0) + (1.0/3.0);
        ret += (1.0/(n+1)) + (1.0/(n+2));

        printf("%.11lf\n",ret/2);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <set>
#include <queue>
#include <iomanip>
#include <string>
#include <string.h>
#include <stack>
using namespace std;

const int maxn = 100000 + 55;

int n;
int a[maxn];
int cnt[255];

bool dp[105][20005][2];
bool visi[105][20005][2];

int solve( int dx, int s, bool calc ){
    if( dx == 100 ) return s == 0 && calc;

    int v = s + 10000;
    bool &ret = dp[dx][v][calc];
    if( visi[dx][v][calc] ) return ret;
    visi[dx][v][calc] = 1;

    ret = solve( dx + 1, s, calc );
    if( cnt[dx] ){
        ret |= solve( dx + 1, s - dx, 1 );
        ret |= solve( dx + 1, s + dx, 1 );
    }
    return ret;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);

    int tests; scanf("%d",&tests);

    while( tests -- ){
        scanf("%d",&n);
        memset( cnt, 0, sizeof(cnt));

        bool yes = 0;

        for( int i = 0; i < n; ++i ){
            scanf("%d",&a[i]);
            cnt[a[i]] ++;
            yes |= cnt[a[i]] >= 2;
        }

        if( yes ){
            printf("YES\n");
            continue;
        }

        memset( visi, 0, sizeof(visi));
        if( solve(1,0,0) ) printf("YES\n");
        else printf("NO\n");
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <math.h>
#include <map>
#include <set>
#include <string>
#include <string.h>
#include <bitset>
using namespace std;

const int maxn = 1000+55;

int n,m;
bitset<maxn>c[maxn];

int main(){
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);

    for( int i = 0; i < m; ++i ){
        int a,b; scanf("%d%d",&a,&b); a--, b--;
        c[a][b] = 1;
    }

    long long sol = 0;
    for( int i = 0; i < n; ++i ){
        for( int j = i + 1; j < n; ++j ){
            int x = (c[i]&c[j]).count();
            sol += x*(x-1)>>1;
        }
    }
    cout<<sol<<endl;

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <math.h>
#include <map>
#include <set>
#include <string>
#include <string.h>
#include <bitset>
using namespace std;

int main(){
    freopen("Ulaz.txt","w",stdout);
    int n = 1000, m = 1000*1000;

    cout<<n<<" "<<m<<endl;

    for( int i = 1; i <= n; ++i )
        for( int j = 1; j <= n; ++j )
            cout<<i<<" "<<j<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <stack>
#include <cstdio>
#include <cstdlib>
using namespace std;

typedef long long ll;

const int maxn = 2000 + 55;
const int inf = 2000000005;

int n;
int v[maxn];
int s[maxn];

int dp[maxn][maxn][2];
int mx[maxn],mn[maxn];


int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    for( int i = 1; i <= n; ++i ){
        scanf("%d",&v[i]);
        s[i] = s[i-1] + v[i];
    }

    for( int i = 0; i < maxn; ++i )
        for( int j = 0; j < maxn; ++j )
            dp[i][j][0] = dp[i][j][1] = -inf;

    for( int i = n; i >= 1; --i ){
        for( int t = 1; t <= n; ++t ){
            if( i+t-1 > n ) break;

            ll x = dp[i+t][t][1];
            ll y = dp[i+t][t][0];
            if( i+t-1 == n ) x = 0,y = 0;

            mx[t] = s[i+t-1] - s[i-1] + x;
            mn[t] = y;
        }

        int curr = 1;
        int curr_max = -inf, curr_min = inf;

        for( int v = 1; v < n; ++v ){

            for( ; curr <= (v<<1); ++curr ){
                if( i+curr-1 > n ) break;
                curr_max = max( curr_max, mx[curr] );
                curr_min = min( curr_min, mn[curr] );
            }

            dp[i][v][0] = curr_max;
            dp[i][v][1] = curr_min;
        }
    }

    printf("%d\n",dp[1][1][0]);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 105;

int n;
char num[maxn];
char buff[maxn];
int seq[maxn];
char txt[50000+55][55];

string mob[]={
"oqz","ij","abc","def","gh","kl","mn","prs","tuv","wxy"
};

inline int id( char c ){
    for( int i = 0; i <= 9; ++i ){
        int sz = mob[i].size();
        for( int j = 0; j < sz; ++j )
            if( mob[i][j] == c ) return i;
    }
    return -1;
}

struct node{
    node *nxt[10];
    int flag;

    void init(){ for( int i = 0; i < 10; ++i ) nxt[i] = NULL; }
    node( int f = 0){ init(); flag = f; };
};

int ok[maxn];
int mem[maxn];

int main(){
   // freopen("Ulaz.txt","r",stdin);

    while( scanf("%s",num) == 1 ){
        if( num[0] == '-' ) break;

        memset( ok, 0, sizeof(ok));
        memset( mem, 0, sizeof(mem));
        node trie;

        scanf("%d",&n);
        for( int i = 0; i < n; ++i ){
            scanf("%s",txt[i]);
            node *curr = &trie;

            int len = strlen(txt[i]);
            for( int j = 0; j < len; ++j ){
                int x = id( txt[i][j] );
                if( curr->nxt[x] == NULL ) curr->nxt[x] = new node();
                curr = curr->nxt[x];
            }
            curr->flag = i+1;
        }

        ok[0] = 1;
        int len = strlen(num);
        for( int i = 0; i < len; ++i ){
            if( ok[i] == false ) continue;

            node *curr = &trie;
            for( int j = i; j < len; ++j ){
                int x = num[j] - '0';
                if( curr->nxt[x] == NULL ) break;
                curr = curr->nxt[x];
                if( curr->flag  ){
                    if( ok[j+1] == 0 || ok[j+1] > ok[i] )ok[j+1] = ok[i] + 1, mem[j+1] = curr->flag;
                }
            }
        }
        if( ok[len] == 0 ){
            printf("No solution.\n");
            continue;
        }

        //for( int i = 0; i <= len; ++i ) cout<<ok[i]<<" ";cout<<endl;
        //for( int i = 0; i <= len; ++i ) cout<<mem[i]<<" ";cout<<endl;

        int it = len;
        vector< int > sol;
        while( it > 0 ){
            sol.push_back( mem[it]-1 );
            it -= strlen( txt[mem[it]-1] );
           // cout<<it<<" | "<<mem[it]<<endl
        }

        for( int i = sol.size()-1; i >= 0; --i )
            printf("%s ",txt[ sol[i] ] );
        printf("\n");
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <math.h>
#include <map>
#include <iomanip>
#include <queue>
#include <string>
#include <string.h>
using namespace std;

int n,m;

int main(){
    scanf("%d%d",&n,&m);
    printf("%d %d\n",m-1,n-1);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 25;

int n;
string code[maxn][5];


int main(){
    //freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < 3; ++j )
            cin >> code[i][j];
    }

    string curr = "";
    bool ok = 1;
    vector< string > sol;

    for( int i = 0; i < n && ok; ++i ){
        int x; scanf("%d",&x); x--;
        sort( code[x], code[x] + 3 );

        ok = 0;
        for( int j = 0; j < 3 && !ok; ++j )
            if( curr < code[x][j] ) curr = code[x][j], ok = 1;
        sol.push_back(curr);
    }


    if( ok == false ){
        printf("IMPOSSIBLE\n");
        return 0;
    }

    for( int i = 0; i < sol.size(); ++i )
        cout<<sol[i]<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <string>
#include <string.h>
using namespace std;

#define pii pair<int,int>
#define r first
#define y second
#define mk make_pair

char gril[5][5];
char mat[5][5];
char tmp[5][5];

void rot(){
    for( int i = 0; i < 4; ++i ){
        for( int j = 0; j < 4; ++j ){
            tmp[j][3-i] = gril[i][j];
        }
    }
    memcpy(gril, tmp, sizeof tmp );
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
    vector< pii > w;
    for( int i = 0; i < 4; ++i )
        scanf("%s",gril[i]);

    for( int i = 0; i < 4; ++i )
        scanf("%s",mat[i]);

    for( int i = 0; i < 4; ++i ){
        for( int r = 0; r < 4; ++r )
            for( int c = 0; c < 4; ++c )
                if( gril[r][c] != '.' ) printf("%c",mat[r][c]);
        rot();
    }

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <string>
#include <string.h>
using namespace std;

const int maxn = 10005;
const int maxlen = 105;
const int prime = 1000000007;

int n;
char comm[maxn][maxlen];

int stp[maxn];
int sol[maxn], lensol[maxn];

int sz;
int h[maxn*100];
int cnt[maxn*100];
int mem[maxlen];

int main(){

    memset( sol, -1, sizeof(sol));
    stp[0] = 1;
    for( int i = 1; i < maxn; ++i ) stp[i] = stp[i-1] * prime;

    //freopen("Ulaz.txt","r",stdin);

    scanf("%d",&n);
    for( int i = 0; i < n; ++i )
        scanf("%s",comm[i]);

    for( int L = 1; L <= 100; ++L ){
        for( int j = 0; j <sz; ++j ) h[j] = cnt[j] = 0;
        sz = 0;

        for( int i = 0; i < n; ++i ){
            int len = strlen(comm[i]);
            if( len < L ) continue;

            int key = 0;
            for( int j = 0; j < L; ++j ) key = comm[i][j] + key * prime;

            h[sz++] = key;

            for( int j = L; j < len; ++j ){
                key -= comm[i][j-L] * stp[L-1];
                key = key*prime + comm[i][j];
                h[sz++] = key;
            }
        }
        h[sz] = 0;
        sort( h,h + sz );

        for( int i = 0; i < sz; ++i ){
            int c = 0;
            while( h[i] == h[i+c] && i+c < sz) c ++;
            cnt[i] = c;
            i = i + c - 1;
        }

        for( int i = 0; i < n; ++i ){
            int len = strlen(comm[i]);
            if( len < L || sol[i] != -1 ) continue;

            int key = 0;
            for( int j = 0; j < L; ++j ) key = comm[i][j] + key * prime;

            int ms = 0;
            int p = lower_bound( h, h + sz , key ) - h;
            cnt[p] --;
            mem[ms++] = p;


            for( int j = L; j < len; ++j ){
                key -= comm[i][j-L] * stp[L-1];
                key = key*prime + comm[i][j];
                p = lower_bound( h, h + sz , key ) - h;
                cnt[p] --;
                mem[ms++] = p;
            }

            for( int j = 0; j < ms; ++j ){
                if( cnt[ mem[j] ] == 0 )
                    sol[i] = j, lensol[i] = L;
                cnt[ mem[j] ] ++;
            }
        }


    }

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < lensol[i]; ++j )
            printf("%c",comm[i][ sol[i] + j ] );
        printf("\n");
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <math.h>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
using namespace std;

const int maxn = 1000 + 55;
const int maxlen = 10000 + 55;
const int inf = 100000000;
const int err = -25001;

struct seq{
    int id,prefix,sum,suffix,len;
    seq(){};
    seq( int p0, int p1, int p2, int p3, int p4 ):id(p0),prefix(p1),sum(p2),suffix(p3),len(p4){};
};

int n;
char tmp[maxlen];

bool cmpl( seq a, seq b ){
    return a.prefix < b.prefix || (a.prefix == b.prefix && a.sum > b.sum );
}

bool cmpr( seq a, seq b ){
    return a.suffix > b.suffix || (a.suffix == b.suffix && a.sum > b.sum );
}

vector< seq > l,r,all;

short dp[1055][10000+55];
bool mode[1055][10000+55];

short solve( int x, int balance ){
    if( x == all.size() ){
        if( balance == 0 ) return 0;
        return err;
    }

    short &sol = dp[x][balance];
    if( sol != err ) return sol;

    sol = solve( x + 1 , balance );

    if( balance - all[x].prefix >= 0 ){
        short tmp = solve( x + 1 , balance + all[x].sum ) + all[x].len;
        if( tmp < err ) tmp = err;

        if( sol < tmp ) sol = tmp, mode[x][balance] = 1;
    }
    return sol;
}

int main(){
    //freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    scanf("%d",&n);


    for( int i = 0; i < n; ++i ){
        scanf("%s",tmp);
        int lowprefix = 0;
        int sum = 0;
        int len = strlen(tmp);

        for( int j = 0; j < len; ++j ){
            if( tmp[j] == '(' ) sum ++;
            else sum --;
            lowprefix = min( lowprefix , sum );
        }
        lowprefix *= -1;
        int lowsuffix = sum + lowprefix;

        seq data = seq(i,lowprefix,sum,lowsuffix,len);
        if( sum >= 0 ) l.push_back( data );
        else r.push_back( data );
    }

    sort( l.begin(), l.end() , cmpl );
    sort( r.begin(), r.end() , cmpr );

    for( int i = 0; i < l.size(); ++i ) all.push_back( l[i] );
    for( int i = 0; i < r.size(); ++i ) all.push_back( r[i] );


    for( int i = 0; i < 1055; ++i )
        for( int j = 0; j < 10055; ++j )
            dp[i][j] = err;

    int sol = solve( 0 , 0 );

    int y = 0;
    vector< int > elem;
    for( int i = 0; i < all.size(); ++i ){
        if( mode[i][y] ){
            elem.push_back( all[i].id + 1);
            y += all[i].sum;
        }
    }


    printf("%d %d\n",sol,(int)elem.size());
    for( int i = 0; i < elem.size(); ++i )
        printf("%d ",elem[i]);

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdlib>
#include <string>
#include <string.h>
#include <cstdio>
#include <set>
#include <map>
using namespace std;

int main(){
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);

    int n; cin >> n;

    vector< string > w;
    vector< int > perm;

    for( int i = 0; i < n; ++i ){
        string s; cin >> s;
        w.push_back(s);
        perm.push_back(i);
    }

    vector< int > x;
    int mx = 0;
    int parts = -1;

    do{
        int sz = 0;
        int curr = 0;
        bool ok = 1;
        for( int i = 0; i < perm.size() && ok; ++i ){
            int p = perm[i];
            for( int j = 0; j < w[p].length() && ok; ++j ){
                sz ++;
                if( w[p][j] == '(' ) curr ++;
                else curr --;

                if( curr < 0 ) ok = 0;
            }

            if( curr == 0 && sz > mx ){
                mx = sz;
                parts = i+1;
                x.clear(); for( int k = 0; k <= i; ++k ) x.push_back( perm[k] );
            }
        }

    }while( next_permutation(perm.begin(),perm.end()) );

    cout<<mx<<endl;

//    cout<<mx<<" "<<parts<<endl;
//
//    for( int i = 0; i < parts; ++i )
//        cout<<x[i]<<" ";cout<<endl;

    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cstdio>
#include <cstdlib>
#include <math.h>
#include <map>
#include <iomanip>
#include <queue>
#include <string>
#include <string.h>
using namespace std;

#define pii pair<int,int>
#define mk make_pair

string sol[] = { "few" , "several" , "pack" , "lots","horde","throng","swarm","zounds","legion"};
pii range[] = {
mk(1,4),mk(5,9),mk(10,19),mk(20,49),mk(50,99),mk(100,249),mk(250,499),mk(500,999),mk(1000,5000)
};


int main(){
    int n; cin >> n;

    for( int i = 0; i < 9; ++i ){
        if( range[i].first <= n && n <= range[i].second ){
            cout<<sol[i]<<endl;
            break;
        }
    }

    return 0;
}


#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <string.h>
using namespace std;

typedef long long ll;

const double eps = 1e-9;
const int inf = 1500000000;
const int maxn = 100 + 55;
const int maxe = 2*maxn * maxn + maxn*10;

int n; double m;
int x[maxn], y[maxn], pengs[maxn], jumps[maxn];

int numNodes;
int source , sink;

int ecnt = 2;
int dst[maxe] , cap[maxe] , next[maxe] , head[maxe] , point[maxe] , work[maxe];

inline void add_edge( int a, int b , int c ){
    cap[ecnt] = c , point[ecnt] = b , next[ecnt] = head[a] , head[a] = ecnt++;
    cap[ecnt] = 0 , point[ecnt] = a , next[ecnt] = head[b] , head[b] = ecnt++;
}

bool bfs(){
    queue< int > q;
    memset( dst , -1 , sizeof(dst));
    dst[source] = 0;
    q.push( source );

    while( !q.empty() ){
        int cnode = q.front(); q.pop();
        for( int adj = head[cnode]; adj > 1; adj = next[adj] ){
            if( dst[ point[adj] ] >= 0 || cap[adj] <= 0 ) continue;
            dst[ point[adj] ] = dst[cnode] + 1;
            q.push( point[adj] );
        }
    }
    return dst[sink] > 0;
}

int flow( int node , int mincap ){
    if( node == sink ) return mincap;

    for( ; work[node] > 1; work[node] = next[ work[node] ] ){
        int adj = work[node], f;
        if( dst[node] + 1 != dst[ point[adj] ] || cap[adj] <= 0 || (f = flow(point[adj], min(mincap, cap[adj]))) == 0 ) continue;
        cap[adj] -= f,  cap[adj^1] += f;
        return f;
    }

    return 0;
}


ll dinic(){
    ll sol = 0;
    while( bfs() ){
        for( int node = 0; node < numNodes; ++node ) work[node] = head[node];
        while(1){
            int f = flow( source , inf );
            if( f == 0 ) break;
            sol += f;
        }
    }
    return sol;
}



void initGraph(int destNode) {
    numNodes = n*2 + 10;
    source = n*2+3;
    sink = n*2+4;

    ecnt = 2;
    for (int i = 0; i < numNodes; ++i)
        head[i] = next[i] = 0;

    for (int i = 0; i < n; ++i) {
        add_edge(i*2, i*2+1, jumps[i]);
        add_edge(i*2+1, i*2, 0);
        if (pengs[i] > 0) {
            add_edge(source, i*2, pengs[i]);
        }
    }
    add_edge(destNode*2, sink, inf);

    for (int i = 0; i < n; ++i) {
        for (int j = i+1; j < n; ++j) {
            ll d = (x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]);
            if (d > m+eps) continue;
            add_edge(i*2+1,j*2, inf);
            add_edge(j*2+1,i*2, inf);
        }
    }
}

int main() {
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);

    while (tests --) {
        int sumPengs = 0;
        scanf("%d%lf",&n,&m);
        m = m * m;
        for (int i = 0; i < n; ++i) {
            scanf("%d%d%d%d",&x[i],&y[i],&pengs[i], &jumps[i]);
            sumPengs += pengs[i];
        }

        vector<int>sol;
        for (int i = 0; i < n; ++i) {
            initGraph(i);
            ll made = dinic();
            if (made == sumPengs) sol.push_back(i);
        }

        if (sol.size() == 0) printf("-1\n");
        else {
            for (int i = 0; i < sol.size()-1; ++i)
                printf("%d ",sol[i]);
            printf("%d\n",sol[sol.size()-1]);
        }
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int mod = 1000000000 + 7;
const int maxn = 100 + 5;

ll w;
int h,m;
int mpow(int b, ll e) {
    if (e == 0) return 1;
    else if(e % 2 == 0) {
        int x = mpow(b,e/2);
        return (x*(ll)x)%mod;
    } else {
        return (b*(ll)mpow(b,e-1))%mod;
    }
}

int c[maxn][maxn];
int prec[maxn][maxn];
int dp[maxn][maxn*maxn];

int main() {
    c[0][0] = 1;
    for (int i = 1; i < maxn; ++i) {
        for (int j = 0; j <= i; ++j) {
            c[i][j] = c[i-1][j];
            if(j) c[i][j] += c[i-1][j-1];
            if (c[i][j] >= mod) c[i][j] -= mod;
        }
    }

    cin >> h >> w >> m;

    for (int k = 0; k <= h; ++k)
        for (int col = 0; col <= h; ++col)
            prec[col][k] = mpow(c[h][k],w/h + (col <= (w%h)));

    dp[0][0] = 1;
    for (int col = 1; col <= h; ++col) {
        for (int sum = 0; sum <= m; ++sum)
            for (int k = 0; k <= min(sum,h); ++k)
                dp[col][sum] = (dp[col][sum] + dp[col-1][sum-k] * (ll)prec[col][k])%mod;
    }
    printf("%d\n",dp[h][m]);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

int main() {
    //freopen("Ulaz.txt","r",stdin);
    vector<int>x;
    for (int i = 0; i < 4; ++i){
        int v; scanf("%d",&v);
        x.push_back(v);
    }
    sort(x.begin(), x.end());
    x.erase(unique(x.begin(), x.end()), x.end());
    printf("%d\n",4-int(x.size()));
    return 0;
}







#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 200;

int h[2], w[2];
char mat[2][maxn][maxn];

int main() {
    //freopen("Ulaz.txt","r",stdin);
    for (int i = 0; i < 2; ++i) {
        scanf("%d%d",&h[i],&w[i]);
        for (int r = 0; r < h[i]; ++r) {
            scanf("%s",&mat[i][r]);
            for (int j = 0; j < w[i]; ++j)
                mat[i][r][j] -= '0';
        }
    }
    int sola=0,solb=0;
    int sol = -1;
    for (int sa = -55; sa < 55; ++sa) {
        for (int sb = -55; sb < 55; ++sb) {
            int sum = 0;
            for (int r = 0; r < h[0]; ++r) {
                for (int c = 0; c < w[0]; ++c) {
                    if (r + sa >= h[1]) continue;
                    if (c + sb >= w[1]) continue;
                    if (r + sa < 0) continue;
                    if (c + sb < 0) continue;
                    sum += mat[0][r][c] * mat[1][r+sa][c+sb];
                }
            }
            if (sol < sum) {
                sol = sum, sola = sa, solb = sb;
            }

        }
    }
    printf("%d %d\n",sola,solb);
    return 0;
}







#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 555;

int h,w;
char mat[maxn][maxn];

int ss[maxn][maxn];

int sum(int r2, int c2, int r1, int c1) {
    int ret = 0;
    ret += ss[r2][c2];
    ret -= ss[r2][c1-1];
    ret -= ss[r1-1][c2];
    ret += ss[r1-1][c1-1];
    return ret;
}

short dp[10][maxn][maxn][1<<4];;

int mask;
bool split(int r1, int c1, int log) {
   // cout<<log<<" "<<r1<<" "<<c1<<endl;
    if (dp[log][r1][c1][mask] != -1) return dp[log][r1][c1][mask];

    int r2 = r1 + (1<<log) - 1;
    int c2 = c1 + (1<<log) - 1;
    int rmid = (r1+r2)/2;
    int cmid = (c1+c2)/2;
    int r[]  = {r1,       rmid+1,rmid+1,r1};
    int c[]  = {c1,       cmid+1,c1,    cmid+1};
    int rn[] = {rmid,     r2,    r2,    rmid};
    int cn[] = {cmid,     c2,    cmid,  c2};

    bool ret = true;
    for (int i = 0; i < 4 && ret; ++i) {
        bool b = mask&(1<<i);
        if (b) ret = sum(rn[i],cn[i],r[i],c[i]) == 0;
        else {
            if (log == 1) ret = mat[r[i]][c[i]] == 1;
            else ret = split(r[i], c[i], log - 1);
        }
    }
    return dp[log][r1][c1][mask] = ret;
}

int main() {
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&h,&w);
    for (int i = 1; i <= h; ++i) {
        scanf("%s",mat[i]+1);
        for (int j = 1; j <= w; ++j) {
            if (mat[i][j] == '.') mat[i][j] = 1;
            else mat[i][j] = 0;
        }
    }

    for (int c = 1; c <= w; ++c) {
        for (int r = 1; r <= h; ++r) {
            ss[r][c] = ss[r-1][c] + mat[r][c];
        }
    }
    for (int r = 1; r <= h; ++r)
        for (int c = 1; c <= w; ++c)
            ss[r][c] += ss[r][c-1];

    int sol = 0;
    memset(dp, -1, sizeof(dp));
    for (int r = 1; r <= h; ++r) {
        for (int c = 1; c <= w; ++c) {
            for (int stp = 4, clog = 2; clog < 10 ; stp *= 2, clog++) {
                if (stp+r > h+1) continue;
                if (stp+c > w+1) continue;
               // cout<<r<<" "<<c<<" = "<<stp<<endl;
                for (mask = 0; mask < (1<<4); ++mask) {
                    sol += split(r, c, clog);
                }
            }
        }
    }

    printf("%d\n",sol);

    return 0;
}







#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 100 + 55;
const int maxm = maxn*maxn;

int n,m;
int vals[maxn];
int a[maxm], b[maxm], c[maxm];

vector< pii > g[maxn];
int visi[maxn];
int token;

bool ok;

void dfs(int node) {
    visi[node] = token;

    for (int i = 0; i < g[node].size(); ++i) {
        int nxt = g[node][i].f;
        int e = g[node][i].s;
        if (visi[nxt] == token) {
            int sum = (vals[node] + vals[nxt])%2;
            if (sum != e) ok = false;
        } else {
            vals[nxt] = (e + vals[node])%2;
            dfs(nxt);
        }
    }
}

int main() {
    //freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);
    for (int i = 0; i < m; ++i) {
        scanf("%d%d%d",&a[i], &b[i], &c[i]);
        a[i]--,b[i]--;
        c[i] = 1-c[i];
        g[a[i]].push_back(mk(b[i],c[i]));
        g[b[i]].push_back(mk(a[i],c[i]));
    }

    ok = true;
    token = 5;
    for (int i = 0; i < n && ok; ++i) {
        if (visi[i])continue;
        ok = false;
        for (int j = 0; j < 2 && !ok; ++j) {
            vals[i] = j;
            ok = true;
            token++;
            dfs(i);

            for (int k = 0; k < n && !ok; ++k)
                if (visi[k] == token)
                    visi[k] = false;
        }
    }

    if (!ok){
        printf("Impossible\n");
        return 0;
    }

    vector<int>sol;
    for (int i = 0; i < n; ++i) {
        if (vals[i]) sol.push_back(i+1);
    }
    printf("%d\n",sol.size());
    for (int i = 0; i < sol.size(); ++i)
        printf("%d ",sol[i]);
    printf("\n");

    return 0;
}







#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 50000;

int n;
int v[maxn];

int main() {
    int tests; scanf("%d",&tests);
    while (tests--){
        scanf("%d",&n);
        ll curr = 0;
        for (int i = 0; i < n; ++i) {
            scanf("%d",&v[i]);
            curr += v[i];
        }
        ll sol = 1LL << 60;;
        v[n++] = 0;
        sort(v,v + n);
        int cBack = 0, cFront = n - 1;
        for (int i = 1; i < n; ++i) {
            int diff = v[i] - v[i-1];
            curr -= cFront*diff;
            curr += cBack*diff;
            sol = min(sol, curr);
            cBack++, cFront--;
        }
        printf("%lld\n",sol);
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

string a,b;
vector<vector<int> >dp;

int main() {
    //freopen("Ulaz.txt","r",stdin);
    while (cin >> a >> b) {
        a = "." + a;
        b = "#" + b;

        dp.resize(sz(a));
        for (int j = 0; j < sz(a); ++j)
            dp[j].resize(sz(b));
        for (int i = 1; i < a.size(); ++i) {
            for (int j = 1; j < b.size(); ++j) {
                if (a[i] == b[j]) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else {
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }

        printf("%d\n",dp[sz(a)-1][sz(b)-1]);
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 20000 + 55;

int n;
int id[maxn], dst[maxn];


pii find(int x) {
    if (x == id[x]) return mk(x, 0);
    pii r = find(id[x]);
    id[x] = r.f;
    dst[x] = dst[x] + r.s;
    return mk(id[x], dst[x]);
}

void merge(int center, int client) {
    id[center] = id[client];
    dst[center] = abs(center-client) % 1000 + dst[client];
}

int main() {
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);
    while (tests--) {
        for (int i = 0; i < maxn; ++i) {
            dst[i] = 0;
            id[i] = i;
        }

        scanf("%d",&n);
        while (1) {
            char c;
            while (c=getchar()) if (c=='I'||c=='E'||c=='O') break;
            if (c == 'O') break;
            else if (c == 'I') {
                int a,b; scanf("%d%d",&a,&b);
                merge(a, b);
            } else if(c == 'E') {
                int a; scanf("%d",&a);
                pii d = find(a);
                printf("%d\n",d.s);
            }
        }
    }

    return 0;
}











#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 3000 + 55;

int m,n,dx;
int v[maxn];

int main() {
    //freopen("Ulaz.txt","r",stdin);
    while(scanf("%d%d%d",&m,&dx,&n) == 3) {
        vector<pii>w;
        for (int i = 0; i < n; ++i) {
            scanf("%d",&v[i]);
            w.push_back(mk(v[i],i));
        }
        sort(w.begin(),w.end());
        int group = n / m;
        int curr = 0;
        vector<int>tmp;
        for (int i = 0; i <= dx; ++i) {
            int add = i < (n%m);
            tmp.clear();
            for (int j = 0; j < group + add; ++j) {
                int t = w[curr++].s;
                tmp.push_back(t);
            }
        }
        sort(tmp.begin(),tmp.end());
        printf("%d\n",v[tmp[0]]);
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 70 + 15;

int mod,n;
char txt[maxn];
int mat[maxn][maxn];

void init() {
    memset(mat, 0, sizeof(mat));
}

void makeMat() {
    for (int i = 0; i < n; ++i) {
        mat[i][0] = 1;
        for (int j = 1; j < n; ++j)
            mat[i][j] = (mat[i][j-1] * (i+1)) % mod;
        mat[i][n] = txt[i] == '*' ? 0 : txt[i] - 'a' + 1;
    }
}

int powMod(int a, int e) {
    if (e == 0) return 1;
    else if(e%2 == 0) {
        int x = powMod(a, e / 2);
        return (x*(ll)x)%mod;
    } else return (a*(ll)powMod(a, e - 1)) % mod;
}

int modInv(int x) {
    return powMod(x, mod - 2);
}

int main() {
   // freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);
    while (tests--) {
        init();
        scanf("%d",&mod);
        scanf("%s",txt);
        n = strlen(txt);
        makeMat();

        for (int i = 0; i < n; ++i) {
            int dx;
            for (dx = i; mat[dx][i] == 0; dx++);
            for (int j = 0; j <= n; ++j) swap(mat[dx][j], mat[i][j]);
            int inv = modInv(mat[i][i]);
            for (int j = 0; j <= n; ++j)
                mat[i][j] = (mat[i][j]*(ll)inv)%mod;
            for (int k = 0; k < n; ++k) {
                if (mat[k][i] == 0 || k == i) continue;
                int t = mat[k][i];
                for (int j = 0; j <= n; ++j) {
                    mat[k][j] = (((mat[k][j] - t * (ll)mat[i][j])%mod)+mod)%mod;
                }
            }
        }

        for (int i = 0; i < n; ++i) {
            printf("%d",mat[i][n]);
            if (i < n-1)printf(" ");
        }
        printf("\n");
    }

    return 0;
}










#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 10 + 5;

int n;
int v[maxn];

int main() {
    //cout<<(1000000000000000000LL)<<endl;
    int tests; scanf("%d",&tests);
    int t = 1;
    while (tests--) {
        scanf("%d",&n);
        ll prod = 1;
        for (int i = 0; i < n; ++i) {
            scanf("%d",&v[i]);
            prod *= v[i];
        }
        ll den = 0;
        for (int i = 0; i < n; ++i)
            den += prod / v[i];
        ll g = __gcd(prod*n,den);
        cout<<"Case "<<t<<": ";
        cout<<prod*n/g<<"/"<<den/g<<endl;
        ++t;
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 40000 + 55;

int n;
int v[maxn];

int rec(int i, int j, int n) {
    int t1 = 0, t2 = 0, t = 0;
    if(i<0 ||j <0 || i >= n || j >= n)return 0;
    if(i == j) t = rec(i+1,j+1,n);
    if(i<=j)t1 = (v[i]>v[j]) + rec(i,j+1,n);
    if(i>=j)t2 = (v[i]>v[j]) + rec(i,j-1,n);
    return t1+t2+t;
}

int main() {
    int caseNum = 0;
    while (scanf("%d",&n) == 1) {
        if (n == 0) break;
        caseNum ++;
        for (int i = 0; i < n; ++i)
            scanf("%d",&v[i]);

        ll sol = n*(ll)(n-1)/2;
        sort(v, v + n);
        for (int i = 0; i < n; ++i) {
            int cnt = 0;
            while(v[i]==v[i+cnt] && i+cnt < n) cnt++;
            sol -= cnt*(ll)(cnt-1)/2;
            i += cnt - 1;
        }
        printf("Case %d: %lld\n",caseNum,sol);
    }
    return 0;
}








#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int h = 9, w = 9;
const int maxn = 10;
const int maxv = 10;

char buff[maxn];
bool box[maxn][maxv];
bool row[maxn][maxv];
bool col[maxn][maxv];
int mat[maxv][maxv];

int getBox(int r, int c) {
    return (r/3)*3 + c/3;
}

bool solve(int r, int c) {
    if (c == 9) r ++, c = 0;
    if (r == 9) return true;

    if (mat[r][c] != 0) return solve(r, c + 1);

    for (int k = 1; k <= 9; ++k) {
        int b = getBox(r,c);
        if (box[b][k] || col[c][k] || row[r][k]) continue;
        box[b][k] = col[c][k] = row[r][k] = true;
        mat[r][c] = k;
        if (solve(r, c + 1)) return true;
        mat[r][c] = 0;
        box[b][k] = col[c][k] = row[r][k] = false;
    }

    return false;
}


int main() {
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);
    while (tests--) {
        memset(box, 0, sizeof(box));
        memset(col, 0, sizeof(col));
        memset(row, 0, sizeof(row));

        for (int i = 0; i < h; ++i) {
            scanf("%s",buff);
            for (int j = 0; j < w; ++j) {
                int x = buff[j] - '0';
                mat[i][j] = x;
                if (x!=0) {
                    box[getBox(i,j)][x] = true;
                    col[j][x] = true;
                    row[i][x] = true;
                }
            }
        }
        bool b = solve(0, 0);
        if (b == 0) {
            col[-4234234234][-23423432] = 1; // let's do a SEGF
            continue;
        }

        for (int i = 0; i < h; ++i) {
            for (int j = 0; j < w; ++j)
                printf("%d",mat[i][j]);
            printf("\n");
        }printf("\n");
    }
    return 0;
}














#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <algorithm>
#include <math.h>
#include <iomanip>
#include <cstdlib>
#include <cstdio>
using namespace std;

const int maxn = 100000 + 55;
const int maxe = 205*maxn;

int cnte = 1;
int head[maxn], point[maxe], nxt[maxe];

inline void add_edge(int a, int b) {
    nxt[cnte] = head[a], point[cnte] = b, head[a] = cnte ++;
}

int n;
int dst[maxn];
bool visited[maxn];

int main() {
    int tests; scanf("%d",&tests);
    while(tests--) {
        memset(visited, false, sizeof(visited));
        cnte = 1;
        memset(head, 0, sizeof(head));

        scanf("%d",&n);
        for (int i = 0; i < n; ++i) {
            int x; scanf("%d",&x);
            int m; scanf("%d",&m);
            for (int i = 0; i < m; ++i) {
                int y; scanf("%d",&y);
                add_edge(x, y);
                add_edge(y, x);
            }
        }
        int c1,c2;
        scanf("%d%d",&c1,&c2);

        dst[c1] = -1;
        visited[c1] = true;
        queue<int> q;
        q.push(c1);
        while(!q.empty()) {
            int u = q.front(); q.pop();
            for (int i = head[u]; i >= 1; i = nxt[i]) {
                int x = point[i];
                if (visited[x]) continue;
                dst[x] = dst[u] + 1;
                visited[x] = true;
                q.push(x);
            }
        }
        printf("%d %d %d\n",c1, c2 ,dst[c2]);
        if(tests) printf("\n");
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 21;

int d[][2] = {0,1, 1,0, 0,-1, -1,0};

int h,w;
pii start, end;
char mat[maxn][maxn];
int dst[maxn][maxn][4];

int main() {
   // freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);
    while (tests--) {
        scanf("%d%d\n",&h,&w);
        for (int i = 0; i < h; ++i) {
            for (int j = 0; j < w; ++j)
                scanf("%c",&mat[i][j]);
            scanf("\n");

            for (int j = 0; j < w; ++j) {
                if (mat[i][j] == 'S') start = mk(i,j);
                else if (mat[i][j] == 'F') end = mk(i,j);
            }
        }

        queue< pair< pii, int > > q;
        pair< pii, int > u;
        q.push(mk(start, 0));
        q.push(mk(start, 2));
        memset(dst, -1, sizeof(dst));
        dst[start.f][start.s][0] = 0;
        dst[start.f][start.s][2] = 0;
        while (!q.empty()) {
            u = q.front(); q.pop();

            for (int t = 0; t <= 1; ++t) {
                int dir = (u.s + t)%4;
                int nxtr = u.f.f + d[dir][0];
                int nxtc = u.f.s + d[dir][1];
                if (mat[nxtr][nxtc] == 'X') continue;
                if (dst[nxtr][nxtc][dir] != -1) continue;
                dst[nxtr][nxtc][dir] = dst[u.f.f][u.f.s][u.s] + 1;
                q.push(mk(mk(nxtr,nxtc), dir));
            }
        }

        int sol = 1 << 30;
        for (int i = 0; i < 4; ++i)
            if (dst[end.f][end.s][i] != -1)
                sol = min(sol, dst[end.f][end.s][i]);
        printf("%d\n",sol);
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 1e7;

bool ok[maxn];
char txt[10];

int main() {
    //freopen("Ulaz.txt","r",stdin);
    ok[0] = ok[1] = true;
    for (int i = 2; i < maxn; i ++) {
        if(ok[i]) continue;
        for (int j = i+i; j <= maxn; j += i)
            ok[j] = true;
    }

    int tests; scanf("%d",&tests);
    while (tests--){
        scanf("%s",txt);
        vector<int>sol;
        int n = strlen(txt);
        sort(txt, txt + n);
        do{
            int x = 0;
            for (int i = 0; i < n; ++i) {
                x = x*10 + txt[i]-'0';
                if (ok[x] == false) {
                    sol.push_back(x);
                }
            }
        }while(next_permutation(txt, txt+n));

        sort(sol.begin(), sol.end());
        sol.erase(unique(sol.begin(),sol.end()), sol.end());
        printf("%d\n",sol.size());
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 55000;
const ll prime = 1000000007;
const int mod  = 100003;

int len;
char txt[maxn*8];
int rc[maxn], lc[maxn];
int lo[maxn], hi[maxn];

int curr, t, cnode;
int process() {
    t = 0;
    int x = cnode++;
    while (txt[curr+t] >= 'a' && txt[curr+t] <= 'z')t++;
    lo[x] = curr, hi[x] = curr + t - 1;
    curr += t;

    if (txt[curr] == '(') {
        curr++;
        lc[x] = process();
        rc[x] = process();
        curr++;
    }
    if (txt[curr] == ',') {
        curr++;
    }
    return x;
}

ll key[maxn];
ll pwp[maxn];
int counter;
int id[maxn];
int subs[maxn];
map<ll,int>mapper;
int sz[maxn];

ll compress(int node) {
    ll lKey = 0, rKey = 0;
    sz[node] = 1;
    int ls = 0, rs = 0;
    if (lc[node] != -1) {
        assert(lc[node] != -1 && rc[node] != -1);
        lKey = compress(lc[node]);
        rKey = compress(rc[node]);
        sz[node] += ls = sz[lc[node]];
        sz[node] += rs = sz[rc[node]];
    }

    ll key = 0;
    for (int i = lo[node]; i <= hi[node]; ++i)
        key = key * prime + txt[i];

    assert(ls >= 0 && ls <= cnode && rs >= 0 && rs <= cnode);
    ll nKey = (lKey * pwp[2] + key) * pwp[1]+ rKey;
    if (mapper.count(nKey) != 0) {
        subs[node] = mapper[nKey];
    } else {
        subs[node] = -1;
        mapper[nKey] = node;
    }
    return nKey;
}


void printTree(int node) {
    if (subs[node] != -1) {
        printf("%d",id[subs[node]]);
        return;
    }

    id[node] = ++counter;
    for (int i = lo[node]; i <= hi[node]; ++i)
        printf("%c",txt[i]);
    if (lc[node] != -1) {
        printf("(");
        printTree(lc[node]);
        printf(",");
        printTree(rc[node]);
        printf(")");
    }
}

int main() {
    pwp[0] = 1;
    for (int i = 1; i < maxn; ++i)
        pwp[i] = pwp[i-1] * prime;

    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);

    while (tests--){
        scanf("%s",txt);
        len = strlen(txt);

        mapper.clear();
        memset(rc, -1, sizeof(rc));
        memset(lc, -1, sizeof(lc));
        curr = cnode = counter = 0;

        process();
        assert(len == curr && cnode >= 1 && cnode <= 50000);

        counter = 0;
        compress(0);
        printTree(0);
        printf("\n");
    }

    return 0;
}









#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 50000 + 55;
const int maxm = 1000000 + 55;

int n,m;
int v[maxn];
int have[maxm];

ll seq[maxm];

int main() {
    seq[0] = seq[1] = 0;
    for (int i = 2; i < maxm; ++i) seq[i] = seq[i-1] + i - 1;
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);
    while (tests--){
        memset(have, 0, sizeof(have));
        scanf("%d%d",&m,&n);
        for (int i = 0; i < n; ++i) scanf("%d",v+i);
        int s = 0;
        vector<int>w;
        for (int i = 0; i < n; ++i) {
            s = (s+v[i])%m;
            have[s]++;
        }

        ll sol = 0;
        for (int i = 0; i < m; ++i)
            sol += seq[have[i]];
        printf("%lld\n",sol+have[0]);
    }
    return 0;
}













#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 100 + 5;
const int maxdeepth = 10 + 5;
const double eps = 1e-9;
const double pi = acos(0)*2;

int n,depth;
vector<pii>w;

double fract;

double getDist(int i, int j) {
    return sqrt((w[i].x-w[j].x)*(w[i].x-w[j].x) + (w[i].y-w[j].y)*(w[i].y-w[j].y));
}

double sLen[maxdeepth];

pdd solve(int dx, int currDepth, double lineToPass, double scale) {
    double prop = getDist(dx, dx + 1) / getDist(0, n-1);
    double L = prop * scale * sLen[depth-2-currDepth];

    cout<<dx<<" "<<depth-2-currDepth<<" , "<<lineToPass<<" "<<scale<<endl;

    if (depth-2-currDepth == 0)
        L = getDist(dx, dx+1)*scale;

    lineToPass -= L;
    cout<<lineToPass<<" , "<<L<<endl;

    if (lineToPass < -eps) {
        pdd r;
        if (depth-2-currDepth > 0) {
            r = solve(0, currDepth + 1, lineToPass + L, scale * prop);
            double xF = w[1].x - w[0].x;
            double yF = w[1].y - w[0].y;
            double xS = w[dx+1].x - w[dx].x;
            double yS = w[dx+1].y - w[dx].y;
            double help = xF*yS - xS*yF;

            double A = xF*xS + yF*yS;
            double B = sqrt((xF*xF + yF*yF)*(xS*xS + yS*yS));

            double cosPhi = A/B;
            double sinPhi = sqrt(1 - cosPhi*cosPhi);
            double angle = acos(cosPhi);

            r.x -= w[0].x*scale*prop, r.y -= w[0].y*scale*prop;
            if (help > 0) r = mk(cosPhi*r.x - sinPhi*r.y, sinPhi*r.x + cosPhi*r.y);
            else r = mk(cosPhi*r.x + sinPhi*r.y, - sinPhi*r.x + cosPhi*r.y);
            r.x += w[dx].x, r.y += w[dx].y;
        } else {
            lineToPass += L;
            pdd diff = mk(w[dx+1].x-w[dx].x, w[dx+1].y-w[dx].y);
            diff.x *= scale, diff.y *= scale;
            double d = sqrt(diff.x*diff.x + diff.y*diff.y);
            double part = lineToPass / d;
            diff.x *= part, diff.y *= part;
            r = mk(w[dx].x*scale + diff.x, w[dx].y*scale + diff.y);
        }
        return r;
    } else {
        if (L < eps) return mk(w[dx+1].x*scale,w[dx+1].y*scale);
        pdd r = solve(dx + 1, currDepth, lineToPass, scale);
        return r;
        //if (depth-2-currDepth == 0) r +=
    }
    return mk(-1,-1);
}

int main() {
    freopen("Ulaz.txt","r",stdin);
  //  freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);
    while (tests--) {
        w.clear();
        scanf("%d",&n);
        double len = 0;
        for (int i = 0; i < n; ++i) {
            int a,b; scanf("%d%d",&a,&b);
            w.push_back(mk(a,b));
            if(i) len += getDist(i,i-1);
        }
        scanf("%d",&depth);
        scanf("%lf",&fract);

        double sscale = 0;
        for (int i = 0; i < n-1; ++i)
            sscale += getDist(i, i+1) / getDist(0, n-1);

        sLen[0] = len;
        for (int i = 1; i <= depth; ++i)
            sLen[i] = sLen[i-1] * sscale;
        cout<<sLen[0]<<" "<<sLen[1]<<" "<<sLen[2]<<endl;


        cout<<sLen[depth-1]<<endl;
        pdd sol = solve(0, 0, sLen[depth-1] * fract, 1);
        printf("(%.10lf,%.10lf)\n",sol.x,sol.y);
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 100 + 5;
const int maxdepth = 10 + 5;
const double eps = 1e-9;
const double pi = acos(0)*2;

int n,d;
double part;
double perimeter;
vector<pdd>w;
double lvl[maxdepth];

double getDist(int i, int j) {
    return sqrt((w[i].x-w[j].x)*(w[i].x-w[j].x) + (w[i].y-w[j].y)*(w[i].y-w[j].y));
}

pdd solve(int dx, int m, double rem) {
    double t = m == -1 ? -1 : lvl[m];
    double len = (getDist(dx, dx + 1) / perimeter) * t;
    if(m == -1) len = getDist(dx, dx + 1);
    rem -= len;

    if (fabs(rem) < eps) return w[dx+1];

    if (rem < eps) {
        rem += len;
        pdd r;
        if (m >= 0) {
            double q = getDist(dx, dx + 1) / perimeter;
            r = solve(0, m-1, rem/q);
            r.x = r.x - w[0].x + w[dx].x, r.y = r.y - w[0].y + w[dx].y;
            r.x -= w[dx].x, r.y -= w[dx].y;
            r.x *= q, r.y *= q;

            double X = w[dx+1].x - w[dx].x, Y = w[dx+1].y - w[dx].y;
            double X2 = w[n-1].x - w[0].x, Y2 = w[n-1].y - w[0].y;
            double cosPhi = (X*X2 + Y*Y2) / (sqrt(X*X+Y*Y)*sqrt(X2*X2 + Y2*Y2));
            double sinPhi = sqrt(1 - cosPhi*cosPhi);
            double orientation = X*Y2 - Y*X2;

            if (orientation < 0) r = mk(cosPhi*r.x - sinPhi*r.y, sinPhi*r.x + cosPhi*r.y);
            else r = mk(cosPhi*r.x + sinPhi*r.y, - sinPhi*r.x + cosPhi*r.y);
            r.x += w[dx].x, r.y += w[dx].y;

        } else {
            double d = getDist(dx, dx + 1);
            double p = rem / d;
            pdd allign = mk(w[dx+1].x - w[dx].x, w[dx+1].y - w[dx].y);
            allign.x *= p, allign.y *= p;
            r = mk(w[dx].x + allign.x, w[dx].y + allign.y);
        }
        return r;
    } else {
        return solve (dx + 1, m, rem);
    }
    return mk(-1, -1);
}

int main() {
    //freopen("Ulaz.txt","r",stdin);
  //  freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);
    while (tests--) {
        w.clear();
        scanf("%d",&n);
        for (int i = 0; i < n; ++i) {
            int a,b; scanf("%d%d",&a,&b);
            w.push_back(mk(a,b));
        }

        scanf("%d",&d); d--;
        scanf("%lf",&part);

        if (fabs(part) < eps) {
            printf("(0,0)\n");
            continue;
        }

        double koef = 0;
        double sum = 0;
        perimeter = getDist(0, n-1);
        for (int i = 0; i < n-1; ++i) {
            koef += getDist(i, i+1) / perimeter;
            sum += getDist(i, i+1);
        }

        lvl[0] = sum;
        for (int i = 1; i <= d; ++i)
            lvl[i] = lvl[i-1] * koef;

        pdd sol = solve(0, d-1, lvl[d]*part);
        printf("(%.10lf,%.10lf)\n",sol.x,sol.y);
    }
    return 0;
}










#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 200 + 55;

int n;
vector<pii>car[2];
int dp[maxn][maxn][2];


int main() {
    int tests; scanf("%d",&tests);
    while (tests --) {
        car[0].clear(), car[1].clear();

        scanf("%d",&n);
        for (int i = 0; i < n; ++i) {
            char c;
            while (c=getchar()) if (c == 'A' || c == 'B') break;
            int arrival,t; scanf("%d%d",&arrival,&t);
            car[c-'A'].push_back(mk(arrival,t));
        }

        for (int i = 0; i < maxn; ++i)
            for (int j = 0; j < maxn; ++j)
                dp[i][j][0] = dp[i][j][1] = 1 << 28;

        dp[0][0][0] = dp[0][0][1] = 0;
        for (int sum = 0; sum <= n; ++sum) {
            for (int dxa = 0; dxa <= sum; ++dxa) {
                int dxb = sum - dxa;
                if (dxa > car[0].size() || dxb > car[1].size())continue;

                int atLeast = dp[dxa][dxb][1];
                int atLeastStart = dp[dxa][dxb][1];
                for (int i = dxa; i < car[0].size(); ++i) {
                    int fin = max(atLeastStart + car[0][i].s, car[0][i].f + car[0][i].s);
                    fin = max(fin, atLeast);
                    dp[i+1][dxb][0] = min(dp[i+1][dxb][0], fin);
                    atLeast = fin + 10;
                    atLeastStart = max(car[0][i].f, atLeastStart) + 10;
                }


                atLeast = dp[dxa][dxb][0];
                atLeastStart = dp[dxa][dxb][0];
                for (int i = dxb; i < car[1].size(); ++i) {
                    int fin = max(atLeastStart + car[1][i].s, car[1][i].f + car[1][i].s);
                    fin = max(fin, atLeast);
                    dp[dxa][i+1][1] = min(dp[dxa][i+1][1], fin);
                    atLeast = fin + 10;
                    atLeastStart = max(atLeastStart, car[1][i].f) + 10;
                }
            }
        }

        int sol = 1 << 29;
        for (int i = 0; i <= n; ++i)
            sol = min(sol, dp[i][n-i][0]), sol = min(sol, dp[i][n-i][1]);


        printf("%d\n",sol);
    }
    return 0;
}





#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

typedef long long ll;

const int maxn = 50000 + 55;

int n,m;
vector<pii>g[maxn];

ll cnt[maxn];
ll subtree_cost[maxn];
ll subtree_cnt[maxn];

void dfs_init(int node, int dad) {
    subtree_cost[node] = 0;
    subtree_cnt[node] = cnt[node];
    for (int i = 0; i < g[node].size(); ++i) {
        if (dad == g[node][i].f) continue;
        dfs_init(g[node][i].f, node);
        subtree_cost[node] += subtree_cost[g[node][i].f] + g[node][i].s * subtree_cnt[g[node][i].f];
        subtree_cnt[node] += subtree_cnt[g[node][i].f];
    }
}

ll best;
vector<int> list;

void check(int node, ll sol) {
    if (best > sol) list.clear(), best = sol;
    if (best == sol) list.push_back(node);
}

void solve(int node, int dad, ll cnt, ll sol) {
    check(node, sol);
    for (int i = 0; i < g[node].size(); ++i) {
        if (dad == g[node][i].f) continue;
        int w = g[node][i].f;
        ll nwcnt = cnt + subtree_cnt[node] - subtree_cnt[w];
        solve(w, node, nwcnt, sol - subtree_cnt[w]*g[node][i].s + nwcnt*g[node][i].s);
    }
}

int main() {
  //  freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);
    while (tests--){
        scanf("%d",&n);

        best = 1LL << 59;
        for (int i = 0; i <= n; ++i) {
            cnt[i] = 0;
            g[i].clear();
        }

        for (int i = 0; i < n-1; ++i) {
            int a,b,c; scanf("%d%d%d",&a,&b,&c); a--, b--;
            g[a].push_back(mk(b,c));
            g[b].push_back(mk(a,c));
        }

        scanf("%d",&m);
        for (int i = 0; i < m; ++i) {
            int a,b; scanf("%d%d",&a,&b); a--;
            cnt[a] += b*2;
        }

        dfs_init(0, -1);
        solve(0, -1,  0, subtree_cost[0]);

        printf("%lld\n",best);
        sort(list.begin(), list.end());
        for (int i = 0; i < list.size() - 1; ++i)
            printf("%d ",list[i]+1); printf("%d\n", list[sz(list)-1]+1);
    }
    return 0;
}











#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 50000 + 55;

int id[maxn];
int sz[maxn];

int find(int x) {
    if(x == id[x]) return x;
    return id[x] = find(id[x]);
}

bool merge(int a, int b) {
    int x = find(a), y = find(b);
    if (x == y) return true;
    if (sz[x] < sz[y])
        sz[y] += sz[x], id[x] = y;
    else
        sz[x] += sz[y], id[y] = x;
    return false;
}

int n;
int cnt[maxn];
int val[maxn];
int visi[maxn];
vector<int>g[maxn];

void init() {
    for (int i = 0; i <= n; ++i)
        id[i] = i, sz[i] = 1, cnt[i] = 0;
    for (int i = 0; i < n; ++i)
        g[i].clear();
}

bool cmp(int a, int b) {
    return val[a] > val[b] || (val[a] == val[b] && a < b);
}

int main() {
    int tests; scanf("%d",&tests);
    int t = 0;
    while (tests--) {
        t++;
        scanf("%d",&n);
        init();

        for (int i = 0; i < n-1; ++i) {
            int a,b; scanf("%d%d",&a,&b); a--, b--;
            bool t = merge(a,b);
            if (t) cnt[a] ++;
            g[a].push_back(b);
            g[b].push_back(a);
        }

        for (int i = 0; i < n; ++i)
            scanf("%d",&val[i]);

        vector<int>good, okay;
        bool impossible = false;
        memset(visi, false, sizeof(visi));
        for (int i = 0; i < n; ++i) {
            if (visi[i]) continue;
            queue<int> q;
            q.push(i);
            visi[i] = true;

            int sumCnt = 0;
            vector<int>order;

            while(!q.empty()) {
                int u = q.front(); q.pop();
                order.push_back(u);
                sumCnt += cnt[u];
                for (int k = 0; k < g[u].size(); ++k) {
                    int w = g[u][k];
                    if (visi[w]) continue;
                    visi[w] = true;
                    q.push(w);
                }
            }
            if (sumCnt > 1) impossible = true;
            else if(sumCnt == 0) {
                for (int j = 0; j < order.size(); ++j)
                    good.push_back(order[j]);
            } else { // == 1
                for (int j = 0; j < order.size(); ++j)
                    okay.push_back(order[j]);
            }
        }
        sort(good.begin(), good.end(), cmp);
        sort(okay.begin(), okay.end());



        if (impossible || sz(good) + sz(okay) < 2) {
            printf("impossible\n");
            continue;
        }

//        printf("Some good: ");
//        for (int i = 0; i < min(sz(good),20); ++i)
//            cout<<good[i]+1<<" ";cout<<endl;
//        printf("Some okay: ");
//        for (int i = 0; i < min(sz(okay),20); ++i)
//            cout<<okay[i]+1<<" ";cout<<endl;
//
//
//        cout<<"t: "<<t<<" ";
        if (sz(good) >= 2 && val[good[0]] == val[good[1]]) printf("%d %d\n",min(good[0],good[1])+1,max(good[0],good[1])+1);
        else if (sz(good) >= 1 && sz(okay) >= 1) printf("%d %d\n",min(good[0],okay[0])+1,max(good[0],okay[0])+1);
        else if(sz(good) >= 2) printf("%d %d\n",min(good[0], good[1])+1, max(good[0], good[1])+1);
        else printf("----\n");
    }
    return 0;
}









#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define f first
#define s second
#define mk make_pair

const int maxn = 100000 + 55;

int sol[maxn];
int row[2][maxn];
int cCount[10];

int main() {
    sol[1] = 1, sol[2] = 2, sol[3] = 3, sol[4] = 4, sol[5] = 5;
    sol[6] = 2, sol[7] = 3;
    for (int i = 0; i < 6; ++i)
        row[0][i] = sol[i+2], cCount[sol[i+2]]++;
    cCount[1]++;

    int curr = 8;
    int prev = 3;
    bool currRow = 1;
    for (int circle = 2; circle < 60; ++circle) {
        int pcnt = (circle-1) * 6;
        for (int side = 0; side < 6; ++side) {
            int dx = side*circle;
            for (int i = 0; i < circle; ++i) {
                bool has[]={0,0,0,0,0,0};
                if (i == circle - 1 && side != 5);
                else if (i == circle-1) has[row[currRow][0]] = true;
                else has[row[!currRow][(dx+i-side)%pcnt]] = true;

                has[row[!currRow][(dx+i-side-1+pcnt)%pcnt]] = true;
                has[prev] = true;

                //if ()

                int take = -1;
                for (int k = 1; k <= 5; ++k)
                    if (has[k] == false && (take == -1 || cCount[take] > cCount[k])) take = k;

                cCount[take]++;
                sol[curr++] = prev = row[currRow][dx+i] = take;
            }
        }
        currRow = !currRow;
    }

   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);
    while (tests--){
        int x; scanf("%d",&x);
        printf("%d\n",sol[x]);
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxx = 22000;

int n;
vector< pii > w;
vector<pii>row[maxx+555];
bool used[maxx];

int ccw(pii c, pii a, pii b) {
    return (a.x-c.x)*(b.y-c.y) - (a.y-c.y)*(b.x-c.x);
}

int main() {
    int tests; scanf("%d",&tests);
    while (tests--){
        w.clear();
        for (int i = 0; i  <maxx; ++i)
            row[i].clear(), used[i] = false;

        scanf("%d",&n);
        for (int i = 0; i < n; ++i) {
            int a,b; scanf("%d%d",&a,&b);
            b += 10000;
            row[b].push_back(mk(a,i));
            w.push_back(mk(a,b));
        }

        for (int i = 0; i < maxx; ++i)
            sort(row[i].begin(), row[i].end());

        int sz = 0;
        vector<int>sol;
        for (int i = maxx-1; i >= 0; --i) {
            for (int j = 0; j < sz(row[i]); ++j) {
                while (sz >= 2 && ccw(w[sol[sz-2]], w[sol[sz-1]], mk(row[i][j].f,i))<0)
                    sol.pop_back(), sz--;
                sol.push_back(row[i][j].s);
                sz++;
            }
        }
        for (int i = 0; i < sol.size(); ++i)
            used[sol[i]] = true;

        for (int r = 0; r < maxx; ++r) {
            for (int i = sz(row[r]) - 1; i >= 0; --i)
                if (used[row[r][i].s] == false) sol.push_back(row[r][i].s);
        }

        assert(sol.size() == n);
        for (int i = 0; i < sz(sol); ++i){
            printf("%d ",sol[i]);
        }
        printf("\n");

    }
    return 0;
}







#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const double eps = 1e-9;
const int inf = (1LL << 31) -1;

const int maxn = 100 + 15;
const int maxm = maxn*maxn;

struct coord{
    int x,y,z;
    coord(){};
    coord(int p1, int p2, int p3):x(p1),y(p2),z(p3){};
    int travel(coord &c) {
        int xd = x-c.x, yd = y-c.y, zd = z-c.z;
        int s = xd*xd + yd*yd + zd*zd;
        return (int)ceil(sqrt(s));
    }
};

int n,numNodes;
coord c0,c1;
coord tunnel[maxn][2];
int creation[maxn];
int shift[maxn];

int cnte = 1;
int head[maxn], nxt[maxm], point[maxm], cost[maxm], start[maxm], source[maxm];

inline void add_edge(int a, int b, int c, int creation = -inf) {
    source[cnte] = a, nxt[cnte] = head[a], point[cnte] = b, cost[cnte] = c, start[cnte] = creation, head[a] = cnte ++;
}

int dist[maxn];
int dad[maxn];
bool block[maxm];

int bellman_ford() {

    for (int i = 0; i < numNodes; ++i)
        for (int e = 1; e < cnte; ++e) {
            if (block[e]) continue;
            int c = max(dist[source[e]], start[e]);
            if (dist[point[e]] > c + cost[e]) {
                dist[point[e]] = c + cost[e];
                dad[point[e]] = e;
            }
        }

    for (int e = 1; e < cnte; ++e) {
        if (block[e]) continue;
        int c = max(dist[source[e]], start[e]);
        if (dist[point[e]] > c + cost[e])
            return e;
    }

    return -1;
}

int main() {
    int tests; scanf("%d",&tests);
    while (tests--) {
        cnte = 1;
        memset(head, 0, sizeof(head));
        memset(block, false, sizeof(block));


        scanf("%d%d%d",&c0.x,&c0.y,&c0.z);
        scanf("%d%d%d",&c1.x,&c1.y,&c1.z);
        scanf("%d",&n);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < 2; ++j)
                scanf("%d%d%d",&tunnel[i][j].x,&tunnel[i][j].y,&tunnel[i][j].z);
            scanf("%d%d",creation+i,shift+i);
        }
        tunnel[n][0] = c0, tunnel[n][1] = c1;

        for (int i = 0; i < n; ++i)
            add_edge(i*2, i*2+1, shift[i], creation[i]);

        for (int i1 = 0; i1 <= n; ++i1) {
            for (int j1 = 0; j1 < 2; ++j1) {
                for (int i2 = 0; i2 <= n; ++i2) {
                    for (int j2 = 0; j2 < 2; ++j2) {
                        add_edge(i1*2+j1, i2*2+j2, tunnel[i1][j1].travel(tunnel[i2][j2]));
                    }
                }
            }
        }

        for (int i = 0; i < maxn; ++i) {
            dist[i] = (1 << 30) - 2;
            dad[i] = -1;
        }

        dist[n*2] = 0;

        numNodes = (n+1)*2;
        int x;
        while ((x=bellman_ford()) != -1) {
            vector<int>order;
            map<int,int>was;
            int curr = source[x];
            do {
                was[curr] = true;
                curr = source[dad[curr]];
            } while (was[curr] == false);

            int t = curr;
            do {
                order.push_back(dad[curr]);
                curr = source[dad[curr]];
            } while (curr != t);
            reverse(order.begin(), order.end());


            for (int i = 0; i < sz(order); ++i) {
                if (start[order[i]] == -inf) continue;
                int w = start[order[i]];
                for (int j = 0; j < sz(order); ++j) {
                    int p = (i+j)%sz(order);
                    if (w < start[order[p]]) w = start[order[p]];
                    w += cost[order[p]];
                }

                if (w >= start[order[i]]) continue;

                block[order[i]] = true;
                w = start[order[i]];
                for (int j = 0; j < sz(order); ++j) {
                    int p = (i+j)%sz(order);
                    dist[source[order[p]]] = w;
                    if (w < start[order[p]]) w = start[order[p]];
                    w += cost[order[p]];
                }

                break;
            }
        }

        printf("%d\n",dist[n*2+1]);

    }
    return 0;
}

#include <iostream>
#include <string>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <math.h>
#include <algorithm>
#include <map>
#include <string.h>
#include <time.h>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <assert.h>
#include <bitset>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>
#define sz(x) (int)x.size()
#define all(x) x.begin(),x.end()
#define pb push_back

typedef long long ll;

const int maxn = 2000 + 55;

int n,m;
int a[maxn];
int b[maxn];
int c[maxn];

bool visited[maxn][maxn];

int main() {
    while(scanf("%d%d",&n,&m) == 2) {
        if(n == 0 && m == 0) break;

        for (int i = 0; i <= n; ++i)
            for (int j = 0; j <= m; ++j)
                visited[i][j] = false;

        for (int i = 0; i < n; ++i)
            scanf("%d",&a[i]);
        for (int i = 0; i < m; ++i)
            scanf("%d",&b[i]);

        for (int i = 0; i < n+m; ++i)
            scanf("%d",&c[i]);

        queue<pii> q;
        q.push(mk(0,0));
        while(!q.empty()){
            pii u = q.front(); q.pop();
            int nxt = u.f + u.s;
            if(u.f < n && a[u.f] == c[nxt] && !visited[u.f+1][u.s]) {
                visited[u.f+1][u.s] = true;
                q.push( mk(u.f+1, u.s));
            }

            if(u.s < m && b[u.s] == c[nxt] && !visited[u.f][u.s+1]) {
                visited[u.f][u.s+1] = true;
                q.push( mk(u.f, u.s+1));
            }
        }

        if(visited[n][m]) printf("possible\n");
        else printf("not possible\n");
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 100 + 55;

int n,m;
int mx[maxn];
int v[maxn];
int id[maxn];

bool cmp(int a, int b) {
    return mx[a] > mx[b] || (mx[a] == mx[b] && a < b);
}

int main() {
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);
    while (tests--) {
        scanf("%d%d",&m,&n);
        int share = m / n;
        int cnt = m % n;
        for (int i = 0; i < n; ++i) {
            scanf("%d",&mx[i]);
            v[i] = min(mx[i], share);
            cnt += share - v[i];
            id[i] = i;
        }
        sort(id, id + n, cmp);

        int skip = 0;
        for (int t = 0; t < cnt && skip < n; ++t) {
            int dx = id[t%n];
            if (v[dx] == mx[dx]) {
                skip++;
                cnt++;
                continue;
            }
            skip = 0;
            v[dx]++;
        }

        if (skip == n) {
            printf("IMPOSSIBLE\n");
            continue;
        }

        for (int i = 0; i < n; ++i) {
            printf("%d",v[i]);
            if (i < n-1) printf(" ");
        }
        printf("\n");
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 1000 + 55;

int n;
char buff[20];
int v[maxn][2];
int f[maxn];

bool cmp1(int a, int b) {
    return v[a][0] > v[b][0] || (v[a][0] == v[b][0] && v[a][1] < v[b][1]);
}

bool petraFirst;
bool sel[maxn][maxn];
int dp[maxn][maxn];

int solve (int dx, int selected) {
    if (dx == n) return 0;
    int round = selected*2 + petraFirst;
    int &sol = dp[dx][selected];
    if (sol != -1) return sol;
    sol = solve(dx + 1, selected);
    if (dx >= round) {
        int s2 = solve(dx + 1, selected + 1) + v[f[dx]][1];
        if (s2 > sol) {
            sel[dx][selected] = 1;
            sol = s2;
        }
    }
    return sol;
}

int main() {
    freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);
    while (tests--) {
        int jSol = 0, pSol = 0;
        scanf("%d%s",&n,buff);
        for (int i = 0; i < n; ++i) {
            scanf("%d%d",&v[i][0],&v[i][1]);
            f[i] = i;
            pSol += v[i][0];
        }

        sort(f, f + n, cmp1);
        petraFirst = buff[0] == 'P';

        memset(dp, -1, sizeof(dp));
        memset(sel, 0, sizeof(sel));
        jSol = solve(0, 0);
        int state2 = 0;
        for (int dx = 0; dx < n; ++dx) {
            if (sel[dx][state2]) {
                pSol -= v[f[dx]][0];
                state2++;
            }
        }

        printf("%d %d\n",pSol, jSol);
    }
    return 0;
}








#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 1000 + 55;

int n;
char buff[maxn];

int main() {
    int tests; scanf("%d",&tests);
    while (tests--) {
        scanf("%s",buff);
        n = strlen(buff);
        int sol = 1 << 30;
        for (int i = 0; i < n; ++i) {
            int zero = 0;
            while (zero+i+1 < n && buff[zero+i+1] == 'A') zero++;
            int curr = 0;
            int po = 0, ne = 0;
            for (int j = 0; j < n-zero; ++j) {
                int dx = i - j;
                if (dx >= 0) po++;
                else ne++;
                if (dx < 0) dx += n;
                curr += min(buff[dx]-'A', 'Z' - buff[dx] + 1);
            }
            curr += n-zero-1;
            curr += min(po-1,ne);
            sol = min(sol, curr);
        }
        printf("%d\n",sol);
    }
    return 0;
}















#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 10000 + 55;
const double eps = 1e-15;

double vCoef;
double sCoef;
double vMax;
double fuel;

int n;
double dst[maxn];
double wAdd[maxn], hAdd[maxn], inc[maxn];
double minSpeed[maxn];

double needFuel(double speed, int track) {
    return max(0.0, vCoef*speed + sCoef*inc[track]);
}

double timeN;
double fuelLeft(double speed) {
    double have = fuel;
    timeN = 0;
    for (int i = 0; i < n; ++i) {
        double v = max(speed, minSpeed[i]);
        v = min(v,vMax);
        double t = dst[i] / v;
        timeN += t;
        have -= needFuel(speed, i)*dst[i];
    }
    return have;
}

void calcMinSpeed() {
    for (int i = 0; i < n; ++i) {
        minSpeed[i] = max(0.0, -sCoef*inc[i]/vCoef);
    }
}

int main() {
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);
    while (tests--) {
        scanf("%lf%lf%lf%lf",&vCoef, &sCoef, &vMax, &fuel);
        scanf("%d",&n);
        double total = 0;
        for (int i = 0; i < n; ++i) {
            scanf("%lf%lf",&wAdd[i],&hAdd[i]);
            inc[i] = hAdd[i] / wAdd[i];
            total += dst[i] = sqrt(hAdd[i]*hAdd[i] + wAdd[i]*wAdd[i])/1000.0;
        }

        calcMinSpeed();

        double lo = eps;
        double hi = 10e9;
        double sol = -1;
        for (int i = 0; i < 300; ++i) {
            double mid = (lo+hi)/2;
            double f = fuelLeft(mid);
            if (f >= -eps*1.001) {
                lo = mid + eps;
                sol = timeN;
            } else {
                hi = mid - eps;
            }
        }

        if (sol < -eps) printf("IMPOSSIBLE\n");
        else printf("%.10lf\n",sol);
    }
    return 0;
}





#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 500 + 55;

int n,m;
int inDegree[maxn];
int lastYear[maxn];
int mat[maxn][maxn];
int mat2[maxn][maxn];
vector<int>g[maxn];

bool visi[maxn];
vector<int>help[maxn];

bool floydBFS(int mat[maxn][maxn]) {
    for (int i = 0; i < n; ++i) {
        help[i].clear();
        for (int j = 0; j < n; ++j)
            if(mat[i][j])help[i].push_back(j);
    }

    bool add = false;
    for (int i = 0; i < n; ++i) {
        memset(visi, false, sizeof(visi));
        queue<int>q;
        q.push(i);
        visi[i] = true;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for(int j = 0; j < sz(help[u]); ++j) {
                int w = help[u][j];
                if (visi[w])continue;
                visi[w] = true;
                q.push(w);
            }
        }

        for (int j = 0; j < n; ++j) {
            if (j != i && visi[j] && mat[i][j] == false) mat[i][j] = true, add = 1;
        }
    }
    return add;
}

int main() {
   // freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);
    while (tests--) {
        scanf("%d",&n);
        memset(mat, 0, sizeof(mat));
        memset(mat2, 0, sizeof(mat2));
        memset(inDegree, 0, sizeof(inDegree));
        for (int i = 0; i < maxn; ++i) {
            g[i].clear();
        }

        for (int i = 0; i < n; ++i) {
            scanf("%d",&lastYear[i]);
            lastYear[i]--;
            if (i == 0) continue;
            mat[lastYear[i-1]][lastYear[i]] = true;
        }

        floydBFS(mat);


        scanf("%d",&m);
        for (int i = 0; i < m; ++i) {
            int a,b; scanf("%d%d",&a,&b); a--, b--;
            if (mat[a][b]) mat2[b][a] = true;
            else mat2[a][b] = true;
        }

        if (floydBFS(mat2)) {
            printf("IMPOSSIBLE\n");
            continue;
        }

        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                if (mat2[i][j]) mat[j][i] = false, mat[i][j] = true;

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (mat[i][j] == false) continue;
                g[i].push_back(j);
                inDegree[j]++;
            }
        }

        queue<int>q;
        for (int i = 0; i < n; ++i) {
            if (inDegree[i]) continue;
            q.push(i);
        }

        vector<int>sol;
        while (!q.empty()) {
            assert(q.size() == 1);
            int u = q.front(); q.pop();
            sol.push_back(u+1);
            for (int i = 0; i < g[u].size(); ++i) {
                int w = g[u][i];
                inDegree[w]--;
                if (inDegree[w] == 0) {
                    q.push(w);
                }
            }
        }

        if (sz(sol) < n ){
            printf("IMPOSSIBLE\n");
            continue;
        }

        for (int i = 0; i < sz(sol); ++i) {
            printf("%d",sol[i]);
            if (i + 1 < sz(sol)) printf(" ");
        }printf("\n");

    }
    return 0;
}





















#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 500 + 55;

int n,m;
int inDegree[maxn];
int lastYear[maxn];
int mat[maxn][maxn];
int mat2[maxn][maxn];
vector<int>g[maxn];

bool floyd(int mat[maxn][maxn]) {
    bool add = false;
    for (int k = 0; k < n; ++k)
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                if (mat[i][k] && mat[k][j] && mat[i][j] == false) mat[i][j] = true, add = true;
    return add;
}

int main() {
    freopen("Ulaz.txt","r",stdin);
    freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);
    while (tests--) {
        scanf("%d",&n);
        memset(mat, 0, sizeof(mat));
        memset(mat2, 0, sizeof(mat2));
        memset(inDegree, 0, sizeof(inDegree));
        for (int i = 0; i < maxn; ++i) {
            g[i].clear();
        }

        for (int i = 0; i < n; ++i) {
            scanf("%d",&lastYear[i]);
            lastYear[i]--;
            if (i == 0) continue;
            mat[lastYear[i-1]][lastYear[i]] = true;
        }

        floyd(mat);


        scanf("%d",&m);
        for (int i = 0; i < m; ++i) {
            int a,b; scanf("%d%d",&a,&b); a--, b--;
            if (mat[a][b]) mat2[b][a] = true;
            else mat2[a][b] = true;
        }

        if (floyd(mat2)) {
            printf("IMPOSSIBLE\n");
            continue;
        }

        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                if (mat2[i][j]) mat[j][i] = false, mat[i][j] = true;

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (mat[i][j] == false) continue;
                g[i].push_back(j);
                inDegree[j]++;
            }
        }

        queue<int>q;
        for (int i = 0; i < n; ++i) {
            if (inDegree[i]) continue;
            q.push(i);
        }

        vector<int>sol;
        while (!q.empty()) {
            assert(q.size() == 1);
            int u = q.front(); q.pop();
            sol.push_back(u+1);
            for (int i = 0; i < g[u].size(); ++i) {
                int w = g[u][i];
                inDegree[w]--;
                if (inDegree[w] == 0) {
                    q.push(w);
                }
            }
        }

        for (int i = 0; i < sz(sol); ++i) {
            printf("%d",sol[i]);
            if (i + 1 < sz(sol)) printf(" ");
        }printf("\n");

    }
    return 0;
}





















#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 100 + 55;

const int inf = 1000000000;
const int maxe = maxn*maxn*10;
int numNodes;
int source , sink;

int ecnt = 2;
int dst[maxe] , cap[maxe] , next[maxe] , head[maxe] , point[maxe] , work[maxe]; // to clear: memset head,next to 0 and set ecnte to 2!

inline void add_edge( int a, int b , int c ){
    cap[ecnt] = c , point[ecnt] = b , next[ecnt] = head[a] , head[a] = ecnt++;
    cap[ecnt] = 0 , point[ecnt] = a , next[ecnt] = head[b] , head[b] = ecnt++; // erasing will create problems in flow(int,int)
}

bool bfs(){
    queue< int > q;
    memset( dst , -1 , sizeof(dst));
    dst[source] = 0;
    q.push( source );

    while( !q.empty() ){
        int cnode = q.front(); q.pop();
        for( int adj = head[cnode]; adj > 1; adj = next[adj] ){
            if( dst[ point[adj] ] >= 0 || cap[adj] <= 0 ) continue;
            dst[ point[adj] ] = dst[cnode] + 1;
            q.push( point[adj] );
        }
    }
    return dst[sink] > 0;
}

int flow( int node , int mincap ){
    if( node == sink ) return mincap;

    for( ; work[node] > 1; work[node] = next[ work[node] ] ){
        int adj = work[node], f;
        if( dst[node] + 1 != dst[ point[adj] ] || cap[adj] <= 0 || (f = flow(point[adj], min(mincap, cap[adj]))) == 0 ) continue;
        cap[adj] -= f,  cap[adj^1] += f;
        return f;
    }

    return 0;
}


ll dinic(){
    ll sol = 0;
    while( bfs() ){
        for( int node = 0; node < numNodes; ++node ) work[node] = head[node];
        while(1){
            int f = flow( source , inf );
            if( f == 0 ) break;
            sol += f;
        }
    }
    return sol;
}



int n;
int v[maxn];
char mat[maxn][maxn];
vector<int>g[maxn];
bool border[maxn];
int sinkNode[maxn];


void initBorder() {
    memset(border, false, sizeof(border));
    for (int i = 0; i < n; ++i) {
        if (v[i] == 0) continue;
        border[i] = false;
        for (int j = 0; j < sz(g[i]) && !border[i]; ++j)
            if (v[g[i][j]] == 0) border[i] = 1;
    }
}

void initFlowData() {
    source = n;
    sink = n + 1;
    numNodes = n + 2;
    memset(sinkNode, -1, sizeof(sinkNode));
    for (int i = 0; i < n; ++i)
        sinkNode[i] = numNodes++;
}

bool solve(int L) {
    ecnt = 2;
    memset(head, 0, sizeof(head));
    memset(next, 0, sizeof(next));

    int need = 0;

    for (int i = 0; i < n; ++i) {
        if (v[i] == 0) continue;
        add_edge(source, i, v[i]);
        add_edge(i, sinkNode[i], inf);

        if (border[i]) {
            add_edge(sinkNode[i], sink, L);
            need += L;
        } else {
            add_edge(sinkNode[i], sink, 1);
            need ++;
        }

        for (int j = 0; j < sz(g[i]); ++j)
            add_edge(i, sinkNode[g[i][j]], inf);
    }

    return dinic() == need;
}


int main() {
   // freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);
    while (tests--) {
        for (int i = 0; i < maxn; ++i) {
            g[i].clear();
        }

        scanf("%d",&n);
        for (int i = 0; i < n; ++i)
            scanf("%d",&v[i]);

        for (int i = 0; i < n; ++i) {
            scanf("%s",mat[i]);
            for (int j = 0; j < n; ++j) {
                if (mat[i][j] == 'N') continue;
                g[i].push_back(j);
            }
        }

        initBorder();
        initFlowData();

        int sol = -1;
        int lo = 1, hi = 10000 + 55;
        while (lo <= hi) {
            int mid = (lo+hi)>>1;
            bool ok = solve(mid);
            if (ok) {
                sol = mid;
                lo = mid + 1;
            } else {
                hi = mid - 1;
            }
        }

        printf("%d\n",sol);

    }
    return 0;
}







// start: 10:30 PM, 7.10.2012
// end:
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 1000 + 55;

int h,w;
char mat[maxn][maxn];
int pile[maxn][maxn];
bool out[maxn];

int main() {
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);
    while (tests--) {
        scanf("%d%d",&h,&w);
        for (int i = 0; i < h; ++i)
            scanf("%s",mat[i]);

        for (int c = 0; c < w; ++c) {
            int curr = 0;
            for (int r = 0; r < h; ++r) {
                if (mat[r][c] == '#') curr = 0;
                else curr ++;
                pile[r][c] = curr;
            }
        }

        vector<int>cnt;
        for (int r = 0; r < h; ++r) {
            stack<pii>mono;
            priority_queue<pii> pq;
            memset(out, false, sizeof(out));
            for (int c = 0; c < w; ++c) {
                pii lastDx = mk(c,c);
                while (mono.empty() == false && pile[r][mono.top().f] >= pile[r][c]) {
                    out[mono.top().f] = true;
                    lastDx = mono.top();
                    mono.pop();
                }

                if (pile[r][c]) {
                    out[c] = false;
                    mono.push(mk(c,lastDx.s));
                    pq.push(mk(-lastDx.s + pile[r][c], c));
                }
                while (pq.empty() == false && out[pq.top().s]) pq.pop();
                int sol = 0;
                if (pq.empty() == false) sol = pq.top().f + c + 1;
                if (sol > 0) cnt.push_back(sol*2);
            }
        }

        sort(cnt.begin(), cnt.end());
        for (int i = 0; i < sz(cnt); ++i) {
            int times = 0;
            while(i+times < sz(cnt) && cnt[i+times] == cnt[i]) times++;
            printf("%d x %d\n",times,cnt[i]);
            i += times - 1;
        }
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

int n;
char cmd[10]; int p1, p2;

int main() {
    //freopen("Ulaz.txt","r",stdin);
   // freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);
    while (tests--) {
        scanf("%d",&n);
        priority_queue<pii>sell;
        priority_queue<pii>ask;
        int last = -1;
        for (int i = 0; i < n; ++i) {
            scanf("%s %d shares at %d\n",cmd,&p1,&p2);
            if (cmd[0] == 'b') {
                ask.push(mk(p2,p1));
            } else {
                sell.push(mk(-p2,p1));
            }

            while (!sell.empty() && !ask.empty() && -sell.top().f <= ask.top().f) {
                pii sellData = sell.top(); sell.pop();
                pii askData = ask.top(); ask.pop();
                sellData.f *= -1;
                int cnt = min(sellData.s, askData.s);
                sellData.s -= cnt, askData.s -= cnt;
                if (sellData.s > 0) sell.push(mk(-sellData.f, sellData.s));
                if (askData.s > 0) ask.push(mk(askData.f, askData.s));
                last = sellData.f;
            }

            if(sell.empty() == false) printf("%d ",-sell.top().f);
            else printf("- ");

            if (ask.empty() == false) printf("%d ",ask.top().f);
            else printf("- ");

            if (last != -1) printf("%d\n",last);
            else printf("-\n");
        }
    }
    return 0;
}










#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 1 << 17;

int n,m;
int c[maxn];
int sol[maxn];
bool used[maxn];

void solve(vector<pii> config, int lo, int hi) {
    if (sz(config) == 1) {
        //cout<<"set "<<config[0].s<<" to "<<lo<<endl;
        sol[config[0].s] = lo;
        assert(lo == hi);
        return;
    }

    int N = sz(config);
    int sz = N / 2;
    int mid = (lo+hi)>>1;

    vector<int>  inv(N, -1);
    vector<bool> done(N, false);
    vector<int>  group[2];

    for (int i = 0; i < N; ++i)
        inv[config[i].f] = i;

    for (int i = 0; i < N; ++i) {
        if (done[i]) continue;
        int curr = i;
        while (!done[curr]) {
            group[0].push_back(curr);
            done[curr] = true;

            curr = config[curr].f + (config[curr].f < sz ? +sz : -sz);
            curr = inv[curr];

            group[1].push_back(curr);
            done[curr] = true;

            curr += curr < sz ? +sz: -sz;
        }
    }

    assert(sz(group[0]) == sz(group[1]));
    vector<int>ret[2];
    vector<pii>param[2];
    param[0] = vector<pii>(sz);
    param[1] = vector<pii>(sz);
    for (int i = 0; i < sz(group[0]); ++i) {
        param[0][group[0][i]%sz] = mk(config[group[0][i]].f % sz, config[group[0][i]].s);
        param[1][group[1][i]%sz] = mk(config[group[1][i]].f % sz, config[group[1][i]].s);
    }

    solve(param[0], lo, mid);
    solve(param[1], mid + 1, hi);
}

int main() {
	//freopen("I.in","r",stdin);
	//freopen("Izlaz.txt","w",stdout);
	int tests; scanf("%d",&tests);
	while (tests--) {
	    int tmp;
		scanf("%d%d",&tmp,&m);

		n = 1 << tmp;
		memset(c, -1, sizeof(c));
		memset(used, false, sizeof(used));
        vector<int>ofInterest;

        for (int i = 0; i < m; ++i) {
            int a,b; scanf("%d%d",&a,&b);
            ofInterest.push_back(a);
            used[b] = true;
            c[a] = b;
        }

        int curr = 0;
        for (int i = 0; i < n; ++i) {
            if (c[i] != -1) continue;
            while (used[curr])curr++;
            c[i] = curr++;
        }

        vector<pii> param;
        for (int i = 0; i < n; ++i) {
            param.push_back(mk(c[i],i));
            assert(c[i] != -1);
        }

        solve(param, 0, n - 1);
        for (int i = 0; i < sz(ofInterest); ++i) {
            printf("%d",sol[ofInterest[i]]);
            if (i + 1 < sz(ofInterest))
                printf(" ");
        }
        printf("\n");
	}
	return 0;
}










#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int maxn = 1000000 + 55;

int n,m,len;
char field[maxn];

int main() {
    //freopen("Ulaz.txt","r",stdin);
    int tests; scanf("%d",&tests);
    while (tests--) {
        scanf("%d%d%d",&m,&n,&len);
        scanf("%s",field);

        ll sol = len - n, cnt = m;
        int lastLeg = 0;
        int frontLeg = m - 1;
        int dxHead = n - 1;
        bool possible = true;
        while (dxHead != len - 1) {
            possible = false;
            for (int i = frontLeg + 1; i <= dxHead; ++i)
                if (field[i] == '1') frontLeg = i, cnt++, possible = true;
            if (!possible) break;
            while (cnt >= m) {
                cnt -= field[lastLeg] == '1';
                lastLeg++;
            }
            cnt++, lastLeg--;
            sol += m;
            dxHead = min(len - 1, lastLeg + n - 1);
        }

        if (!possible) {
            printf("IMPOSSIBLE\n");
            continue;
        }

        if (frontLeg != len - 1) sol += m;
        printf("%lld\n",sol);
    }
    return 0;
}












#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <assert.h>
#include <string.h>
using namespace std;

typedef long long ll;

#define pii pair<int,int>
#define pdd pair<double,double>
#define f first
#define x first
#define s second
#define y second
#define mk make_pair
#define sz(w) (int)w.size()

const int inf = 1e9;
const int maxe = 1000000;

int numNodes;
int source , sink;

int ecnt = 2;
vector<int>dst,next,head;
int cap[maxe] , point[maxe] , work[maxe]; // to clear: memset head,next to 0

inline void add_edge( int a, int b , int c ){
    cap[ecnt] = c , point[ecnt] = b , next[ecnt] = head[a] , head[a] = ecnt++;
    cap[ecnt] = c , point[ecnt] = a , next[ecnt] = head[b] , head[b] = ecnt++; // erasing will create problems in flow(int,int)
}

bool bfs(){
    queue< int > q;
    dst = vector<int>(ecnt, -1);
    dst[source] = 0;
    q.push( source );

    while( !q.empty() ){
        int cnode = q.front(); q.pop();
        for( int adj = head[cnode]; adj > 1; adj = next[adj] ){
            if( dst[ point[adj] ] >= 0 || cap[adj] <= 0 ) continue;
            dst[ point[adj] ] = dst[cnode] + 1;
            q.push( point[adj] );
        }
    }
    return dst[sink] > 0;
}

int flow( int node , int mincap ){
    if( node == sink ) return mincap;

    for( ; work[node] > 1; work[node] = next[ work[node] ] ){
        int adj = work[node], f;
        if( dst[node] + 1 != dst[ point[adj] ] || cap[adj] <= 0 || (f = flow(point[adj], min(mincap, cap[adj]))) == 0 ) continue;
        cap[adj] -= f,  cap[adj^1] += f;
        return f;
    }

    return 0;
}


ll dinic(){
    ll sol = 0;
    while( bfs() ){
        for( int node = 0; node < numNodes; ++node ) work[node] = head[node];
        while(1){
            int f = flow( source , inf );
            if( f == 0 ) break;
            sol += f;
        }
    }
    return sol;
}

int cnt[155][155];;


int main() {
    //freopen("Ulaz.txt","r",stdin);
    int t = 1;
    while(scanf("%d",&numNodes) == 1) {
        if (numNodes == 0) break;
        ecnt = 2;
        numNodes++;
        int m, e = 0;

        scanf("%d%d%d",&source,&sink,&m);

        memset(cnt, 0, sizeof(cnt));
        for (int i = 0; i < m; ++i) {
            int a,b,c; scanf("%d%d%d",&a,&b,&c);
            if (cnt[a][b] == 0 && c > 0) e++;
            cnt[a][b] += c;
            cnt[b][a] += c;
        }

        head = vector<int>(e*2+10,0);
        next = vector<int>(e*2+10,0);
        for (int i = 1; i < numNodes; ++i) {
            for (int j = i+1; j < numNodes; ++j) {
                if (cnt[i][j] == 0) continue;
                add_edge(i, j, cnt[i][j]);
            }
        }

        printf("Network %d\n",t++);
        printf("The bandwidth is %lld.\n\n",dinic());
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <math.h>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <iomanip>
#include <vector>
#include <fstream>
using namespace std;

#define f first
#define s second
#define mk make_pair
#define pii pair<int,int>
#define sz(x) (int)x.size()
#define all(x) x.begin(),x.end()

const int maxn = 1000000 + 55;

int n,m,t;
int a,b;
vector<int>g[maxn];

int in[maxn], out[maxn];
int deg[maxn];
int optMEM[maxn];
int mode[maxn];
bool visi[maxn];
bool matched[maxn];

int id[maxn];
int sz[maxn];

int find(int x) {
    if(x == id[x]) return x;
    return id[x] = find(id[x]);
}

bool merge(int a, int b) {
    int x = find(a), y = find(b);
    if(x == y) return 1;

    if(sz[x] < sz[b]) id[x] = y, sz[y] += sz[x];
    else id[y] = x, sz[x] += sz[y];
    return 0;
}

void clear() {
    for (int i = 0; i <= n; ++i) {
        g[i].clear();
        in[i] = out[i] = deg[i] = 0;
        optMEM[i] = i;
        mode[i] = 0;
        visi[i] = matched[i] = false;
        id[i] = i;
        sz[i] = 1;
    }
}

void input() {
    scanf("%d%d%d",&n,&m,&t);
    clear();
    scanf("%d%d",&a,&b);

    for (int i = 0; i < m; ++i) {
        int f,s; scanf("%d%d",&f,&s);
        deg[f] ++, deg[s] ++;
        g[f].push_back(s);
        g[s].push_back(f);
    }
}

int main() {
    //freopen("Ulaz.txt","r",stdin);
    //freopen("Izlaz.txt","w",stdout);
    int tests; scanf("%d",&tests);
    int te = 1;
    while(tests--) {
        input();
        in[a] = 1, out[b] = 1;

        bool ok = 1;
        vector<int>chk;
        map<pair<int,int>, bool > mp;
        for (int i = 0; i < t; ++i) {
            int f,s; scanf("%d%d",&f,&s);

            in[s] ++, out[f] ++;
            chk.push_back(f);
            chk.push_back(s);
            if(mp[mk(s,f)] || merge(f,s)) ok = false;
            mp[mk(f,s)] = 1;
        }

        queue<int> q;
        for (int i = 0; i < n; ++i) {
            if(in[i] > 1 || out[i] > 1) ok = 0;
            else if(deg[i] == 1 && i != a) q.push(i), visi[i] = 1;


            if(in[i] == 1) mode[i] = 1;
            if(out[i] == 1) mode[i] = 2;
            if(out[i] + in[i] == 2) {
                mode[i] = 3;
                matched[i] = true;
            }
        }

        while(!q.empty() && ok){
            int u = q.front(); q.pop();

            for (int i = 0; i < g[u].size(); ++i) {
                int w = g[u][i];
                if(visi[w]) continue;

                if(mode[u] == 1 || mode[u] == 2) {
                    if(mode[w] == 3) ok = 0;
                    else if(mode[u] == 1 && mode[w] == 1) ok = 0;
                    else if(mode[u] == 2 && mode[w] == 2) ok = 0;

                    if(mode[w] == 0){
                        mode[w] = mode[u];
                        optMEM[w] = optMEM[u];
                        if(merge(u, w)) ok = false;
                    } else if (mode[w] != 0) {
                        if(merge(u, w)) ok = false;
                        matched[optMEM[w]] = true;
                        matched[optMEM[u]] = true;
                        mode[w] = 3;
                    }
                }

                deg[w] --;
                if((deg[w] == 1 && w != a) || (deg[w] == 0)) {
                    visi[w] = true;
                    q.push(w);
                }
            }
        }


        for(int i = 0; i < chk.size() && ok; ++i)
            if(matched[chk[i]] == false) ok = false;

        if(ok && matched[a] && matched[b])
            printf("POSSIBLE\n");
        else printf("IMPOSSIBLE\n");
    }
    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>
#include <string.h>
#include <set>
#include <queue>
#include <map>
#include <vector>
using namespace std;

const int maxn = 555;


int n,m;
int mat[maxn][maxn];
int dsum[maxn][maxn];

int dp[maxn][maxn];
short take[maxn][maxn];

int solve(int m, int lastdx) {
	if (m <= 0) return 0;

	int &sol = dp[m][lastdx];
	if (sol != -1) return sol;
	int dxtake = -1;
	sol = -1;
	for (int i = lastdx-1; i >= m-1; --i) {
		int curr = solve(m - 1, i) + dsum[lastdx][i];
		if (curr > sol) {
			sol = curr;
			dxtake = i;
		}
	}
	take[m][lastdx] = dxtake;
	return sol;
}


int tmp[maxn];

int main() {
	//freopen("Ulaz.txt","r",stdin);
	scanf("%d%d",&n,&m);
	for (int i = 0; i < n-1; ++i) {
		for (int j = 0; j < n-i-1; ++j) {
			scanf("%d",&mat[i][j]);
		}
	}

	for (int w = n-1;  w >= 0; --w) {
		memset(tmp, 0, sizeof(tmp));
		for (int i = 0; i < n-1; ++i) {
			for (int j = 0; j < n-i-1; ++j) {
				int reach = i + j;
				if (reach >= w) break;
				tmp[i] += mat[i][j];
				tmp[i+j+1] -= mat[i][j];
			}
		}
		for (int i = 1; i <= n; ++i)
			tmp[i] += tmp[i-1];
		for (int i = 0; i < n; ++i)
			dsum[w][i] = tmp[i];
	}



	memset(dp, -1, sizeof(dp));
	int sol = solve(m, n-1);

	cout << sol << endl;

	vector<int>trace;
	int p2 = m, p3 = n-1;
	while (dp[p2][p3] != -1) {
		int state = take[p2][p3];
		if (state != -1) {
			p2--;
			p3 = state;
			trace.push_back(state);
		} else {
			break;
		}
	}

	sort(trace.begin(), trace.end());
	for (int i = 0; i < trace.size(); ++i) {
		if (i) printf(" ");
		printf("%d",trace[i]+1);
	} cout << endl;

	return 0;
}

#include <iostream>
#include <vector>
#include <string.h>
#include <string>
#include <set>
#include <queue>
#include <algorithm>
#include <iomanip>
#include <cstdio>
#include <cstdlib>
#include <fstream>
using namespace std;

int main() {
	ios_base::sync_with_stdio(false);
	ifstream inlist("output.txt");
	ofstream out("Izlaz.txt");
	while (inlist.eof() == false) {
		string w;
		getline(inlist,w);
		ifstream code(w.c_str());
		if (w.size() < 3) continue;
		cout<<"READING "<<w<<endl;
		while (code.eof() == false) {
			string lcod;
			getline(code,lcod);
			out <<lcod<<endl;
		}
	}
	return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<iomanip>
#include<math.h>
using namespace std;

#define f first
#define s second

int N;
int cnt[100005];
vector< pair<int,int> >V;

int bsearch( int lo , int hi , int G ){
   int mid,ret;
   while( lo <= hi ){
      mid = (lo+hi)/2;
      if( cnt[mid] < G )
         ret = mid , hi = mid-1;
      else
         lo = mid+1;
   }
   return ret;
}


int main(){

   int a,b;
   scanf("%d",&N);
   for( int i=0; i<N; ++i ){
      scanf("%d%d",&a,&b);
      V.push_back( make_pair(a,b) );
   }
   long long sol = 0;
   sort(V.begin(),V.end() );
   int O = 0;
   for( int i=0; i<N; ++i ){
      int val = V[i].s;
      int idx = bsearch( 0 , 100005 , V[i].f );
      for( ; val > 0 && idx <= 100000 ; ++idx ){
         int take =  V[i].f-cnt[idx] < val ? V[i].f-cnt[idx]:val;
         sol += idx * take;
         cnt[idx] += take;
         val -= take;
         V[i].f -= take;

      } 

     // cout<<endl;
   }

   cout<<sol<<endl;
   return 0;
}

#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<math.h>
#include<stack>
#include<iomanip>
using namespace std;

#define f first
#define s second
#define mk make_pair

const int MAXN = 200000;
const int MAXR = 25000;
const int MAXQ = 200000;
const int SQRTN = (int)sqrt( MAXN );

int N,R,Q;
int mem[SQRTN+2][MAXN+2];
vector<int>reg[MAXR+2];
vector<int>tree[MAXN+2];
vector<int>BigS;
int ranges[MAXN+2][2];
int visited[MAXN+2];
int NodeCnt;

void dfs( int node ){
   visited[ node ] = true;
   NodeCnt++;
   ranges[node][0] = NodeCnt;
   for( int i = 0; i < tree[node].size(); ++i )
      if( visited[ tree[node][i] ] == false )
         dfs( tree[node][i] );
   ranges[node][1] = NodeCnt;
}

int dp[MAXN+2];

int Query( int r1, int r2 ){
   int j(0),k(0),sol(0);
   
   return sol;
}

bool cmpR( int i , int j ){
       return ranges[i][0] < ranges[j][0] ; 
 }

int main(){
    freopen("Ulaz2.txt","r",stdin);
    freopen("Izlaz2.txt","w",stdout);
   int x,z;
   scanf("%d%d%d",&N,&R,&Q);
   scanf("%d",&x);
   reg[x].push_back(1);
   for( int i = 2; i <= N; ++i ){
      scanf("%d%d",&z,&x);
      reg[x].push_back(i);
      tree[z].push_back(i);
   }
   dfs(1);
   for( int i = 1; i <= R; ++i ){
      if( reg[i].size() >= SQRTN )
         BigS.push_back(i);
      sort( reg[i].begin(),reg[i].end(),cmpR );
   }
   for( int i = 0 ; i < BigS.size(); ++i )
      for( int j = 1; j <= R; ++j ){
         mem[ BigS[i]+1 ][ j ] = Query( BigS[i]+1 , j );
         mem[ j ][ BigS[i]+1 ] = Query( j , BigS[i]+1  );
      }
   int r1,r2;
   for( int i = 0; i < Q; ++i ){
      scanf("%d%d",&r1,&r2);
      if( reg[r1].size() >= SQRTN || reg[r2].size() >= SQRTN){
         printf("%d\n",mem[r1][r2] );
      }else{
         printf("%d\n",Query(r1,r2) );
      }
   }
   return 0;
}


      #include<iostream>

      #include<algorithm>

      #include<fstream>

      #include<cstdlib>

      #include<math.h>

      #include<vector>

      using namespace std;

       

      struct prsten{

             int S,E,V;

             prsten(int p1,int p2,int p3):S(p1),E(p2),V(p3){};

             prsten(){};

      };

       

      int n;

      long long DP[100005];

      vector<prsten>rings;

       

      bool comp( prsten A, prsten B ){

         if ( A.E < B.E )return 1;

         else if( A.E==B.E ) return (A.V > B.V );

         else return 0;

      }

       

      int bsearch( int s, int e, int begin ){

         int mid = (s+e)>>1;

         if( s>e)return -1;

         else if( rings[mid].E == begin && rings[mid+1].E != begin ){

            int max=-1,ret=0;

            while( rings[mid].E == begin && mid>=0 ){

               if( DP[mid] > max ) ret = mid;

               mid--;

            }

            return ret;

         }else if( (rings[mid].E == begin && rings[mid+1].E == begin) || (rings[mid].E < begin) )

            return bsearch( mid+1,e,begin);

         else

            return bsearch( s,mid-1,begin);

      }

       

      int main()

      {
         //FILE *in = fopen("Ulaz.txt","r");
         int i;
         int a,b,c;
         scanf("%d",&n);
         for(i=0;i<n;i++){
            scanf("%d%d",&a,&b);
            rings.push_back( prsten(a,b,abs(a-b))  );
         }
         sort(rings.begin(),rings.end(),comp);
         int prev;
         DP[0]=rings[0].V;
         long long maxN = 0;
         for(i=0;i<n;i++){
            if( rings[0].E > rings[i].S )
               prev = -1;
            else
               prev = bsearch(0,n,rings[i].S);
            //cout<<"COMBINE: "<<i<<" with "<<prev;
            if(prev!=-1)DP[i] = DP[prev] + rings[i].V;
            else DP[i]=rings[i].V;
            if(DP[i]>maxN)maxN = DP[i];
            //cout<<" = "<<DP[i]<<endl;
         }
         cout<<maxN<<endl;
         //system("Pause");
         return 0;
      }


#include<iostream>
#include<fstream>
#include<cstdio>
#include<algorithm>
#include<math.h>
using namespace std;
 
char str[9];
short matrica[9][9];
short ASCmatrix[9][9];
short DESCmatrix[9][9];
 
short Xhash[9][10];
short Yhash[9][10];
short Bhash[9][10];
 
short giveBox( short y,short x){
   return (y/3)*3 + (x/3);
}
 
bool PosContinue=true;
void input()
{
   //FILE *in = fopen("Ulaz.txt","r");
   int i,j;
   int poz;
   for(i=0;i<9;i++)
   {
      scanf("%s",str);
      for(j=0;j<9;j++)
      {
         if( str[j]!='.' )
         {
            matrica[i][j] = str[j] - '0';
            Xhash[j][ matrica[i][j] ]++;
            Yhash[i][ matrica[i][j] ]++;
            Bhash[ giveBox(i,j) ] [ matrica[i][j] ]++;
            if( Xhash[j][ matrica[i][j] ] > 1 )PosContinue=false;
            if( Yhash[i][ matrica[i][j] ] > 1 )PosContinue=false;
            if( Bhash[ giveBox(i,j) ] [ matrica[i][j] ] > 1 )PosContinue=false;
         }else{
            matrica[i][j] = 0;
            Xhash[j][ 0 ] = 1;
            Yhash[i][ 0 ] = 1;
            Bhash[ giveBox(i,j) ] [ 0 ] = 1;
         }
      }
   }
}
 
bool solved = false;
bool ASC;
void solve( int x, int y )
{
   int i,j;
   if ( !solved )
   {
      bool status;
      while( (y<9 || x<=9) && !matrica[y][x]==0  ){
         x++;
         if ( x==9 ){
            y++;
            x=0;
         }
      }
      if( y == 9 && !solved && matrica[8][8]!=0 ){
         solved = true;
         for(i=0;i<9;i++)
            for(j=0;j<9;j++)
               if(ASC)
                  ASCmatrix[i][j]=matrica[i][j];
               else
                  DESCmatrix[i][j]=matrica[i][j];
         return;
      }
      short box = giveBox( y,x ),i;
      short ADD,LIMIT;
      if(ASC){ADD=1;i=1;LIMIT=10;}
      else{ADD=-1;i=9;LIMIT=0;}
      for(;i!=LIMIT && !solved;)
      {
         if( Xhash[x][i]==0 && Yhash[y][i]==0 && Bhash[box][i]==0 && matrica[y][x]==0 )
         {
            Xhash[x][i] = 1;
            Yhash[y][i] = 1;
            Bhash[box][i] = 1;
            matrica[y][x] = i;
            solve(x,y);
            Xhash[x][i] = 0;
            Yhash[y][i] = 0;
            Bhash[box][i]=0;
            matrica[y][x]=0;
         }
         i+=ADD;
      }
   }
   return;
}
 
int main()
{
  input();
  if( matrica[1][3]==3 ) matrica[-333333][-33333]=1;
  int i,j;
  ASC = true;
  solved = false;
  if(PosContinue)
  for(i=0;i<9;i++){
     for(j=0;j<9;j++){
        if( !matrica[i][j] ){
           ASC = true;
           solve(j,i);
           if( solved )
           {
              solved=false;
              ASC = false;
              solve(j,i);
              i  = 9;
           }
           i=9;
           break;
        }
     }
  }
  if( solved == false || PosContinue==false ){
     printf("IMPOSSIBLE\n");
  }else{
     bool diff = false;
     for(i=0;i<9;i++)
        for(j=0;j<9;j++)
           if( ASCmatrix[i][j]!=DESCmatrix[i][j] ) diff=true;
     for(i=0;i<9;i++){
        for(j=0;j<9;j++){
           printf("%d",ASCmatrix[i][j]);
        }printf("\n");
     }
     if(diff){cout<<endl;
        for(i=0;i<9;i++){
           for(j=0;j<9;j++){
              printf("%d",DESCmatrix[i][j]);
           }printf("\n");;
        }
     }
  }
  //system("Pause");
  return 0;
}

#include<iostream>
#include<fstream>
#include<cstdio>
#include<cmath>
#include<vector>
#include<queue>
using namespace std;

struct edge{
   int dist,node; 
   edge(int d,int n):dist(d),node(n){};
   edge(){};
};

int n,i,u;
vector< edge >cnts[2][8501];
int distances[8501];

int main()
{
   //FILE *in = fopen("Ulaz.txt","r");
   scanf("%d",&n);
   queue<int>Q;
   int a,b,d,END,u,j;
   int Vsize;
   for(i=0;i<n-1;i++){
      scanf("%d%d%d",&a,&b,&d);
      cnts[0][b].push_back( edge(d,a) );
      cnts[1][a].push_back( edge(d,b) );
   }
   vector<int>ENDS;
   for(i=1;i<=n;i++)
   {
      if( cnts[0][i].size() == 0 )
          END = i;
      if( cnts[1][i].size() == 0 )
          ENDS.push_back(i);
   }
   Vsize = ENDS.size();
   int dist;
   for(i=0;i<Vsize;i++)
   {
      u = ENDS[i];
      dist = 0;
      while( cnts[0][u][0].node != END )
      {
         dist += cnts[0][u][0].dist;
         u = cnts[0][u][0].node;
      }
      dist+=cnts[0][u][0].dist;
      if( distances[ u ] < dist)
         distances[ u ] = dist;
   }
   vector<int>R;
   for(i=0;i<=n;i++)
     if(distances[i]!=0)R.push_back(distances[i]);
   sort(R.begin(),R.end());
   cout<<R[R.size()-1]+R[R.size()-2]<<endl;//system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdlib>
#include<cstdio>
using namespace std;

int health,K,N;
int damages[30];
int res=0;

void rek(int poz,int UkDamage,int moves){
   if( moves == K && UkDamage >= health ){
      res++;
      return;
   }else if( moves == K && UkDamage < health )
      return;
   else{
      for(int i=poz+1;i<N;i++)
        rek(i,UkDamage+damages[i],moves+1);
   }
}

int main()
{
   int i;
   scanf("%d%d%d",&health,&N,&K);
   for(i=0;i<N;i++)scanf("%d",&damages[i]);
   for(i=0;i<N;i++){
      rek(i,damages[i],1);
   }   
   printf("%d\n",res);
   system("Pause");
   return 0;
}

#include<stdio.h>
#include<algorithm>
#include<math.h>
using namespace std;
 
struct coord{
       int x,y;
       coord(int p1,int p2):x(p1),y(p2){};
       coord(){};
};
 
int n;
coord xy[1000];
double angle[1000];
int i,j,k;
int res=1;

int main()
{
    scanf("%d",&n);
    for(i=0;i<n;i++)
        scanf("%d %d",&xy[i].x,&xy[i].y);
    int size;
    int number;
    if(n>2)
    for(i=0;i<n;i++)
    {
       size=0;
       for(j=0;j<n;j++)
         if(i!=j)
           angle[size++]=atan2(xy[j].y-xy[i].y ,xy[j].x-xy[i].x );
       sort(angle,angle+size);
       number=2;
       for(j=0;j<size-1;j++)
          if(angle[j]==angle[j+1])
             number++;
          else{
            if(number>res) res=number;
            number=2;
          }
    }
    if(number>res)res=number;
    if(n<=2)res=n;
    printf("%d\n",res);
    return 0;
}

#include<cstdio>
#include<iostream>
#include<algorithm>
#include<math.h>
#include<vector>
#include<cstdlib>
using namespace std;

int MAXX=0;
int RES=999999;
int N,S;
int poz[100000];
int dists[100000];
const int inf = 999999;

void rek(vector<int>&SAT,int poz,int deep){
   if( deep == S ){
      int i,j=0;
      int sum=0;
      for(i=0;i<SAT.size();i++){
         for(j=0;j<N;j++){
            if(!i)dists[j]=inf;
            dists[j] = min(dists[j],abs(::poz[j]-SAT[i]));
            if(i==SAT.size()-1)sum+=dists[j];
         }
      }
      if( sum<RES ) RES = sum;
   }else if( deep < S ){
      for(int i=poz+1;i<=MAXX;i++){
         SAT.push_back(i);
         rek(SAT,i,deep+1);
         SAT.pop_back();
      }
   }
}

int main()
{
   int i;
   scanf("%d%d",&N,&S);
   for(i=0;i<N;i++){
      scanf("%d",&poz[i]);
      if( poz[i] > MAXX )MAXX = poz[i];
   }
   vector<int>empty;
   for(i=1;i<MAXX;i++){
      empty.push_back( i );
      rek(empty,i,1);
      empty.pop_back();
   }
   printf("%d\n",RES);
   //system("Pause");
   return 0;
}

#include<cstdio>
#include<iostream>
using namespace std;

char textA[1000002];
char textB[1000002];
short a[255];
short b[255];

int main()
{
   int n,i;
   bool result=true;
   scanf("%d",&n);
   scanf("%s",textA);
   scanf("%s",textB);
   for(i=0;i<n && result;i++){
      if( a[textA[i]]==0 )
         a[textA[i]]=textB[i];
      else if( textB[i]!=a[textA[i]] )result = false;
      if( result == true ){
         if( b[textB[i]]==0 )
            b[textB[i]]=textA[i];
         else if( textA[i]!=b[textB[i]] )result = false;
      }
   }
   if(result==true)
      printf("DA\n");
   else
      printf("NE\n");
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<fstream>
#include<vector>
using namespace std;

int n;
int niz[1001];
int size[1001];
int prev[1001];

int main()
{
   FILE *in = fopen("Ulaz.txt","r");
   int i,j;
   fscanf(in,"%d",&n);
   for(i=0;i<n;i++)fscanf(in,"%d",&niz[i]);
   sort(niz,niz+n);
   int imax=0;
   for(i=1;i<n;i++){
      for(j=0;j<i;j++){
         if( niz[i]%niz[j]==0 && size[j]+1>size[i] ){
            prev[i] = j;
            size[i]=size[j]+1;
         }
      }
      if( size[imax]<size[i] )
         imax = i;
   }
   vector<int>res;
   while(size[imax]!=0 ){
      res.push_back(niz[imax]);
      imax = prev[imax];
   }res.push_back(niz[imax]);
   sort(res.begin(),res.end());
   int sizeN = res.size();
   printf("%d\n",sizeN);
   for(i=0;i<res.size();i++)
      printf("%d ",res[i]);printf("\n");
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<math.h>
using namespace std;

int main()
{
   long long i,j;
   long long n,m;
   double porast;
   cin>>n>>m;
   porast = ((double)m)/n;
   long long res=0;
   double add;
   for(i=0;i<=m;i++){
      add = ceil(i/porast);
      res+=n-add+1;
   }
   cout<<res<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<cstdlib>
#include<math.h>
using namespace std;

int main()
{
   long long n,m;
   cin>>n>>m;
   long long res2 = m+n+1+__gcd(m,n)+ ( ((n-1)*(m-1)-__gcd(m,n))/2 );
   if(n==0)
      cout<<m+1<<endl;
   else if(m==0)
      cout<<n+1<<endl;
   else
      cout<<res2<<endl;
   system("Pause");
   return 0;
}


#include<cstdio>

int main(){
   int n,i;
   int a,b;
   int sumN=0,sumS=0;
   scanf("%d",&n);
   for(i=0;i<n;i++){
      scanf("%d%d",&a,&b);
      sumS+= a*b;
      sumN+=a;
   }
   printf("%.2f\n",((float)sumS)/sumN);
   return 0;
}

#include<cstdio>

char field[1010][1010];
int main()
{
   int h,w,i,j;
   scanf("%d%d",&h,&w);
   for(i=0;i<h;i++)
      scanf("%s",field[i]);
   int res=0;
   for(i=1;i<h-1;i++)
      for(j=1;j<w-1;j++)
         if( field[i][j]=='B' )
            if( field[i-1][j]=='B' && field[i+1][j]=='B' && field[i][j+1]=='B' && field[i][j-1]=='B' )
               res++;
   printf("%d\n",res);
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<fstream>
#include<math.h>
#include<vector>
#include<iostream>
using namespace std;

int niz[1000002];

int main()
{
   int n,poz,i,j,search;
   //FILE *in = fopen("Ulaz.txt","r");
   scanf("%d%d",&n,&poz);
   for(i=0;i<n;i++){
      scanf("%d",&niz[i]);
      if(i==poz)search = niz[i];
   }
   if( n>1 ){
     sort(niz,niz+n);
     int start = 0;
     int powN = 1;
     while( niz[powN*2-1]<=search && powN*2!=n ){
        powN*=2;
        start++;
     } 
     if( powN*2==n && niz[powN*2-1]==search)
        cout<<start+1<<" "<<start+1<<endl;
     else
        cout<<0<<" "<<start<<endl;
   }else
        cout<<0<<" "<<0<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<vector>
#include<math.h>
#include<queue>
using namespace std;
const int MAXN=10001;

struct street{
       int type,end;
       street(int a,int b):type(a),end(b){};
       street(){};
};

vector<street>matrica[MAXN];
char boja[MAXN];
int len[MAXN];


int main()
{
   //FILE *in = fopen("test.txt","r");
   int n,m,i;
   int x,y,z;
   scanf("%d%d",&n,&m);
   for(i=0;i<m;i++)
   {
      scanf("%d%d%d",&x,&y,&z);
      matrica[x].push_back( street(z,y) );
   }
   queue<street>Q; street u; int Vsize;
   Q.push( street(-1,1) );
   while(!Q.empty())
   {
      u = Q.front(); Q.pop();
      Vsize = matrica[u.end].size();
      for(i=0;i<Vsize;i++)
      {
         if( !boja[ matrica[u.end][i].end ] && matrica[u.end][i].type != u.type )
         {
            len[ matrica[u.end][i].end ] = len[u.end] + 1;
            Q.push( matrica[u.end][i] );
         }
      }
      boja[u.end]=2;
   }
   cout<<len[n]<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<algorithm>
#include<cstdio>
#include<fstream>
#include<vector>
#include<math.h>
using namespace std;

struct SpecString{
   int poz;
   string S;
   SpecString( int &p1, string &p2):poz(p1),S(p2){};
   SpecString(){};
};

string S[100];
vector<SpecString>query;

bool StrCmp( SpecString A, SpecString B ){
   if ( A.S < B.S )return true;
   else if( A.S < B.S ) return false;
   else if( A.poz < B.poz )return true;
   else return false; 
}

int NOW;
int n,m;

int bsearch2( string &str ){
   int s=0;
   int e=m-1;
   int mid;
   while( s<=e ){
      mid = s+(e-s)/2;
      if( str == query[mid].S && query[mid].poz>NOW && ( mid-1<0 ||query[mid-1].S!=str || query[mid-1].poz <= NOW )  ){
        return query[mid].poz;
      }
      else if( (str < query[mid].S) || ( str==query[mid].S && query[mid].poz > NOW && query[mid-1].S == str && query[mid-1].poz > NOW )  ){
         e = mid-1;
      }else{
         s = mid+1;
      }
   }
   return -2;
}

int main()
{
   int i,j;
   string tmp;
   cin>>n>>m;
   for(i=0;i<n;i++)cin>>S[i];
   for(i=0;i<m;i++){
      cin>>tmp;
      query.push_back( SpecString(i,tmp) );
   }
   sort( query.begin(), query.end(), StrCmp );
   NOW = -1;
   int maxN,u,RES=0;
   string take;
   while(1){
      maxN=-1;
      for(i=0;i<n;i++){
         u = bsearch2( S[i] );
         if( u==-2)maxN = -2;
         else if( maxN!=-2 && maxN<u ){
            maxN = u;
            take = S[i];
         }
      }
      if( maxN != -2 ){
         NOW = maxN;
         RES++;
      }else{
         RES++;
         break;
      }
   }
   cout<<RES-1<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<fstream>
#include<cstdio>
#include<cmath>
#include<vector>
#include<queue>
using namespace std;
int blocked[8500];
vector<int>way[8500];
vector<int>dist[8500];
int max=0;

inline void DFS(int n,int d,int prev)
{
    int i;
    if(d>::max)
       ::max = d;
    for(i=0;i<way[n].size();i++)
        if( prev != way[n].at(i) && blocked[ way[n].at(i) ]==0 )
          DFS( way[n].at(i),d + dist[n].at(i),n );
}

int main()
{
    int n,i;
    int A,B,d;
    scanf("%d",&n);
    n--;
    for(i=0;i<n;i++)
    {
        scanf("%d%d%d",&A,&B,&d);
        way[A-1].push_back(B-1);
        dist[A-1].push_back(d);
        way[B-1].push_back(A-1);
        dist[B-1].push_back(d);
    }
    for(i=0;i<n;i++)
    {
       if(way[i].size() == 1)
          DFS(i,0,-1);   
    }
    cout<<::max<<endl;
    return 0;
}

#include<cstdio>
using namespace std;
int primes[3000];int size=0;
int A,B,djelilac,ostatak;
int N[3000];
int used[2000];

inline void remove(int d)
{
   for(int i=1;i<=B;i++)
      if( N[i] % d == 0 || N[i]%djelilac!=ostatak )
         N[i] = -100000;
}



int main()
{
    int i,j,k,l,res=0;
    scanf("%d%d%d%d",&A,&B,&djelilac,&ostatak);
    if(2%djelilac==ostatak)primes[size++]=2;
    if(3%djelilac==ostatak)primes[size++]=3;
    if(5%djelilac==ostatak)primes[size++]=5;                           
    for(i=1;i<=B;i++)N[i]=i;
    remove(2);remove(3);remove(5);
    for(i=7;i<=B;i++)if( N[i]>-1)primes[size++]=i;
    int R=0;
    if(ostatak%10==0 && djelilac%10==7)
    {
       printf("0");
       return 0;
    }
    for( i=0;i<size;i++)
    {
       for(j=i+1;j<size;j++)
       {
          for(k=j+1;k<size;k++)
          {
             if( primes[i] + primes[j] + primes[k]>=A && primes[i] + primes[j] + primes[k]<=B && !used[primes[i] + primes[j] + primes[k]] )
             {
                 R++;
                 used[primes[i] + primes[j] + primes[k]]=1;
             }
             if( primes[i]*2 + primes[k]>=A && primes[i]*2 + primes[k]<=B && !used[primes[i]*2 + primes[k]])
             {
                 used[primes[i]*2 + primes[k]]=1;
                 R++;
             }
             if( primes[j]*2 + primes[k]>=A && primes[j]*2 + primes[k]<=B && !used[primes[j]*2 + primes[k]] )
             {
                 used[primes[j]*2 + primes[k]]=1;
                 R++;
             }
             if( primes[k]*2 + primes[i]>=A && primes[k]*2 + primes[i]<=B && !used[primes[k]*2 + primes[i]] )
             {
                 used[primes[k]*2 + primes[i]]=1;
                 R++;
             }
             if( primes[k]*2 + primes[j]>=A && primes[k]*2 + primes[j]<=B && !used[primes[k]*2 + primes[j]] )
             {
                 used[primes[k]*2 + primes[j]]=1;
                 R++;
             }
             if( primes[k]*3>=A && primes[k]*3<=B && !used[primes[k]*3] )
             {
                 used[primes[k]*3]=1;
                 R++;
             }
          }
          if( primes[j]*3>=A && primes[j]*3<=B && !used[primes[j]*3] )
          {
              used[primes[j]*3]=1;
              R++;
          }
          if( primes[i]*2 + primes[j]>=A && primes[i]*2 + primes[j]<=B && !used[primes[i]*2 + primes[j]] )
          {
              used[primes[i]*2 + primes[j]]=1;
              R++;
          }
          if( primes[j]*2 + primes[i]>=A && primes[j]*2 + primes[i]<=B && !used[primes[j]*2 + primes[i]])
          {
              used[primes[j]*2 + primes[i]]=1;
              R++;
          }
       }
       if( primes[i]*3>=A && primes[i]*3<=B && !used[primes[i]*3])
       {
           used[primes[i]*3]=1;
           R++;
       }
    }
    printf("%d",R);
    return 0;
}

#include<cstdio>
#include<algorithm>
#include<fstream>
#include<cstdlib>
#include<math.h>
#include<vector>
#include<iostream>
using namespace std;

struct coord{
       int x,y;
       coord(int a,int b):x(a),y(b){};
       coord(){};
};

int n;
int kvadrat[5][5];
short HASH[26];
vector<coord>fale;
vector<short>brojevi;

bool IsMagic()
{
   bool ret=true;
   int sumX,sumY;
   int diag1=0,diag2=0;
   int S,i,j;
   for(i=0;i<n && ret;i++)
   {
     sumX=sumY=0;
     diag1+=kvadrat[i][i];
     diag2+=kvadrat[n-i-1][i];
     for(j=0;j<n && ret;j++)
     {
        sumX+=kvadrat[i][j];
        sumY+=kvadrat[j][i];
     }
     if(!i)S = sumX;
     if( S!=sumX || S!=sumY )
        ret = false;
   }
   if(ret && ( S!=diag1 || S!=diag2) )
      ret = 0;
   return ret;
}

void ulaz()
{
   int i,j;
   FILE *in = fopen("Ulaz.txt","r");
   fscanf(in,"%d",&n);
   for(i=0;i<n;i++)
   {
      for(j=0;j<n;j++)
      {
         fscanf(in,"%d",&kvadrat[i][j]);
         if( kvadrat[i][j] == 0 )
            fale.push_back( coord(j,i) );
         HASH[ kvadrat[i][j] ]=1;
      }
   }
}
short Vsize;
bool found = false;
void solve( int poz )
{
   if( found == false )
   {
      if( poz == fale.size() ){
         if( IsMagic() )found = true;
      }else{
         for(int i=0;i<Vsize;i++)
         {
            if( !HASH[ brojevi[i] ] ){
               HASH[ brojevi[i] ] = 1;
               kvadrat[ fale[poz].y ] [ fale[poz].x ] = brojevi[i];
               solve( poz+1 );
               if( !found )
               {
                  HASH[ brojevi[i] ] = 0;
                  kvadrat[ fale[poz].y ] [ fale[poz].x ] = 0;
               }
            }
         }
      }
   }
}

void proces()
{
   int i,j;
   for(i=1;i<=n*n;i++)
      if( HASH[i]==0 )
        brojevi.push_back(i);
   Vsize = brojevi.size();
   solve( 0 );
}

void out()
{
   if(found)
   {
      int i,j;
      for(i=0;i<n;i++){
         for(j=0;j<n;j++)
            printf("%d ",kvadrat[i][j]);
         printf("\n");
      }
   }else
      printf("-1\n");
}

int main()
{
   ulaz();
   proces();
   out();
   system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<iostream>
#include<fstream>
#include<vector>
using namespace std;
const short SMAX = 5;

int n;
short field[SMAX][SMAX];
bool hashV[SMAX*SMAX+1];
vector<short>NotIn;
short hashX[SMAX];
short hashY[SMAX];
short Diag1=0,Diag2=0;

void input();
void prepare();
void GiveComm();
void rek(int);

void input()
{
   int i,j;
   FILE *in = fopen("Ulaz.txt","r");
   fscanf(in,"%d",&n);
   short DX=n-1,DY=0;
   for(i=0;i<n;i++)
   {
      for(j=0;j<n;j++)
      {
         fscanf(in,"%d",&field[i][j]);
         hashX[j]++;
         hashY[i]++;
         hashV[ field[i][j] ] = 1;
         if( i == j && field[i][j] ) Diag1++;
         if( i==DY && j==DX )
         {
            if( field[i][j] ) Diag2++;
            DY++;
            DX--;
         }
      }
   }
}

void prepare()
{
   int i;
   for(i=1;i<=n*n;i++)
      if( !hashV[i] )
         NotIn.push_back(i);
}

int GiveComm() // daj mi mjesto koje je najmanje popunjeno
{
   int method=1;
   int place=0;
   int min = 10;
   for(i=0;i<n;i++)
      if( hashX[i] < min )
      {
         method = 2;
         place = i;
      }
   for(i=0;i<n;i++)
      if( hashY[i] < min )
      {
         method = 3;
         place = i;
      }
   if( Diag1 < min )
      method = 4;
   else if ( Diag2 < min )
      method = 5;
   return (method*100)+place;
}

void rek( int sum)
{
   int comm = GiveComm();
   if( comm / 100 == 2 )
   {
      for(int i=0;i<n;i++)
      {
         if( field[ comm%100 ][i] == 0 )
         {
            for(int j=0;j<NotIn.size();j++)
            {
               if( hashV[ NotIn[j] ] == 0 )
               {
                  hashV[ NotIn[j] ] = 1;
                  field[comm%100][i] = NotIn[j];
                  rek(
               }
            }
         }
      }
   }
}

int main()
{
   input();
   prepare();
   rek(0);
   system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<iostream>
#include<fstream>
#include<vector>
#include<queue>
#include<cstdlib>
#include<cmath>
#include<functional>
#include<utility>
#include<iomanip>
#include<numeric>
#include<map>
using namespace std;
const short SMAX = 5;

struct coord{
   short x,y;
   coord(int a,int b):x(a),y(b){};
   coord(){};
};

int n;
short field[SMAX][SMAX];
bool hashV[SMAX*SMAX+1];

short hashX[SMAX],sumX[SMAX],faleX[SMAX]; vector<short>elemsX[SMAX];
short hashY[SMAX],sumY[SMAX],faleY[SMAX]; vector<short>elemsY[SMAX];
short Diag1=0, Diag1S=0,fale1;            vector<coord>elems1;
short Diag2=0, Diag2S=0,fale2;            vector<coord>elems2;
vector < short > NotIn;

void input();
void prepare();
int GiveComm();
int suming();

void prepare()
{
   int i;
   for(i=1;i<=n*n;i++)
      if( !hashV[i] )
         NotIn.push_back(i);
   for(i=0;i<n;i++)
   {
      faleX[i] = n-hashX[i];
      faleY[i] = n-hashY[i];
   }
   fale1=n-Diag1;
   fale2=n-Diag2;
}

void input()
{
   int i,j;
   FILE *in = fopen("Ulaz.txt","r");
   fscanf(in,"%d",&n);
   short DX=n-1,DY=0;
   for(i=0;i<n;i++)
   {
      for(j=0;j<n;j++)
      {
         fscanf(in,"%d",&field[i][j]);
         if( field[i][j] )
         {
            if( i == j ){
               Diag1++;
               Diag1S+=field[i][j];
               elems1.push_back( coord(j,i) );
            }else if( i+j+1==n ){
               Diag2++;
               Diag2S+=field[i][j];
               elems2.push_back( coord(j,i) );
            }
            hashX[j]++; sumX[j]+=field[i][j];
            hashY[i]++; sumY[i]+=field[i][j];
            hashV[ field[i][j] ] = 1;
         }else{
            elemsX[j].push_back( i );
            elemsY[i].push_back( j );
         }
      }
   }
}

int param2 = 0;
int GiveComm() // daj mi mjesto koje je najmanje popunjeno
{
   int method=1;
   int place=0;
   int maxN = -1;
   int i;
   for(i=0;i<n;i++)
   {
      if( hashX[i] > maxN && hashX[i]!=n )
      {
         method = 2;
         place = i;
         maxN = hashX[i];
      }
      if( hashX[i]==n )
         param2 = sumX[i];
   }
   for(i=0;i<n;i++)
   {
      if( hashY[i] > maxN && hashY[i]!=n )
      {
         method = 3;
         place = i;
         maxN = hashX[i];
      }
      if( hashY[i]==n )
         param2 = sumY[i];
   }
//   if( Diag1 > maxN && Diag1!=n ){
 //     method = 4;
//      maxN = Diag1;
//   }
//   if( Diag1==n )
////      param2 = Diag1S;
//   if( Diag2==n )
//      param2 = Diag2S;
//   else if ( Diag2 > maxN && Diag2!=n )
//      method = 5;
   return (method*100)+place;
}

int suming( int What)
{
   int ret = 0,i;
   if( What / 100 == 2 )
      for(i=0;i<n;i++)
         ret += field[i][What%100];
   else if( What / 100 == 3 )
      for(i=0;i<n;i++)
         ret += field[What%100][i];
   else if( What / 100 == 4 )
      for(i=0;i<n;i++)
         ret += field[i][i];
   else
      for(i=0;i<n;i++)
         ret += field[n-i-1][i];
   return ret;
}

inline bool IsAtDiag1(int x,int y)
{
   return (x==y);
}

inline bool IsAtDiag2(int x,int y)
{
   return( ( x!=y || (n%2 && x==n/2) ) && x+y==n-1 ); 
}

bool found=false;
int T;
void MainRek(int param,int sum)
{
   int i,j,q;
   for(i=0;i<n;i++){for(j=0;j<n;j++)cout<<field[i][j]<<" ";cout<<endl;}cout<<param<<endl;
   if( param/100 == 2 )
   {
      if( (hashX[param%100]<n-1) || (hashX[param%100]<n && sum==-1) )
      {
         short p = elemsX[param%100][(hashX[param%100]+faleX[param%100])-n ];
         bool d1 = IsAtDiag1(param%100,p);
         bool d2 = IsAtDiag2(param%100,p);
         for(i=0;i<NotIn.size();i++)
         {
            if( !hashV[ NotIn[i] ] && ( sum==-1 || ( (!d1 || Diag1S+NotIn[i]<=sum)
                && (!d2 || Diag2S+NotIn[i]<=sum) && (sumX[param%100]+NotIn[i]<=sum) && (sumY[p]+NotIn[i]<=sum) ) ) )
            {
               field[p][param%100]=NotIn[i];
               hashV[ NotIn[i] ]=1;
               if(d1){Diag1++;Diag1S+=NotIn[i];}
               if(d2){Diag2++;Diag2S+=NotIn[i];}
               hashX[param%100]++;sumX[param%100]+=NotIn[i];
               hashY[p]++;sumY[p]+=NotIn[i];
               MainRek(param,sum);
               if( !found )
               {
                  field[p][param%100]=0;
                  hashV[ NotIn[i] ]=0;
                  if(d1){Diag1--;Diag1S-=NotIn[i];}
                  if(d2){Diag2--;Diag2S-=NotIn[i];}
                  hashX[param%100]--;sumX[param%100]-=NotIn[i];
                  hashY[p]--;sumY[p]-=NotIn[i];
               }
            }
         }
      }else{
         if( hashX[param%100]<n && sum!=-1 )
         {;
            int p = elemsX[param%100][(hashX[param%100]+faleX[param%100])-n];
            int val = sum-sumX[param%100];
            bool d1 = IsAtDiag1(param%100,p);
            bool d2 = IsAtDiag2(param%100,p);
            if( !hashV[ val ] && ( (!d1 || Diag1S+val<=sum)
                && (!d2 || Diag2S+val<=sum) && (sumX[param%100]+val<=sum) && (sumY[p]+val<=sum)  ) &&
                sumX[param%100]==sumY[p] && (!d1 || Diag1S==sumY[p]) && (!d2 || Diag2S==sumY[p] ) )
            {
               field[p][param%100]=val;
               hashV[ val ]=1;
               if(d1){Diag1++;Diag1S+=val;}
               if(d2){Diag2++;Diag2S+=val;}
               hashX[param%100]++;sumX[param%100]+=val;
               hashY[p]++;sumY[p]+=val;
               MainRek(param,sum);
               if( !found )
               {
                  field[p][param%100]=0;
                  hashV[ val ]=0;
                  if(d1){Diag1--;Diag1S-=val;}
                  if(d2){Diag2--;Diag2S-=val;}
                  hashX[param%100]--;sumX[param%100]-=val;
                  hashY[p]--;sumY[p]-=val;
               }
            }
         }else{
            if( sum==-1 ) sum = suming(param);
            q = GiveComm();
            if( q!=100)
               MainRek(q,sum);
            else
               found = 1;
         }
      }
   }else if( param/100 == 3 )
   {
      if( (hashY[param%100]<n-1) || (hashY[param%100]<n && sum==-1) )
      {
         short p = elemsY[param%100][(hashY[param%100]+faleY[param%100])-n ];
         bool d1 = IsAtDiag1(p,param%100);
         bool d2 = IsAtDiag2(p,param%100);
         for(i=0;i<NotIn.size();i++)
         {
            if( !hashV[ NotIn[i] ] && ( sum==-1 || ( (!d1 || Diag1S+NotIn[i]<=sum)
                && (!d2 || Diag2S+NotIn[i]<=sum) && (sumX[p]+NotIn[i]<=sum) && (sumY[param%100]+NotIn[i]<=sum) ) ) )
            {
               field[param%100][p]=NotIn[i];
               hashV[ NotIn[i] ]=1;
               if(d1){Diag1++;Diag1S+=NotIn[i];}
               if(d2){Diag2++;Diag2S+=NotIn[i];}
               hashY[param%100]++;sumY[param%100]+=NotIn[i];
               hashX[p]++;sumX[p]+=NotIn[i];
               MainRek(param,sum);
               if( !found )
               {
                  field[param%100][p]=0;
                  hashV[ NotIn[i] ]=0;
                  if(d1){Diag1--;Diag1S-=NotIn[i];}
                  if(d2){Diag2--;Diag2S-=NotIn[i];}
                  hashY[param%100]--;sumY[param%100]-=NotIn[i];
                  hashX[p]--;sumX[p]-=NotIn[i];
               }
            }
         }
      }else{
         if( hashY[param%100]<n && sum!=-1 )
         {
            int p = elemsY[param%100][(hashY[param%100]+faleY[param%100])-n];
            int val = sum-sumY[param%100];
            bool d1 = IsAtDiag1(param%100,p);
            bool d2 = IsAtDiag2(param%100,p);
            if( !hashV[ val ] && ( (!d1 || Diag1S+val<=sum)
                && (!d2 || Diag2S+val<=sum) && (sumX[p]+val<=sum) && (sumY[param%100]+val<=sum)  ) )
            {
               field[param%100][p]=NotIn[i];
               hashV[ NotIn[i] ]=1;
               if(d1){Diag1++;Diag1S+=NotIn[i];}
               if(d2){Diag2++;Diag2S+=NotIn[i];}
               hashY[param%100]++;sumY[param%100]+=NotIn[i];
               hashX[p]++;sumX[p]+=NotIn[i];
               MainRek(param,sum);
               if( !found )
               {
                  field[param%100][p]=0;
                  hashV[ NotIn[i] ]=0;
                  if(d1){Diag1--;Diag1S-=NotIn[i];}
                  if(d2){Diag2--;Diag2S-=NotIn[i];}
                  hashY[param%100]--;sumY[param%100]-=NotIn[i];
                  hashX[p]--;sumX[p]-=NotIn[i];
               }
            }
         }else{
            if( sum==-1 ) sum = suming(param);
            q = GiveComm();
            if( q!=100)
               MainRek(q,sum);
            else
               found = 1;
         }
      }
   }
}

int main()
{
   input();
   prepare();
   int ToBegin = GiveComm();
   if( param2 == 0 )MainRek(ToBegin,-1);
   else MainRek(ToBegin,param2);
   int i,j;
   if(found)
   {
      for(i=0;i<n;i++){
        for(j=0;j<n;j++)
           cout<<field[i][j]<<" ";cout<<endl;
      }
   }else
      cout<<"-1"<<endl;
   system("Pause");
   return 0;
}

#include<cstdio>
#include<algorithm>
#include<iostream>
#include<fstream>
#include<vector>
#include<queue>
#include<cstdlib>
#include<cmath>
#include<functional>
#include<utility>
#include<iomanip>
#include<numeric>
#include<map>
using namespace std;
const short SMAX = 5;

struct coord{
   short x,y;
   coord(int a,int b):x(a),y(b){};
   coord(){};
};

int n;
short field[SMAX][SMAX];
bool hashV[SMAX*SMAX+1];

short hashX[SMAX],sumX[SMAX];
short hashY[SMAX],sumY[SMAX];
short Diag1=0, Diag1S=0;
short Diag2=0, Diag2S=0;
vector < short > NotIn;

inline bool IsAtDiag1(int x,int y)
{
   return (x==y);
}

inline bool IsAtDiag2(int x,int y)
{
   return( ( x!=y || (n%2 && x==n/2) ) && x+y==n-1 ); 
}


void prepare()
{
   int i;
   for(i=1;i<=n*n;i++)
      if( !hashV[i] )
         NotIn.push_back(i);
}

void input()
{
   int i,j;
  // FILE *in = fopen("Ulaz.txt","r");
   scanf("%d",&n);
   short DX=n-1,DY=0;
   for(i=0;i<n;i++)
   {
      for(j=0;j<n;j++)
      {
         scanf("%d",&field[i][j]);
         if( field[i][j] )
         {
            if( i == j ){
               Diag1++;
               Diag1S+=field[i][j];
            }else if( i+j+1==n ){
               Diag2++;
               Diag2S+=field[i][j];
            }
            hashX[j]++; sumX[j]+=field[i][j];
            hashY[i]++; sumY[i]+=field[i][j];
            hashV[ field[i][j] ] = 1;
         }
      }
   }
}

int suming( int What)
{
   int ret = 0,i;
   if( What / 100 == 2 )
      for(i=0;i<n;i++)
         ret += field[i][What%100];
   else if( What / 100 == 3 )
      for(i=0;i<n;i++)
         ret += field[What%100][i];
   else if( What / 100 == 4 )
      for(i=0;i<n;i++)
         ret += field[i][i];
   else
      for(i=0;i<n;i++)
         ret += field[n-i-1][i];
   return ret;
}

int NS;
bool found=false;
void rekRow(int row,int q,int sum)
{
     int k,l;
   for(q++;q<n;q++)
   {
      int i = q;
      if( field[row][i]==0 )
      {
         q=n;
         for(int j=0;j<NS;j++)
         {
            if( hashV[ NotIn[j] ] == 0 &&
                sumX[i]+NotIn[j]<=sum &&
                sumY[row]+NotIn[j]<=sum &&
                 ( !(i==row) || Diag1S+NotIn[j]<=sum) &&
                 ( !(row==n-i-1 ) || Diag2S+NotIn[j]<=sum)  )
            {
               field[row][i]=NotIn[j]; hashV[NotIn[j]] = 1;
               sumX[i]+=NotIn[j]; hashX[i]++;
               sumY[row]+=NotIn[j]; hashY[row]++;
               if( i == row ){Diag1S+=NotIn[j];Diag1++;}
               if( row == n-i-1 ){Diag2S+=NotIn[j];Diag2++;}
               rekRow(row,i,sum);
               if(!found)
               {
                  field[row][i]=0; hashV[NotIn[j]] = 0;
                  sumX[i]-=NotIn[j]; hashX[i]--;
                  sumY[row]-=NotIn[j]; hashY[row]--;
                  if( i == row ){Diag1S-=NotIn[j];Diag1--;}
                  if( row == n-i-1 ){Diag2S-=NotIn[j];Diag2--;}
               }
            }
         }
      }
   }
   if( q==n )
   {
      if(row<n-1)
         rekRow(row+1,0,sum);
      else{
         int i,j;
         j = sumX[0];
         found = true;
         for(i=0;i<n;i++)
            if( sumX[i]!=j || sumY[i]!=j)found = false;
         if(found) found = ( j==Diag1S && j==Diag2S );
      }
   }
}

void rekDiag2(int sum,int q=-1)
{  
   for(q++;q<n;q++)
   {
      int i = q;
      if( field[n-i-1][i]==0 )
      {
         q=n;
         for(int j=0;j<NS;j++)
         {
            if( hashV[ NotIn[j] ] == 0 &&
                Diag2S+NotIn[j] <= sum &&
                sumX[i]+NotIn[j]<= sum &&
                sumY[n-i-1]+NotIn[j] <= sum &&
                ( !(n-i-1==i) || Diag1S+NotIn[j]<=sum )  )
            {
               field[n-i-1][i]=NotIn[j]; hashV[NotIn[j]] = 1;
               Diag2S+=NotIn[j]; Diag2++;
               sumX[i]+=NotIn[j]; hashX[i]++;
               sumY[n-i-1]+=NotIn[j]; hashY[n-i-1]++;
               if( n-i-1 == i ){Diag1S+=NotIn[j];Diag1++;}
               rekDiag2(sum,i);
               if(!found)
               {
                  field[n-i-1][i]=0; hashV[NotIn[j]] = 0;
                  Diag2S-=NotIn[j]; Diag2--;
                  sumX[i]-=NotIn[j]; hashX[i]--;
                  sumY[n-i-1]-=NotIn[j]; hashY[n-i-1]--;
                  if( n-i-1 == i ){Diag1S-=NotIn[j];Diag1--;}
               }
            }
         }
      }
   }
   if(q==n)rekRow(0,0,sum);
}

void rekDiag1(int q=-1)
{

   for(q++;q<n;q++)
   {
      int i = q;
      if( field[i][i]==0 )
      {
         q=n;
         for(int j=0;j<NS;j++)
         {
            if( hashV[NotIn[j]]==0 )
            {
               field[i][i]=NotIn[j]; hashV[ NotIn[j] ] = 1;
               Diag1S+=NotIn[j];  Diag1++;
               sumX[i]+=NotIn[j]; hashX[i]++;
               sumY[i]+=NotIn[j]; hashY[i]++;
               if( n%2 && i==n/2 ){Diag2S+=NotIn[j];Diag2++;}
               rekDiag1(i);
               if(!found)
               {
                  field[i][i]=0; hashV[ NotIn[j] ] = 0;
                  Diag1S-=NotIn[j];  Diag1--;
                  sumX[i]-=NotIn[j]; hashX[i]--;
                  sumY[i]-=NotIn[j]; hashY[i]--;
                  if( n%2 && i==n/2 ){Diag2S-=NotIn[j];Diag2--;}
               }
            }
         }
      }
   }
   if(q==n)rekDiag2(Diag1S);
}

int main()
{
   input();
   prepare();
   NS = NotIn.size();
   int i,j;
   rekDiag1();
   if(found)
   {
      for(i=0;i<n;i++){
        for(j=0;j<n;j++)
           cout<<field[i][j]<<" ";cout<<endl;
      }
   }else
      cout<<"-1"<<endl;
   //system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
using namespace std;

struct coord{
   double x,y;
   coord(FILE *inp){fscanf(inp,"%lf%lf",&x,&y);}
   coord(double p1,double p2):x(p1),y(p2){};
   coord(){};
};

int n;
coord pikado[20];
int m;
int uglove[20];
int counter[20];
int res[20];
const int Xright = (int)20e8;

double cross( coord &null , coord &A,coord &B){
   return (A.x-null.x)*(B.y-null.y)-(B.x-null.x)*(A.y-null.y);
}

bool na_duzi(coord &A,coord &B,coord &C){
   if(  min(A.x,B.x)<=C.x && C.x<=max(A.x,B.x) && min(A.y,B.y)<=C.y && C.y<=max(A.y,B.y) )
      return true;
   else
      return false;
}

bool Pass( coord &A,coord B,coord &C,coord &D )
{
   if( (C.y < A.y || D.y < A.y) && (C.x > A.x || D.x > A.x) ){
      double s1 = cross(A,B,C);
      double s2 = cross(A,B,D);
      double s3 = cross(C,D,A);
      double s4 = cross(C,D,B);
      if( ((s1<0 && s2>0)||(s1>0 && s2<0)) && ((s3<0 && s4>0)||(s3>0 && s4<0)) )
         return 1;
      else if( s1==0 && na_duzi(A,B,C) )return 1;
      else if( s2==0 && na_duzi(A,B,D) )return 1;
      else if( s3==0 && na_duzi(C,D,A) )return 1;
      else if( s4==0 && na_duzi(C,D,B) )return 1;
      else return 0;
   }else
      return 0;
}

int main()
{
   FILE *in = fopen("pik2.in.txt","r");
   int i,j,k;
   fscanf(in,"%d",&n);
   for(i=0;i<n;i++)pikado[i]=coord(in);
   fscanf(in,"%d",&m);
   for(i=0;i<m;i++)fscanf(in,"%d",&uglove[i]);
   coord prev,now,tmp;
   for(i=0;i<m;i++)
   {
      prev = coord(in);
      tmp = prev;
      for(j=1;j<uglove[i];j++)
      {
         now = coord(in);
         for(k=0;k<n;k++){
            if( Pass( pikado[k],coord(Xright,pikado[k].y),prev,now) ){
                counter[k]++;
            }
         }
         prev = now;
      }
      for(k=0;k<n;k++){
            if( Pass( pikado[k],coord(Xright,pikado[k].y),prev,tmp) ){
                counter[k]++;
            }
      }
      for(j=0;j<n;j++){
         if( counter[j]%2 )res[j]++;
         counter[j]=0;
      }
   }
   for(i=0;i<n;i++)
      printf("%d ",res[i]);printf("\n");
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
using namespace std;

int main()
{
   int n,i,j;
   bool search=true;
   cin>>n;
   int T,max=0,maxN=0;
   for(i=1905120000;i<=n;i++){
     T=1;
     for(j=1;j<=i/2;j++)
     {
        if(i%j==0)
          T++;
     }
     if(max<T)
     {
        maxN=i;
        max = T;
     }
     cout<<maxN<<endl;
     cout<<max<<endl;
     system("Pause");
   }
   cout<<maxN<<endl;
   cout<<max<<endl;
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
using namespace std;

int main()
{
   int n;
   bool search=true;
   cin>>n;
   int A=0,B=0,C=0,D=0,E;
   int SUM=1;
   while(search)
   {
      if( SUM * 2 <= n && SUM*4 ){
         A++;
         SUM *= 2;

      }else
         break;
      if( SUM * 3 <= n ){
         B++;
         SUM *= 3;continue;
      }
      
      if( SUM * 5 <= n ){
         C++;
         SUM *= 5;
      }
      
      if( SUM * 7 <= n ){
         D++;
         SUM *= 7;
      }
   }
   cout<<SUM<<endl;
   cout<<(A+1)*(B+1)*(C+1)*(D+1)<<endl;
   system("Pause");
   return 0;
}

#include<cstdio>
#include<cstdlib>

int delioci(int n)
{
    int s2=0,s3=0,s5=0,s7=0,sE=0;
    while(n%2==0){
       n/=2;
       s2++;
    }
    while(n%3==0)
    {
       n/=3;
       s3++;
    }
    while(n%5==0)
    {
       n/=5;
       s5++;
    }
    while(n%7==0)
    {
       n/=2;
       s7++;
    }
    return ((s2+1)*(s3+1)*(s5+1)*(s7+1)*(sE+1));
}


int main()
{
   int n,i,j;
   int max=0,maxN=0;
   scanf("%d",&n);
   for(i=n/2;i<=n;i++)
   {
      j = delioci(i);
      if( j > maxN )
      {
         maxN = j;
         max = i;
      }
      printf("%d\n",i);
   }
   printf("%d\n",max);
   printf("%d\n",maxN);
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;

int main()
{
    int n;
    scanf("%d",&n);
    long long int Ag=1,Bg=1,Cg=1,Dg=1;
    long long int A=1,B=1,C=1,D=1;
    while(A<=n || B<=n || C<=n || D<=n){
       if(A<=n){
          Ag++;
          A*=2;
       }
       if(B<=n){
       Bg++;
       B*=3;
       }
       if(C<=n){
       Cg++;
       C*=5;
       }
       if(D<=n){
       Dg++;
       D*=7;
       }
    }
    long long int i,j,k,l;
    long long int T1,T2;
    int max=0,maxN=0;
    D=1;
    for(i=0;i<Dg;i++)
    {
       C=1;
       for(j=0;j<Cg;j++)
       {
          T1=D*C;
          if(T1>n)break;
          B=1;
          for(k=0;k<Bg;k++)
          {
             T1 = D*C*B;
             if(T1>n)break;
             A=1;
             for(l=0;l<Ag;l++)
             {
                T1 = A*B*C*D;
                T2 = (i+1)*(j+1)*(k+1)*(l+1);
                if( (T2 > max && T1 <= n) || (T2==max && T1 < maxN)  )
                {
                   max=T2;
                   maxN=T1;
                }
                A*=2;
             }
             B*=3;
          }
          C*=5;
       }
       D*=7;
    }
    printf("%d\n%d\n",maxN,max);
    return 0;
}

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;

int labud1 = 90;
int labud2 = 100;
int block = 1000000;
int topi =  2;
int empty = 110;

struct coord{
       int x,y;
       coord(int a,int b):x(a),y(b){}
};

int h,w;
int counter=0;
bool found=false;
char matrica[2000][2000];
vector<coord*>FloodPoz;

void ulaz()
{
   int i,j;
   scanf("%d%d%d",&h,&w);
   for(i=0;i<h;i++)
   {
       for(j=0;j<w;j++)
       {
          scanf("%c",&matrica[i][j]);
          if( matrica[i][j]=='L' )
             FloodPoz.push_back( new coord(j,i) );
       }
       scanf("%c");
   }
}

int color;
void flood(int x,int y)
{
   if( x>=0 && x<w && y>=0 && y<h && matrica[y][x]!=color && !found )
   {
      if( color == labud1 && matrica[y][x] == labud2 )found=true;
      if( color == labud2 && matrica[y][x] == labud1 )found=true;
      if( matrica[y][x] != topi && matrica[y][x]!='X' )
      {
         matrica[y][x] = color;
         flood(x-1,y);
         flood(x+1,y);
         flood(x,y-1);
         flood(x,y+1);
      }else
         matrica[y][x]=topi;
   }
}

void proces()
{
   int i,j;
   int counter=0;
   color = labud1;
   flood( FloodPoz.at(0)->x , FloodPoz.at(0)->y);
   color = labud2;
   if(!found){
      flood( FloodPoz.at(1)->x , FloodPoz.at(1)->y);
      counter++;
   }
   color = empty;
   for(i=0;i<h;i++)
      for(j=0;j<w;j++)
         if( matrica[i][j]=='.' )
         {
            FloodPoz.push_back( new coord( j,i) );
            flood(j,i);
         }
   int Sv = FloodPoz.size();
   while(!found)
   {
       counter++;
       empty++;labud1++;labud2++;topi++;
       for(i=2;i<Sv;i++)
         flood( FloodPoz.at(i)->x,FloodPoz.at(i)->y);
       color = labud1;
       flood( FloodPoz.at(0)->x , FloodPoz.at(0)->y);
       color = labud2;
       flood( FloodPoz.at(1)->x , FloodPoz.at(1)->y);
   }
   cout<<counter<<endl;
}

int main()
{
    ulaz();
    proces();
    return 0;
}

#include<cstdio>
#include<cmath>
#include<string>
#include<iostream>
#include<fstream>
using namespace std;
string S[4];
string S1[4];
int len;

int calculate_rect()
{
   int i,j,k,l,m,n;
   int maxP=0,T;
   for(i=1;i<len-3;i++) // POMJERA S[2] U HORIZONDALI (smjer:'->') // 
   {
      for(j=len-2;j>=i+2;j--) // POMJERA S[3] U HORIZONTALI (smjer:'<-') //
      {
         for(k=1;k<len-3;k++) // POMJERA S[2] U VERTIKALI (smjer:'DOLE') //
         {
            if( S[2][k]==S[0][i] )
            {
               for(l=1;l<len-3;l++) // POMJERA S[3] U VERTIKALI (smjer:'DOLE')
               {
                  if(S[3][l]==S[0][j])
                  {
                     for(m=len-min(k,l)-2;m>=2;m--) // POMJERA S[1] U VERTIKALI (smjer:'GORE')
                     {
                        for(n=1;n<=(j-i);n++) // POMJERA S[1] U HORIZONTALI ( smjer:'->' )
                        {
                           if( S[2][k+m]==S[1][n] && S[3][l+m]==S[1][n+(j-i)] )
                           {
                              T = (j-i-1)*(m-1);
                              if(T>maxP)
                                 maxP = T;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
   return maxP;
}

int main()
{
    int maxN=0,i;
    scanf("%d",&len);
    cin>>S[0]>>S[1]>>S[2]>>S[3];
    for(i=0;i<4;i++)S1[i]=S[i];
    do{
       next_permutation(S,S+4);
       i = calculate_rect();
       if( i> maxN)
         maxN=i;
    }while( S1[0]!=S[0] ||
            S1[1]!=S[1] ||
            S1[2]!=S[2] ||
            S1[3]!=S[3]    );
    printf("%d\n",maxN);
    return 0;
}

#include<cstdio>
#include<cstdlib>
using namespace std;
#define si int

int max=0,maxN=0,T,n;
void rek(si S,si A,si B,si C,si D)
{
   T = (A+1)*(B+1)*(C+1)*(D+1);
   if( T > maxN )
   {
      maxN = T;
      ::max = S;
   }
   if( S*2 <= n )
      rek(S*2,A+1,B,C,D);
   if( S*3 <= n)
      rek(S*3,A,B+1,C,D);
   if( S*5 <= n )
      rek(S*5,A,B,C+1,D);
   if( S*7 <= n )
      rek(S*7,A,B,C,D+1);
}

int main()
{
   scanf("%d",&n);
   rek(1,0,0,0,0);
   printf("%d\n",::max);
   printf("%d\n",::maxN);
   system("Pause");
   return 0;
}

#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int niz[1000000];

int main()
{
   int F1,F2,F3;
   int C,B,A,tmp;
   int n,i,j;
   cin>>F1>>F2>>F3>>C>>B>>A>>n;
   A = pow((float)A,n);
   if (n==0)cout<<1<<endl;
   else {
     tmp = pow((float)A,n/2) ;
     tmp = tmp * tmp ;
     if (n % 2 == 1) tmp = tmp * A ;
     cout<<tmp<<endl;     
   }
   system("Pause");
   return 0;
}

#include<cstdio>
#include<iostream>
#include<cstdlib>
using namespace std;

int main()
{
    int n,rok;
    int i,b,t;
    scanf("%d%d",&n,&rok);
    b=0;
    int min=(int)3e9;
    int Res=0;
    int p=1;
    for(i=0;i<n;i++)
    {
       scanf("%d",&t);
       if(b==rok){
          Res = Res + (b*min);
          p=i+1;
          b = 0;
          min=t;
       }else if(t<=min){
          Res = Res + (b*min);
          p=i+1;
          b = 0;
          min=t;
       }else if(i+1==n){
          Res += min*(b+1);
          p=i+1;
       }
       b++;
    }
    printf("%d\n",Res);
    return 0;
}

#include<cstdio>
#include<fstream>
#include<iostream>
using namespace std;
int cost[1001];

int main()
{
    int n,rok;
    int pay;
    int i,j;
    bool F;
    int res=0;
    scanf("%d%d",&n,&rok);
    for(i=0;i<n;i++)
    {
       scanf("%d",&pay);
       cost[pay]=i+1;
       F=0;
       for(j=0;j<1001;j++)
       {
          if( cost[j] + rok > i+1 && cost[j]!=0 ){
             F = 1;
             break;
          }
       }
       if(F){
           res = res + j;

       }else{
           res = res + pay;

       }
    }
    printf("%d\n",res);

    return 0;
}

#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
int niz[100000000];
char str[20];

int giveKey()
{
   int KEY=0;
   int exp = strlen(str)-1;
   for(int i=0;i<strlen(str);i++)
   {
      KEY = KEY + (( str[i]-'a' )*(int)pow((float)26,exp));
      exp--;
   }
   return KEY;
}

int main()
{
    int n,M,T;
    printf("How much strings do you want to HASH???\n");
    scanf("%d",&n);
    while(n--)
    {
       printf("Enter string:\n");
       scanf("%s",str);
       printf("Enter a Value you want to memorize:\n");
       scanf("%d",&M);
       niz[ giveKey() ] = M;
    }
    printf("How much keys do you want to READ???\n");
    scanf("%d",&n);
    while(n--)
    {
       printf("Enter string:\n");
       scanf("%s",str);
       printf("%d\n",niz[ giveKey() ] );
    }
    system("Pause");
    return 0;
}

#include<iostream>
using namespace std;

int main()
{
    int i,j,k,l,m,n;
    cout<<"Unesite broj Jimmy Bondova i misija:\n";
    int a;
    cin>>a;
    int a1=a-1;
    int  b[a][a];
    for(i=0;i<=a1;i++)
    {
        cout<<"Unesite za "<<i+1<<". misiju vjerovatnost:\n";
        for(j=0;j<=a1;j++)
        {
                cin>>b[i][j];
        }
        cout<<"\n";
    }
    double max[a];
    int brisac=0;
    for(i=0;i<=a1;i++)
    {
        max[i]=b[i][0];
        for(j=0;j<=a1;j++)
        {
                if(max[i]<b[i][j])
                {brisac=j; max[i]=b[i][j];}
        }
        
        for(k=0;k<=a1;k++)//pokrenuti funkciju brisac koja ce sve vrijednost postaviti na -10
        {
                b[k][brisac]=-10000;
        }
        
    }
    float procenat=1.00;
    for(l=0;l<=a1;l++)
    {
        procenat=procenat*(max[l]/100);
    }
    procenat=procenat*100;
    cout<<"Procenat uspjeha izosi:\n"<<procenat<<"\n";
    cin>>a1;
}
    
    
    

// MADE IN 2007.12 SO DON't wonder the code isn't beautiful ... xD

#include<iostream>
#include<iomanip>
using namespace std;

int main()
{
    int r;
    cin>>r;
    int c;
    cin>>c;
    int r1=r-1;int c1=c-1;
    char matrica[305][305];
    int i=0,j;
    while(i<=r1)
    {
        for(j=0;j<=c1;j++)
        {
                cin>>matrica[i][j];
        }
        i++;
    }
    
    char mem[300];char mem1[300];
    int najveci=-1;
    /////////////////////////////////////////////////////////////////////////////////////////////////
    for(i=0;i<r1;i++) //pocetak petlje za provjeravanja da li se killer moze naci u dimenzije 2 sa 2
    {
        for(j=0;j<c1;j=j+1)
        {
                mem[0]=matrica[i][j];
                mem[1]=matrica[i][j+1];
                mem1[0]=matrica[i+1][j];
                mem1[1]=matrica[i+1][j+1];
                if(mem[0]==mem1[0] && mem[1]==mem1[1] ||
                   mem[0]==mem1[1] && mem[1]==mem1[0] ||
                   mem[1]==mem1[0] && mem[0]==mem1[1])
                {
                                najveci=2;
                }
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////
    for(i=0;i<r1-1;i++)    //provjera da li se killer moze naci u dimenziju 3 sa 3
    {
        for(j=0;j<=c1;j++)
        {
                mem[0]=matrica[i][j];
                mem[1]=matrica[i][j+1];
                mem[2]=matrica[i][j+2];
                mem1[0]=matrica[i+2][j];
                mem1[1]=matrica[i+2][j+1];
                mem1[2]=matrica[i+2][j+2];
                if(mem[0]==mem1[0] && mem[1]==mem1[1] && mem[2]==mem1[2])
                {
                                najveci=3;
                }
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////
    cout<<najveci<<endl;    
    return 0;
}

#include<iostream>
#include<iomanip>
using namespace std;

int main()
{
    int r,c;
    cout<<"Unesite broj redova:\n";
    cin>>r;
    cout<<"Unesite broj colona:\n";
    cin>>c;
    int matrica[r][c];
    int brojilac=0;
    int i=0;int j=0;
    int p1=0;  int k1=c;/*dodaci:*/   int r1=0;   // deklaracija variabli koji su potrebni za prvi func
    int p2=1;  int k2=r; /*dodaci:*/  int c2=c-1; // deklaracija variabli koji su potrebni za drugi func
    int p3=c-2;int k3=0;/*dodaci:*/   int r3=r-1; // deklaracija variabli koji su potrebni za treci func
    int p4=r-2;int k4=0;/*dodaci:*/   int r4=0;   // deklaracija variabli koji su potrebni za ctvrti func
    
    while(true)
    {
        if(p1>=k1){break;}
        for(i=p1;i<k1;i++)
        {
                brojilac++;
                matrica[r1][i]=brojilac;
        }
        r1++;p1++;k1--;
     
        if(p2>=k2){break;}
        for(j=p2;j<k2;j++)
        {
                brojilac++;
                matrica[j][c2]=brojilac;
        }
        p2++;k2--;c2--;
  
        
        if(p3<k3){break;}
        for(i=p3;i>=k3;i--)
        {
                brojilac++;
                matrica[r3][i]=brojilac;
        }
        p3--;k3++;r3--;
       
        if(p4<=k4){break;}          
        for(j=p4;j>k4;j--)
        {
                brojilac++;
                matrica[j][r4]=brojilac;
        }
        r4++;p4--;k4++;  
    }
    r=r-1;
    c=c-1;
     for(i=0;i<=r;i++)
     {
          for(j=0;j<=c;j++)
          { 
                    cout<<setw(3)<<matrica[i][j]<<" ";
          }
          cout<<"\n";
     }
     cin>>r; 
}

#include<iostream>
using namespace std;

int main()
{
    cout<<"Unesite n:\n";
    int n;
    cin>>n;
    int l[n];
    for(int i=0;i<n;i++)
    {
        cout<<"Unesite visinu za "<<i+1<<" covjeka reda:\n";
        cin>>l[i];
    }
    int brojilac=0;
    
    for(int j=0;j<n-1;j++)//bonalazenje ljudi koji su jedan do drugog
    {brojilac++;}
    
    for(int k=0;k<n-2;k++)
    {
        
        if(l[k]>=l[k+1])
        {brojilac++;}
    
    }
    
    cout<<brojilac;    
    cin>>n;
}

#include <iostream>
#include <vector>
using namespace std;


int main(){

    vector< int > q;

    for( int i = 0; i < 10; ++i ){
        int n;
        scanf("%d",&n);
        q.push_back( n % 42 );
    }

    sort(q.begin(),q.end());
    q.erase( unique(q.begin(),q.end()), q.end() );

    cout<<q.size()<<endl;

    return 0;
}

#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstdio>
#include<math.h>
#include<string>
using namespace std;

char res[5][200];

void okviri( int x , char mark ,int y = 2 ){
   res[0][x]=mark;
   res[1][x-1] = res[1][x+1]=mark;
   if(res[2][x-2]!='*')
      res[2][x-2] = res[2][x+2]=mark;
   else
      res[2][x+2]=mark;
   res[3][x-1] = res[3][x+1]=mark;
   res[4][x] = res[4][x]=mark;
}

int main()
{
   string text;
   cin>>text;
   int i,j;
   int strsize = text.size();
   int xN = 2;
   int width = (strsize-1)*3 + 4 + strsize;
   for(i=0;i<5;i++)fill(res[i],res[i]+width,'.');
   for(int i=0;i<strsize;i++){
      if( (i+1)%3==0 )okviri(xN,'*');
      else okviri(xN,'#');
      res[2][xN]=text[i];
      xN+=4;
   }
   for(i=0;i<5;i++){
      for(j=0;j<width;j++){
         printf("%c",res[i][j]);
      }printf("\n");
   }
   //system("Pause");
   return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <math.h>
#include <cstdlib>
#include <stack>
#include <set>
#include <stack>
#include <map>
using namespace std;

int n;
bool mx[550][550];

short dp[550][550][20][3];

bool mem[550][550];
int sol[550][550];

int setv( int y1, int y2 , int x1 , int x2 , bool v ){
    int ret = 0;
    for( int i = y1; i <= y2; ++i )
        for( int j = x1; j <= x2; ++j ){
            mem[i][j] = v;
            ret += bool(v != mx[i][j]);
        }
    return ret;
}

void setm( int y1, int y2 , int x1 , int x2 , bool v ){ for( int i = y1; i <= y2; ++i )for( int j = x1; j <= x2; ++j )sol[i][j] = v; }

int maxx = INT_MAX;

int solve( int y1 , int y2,  int x1, int x2 , int deep  ){


    if( y1 == y2 && x1 == x2 ){
        mem[y1][x1] = mx[y1][x1];
        return 0;
    }

    int ymid = (y2 + y1 - 1) >> 1;
    int xmid = (x2 + x1 - 1) >> 1;


    int ret = INT_MAX;
    int si = dp[y1][x1][deep][0];
    int sj = dp[y1][x2][deep][1];
    if( dp[y1][x2][deep][2] != -1 )ret= dp[y1][x2][deep][2];

    if( si == -1 )
    for( int i = 0; i < 4; ++i ){
        for( int j = 0; j < 4; ++j ){
            if( i == j ) continue;

            int q = 0;

            for( int k = 0; k <= 1; ++k ){
                int m = i;
                if( k == 1 ) m = j;

                if( m == 0 ) q += setv( y1 , ymid , x1 , xmid , k );
                if( m == 1 ) q += setv( ymid + 1 , y2 , x1 , xmid , k );
                if( m == 2 ) q += setv( y1 , ymid , xmid + 1 , x2 , k );
                if( m == 3 ) q += setv( ymid + 1 , y2 , xmid + 1 , x2 , k );
            }


            for( int k = 0; k < 4; ++k ){
                if( k == i || k == j ) continue;

                if( k == 0 ) q += solve( y1 , ymid , x1 , xmid , deep + 1 );
                if( k == 1 ) q += solve( ymid + 1 , y2 , x1 , xmid , deep + 1  );
                if( k == 2 ) q += solve( y1 , ymid , xmid + 1 , x2 , deep + 1  );
                if( k == 3 ) q += solve( ymid + 1 , y2 , xmid + 1 , x2 , deep + 1  );

            }

            if( ret > q )
                ret = q , si = i , sj = j;
        }
    }

    for( int k = 0; k <= 1; ++k ){
        int m = si;
        if( k == 1 ) m = sj;

        if( m == 0 ) setm( y1 , ymid , x1 , xmid , k );
        if( m == 1 ) setm( ymid + 1 , y2 , x1 , xmid , k );
        if( m == 2 ) setm( y1 , ymid , xmid + 1 , x2 , k );
        if( m == 3 ) setm( ymid + 1 , y2 , xmid + 1 , x2 , k );
    }

    if( x1 == xmid ){
        for( int k = 0; k < 4; ++k ){
            if( k == si || k == sj ) continue;

            if( k == 0 ) sol[y1][x1] = mx[y1][x1];
            if( k == 1 ) sol[y2][x1] = mx[y2][x1];
            if( k == 2 ) sol[y1][x2] = mx[y1][x2];
            if( k == 3 ) sol[y2][x2] = mx[y2][x2];
        }
    }

    dp[y1][x1][deep][0] = si;
    dp[y1][x2][deep][1] = sj;
    dp[y1][x2][deep][2] = ret;

    return ret;
}

int main(){
    FILE *in = stdin;//fopen("Ulaz.txt","r");
    fscanf(in,"%d",&n);

    char c;
    for( int i = 1; i <= n; ++i )
        for( int j = 1; j <= n; ++j ){
            while( c = fgetc(in) ) if( c == '0' || c == '1' ) break;
            mx[i][j] = c - '0';
        }

    memset( dp , -1, sizeof(dp));
    int ss = solve( 1 , n , 1 , n , 0 );

    printf("%d\n",ss);


    for( int i = 1; i <= n; ++i ){
        for( int j = 1; j <= n; ++j ){
            putchar(sol[i][j]+'0');
        }putchar('\n');
    }

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <algorithm>
#include <iomanip>
#include <set>
#include <math.h>
#include <vector>
using namespace std;

int n;
int mx[25][25];
double p[25][25];

double dp[22][(1<<20) +5];

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int i = 1; i <= n; ++i )
        for( int j = 1; j <= n; ++j ){
            scanf("%d",&mx[i][j]);
            p[i][j] = mx[i][j] / 100.0;
        }

    dp[0][0] = 1;

    for( int i = 1; i < (1<<n); ++i ){
        int cnt = __builtin_popcount(i);

        for( int k = 0; k < n; ++k ){
            if( ~i&(1<<k) )continue;
            dp[cnt][i] = max( dp[cnt][i] , dp[cnt-1][ i^(1<<k) ] * p[cnt][k+1] );
        }
    }

    printf("%.20lf\n",dp[n][ (1<<n)-1 ]*100 );

    return 0;
}

#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
#include <fstream>
#include <set>
#include <queue>
#include <math.h>
#include <iomanip>
using namespace std;

typedef long long ll;

int n,m;
char mx[305][305];

const int bit = 12;
int dp[305][305][4]; // gore , dole , ljevo , desno



int main(){

    int q = (1<<bit) - 1;

    scanf("%d%d",&n,&m);

    for( int i = 0; i < n; ++i )
        scanf("%s",mx[i]);

    int v = n-1;
    int h = m-1;

    for( int i = 0; i < n; ++i ){
        for( int j = 0; j < m; ++j ){

            if( i == 0 ){
                for( int k = 0; k < bit && i-k >=0; ++k ) dp[i][j][0] |= (mx[i-k][j]=='1') << k;
                for( int k = 0; k < bit && i+k < n; ++k ) dp[i][j][1] |= (mx[i+k][j]=='1') << k;
            }else{
                dp[i][j][0] = dp[i-1][j][0] << 1;
                dp[i][j][0] |= (mx[i][j]=='1');
                dp[i][j][0] &= q;

                dp[i][j][1] = dp[i-1][j][1] >> 1;
                if( i+bit-1 < n ) dp[i][j][1] |= (mx[i+bit-1][j]=='1') << (bit-1);
                dp[i][j][1] &= q;
            }

            if( j == 0 ){
                for( int k = 0; k < bit && j-k >=0; ++k ) dp[i][j][2] |= (mx[i][j-k]=='1') << k;
                for( int k = 0; k < bit && j+k < m; ++k ) dp[i][j][3] |= (mx[i][j+k]=='1') << k;
            }else{
                dp[i][j][2] = dp[i][j-1][2] << 1;
                dp[i][j][2] |= (mx[i][j]=='1');
                dp[i][j][2] &= q;

                dp[i][j][3] = dp[i][j-1][3] >> 1;
                if( j+bit-1 < m ) dp[i][j][3] |= (mx[i][j+bit-1]=='1' ) << (bit-1);
                dp[i][j][3] &= q;

            }
        }
    }

    int sol = -1;

    for( int x = 0; x < m-1; ++x ){
        for( int y = 0; y < n-1; ++y ){

            int mn = min(x+1,y+1);
            mn = min( mn , m - x );
            mn = min( mn , n - y );

            if( (mn<<1) <= sol ) continue;


            if( mx[y][x] == mx[y+1][x+1] && mx[y][x+1] == mx[y+1][x] ){
                sol = max( sol , 2 );
                for( int exp = 1; (x+exp+1 < m && x-exp >= 0) && (y+exp+1 < n && y-exp >= 0); ++exp ){

                    bool ok = true;
                    int w = (exp<<1) + 2;

                    for( int k = 0; k < w && ok; ++k ){
                        if( k + bit-1 < w ){
                            if( dp[y-exp][x-exp+k][3] != dp[y+exp+1][x+exp+1-k][2] || dp[y-exp+k][x-exp][1] != dp[y+exp+1-k][x+exp+1][0] ) ok = false;
                            k += bit-2;
                        }else if( mx[y-exp][x-exp+k] != mx[y+exp+1][x+exp+1-k] || ( mx[y-exp+k][x-exp] != mx[y+exp+1-k][x+exp+1] ) ) ok = false;
                    }

                    if( !ok ) break;

                    if( sol < w ) sol = w;

                }
            }

            for( int exp = 1; (x+exp < m && x-exp >= 0) && (y+exp < n && y-exp >= 0); ++exp ){
                bool ok = true;
                int w = (exp<<1) + 1;

                for( int k = 0; k < w && ok; ++k ){
                        if( k + bit-1 < w ){
                            if( dp[y-exp][x-exp+k][3] != dp[y+exp][x+exp-k][2] || dp[y-exp+k][x-exp][1] != dp[y+exp-k][x+exp][0] ) ok = false;
                            k += bit-2;
                        }else if( mx[y-exp][x-exp+k] != mx[y+exp][x+exp-k] || ( mx[y-exp+k][x-exp] != mx[y+exp-k][x+exp] ) ) ok = false;
                    }

                if( !ok ) break;
                if( sol < w ) sol = w;

            }

        }
    }

    printf("%d\n",sol);

    return 0;
}

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;

int arr[4];

int GetV( char c ){
   if( c == 'C' ) return arr[2];
   if( c == 'B' ) return arr[1];
   if( c == 'A' ) return arr[0];
}

int main(){
    scanf("%d%d%d",&arr[0],&arr[1],&arr[2]);
    sort( arr , arr + 3 );
    
    string s;
    cin >> s;
    printf("%d %d %d",GetV( s[0] ) , GetV( s[1] ) , GetV( s[2] )  );
    putchar('\n');
    
    return 0;
}

#include<iostream>
#include<cstdlib>
#include<fstream>
#include<string>
using namespace std;
ifstream in("Ulaz.txt");
int niz[100000];

int main()
{
    string K1,K2;
    int n1,n2;
    int step;
    int i,j,k,l;
    in>>n1>>n2;
    in>>K1>>K2;
    reverse(&K1[0],&K1[n1]);
    in>>step;
    for(i=0;i<n1;i++)niz[i]=1;
    while(step)
    {
       for(i=0;i<n1+n2-1;i++)
          if( niz[i] == 1 && niz[i+1]==0)
          {
             swap(niz[i],niz[i+1]);
             i++;
          }
       step--;
    }
    k=0;l=0;
    for(i=0;i<n1+n2;i++)
       if(niz[i]==1)
       {
          cout<<K1[k];
          k++;
       }else{
          cout<<K2[l];
          l++;
       }
    cout<<endl;
    system("Pause");
}

#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;


int main(){
    int r1,s;
    scanf("%d%d",&r1,&s);
    printf("%d\n",2*s - r1 );
    return 0;
}

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <math.h>
using namespace std;

int main(){
    int n;
    scanf("%d",&n);
    
    int sol = 0;
    
    for( int m = 4; m <= n; ++m ){
        for( int i = 2; i < m-1; ++i ){
           int L = i - 1;
           int R = m - i - 1;
        
           sol += L * R;
        }
    }
    
    printf("%d\n",sol);
    return 0;
}

#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <map>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <queue>
#include <set>
using namespace std;

const int inf = 999999999;

struct coord{
    double x,y;
    coord(){};
    coord( double p1, double p2 ):x(p1),y(p2){};

    bool operator<( const coord & c2 ) const {
        return x < c2.x || ( x == c2.x && y < c2.y );
    }
};

struct segment{
    coord a,b;
    segment(){};
    segment( coord p1 , coord p2 ):a(p1),b(p2){}

    bool overlapp( segment );

    int ccw( coord c ){
        return (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);
    }
};


bool online( coord A , coord B , coord ref ){
   return ( min(A.x,B.x)<=ref.x && max(A.x,B.x)>=ref.x && min(A.y,B.y)<=ref.y && max(A.y,B.y)>=ref.y );
}


bool segment::overlapp( segment s ){
    if( ccw(s.a) != 0 || ccw(s.b) != 0 )return false;
    if( online( a , b , s.a ) || online( a , b , s.b ) ) return true;
    return false;
}



coord sect( coord a , coord b , coord c , coord d ){
    double A1 = b.y - a.y;
    double B1 = a.x - b.x;
    double C1 = A1*a.x + B1*a.y;

    double A2 = d.y - c.y;
    double B2 = c.x - d.x;
    double C2 = A2*c.x + B2*c.y;

    double det = A1*B2 - A2*B1;

    coord sol;

    if( fabs(det) < 0.0000001 ) return coord( inf , inf );
    else{
        double x = (B2*C1 - B1*C2) / det;
        double y = (A1*C2 - A2*C1) / det;

        sol = coord(x,y);
    }

    if( online( a,b,sol) && online( c,d,sol) )
        return sol;
    else
        return coord( inf,inf );
}


int n;
vector< segment >row;
bool kill[100];

coord tmp[5];

bool sortx( coord a , coord b ){ return a.x < b.x; }
bool sorty( coord a , coord b ){ return a.y < b.y; }

bool eq( coord a , coord b ){
    return fabs(a.x-b.x) < 0.00001 && fabs(a.y-b.y) < 0.00001;
}

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d",&n);

    for( int i = 0; i < n; ++i ){
        int x1,y1,x2,y2; scanf("%d%d%d%d",&x1,&y1,&x2,&y2);

        row.push_back(  segment( coord(x1,y1) , coord(x2,y2) )   );
    }

    bool done = false;
    while( !done ){
        done = true;

        for( int i = 0; i < row.size(); ++i ){
            for( int j = i+1; j < row.size(); ++j ){
                if( kill[i] || kill[j] ) continue;

                if( row[i].overlapp( row[j] ) ){
                    done = false;
                    kill[j] = true;

                    tmp[0] = row[i].a , tmp[1] = row[i].b;
                    tmp[2] = row[j].a , tmp[3] = row[j].b;

                    if( row[i].a.x != row[i].b.x ){
                        sort( tmp , tmp + 4 , sortx );
                        row[i].a = tmp[0];
                        row[i].b = tmp[3];
                    }else{
                        sort( tmp , tmp + 4 , sorty );
                        row[i].a = tmp[0];
                        row[i].b = tmp[3];
                    }

                }
            }
        }
    }

    vector< segment > w;

    for( int i = 0; i < row.size(); ++i ){
        if( !kill[i] )
            w.push_back( row[i] );
    }

    int sol = 0;

    for( int i = 0; i < w.size(); ++i ){
        for( int j = i+1; j < w.size(); ++j ){
            for( int k = j+1; k < w.size(); ++k ){

                coord p1 = sect( w[i].a , w[i].b , w[j].a , w[j].b );
                coord p2 = sect( w[i].a , w[i].b , w[k].a , w[k].b );
                coord p3 = sect( w[j].a , w[j].b , w[k].a , w[k].b );

                if( fabs(p1.x-inf)<0.0001 || fabs(p2.x-inf)<0.0001 || fabs(p3.x-inf)<0.0001 ) continue;
                if( eq(p1,p2) || eq(p2,p3) || eq( p1,p3) ) continue;

                sol++;



            }
        }
    }

    printf("%d\n",sol);


    return 0;
}

#include <iostream>
#include <vector>
#include <math.h>
#include <cstdlib>
#include <iomanip>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <string.h>
using namespace std;

int grow( char c ){
    if( c == 'A' || c == 'B' || c == 'C' || c == 'D' ) return 0;
    if( c == 'E' || c == 'F' || c == 'G' || c == 'H' ) return 1;
    if( c == 'I' || c == 'J' || c == 'K' || c == 'L' ) return 2;
    if( c == 'M' || c == 'N' || c == 'O' || c == '.' ) return 3;
    return -1;
}

int gcol( char c ){
    if( c == 'A' || c == 'E' || c == 'I' || c == 'M' ) return 0;
    if( c == 'B' || c == 'F' || c == 'J' || c == 'N' ) return 1;
    if( c == 'C' || c == 'G' || c == 'K' || c == 'O' ) return 2;
    if( c == 'D' || c == 'H' || c == 'L' || c == '.' ) return 3;
    return -1;
}

char fld[40][40];

int main(){
    for( int i = 0; i < 4; ++i )
        scanf("%s",fld[i]);
    
    int sol = 0;
    for( int i = 0; i < 4; ++i )
        for( int j = 0; j < 4; ++j ){
            if( fld[i][j] == '.' )continue;
            sol += abs( grow(fld[i][j]) - i) + abs( gcol(fld[i][j]) - j );
        }
    printf("%d\n",sol);
    return 0;
}

#include<cstdio>
#include<algorithm>
using namespace std;
long long int combinations[30001];
long long int value[30001];

int main()
{
    long long int n,i;
    scanf("%lld",&n);
    for(i=0;i<n;i++)
    {
        scanf("%lld",&value[i]);
        if(i==2)
            combinations[i] = 1;
        else if(i==3)
            combinations[i]=3;
        else if(i>3)
            combinations[i] = combinations[i-1] + i-1;
    }
    sort(value,&value[n]);
    long long int result=0;
    for(i=2;i<n;i++)
        if(value[i]<0)
            result = (result + (combinations[i] *(value[i]+ 10007)))%10007;
        else 
            result = (result + (combinations[i] * value[i] % 10007)) % 10007;
    printf("%lld",result);
    return 0;
}

#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
#include <map>
#include <set>
#include <queue>
#include <math.h>
#include <iomanip>
using namespace std;

const int maxn = 500000 + 55;
const int inf = 999999999;

int n,m;
int l[maxn] , r[maxn];

void erase( int x ){
    r[ l[x] ] = r[x];
    l[ r[x] ] = l[x];
}

void move_before( int x, int y ){
    erase( x );
    l[x] = l[y];
    r[x] = y;
    r[ l[y] ] = x;
    l[ y ] = x;
}

void move_after( int x, int y ){
    erase( x );
    l[x] = y;
    r[x] = r[y];
    l[ r[y] ] = x;
    r[ y ] = x;
}

void print(){
    int now = 0;
    printf("BEGIN:\n");
    do{
        now = r[now];
        printf("%d\n",now);
    }while( r[now] >= 1 && r[now] <= n );
    printf("END\n");
}

vector< int > order(){
    vector< int > ret;
    int now = 0;
    do{
        now = r[now];
        ret.push_back( now );
    }while( r[now] >= 1 && r[now] <= n );
    return ret;
}

int sz[maxn];

int main(){
    freopen("Ulaz.txt","r",stdin);
    scanf("%d%d",&n,&m);
    r[0] = 1 , l[n+1] = n;

    for( int i = 1; i <= n; ++i ) l[i] = i-1, r[i] = i+1;

    for( int i = 0; i < m; ++i ){
        char c; while( c = getchar() ) if( c == 'A' || c == 'B' ) break;
        int x,y; scanf("%d%d",&x,&y);
        if( c == 'A' ) move_before( x , y );
        else move_after( x , y );
    }

    vector< int > f = order();
    for( int i = 1; i < n; ++i ) sz[i] = inf;

    int sol = 0;
    for( int i = 0; i < n; ++i ){
        int d = upper_bound( sz , sz+n , f[i] ) - sz;
        sz[d] = f[i];
        sol = max( sol , d );
    }

    return 0;
}

